{"version":3,"sources":["components/tooltipButton.tsx","error/errorWithTextRange.ts","utils/localStorage.ts","language/language.ts","language/en.ts","language/cs.ts","error/raSyntaxError.ts","error/raSemanticError.ts","utils/fontUtils.ts","utils/whisperUtils.ts","components/xTextArea.tsx","utils/math.ts","relation/relation.ts","error/codeError.ts","error/errorFactory.ts","expression/exprTokens.ts","utils/stringUtils.ts","ratree/raTreeNode.ts","ratree/relationNode.ts","types/indexedString.ts","utils/indexedStringUtils.ts","ratree/unaryNode.ts","relation/row.ts","ratree/projectionNode.ts","utils/keywords.ts","types/isToISMap.ts","vetree/comparingOperator.ts","ratree/renameNode.ts","vetree/veTreeNode.ts","vetree/logicalOperator.ts","vetree/computingOperator.ts","vetree/literalValue.ts","vetree/referenceValue.ts","expression/valueTokens.ts","expression/valueParser.ts","ratree/binaryNode.ts","ratree/raTreeTools.ts","ratree/selectionNode.ts","ratree/antijoinNode.ts","ratree/outerJoinNode.ts","ratree/cartesianProductNode.ts","ratree/divisionNode.ts","ratree/naturalJoinNode.ts","ratree/setOperationNode.ts","ratree/thetaJoinNode.ts","ratree/raTreeFactory.ts","expression/exprParser.ts","components/textInput.tsx","components/messageBox.ts","components/expressionSection.tsx","components/resultRelationTable.tsx","components/evaluationTree.tsx","utils/fileDialog.ts","types/csvSupport.ts","types/nnToSMap.ts","relation/storedRelation.ts","relation/columnType.ts","relation/relationStoreManager.ts","components/resultSection.tsx","expression/expressionStoreManager.ts","project/samples.ts","components/managementSection.tsx","project/project.ts","expression/expression.ts","project/projectStoreManager.ts","batch/operationsCount.ts","batch/configUtils.ts","batch/batchProcessor.ts","components/editRelationTable.tsx","components/relationsSection.tsx","utils/mail.ts","components/mainScreen.tsx","postMailAccessToken.ts","index.tsx","serviceWorker.ts"],"names":["TooltipButton","className","this","props","onClick","style","text","undefined","tooltipClassName","tooltipStyle","event","stopPropagation","preventDefault","tooltip","React","Component","ErrorWithTextRange","msg","range","Error","insertRangeIfUndefined","err","defaultLanguage","defaultDarkTheme","LocalStorage","storageSupported","storedSeparator","localStorage","getItem","console","log","setItem","csvValueSeparator","lan","allSupportedLanguages","includes","language","darkTheme","warn","isInit","init","String","Storage","EN","abbr","relationErrors","emptyColumn","duplicitColumn","keywordColumn","invalidColumn","unsupportedNull","invalidNumber","invalidBoolean","codeErrors","resultSection_nodeIndexNotFound","resultSection_evalError","resultSection_nullRelationToSave","resultSection_nullRelationToAdd","row_absentColumn","valueParser_unexpectedToken","exprParser_unexpectedToken","exprParser_thetaJoinBranchError","exprParser_projectionBranchError","semanticErrors","exprParser_relationNotDefined","binaryNode_commonColumns","setOperationNode_notEqualColumns","divisionNode_rightColumnsNotSubset","divisionNode_rightColumnsNotProperSubset","renameNode_absentOriginalColumn","renameNode_changeToDuplicit","projectionNode_absentColumn","projectionNode_emptyProjection","referenceValue_absentColumn","semanticError","syntaxErrors","exprParser_emptyStringGiven","exprParser_outerJoinWhenNullNotSupported","exprParser_unexpectedPart","exprParser_bothBranchesError","exprParser_invalidExpression","exprParser_invalidParentheses","exprParser_invalidStart","exprParser_invalidEnd","exprParser_relationAfterRelation","exprParser_relationAfterUnary","exprParser_relationAfterClosing","exprParser_unaryAfterBinary","exprParser_unaryAfterOpening","exprParser_binaryAfterBinary","exprParser_binaryAfterOpening","exprParser_openingAfterRelation","exprParser_openingAfterUnary","exprParser_openingAfterClosing","exprParser_closingAfterBinary","exprParser_closingAfterOpening","valueParser_emptyInput","valueParser_unsupportedNull","valueParser_unexpectedPart","valueParser_missingOpeningParenthesis","valueParser_missingClosingParenthesis","valueParser_invalidExpression","valueParser_invalidStart","valueParser_invalidEnd","valueParser_literalAfterLiteral","valueParser_literalAfterReference","valueParser_literalAfterClosing","valueParser_referenceAfterLiteral","valueParser_referenceAfterReference","valueParser_referenceAfterClosing","valueParser_notAfterLiteral","valueParser_notAfterReference","valueParser_notAfterClosing","valueParser_binaryAfterOperator","valueParser_binaryAfterOpening","valueParser_openingAfterLiteral","valueParser_openingAfterReference","valueParser_openingAfterClosing","valueParser_closingAfterOperator","valueParser_closingAfterOpening","stringUtils_missingClosingChar","stringUtils_charNotFound","renameNode_missingArrow","renameNode_invalidNewName","renameNode_keywordNewName","renameNode_multipleRenameOfTheColumn","selectionNode_resultNotBoolean","thetaJoinNode_resultNotBoolean","comparingOperator_differentInputTypes","computingOperator_inputTypesNotNumbers","logicalOperator_leftInputNotBoolean","logicalOperator_rightInputNotBoolean","syntaxError","userMessages","loadedRelationsTotalNo","loadedRelationsTotalSome","loadRelationNew","loadAllRelationsNew","deleteLoadedRelations","relationsExportOK","relationsExportErr","relationsImport","expressionsExportOK","expressionsExportErr","expressionsImport","operations","selection","projection","rename","union","intersection","difference","naturalJoin","cartesianProduct","leftSemiJoin","rightSemiJoin","leftAntijoin","rightAntijoin","thetaJoin","leftThetaSemiJoin","rightThetaSemiJoin","fullOuterJoin","leftOuterJoin","rightOuterJoin","division","managementSection","batchTitle","batchLoad","batchConfig","batchConfigInfo","batchNoConfig","loadButton","saveButton","samplesButton","samplesMenuTitle","settingsButton","settingsNullValues","settingsNullValuesAllowed","settingsNullValuesForbidden","settingsCSVSeparator","settingsCSVSeparatorSemicolon","settingsCSVSeparatorComma","settingsTheme","settingsThemeLight","settingsThemeDark","settingsLanguage","aboutButton","relationSection","relationSectionHeader","loadAllButton","loadAllButtonTooltip","removeLoadedButton","removeLoadedButtonTooltip","importButton","importButtonTooltip","exportButton","exportButtonTooltip","loadButtonTooltip","renameButton","deleteButton","deleteButtonTooltip","revertButton","revertButtonTooltip","expressionSection","expressionSectionHeader","evaluateButton","evaluateButtonTooltip","expressionTextareaPlaceholder","lineComment","blockComment","resultSection","resultSectionHeader","exportEvalTreeButton","exportEvalTreeButtonTooltip","evalTreeTitle","resultRelationTitle","intermediateRelationTitle","addButton","addButtonTooltip","exportRelationButton","exportRelationButtonTooltip","languageMap","Map","lang","get","getLanguage","RASyntaxError","captureStackTrace","name","RASemanticError","computeFontSizeInPx","fontFamily","fontSize","div","document","createElement","setAttribute","innerText","documentElement","appendChild","divWidth","clientWidth","divHeight","clientHeight","remove","fontWidth","length","fontHeight","getStartOfWordBeforeIndex","str","index","prefixText","slice","i","exec","charAt","cssConstants","getComputedStyle","querySelector","getPropertyValue","lineHeight","Number","numsBackgroundLight","numsBackgroundDark","numsColorLight","numsColorDark","XTextArea","textarea","start","selectionStart","end","selectionEnd","setSelectionRange","activeElement","id","focus","placeholder","getElementById","table","classList","add","tr","td1","td2","ta","mouseIsDown","value","canvas","width","canvasWidth","canvasLines","whisperDiv","isShown","selectedIndex","changeSelected","indexDiff","setSelected","newIndex","n","m","childElementCount","children","NaN","getSelectedWhisper","paintLineNumbers","height","ctx","getContext","fillStyle","fillRect","scrollHeight","font","linesCount","fillText","e","update","lines","updateParentheses","createWhisper","whispers","hideWhisper","innerHTML","forEach","whisper","onclick","ondblclick","insertCurrentSelectedWhisper","notAutoShowWhisper","moveWhisper","cursorLineAndColumn","getPositionLineAndColumn","cursorDistanceFromTATotalTop","line","cursorDistanceFromTATotalLeft","column","yPos","scrollTop","xPos","scrollLeft","getBoundingClientRect","y","window","innerHeight","currWhisper","beforeAdd","afterAdd","newCursorPos","onChange","errorDivs","moveErrors","highlight","startLine","rangeLength","startColumn","x","innerWidth","messageSpan","updateErrors","ranges","pushHighlight","parentElement","push","createHighlightDiv","getLineLength","parentheses","parenthesesDivs","c1","c2","around","filter","p","first","div1","createParenthesesDiv","div2","toggle","moveParentheses","insertPairSymbol","second","before","between","after","checkPairSymbolDelete","prevI","nextI","prev","next","addEventListener","onscroll","onmousedown","setTimeout","onmouseup","onmousemove","oninput","ev","target","onkeydown","key","ctrlKey","cursor","onCtrlInput","errors","prevProps","position","textBeforeCursor","match","lastNewLine","lastIndexOf","newLinesFound","lineStart","lineEnd","newEvent","MouseEvent","type","dispatchEvent","span","Relation","columns","columnNames","rows","finishedSchema","hasColumn","hasFinishedSchema","set","some","cn","f","row","isEqual","getTypes","finishSchema","finish","r","equals","map","s","join","columnTypes","getOrderedPrintValues","longest","d","pad","ss","padEnd","repeat","other","Set","CodeError","ErrorFactory","params","assertParamsCount","joinStringArrays","expectedCount","a","b","aLen","toConcat","Array","concat","ExprToken","getRange","ParenthesisToken","OpeningParenthesis","ClosingParenthesis","RelationToken","UnaryOperatorToken","BinaryOperatorToken","precedence","precedenceLevelA","precedenceLevelB","StringUtils","split","every","c","isLetter","startsWith","isNameChar","res","toLowerCase","toUpperCase","isDigit","test","substring","char","digitFound","dotFound","backslashes","curChar","error","escape","depth","inQuotes","nesting","escapeCount","charFound","RATreeNode","resultRelation","eval","RelationNode","relation","cursorIndex","result","getName","IndexedString","chars","startIndex","arr","ic","isEmpty","RangeError","separator","empty","sepLen","strSplit","prefixSum","_start","_end","newFromArray","trimStr","trim","indexOf","strings","is","searchString","endPosition","endsWith","searchValue","replaceValue","replace","IndexedStringUtils","isWord","toString","isName","isWhitespacesOnly","isNumber","strParts","nextWord","nextName","nextNonWhitespacePart","nextNumber","nextQuotedString","getFirstIndex","nextBorderedPart","copy","getChars","inLineComment","blockCommentStart","errStart","skippedStr","skipWhitespacesAndChar","UnaryNode","subtree","Row","types","values","finished","keys","has","orderedColumns","ret","codeError","ProjectionNode","stringRange","projStart","isEvaluated","source","getResult","projectedIndexed","parseProjection","proj","projected","forEachColumn","addColumn","getRows","newRow","getColumns","getValues","addValue","addRow","fakeEval","getColumnNames","absent","strName","printInLine","getOperationSymbol","forbiddenColumnNames","forbiddenRelationNames","isForbiddenColumnName","ComparingOperatorType","ISToISMap","keyValue","delete","clear","size","RenameNode","doThrow","handleError","parts","part","words","w","beforeError","afterError","changes","parseChanges","toChange","newName","returned","duplicit","beforeStr","afterStr","VETreeNode","LogicalOperatorType","ComparingOperator","operator","left","right","equal","nonEqual","less","more","lessOrEqual","moreOrEqual","leftResult","rightResult","ComputingOperatorType","LogicalOperator","and","or","not","LiteralValue","ReferenceValue","columnName","getValue","getType","ComputingOperator","plus","minus","multiplication","ValueToken","OperatorToken","LogicalNotToken","LogicalAndToken","LogicalOrToken","ComputingMultiplicationToken","ComputingDivisionToken","ComputingPlusToken","ComputingMinusToken","ComparingToken","OpeningParentheses","ClosingParentheses","LiteralToken","ReferenceToken","ValueParser","nullValuesSupport","tokens","parseTokens","assertValidInfixTokens","simplify","rpn","toRPN","rpnToVETree","token","rest","i2","token1","token2","notIndexes","indexesToRemove","t","rpnQueue","operatorsStack","pop","curToken","rpnToVETreeRecursive","deduct","multiply","divide","JSON","stringify","BinaryNode","leftSubtree","rightSubtree","depthSearch","root","findIndexInTree","node","getSubtree","leftSearch","getLeftSubtree","getRightSubtree","getTreeDepth","Math","max","isInRangeAndNotInQuotes","len","cursorIndexInStr","insideQuotes","AntijoinType","SelectionNode","boolExpr","parse","bool","newResult","fakeParse","OuterJoinType","AntijoinNode","rowsToKeep","rowsToHelp","leftSource","rightSource","commonColumns","lc","keptRow","helpRow","fakeEvalBinary","CartesianProductNode","leftRow","rightRow","leftColumn","DivisionNode","leftColumns","rightColumns","getSchemaString","resultColumns","getNamesSchemaString","leftRows","rightRows","testRow","lr","entries","NaturalJoinType","OuterJoinNode","full","SetOperationType","NaturalJoinNode","leftSemi","natural","rightSemi","ThetaJoinType","SetOperationNode","typeStr","getOperationName","rr","ThetaJoinNode","condition","bothSourceColumns","booleanResult","sourceColumns","RATreeFactory","unaryClass","expr","binaryClass","ExprParser","relations","deleteAllComments","new","rpnToRATree","innerResult","pushParentheses","getLastIndex","selectionExpected","restStartIndex","recursiveReturn","rightThetaSemijoin","containsAny","leftSemijoin","rightSemijoin","leftThetaSemijoin","indexAt","missing","splice","rpnToRATreeRecursive","createUnary","createBinary","TextInput","inputRef","handleChange","disable","forbidden","setState","buttonDisable","handleKeyDown","state","handleSubmit","current","blur","onSubmit","createRef","ref","spellCheck","autoComplete","onKeyDown","disabled","buttonText","boxMargin","MessageBox","box","visibility","onmouseenter","clearHideTimeout","onmouseleave","setHideTimeout","paragraph","button","hideBox","moveBox","body","firstElementChild","display","hideTimeout","hideIntervalId","clearTimeout","ExpressionSection","textAreaRef","lastChange","lastWhisperAndErrorsUpdate","whispersAndErrorsUpdateRate","updateErrorsAndParentheses","getCurExpr","isNaN","message","evalExpr","tree","expressions","currentExpressionIndex","onEval","errorRanges","er","showError","newExpression","onNewExpression","deleteExpression","onDeleteExpression","exportExpressions","onExportExpressions","importExpressions","onImportExpressions","addSpecialString","shift","getSelection","firstPart","secondPart","newPosition","newStr","handleExprChange","setSelection","onDone","Date","now","handleCtrlInput","updateWhispersAndErrors","textArea","isFocused","fakeParseResult","wordBeforeCursor","helpArray","likelihood","wordStart","wordEnd","sort","help","sortWhispers","handleExprNameChange","onUnexpectedError","handleDragDrop","data","dataTransfer","getData","fromIndex","onDragExpression","sectionClicked","setInterval","setPlaceholder","onSelectDifferentExpression","ops","createButton","createOpButton","buttonGroupMargin","marginRight","handleSelectDifferentExpression","draggable","onDragStart","setData","onDragOver","onDrop","minWidth","marginLeft","padding","ResultRelationTable","getOrderByText","orderDir","orderBy","prevState","snapshot","updateOrderBy","getRowsCount","colSpan","sortCol","aValue","bValue","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","localeCompare","headerRow","createHeaderRow","createRows","EvaluationTree","TreeComponent","raTree","selected","nodeHeight","backgroundColorLight","backgroundColorDark","textColorLight","textColorDark","selectedNodeColorLight","unselectedNodeColorLight","selectedNodeColorDark","unselectedNodeColorDark","TreeNodeComponent","useTooltip","tooltipOpen","showTooltip","hideTooltip","nodeWidth","title","symbol","Group","top","rx","fill","onMouseOver","tooltipLeft","tooltipTop","onMouseOut","dy","textAnchor","pointerEvents","treeDepth","margin","bottom","yMax","xMax","indexes","parseTreeForDisplayHelper","maxNodeTextLength","parseTreeForDisplay","hierarchy","Tree","links","link","LinkVertical","stroke","strokeWidth","strokeOpacity","descendants","FileDialog","Promise","resolve","element","fileInput","firstChild","files","click","accept","file","reader","FileReader","onload","readAsText","openFilesHelper","fileInfo","readFile","splitCSVLine","partStart","NNToSMap","entry","parseKey","rowNumber","StoredRelation","columnCount","rowCount","actual","revertState","toDataObject","recomputeErrors","isStoredRelationData","rel","checkColumnNames","checkRowInput","columnIndex","reduce","agg","rowIndex","input","lower","_","rowInput","addNewColumn","columnType","checkColumnTypes","obj","isArray","o","isSupportedColumnType","RelationStoreManager","openFiles","then","skipped","csvToRelation","createValidName","filename","valueSeparator","zip","JSZip","relationToCsv","generateAsync","content","saveAs","catch","blob","Blob","findValueSeparator","names","getColumnTypes","ResultSection","sectionRef","getCurrentRelation","currentNode","evaluationTreeRoot","handleSelectedNodeChange","exportEvalTreeAsPng","svg","rect","options","expressionName","downloadSVG","exportRelation","save","fromRelation","addRelation","onAddResult","relationType","selectedNode","tableTitle","ExpressionStoreManager","skippedExpressions","loadedFiles","skippedFiles","splitExpressionNameAndText","firstNewLineIndex","firstRow","textContent","samples","project","getSamples","ManagementSection","onLoadProject","onSaveProject","samplesMenu","sample","onLoadSample","createSamplesButton","settingsMenu","checked","onNullValuesSupportChange","htmlFor","onCsvValueSeparatorChange","onDarkThemeChange","onLanguageChange","createSettingsButton","batchMenu","onBatchConfig","batchConfigurationInfo","onBatchLoad","createBatchButton","href","isProjectObject","isExpression","copyProject","exp","ProjectStoreManager","reject","openFile","OperationsTypes","zeroOperations","addOperations","counts","antijoin","count","cartesian","outerJoin","semijoin","thetaSemijoin","binaryOperations","unaryOperations","operationsOfTree","operationOfUnaryNode","operationOfBinaryNode","createCountComparator","comparators","field","countValue","comparator","createOperationsCounter","op","_ops","cur","getDescription","ruleDef","description","createCountOperationRule","unique","counter","sign","createOperationsIndicator","removeExtension","lastDotIndex","identityReportNameModifier","createReportNameModifier","config","joinPathParts","modifier","usePathParts","prefix","suffix","fieldName","previousModifier","BatchProcessor","loadType","configurationFileName","reportNameModifier","operationRules","tableRules","queryRules","loaded","ruleName","rule","createRule","resultFilename","fields","subRules","each","sr","createEachOperationRule","tables","createTableRule","queries","createQueryRule","processFiles","openZip","loadAsync","createFolders","zippedFiles","Object","dir","zippedFile","async","storedData","storedRelation","fromData","isValid","createRelation","ignored","time","reports","processed","downloadReports","report","timeEnd","processNext","processFile","status","parseRelations","exprParser","exprCount","processExpression","reportHeader","formatRelations","sectionLine","parser","evaluationTree","contentLine","contentString","rels","exprs","errs","nvs","total","binary","unary","ruleErrors","rulesCount","errorsCount","toLocaleString","inlines","format","cellPaddingSides","inputMarginSides","EditRelationTable","containerRef","tableHeadRowRef","columnWidths","handleInputResize","inputElement","scrollWidth","getErrors","setSelectedInput","selectedColumn","selectedRow","moveSelectedInputRight","getColumnCount","moveSelectedInputLeft","moveSelectedInputUp","moveSelectedInputDown","getRowCount","onColumnNameChange","onColumnTypeChange","onRowInputChange","handleNewColumn","onNewColumn","scrollTo","handleNewRow","onNewRow","handleDeleteColumn","onDeleteColumn","handleDeleteRow","onDeleteRow","createInput","autoFocus","createDeleteButton","callback","componentDidUpdate","headRow","cells","cell","rowData","createTooltip","rowSpan","border","createNamesRow","createTypesRow","createAddRow","RelationsSection","getCurRel","storedRelations","storedRelationIndex","handleRelationNameChange","onRelationNameChange","loadRelation","onLoadRelation","loadAllRelations","onLoadAllRelations","exportRelations","onExportRelations","importRelations","onImportRelations","deleteRelation","onDeleteStoredRelation","revertRelation","onRevertRelation","newRelation","onNewRelation","removeLoadedRelations","onRemoveLoadedRelations","createRelationMenuButtons","actuality","isActual","handleSelectDifferentRelation","onDragRelation","onSelectDifferentRelation","getRevertName","Mail","accessToken","subject","data_js","access_token","request","XMLHttpRequest","onreadystatechange","readyState","response","toParams","open","setRequestHeader","send","encodeURIComponent","MainScreen","expressionSectionRef","reportUnexpectedError","postMail","stack","loadedRelations","selectedRelation","selectedExpression","loadProject","evaluatedExpressionName","updateExpressionsErrors","ensureUniqueRelationName","handleBatchConfig","configInfo","getConfigInfo","handleBatchLoad","process","handleLoadProject","load","handleSaveProject","handleLoadSampleProject","handleNullValuesSupportChange","setNullValuesSupport","handleCsvValueSeparatorChange","setCsvValueSeparator","handleLanguageChange","setLanguage","handleDarkThemeChange","setDarkTheme","setName","handleRelationColumnNameChange","setColumnName","handleRelationColumnTypeChange","setColumnType","handleRelationRowInputChange","setRowInput","handleRelationNewRow","addNewRow","handleRelationNewColumn","handleRelationDeleteRow","deleteRow","handleRelationDeleteColumn","deleteColumn","handleDragRelation","from","to","moved","fromValue","newArray","handleCreateNewRelation","handleDeleteRelation","handleRevertRelation","revert","handleRemoveLoadedRelations","previous","setActual","handleExportRelations","handleImportRelations","info","countBefore","handleLoadRelation","currRelation","msgPart2","handleLoadAllRelations","handleExprEval","handleExprTextChange","handleDragExpression","handleCreateNewExpression","handleDeleteExpression","handleExportExpressions","handleImportExpressions","addResultRelation","getDarkTheme","getCsvValueSeparator","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.bc4b693d.chunk.js","sourcesContent":["import React from 'react'\n\n/**\n * Props of TooltipButton component.\n * @category Components\n * @public\n */\ninterface TooltipButtonProps {\n  /**\n     * text on the button\n     * @type string\n     * @public\n     */\n  text: string\n  /**\n     * handler of the button click\n     * @type function\n     * @public\n     */\n  onClick: () => void\n  /**\n     * css class of the button\n     * @type string?\n     * @public\n     */\n  className?: string\n  /**\n     * inline styling for button\n     * @type React.CSSProperties?\n     * @public\n     */\n  style?: React.CSSProperties\n  /**\n     * text of the tooltip\n     * @type string\n     * @public\n     */\n  tooltip: string\n  /**\n     * css class of the tooltip (it always has default .tooltip class)\n     * @type string?\n     * @public\n     */\n  tooltipClassName?: string\n  /**\n     * inline styling for tooltip\n     * @type React.CSSProperties?\n     * @public\n     */\n  tooltipStyle?: React.CSSProperties\n}\n\ninterface TooltipButtonState {\n}\n\n/**\n * Button with a tooltip text.\n * Accepts {@link TooltipButtonProps} props.\n * @category Components\n * @public\n */\nexport class TooltipButton extends React.Component<TooltipButtonProps, TooltipButtonState> {\n\n  render () {\n    return (\n      <button\n        className={this.props.className}\n        onClick={this.props.onClick}\n        style={this.props.style}\n      >{this.props.text}\n        <span\n          className={'tooltip ' + (this.props.tooltipClassName !== undefined ? this.props.tooltipClassName : '')}\n          style={this.props.tooltipStyle}\n          onClick={event => {\n            event.stopPropagation()\n            event.preventDefault()\n          }}\n        >{this.props.tooltip}</span>\n      </button>\n    )\n  }\n}\n","import { StartEndPair } from '../types/startEndPair'\n\n/**\n * Error with optional text range of the error.\n * @extends Error\n * @category Errors\n * @public\n */\nexport class ErrorWithTextRange extends Error {\n  /**\n     * @param msg error message {@type string}\n     * @param range optional text range of the error {@type StartEndPair?}\n     * @public\n     */\n  constructor (msg: string, public range?: StartEndPair | undefined) {\n    super(msg)\n  }\n}\n\n/**\n * If the given error is ErrorWithTextRange instance and has undefined range, sets its range to given value.\n * Returns (possibly modified) input error.\n *\n * @param err error tu be inserted in {@type ErrorWithTextRange}\n * @param range inserted range {@type StartEndPair?}\n * @category Errors\n * @public\n */\nexport function insertRangeIfUndefined<T> (err: T, range: StartEndPair | undefined): T {\n  if (err instanceof ErrorWithTextRange && err.range === undefined) {\n    err.range = range\n  }\n  return err\n}\n","import { CsvValueSeparator } from '../types/csvSupport'\nimport { isSupportedLanguage, SupportedLanguage } from '../language/language'\n\n\nconst defaultCsvValueSeparator: CsvValueSeparator = ';'\nconst defaultLanguage: SupportedLanguage = 'EN'\nconst defaultDarkTheme = 'false'\n\n/**\n * Static class for maintaining the access to local storage of the browser. It handles user settings:\n * saving file type, csv value separator, language, light/dark theme of the application.\n * If the local storage is not used, it uses the application memory and the default values.\n * @category Utils\n * @public\n */\nexport class LocalStorage {\n\n  private static isInit = false\n  private static readonly storageSupported: boolean = typeof (Storage) !== 'undefined'\n\n  private static csvValueSeparator: CsvValueSeparator\n  private static language: SupportedLanguage\n  private static darkTheme: string\n\n  /**\n     * Initializes the LocalStorage. If there are the requested values, loads them to application memory.\n     * If the local storage is not supported, uses the default values.\n     */\n  private static init (): void {\n    if (LocalStorage.storageSupported) {\n      const storedSeparator = localStorage.getItem('csvValueSeparator')\n      if (storedSeparator !== ';' && storedSeparator !== ',') {\n        console.log('csvValueSeparator not found in localStorage and set to default')\n        localStorage.setItem('csvValueSeparator', defaultCsvValueSeparator)\n        LocalStorage.csvValueSeparator = defaultCsvValueSeparator\n      } else {\n        // @ts-ignore\n        LocalStorage.csvValueSeparator = localStorage.getItem('csvValueSeparator')\n      }\n      if (!isSupportedLanguage(localStorage.getItem('language'))) {\n        console.log('language not found in localStorage and set to default')\n        localStorage.setItem('language', defaultLanguage)\n        LocalStorage.language = defaultLanguage\n      } else {\n        // @ts-ignore\n        LocalStorage.language = localStorage.getItem('language')\n      }\n\n      if (localStorage.getItem('darkTheme') !== 'true' && localStorage.getItem('darkTheme') !== 'false') {\n        console.log('darkTheme not found in localStorage and set to default')\n        localStorage.setItem('darkTheme', defaultDarkTheme)\n        LocalStorage.darkTheme = defaultDarkTheme\n      } else {\n        // @ts-ignore\n        LocalStorage.darkTheme = localStorage.getItem('darkTheme')\n      }\n    } else {\n      console.warn('LocalStorage not supported in the browser. Default values used.')\n      LocalStorage.csvValueSeparator = defaultCsvValueSeparator\n      LocalStorage.language = defaultLanguage\n      LocalStorage.darkTheme = defaultDarkTheme\n    }\n    LocalStorage.isInit = true\n  }\n\n  /**\n     * Returns stored CSV value separator.\n     *\n     * @return stored CSV value separator {@type CsvValueSeparator}\n     * @public\n     */\n  static getCsvValueSeparator (): CsvValueSeparator {\n    if (!LocalStorage.isInit) {\n      LocalStorage.init()\n    }\n    return LocalStorage.csvValueSeparator\n  }\n\n  /**\n     * Stores the given CSV value separator.\n     *\n     * @param csvValueSeparator CSV value separator to store {@type CsvValueSeparator}\n     * @public\n     */\n  static setCsvValueSeparator (csvValueSeparator: CsvValueSeparator): void {\n    LocalStorage.csvValueSeparator = csvValueSeparator\n    if (LocalStorage.storageSupported) {\n      localStorage.setItem('csvValueSeparator', csvValueSeparator)\n    }\n  }\n\n  /**\n     * Returns stored language settings.\n     *\n     * @return stored language {@type SupportedLanguage}\n     * @public\n     */\n  static getLanguage (): SupportedLanguage {\n    if (!LocalStorage.isInit) {\n      LocalStorage.init()\n    }\n    return LocalStorage.language\n  }\n\n  /**\n     * Stores the given language settings.\n     *\n     * @param language language settings to store {@type SupportedLanguage}\n     * @public\n     */\n  static setLanguage (language: SupportedLanguage): void {\n    LocalStorage.language = language\n    if (LocalStorage.storageSupported) {\n      localStorage.setItem('language', language)\n    }\n  }\n\n  /**\n     * Returns stored theme settings: true if the stored theme is dark, false if light.\n     *\n     * @return true if the stored theme is dark, false if light {@type boolean}\n     * @public\n     */\n  static getDarkTheme (): boolean {\n    if (!LocalStorage.isInit) {\n      LocalStorage.init()\n    }\n    return LocalStorage.darkTheme === 'true'\n  }\n\n  /**\n     * Stores the given theme settings: true if the stored theme is dark, false if light.\n     *\n     * @param darkTheme theme settings to store {@type boolean}\n     * @public\n     */\n  static setDarkTheme (darkTheme: boolean): void {\n    LocalStorage.darkTheme = String(darkTheme)\n    if (LocalStorage.storageSupported) {\n      localStorage.setItem('darkTheme', String(darkTheme))\n    }\n  }\n}\n","import { LocalStorage } from '../utils/localStorage'\nimport { EN } from './en'\nimport { CS } from './cs'\nimport { CodeErrorMessages } from '../error/codeError'\nimport { SemanticErrorMessages } from '../error/raSemanticError'\nimport { SyntaxErrorMessages } from '../error/raSyntaxError'\n\n/**\n * IF YOU WANT TO ADD A NEW LANGUAGE, READ THIS:\n *\n * Adding a language is simple, follow these steps:\n * 1) Copy the \"en.ts\" file in this package and name it as the lowercase new language abbreviation, e.g., \"cs.ts\"\n * 2) Rename the language definition object to the uppercase language abbreviation, e.g., \"CS\"\n * 3) Translate the messages in the new file. Some messages are split into an array - if you are not sure what to\n * write in each part, see its usage or other languages.\n * 4) Add the uppercase language abbreviation, e.g., \"CS\", in the allSupportedLanguages array in this file.\n * 5) Import your language definition in this file, e.g., \"import {CS} from \"./cs\";\"\n * 6) Add the imported language definition into languageMap map in this file, e.g., \"[\"CS\", CS],\"\n * 7) (voluntary) Create a project sample in your language in /project/samples.ts - you can translate existing samples.\n * 8) Test whether the application works.\n */\n\n/**\n * All languages supported in the application.\n * NOTE FOR NEW LANGUAGES: If you define a new language file \"lang.ts\", add \"LANG\" to this array.\n * @type string[]\n * @category Language\n * @public\n */\nexport const allSupportedLanguages: string[] = (<L extends string>(arr: L[]) => arr)(['EN', 'CS'])\n\n/**\n * Abbreviation of supported languages in the application.\n * @category Language\n * @public\n */\nexport type SupportedLanguage = (typeof allSupportedLanguages)[number]\n\n/**\n * Definition of a language for Rachel.\n * NOTE FOR NEW LANGUAGES: If you want to define a new language, it must be through this interface in a new file in\n * this package (see en.ts file as an example of English language definition).\n * @category Language\n * @public\n */\nexport interface LanguageDef {\n  /**\n     * Abbreviation of the language\n     * @public\n     */\n  abbr: SupportedLanguage\n  /**\n     * Description of errors in relation definitions.\n     * @public\n     */\n  relationErrors: {\n    emptyColumn: string,\n    duplicitColumn: string,\n    keywordColumn: string,\n    invalidColumn: string,\n\n    unsupportedNull: string,\n    invalidNumber: string,\n    invalidBoolean: string,\n  }\n  /**\n     * Description of unexpected errors.\n     * @public\n     */\n  codeErrors: CodeErrorMessages\n  /**\n     * Description of semantic errors in expressions.\n     * @public\n     */\n  semanticErrors: SemanticErrorMessages\n  /**\n     * Default semantic error message.\n     * @public\n     */\n  semanticError: string\n  /**\n     * Description of syntactic errors in expressions.\n     * @public\n     */\n  syntaxErrors: SyntaxErrorMessages\n  /**\n     * Default syntax error message.\n     * @public\n     */\n  syntaxError: string\n  /**\n     * Info messages for the user in pop-up message box.\n     * @public\n     */\n  userMessages: {\n    loadedRelationsTotalNo: string,\n    loadedRelationsTotalSome: string,\n    loadRelationNew: string,\n    // 2 parts expected - see English language as an example\n    loadAllRelationsNew: string[],\n    deleteLoadedRelations: string,\n\n    relationsExportOK: string,\n    relationsExportErr: string,\n    // 2 parts expected - see English language as an example\n    relationsImport: string[],\n\n    expressionsExportOK: string,\n    expressionsExportErr: string,\n    // 4 parts expected - see English language as an example\n    expressionsImport: string[],\n  }\n  /**\n     * Names of RA operations.\n     * @public\n     */\n  operations: {\n    selection: string,\n    projection: string,\n    rename: string,\n    union: string,\n    intersection: string,\n    difference: string,\n    naturalJoin: string,\n    cartesianProduct: string,\n    leftSemiJoin: string,\n    rightSemiJoin: string,\n    leftAntijoin: string,\n    rightAntijoin: string,\n    thetaJoin: string,\n    leftThetaSemiJoin: string,\n    rightThetaSemiJoin: string,\n    fullOuterJoin: string,\n    leftOuterJoin: string,\n    rightOuterJoin: string,\n    division: string,\n  }\n  /**\n     * Description of elements in management section.\n     * @public\n     */\n  managementSection: {\n    batchTitle: string,\n    batchLoad: string,\n    batchConfig: string,\n    batchConfigInfo: string[],\n    batchNoConfig: string,\n\n    loadButton: string,\n    saveButton: string,\n\n    samplesButton: string,\n    samplesMenuTitle: string,\n\n    settingsButton: string,\n    settingsNullValues: string,\n    settingsNullValuesAllowed: string,\n    settingsNullValuesForbidden: string,\n    settingsCSVSeparator: string,\n    settingsCSVSeparatorSemicolon: string,\n    settingsCSVSeparatorComma: string,\n    settingsTheme: string,\n    settingsThemeLight: string,\n    settingsThemeDark: string,\n    settingsLanguage: string,\n\n    aboutButton: string,\n  }\n  /**\n     * Description of elements in relation section.\n     * @public\n     */\n  relationSection: {\n    relationSectionHeader: string,\n\n    loadAllButton: string,\n    loadAllButtonTooltip: string,\n    removeLoadedButton: string,\n    removeLoadedButtonTooltip: string,\n    importButton: string,\n    importButtonTooltip: string,\n    exportButton: string,\n    exportButtonTooltip: string,\n\n    loadButton: string,\n    loadButtonTooltip: string,\n    renameButton: string,\n    deleteButton: string,\n    deleteButtonTooltip: string,\n    revertButton: string,\n    revertButtonTooltip: string,\n  }\n  /**\n     * Description of elements in expression section.\n     * @public\n     */\n  expressionSection: {\n    expressionSectionHeader: string,\n\n    importButton: string,\n    importButtonTooltip: string,\n    exportButton: string,\n    exportButtonTooltip: string,\n\n    evaluateButton: string,\n    evaluateButtonTooltip: string,\n    renameButton: string,\n    deleteButton: string,\n    deleteButtonTooltip: string,\n\n    expressionTextareaPlaceholder: string,\n\n    lineComment: string,\n    blockComment: string,\n  }\n  /**\n     * Description of elements in result section.\n     * @public\n     */\n  resultSection: {\n    resultSectionHeader: string,\n\n    exportEvalTreeButton: string,\n    exportEvalTreeButtonTooltip: string,\n    evalTreeTitle: string,\n\n    resultRelationTitle: string,\n    intermediateRelationTitle: string,\n    addButton: string,\n    addButtonTooltip: string,\n    exportRelationButton: string,\n    exportRelationButtonTooltip: string,\n  }\n}\n\n/**\n * Map of supported languages to their definition.\n * NOTE FOR NEW LANGUAGES: If you define a new language, add its definition mapping here.\n */\nconst languageMap: Map<SupportedLanguage, LanguageDef> = new Map<SupportedLanguage, LanguageDef>([\n  ['EN', EN],\n  ['CS', CS],\n])\n\n/**\n * Returns true if the given value is a supported language.\n * @param lan checked value {@type any}\n * @return true if the given value is a supported language {@type boolean}\n * @category Language\n * @public\n */\nexport function isSupportedLanguage (lan: any): boolean {\n  return allSupportedLanguages.includes(lan)\n}\n\n/**\n * Returns definition of the current selected language.\n * @return definition of the current selected language {@type LanguageDef}\n * @category Language\n * @public\n */\nexport function language (): LanguageDef {\n  const lang = languageMap.get(LocalStorage.getLanguage())\n  if (lang === undefined) {\n    return EN\n  }\n  return lang\n}\n","import { LanguageDef } from './language'\nimport { CodeErrorMessages } from '../error/codeError'\nimport { SemanticErrorMessages } from '../error/raSemanticError'\nimport { SyntaxErrorMessages } from '../error/raSyntaxError'\n\n/**\n * English messages for CodeErrors mapped by their error codes.\n */\nconst codeErrors: CodeErrorMessages = {\n  resultSection_nodeIndexNotFound:\n        ['ResultSection.getCurrentRelation: Selected node index in the evaluation tree was not found.'],\n  resultSection_evalError:\n        ['ResultSection.getCurrentRelation: Evaluation error in result section: ', /* error */ '.'],\n  resultSection_nullRelationToSave:\n        ['ResultSection.saveResultRelation: Resulting relation is null when trying to save it.'],\n  resultSection_nullRelationToAdd:\n        ['ResultSection.handleAddRelation: Resulting relation is null when trying to add it.'],\n\n  row_absentColumn:\n        ['Row.getOrderedValues: Column ', /* column */ ' is missing in a row with columns: ', /* column */ '.'],\n\n  valueParser_unexpectedToken:\n        ['ValueParser.rpnToVETreeRecursive: Unexpected token: ', /* token */ '.'],\n\n  exprParser_unexpectedToken:\n        ['ExprParser.isValidSequence: Unexpected token: ', /* token */ '.'],\n  exprParser_thetaJoinBranchError:\n        ['ExprParser.parseTokensForWhisper: Error in theta join branch: ', /* error */ '.'],\n  exprParser_projectionBranchError:\n        ['ExprParser.parseTokensForWhisper: Error in projection branch: ', /* error */ '.'],\n}\n\n/**\n * English messages for RASemanticErrors mapped by their error codes.\n */\nconst semanticErrors: SemanticErrorMessages = {\n  exprParser_relationNotDefined: ['Relation \"', /* relation */ '\" is not defined. Check definitions of relations.'],\n\n  binaryNode_commonColumns: ['Source relations for ', /* operator */ ' have common columns \"', /* columns */ '\".'],\n  setOperationNode_notEqualColumns:\n        ['Source relations \"', /* left */ '\" and \"', /* right */ '\" for set ', /* operation */ ' do not have the same column sets.'],\n  divisionNode_rightColumnsNotSubset:\n        ['Right-hand relation schema \"', /* schema */ '\" is not a subset of the left-hand relation schema \"', /* schema */ '\".'],\n  divisionNode_rightColumnsNotProperSubset:\n        ['Right-hand relation schema \"', /* schema */ '\" is not a proper subset of the left-hand relation schema \"',\n        /* schema */ '\". There must exist at least one column in the left relation which is not present in the right relation.'],\n  renameNode_absentOriginalColumn: ['Invalid renaming attempt, column \"', /* column */ '\" does not exist in the source relation.'],\n  renameNode_changeToDuplicit: ['Invalid renaming attempt, new column name \"', /* column */ '\" is ambiguous in the changed relation.'],\n  projectionNode_absentColumn: ['Invalid projection of the column \"', /* column */ '\". It does not exist in the source relation.'],\n  projectionNode_emptyProjection: ['Invalid projection attempt, no column to project.'],\n\n  referenceValue_absentColumn: ['Column \"', /* column */ '\" is missing in a schema with columns: ', /* columns */ '.'],\n}\n\n/**\n * English messages for RASyntaxErrors mapped by their error codes.\n */\nconst syntaxErrors: SyntaxErrorMessages = {\n  exprParser_emptyStringGiven: ['Cannot parse an expression from an empty string.'],\n  exprParser_outerJoinWhenNullNotSupported: ['Found ', /* outer join */ ' when null values are not supported.'],\n  exprParser_unexpectedPart: ['Unexpected part \"', /* part */ '\" in an expression.'],\n  exprParser_bothBranchesError: ['All combinations throw error in \"', /* part */ '\". When treated as projection:\\n',\n    /* error */ '\\nWhen treated as theta join:\\n', /* error */ ''],\n  exprParser_invalidExpression: ['Given string is not a valid relational algebra expression.'],\n  exprParser_invalidParentheses: ['Invalid structure of parentheses in the expression.'],\n  exprParser_invalidStart: ['Relational algebra expression cannot start with ', /* start */ '.'],\n  exprParser_invalidEnd: ['Relational algebra expression cannot end with ', /* end */ '.'],\n  exprParser_relationAfterRelation: ['Relation \"', /* relation */ '\" after relation \"', /* relation */'\".'],\n  exprParser_relationAfterUnary: ['Relation \"', /* relation */ '\" after unary operator \"', /* unary */ '\".'],\n  exprParser_relationAfterClosing: ['Relation \"', /* relation */ '\" after closing parenthesis.'],\n  exprParser_unaryAfterBinary: ['Unary operator \"', /* unary */ '\" after binary operator \"', /* binary */ '\".'],\n  exprParser_unaryAfterOpening: ['Unary operator \"', /* unary */ '\" after opening parenthesis.'],\n  exprParser_binaryAfterBinary: ['Binary operator \"', /* unary */ '\" after binary operator \"', /* binary */ '\".'],\n  exprParser_binaryAfterOpening: ['Binary operator \"', /* binary */ '\" after opening parenthesis.'],\n  exprParser_openingAfterRelation: ['Opening parenthesis after relation \"', /* relation */ '\".'],\n  exprParser_openingAfterUnary: ['Opening parenthesis after unary operator \"', /* unary */ '\".'],\n  exprParser_openingAfterClosing: ['Opening parenthesis after closing parenthesis.'],\n  exprParser_closingAfterBinary: ['Closing parenthesis after binary operator \"', /* binary */ '\".'],\n  exprParser_closingAfterOpening: ['Closing parenthesis after opening parenthesis.'],\n\n  valueParser_emptyInput: ['Empty string given as a condition.'],\n  valueParser_unsupportedNull: ['Null constant used when null values are not supported.'],\n  valueParser_unexpectedPart: ['Unexpected part \"', /* part */ '\" in the expression.'],\n  valueParser_missingOpeningParenthesis: [\"Missing opening parenthesis '(' in an expression.\"],\n  valueParser_missingClosingParenthesis: [\"Missing closing parenthesis ')' in an expression.\"],\n  valueParser_invalidExpression: ['Given string is not a valid expression.'],\n  valueParser_invalidStart: ['Expression cannot start with \"', /* start */ '\".'],\n  valueParser_invalidEnd: ['Expression cannot end with \"', /* end */ '\".'],\n  valueParser_literalAfterLiteral: ['Literal \"', /* literal */ '\" after literal \"', /* literal */ '\".'],\n  valueParser_literalAfterReference: ['Literal \"', /* literal */ '\" after reference to column \"', /* column */ '\".'],\n  valueParser_literalAfterClosing: ['Literal \"', /* literal */ '\" after closing parenthesis.'],\n  valueParser_referenceAfterLiteral: ['Reference to column \"', /* column */ '\" after literal \"', /* literal */ '\".'],\n  valueParser_referenceAfterReference: ['Reference to column \"', /* column */ '\" after reference to column \"', /* column */ '\".'],\n  valueParser_referenceAfterClosing: ['Reference to column \"', /* column */ '\" after closing parenthesis.'],\n  valueParser_notAfterLiteral: ['Logical not operator \"', /* not */ '\" after literal \"', /* literal */ '\".'],\n  valueParser_notAfterReference: ['Logical not operator \"', /* not */ '\" after reference to column \"', /* column */ '\".'],\n  valueParser_notAfterClosing: ['Logical not operator \"', /* not */ '\" after closing parenthesis.'],\n  valueParser_binaryAfterOperator: ['Binary operator \"', /* binary */ '\" after binary operator \"', /* binary */ '\".'],\n  valueParser_binaryAfterOpening: ['Binary operator \"', /* binary */ '\" after opening parenthesis.'],\n  valueParser_openingAfterLiteral: ['Opening parenthesis after literal \"', /* literal */ '\".'],\n  valueParser_openingAfterReference: ['Opening parenthesis after reference to column \"', /* column */ '\".'],\n  valueParser_openingAfterClosing: ['Opening parenthesis after closing parenthesis.'],\n  valueParser_closingAfterOperator: ['Closing parenthesis after binary operator \"', /* binary */ '\".'],\n  valueParser_closingAfterOpening: ['Closing parenthesis after opening parenthesis.'],\n\n  stringUtils_missingClosingChar: [\"Missing '\", /* closing char */ \"' after opening '\", /* opening char */ \"'.\"],\n  stringUtils_charNotFound: ['Expected \"', /* char */ '\" not found.'],\n\n  renameNode_missingArrow: ['Invalid renaming attempt, use the \"OldName -> NewName\" format separated by commas.'],\n  renameNode_invalidNewName: ['Invalid renaming attempt to \"', /* name */\n    '\". New column name must contain letters, numbers and underscores only and start with a letter or an underscore.'],\n  renameNode_keywordNewName: ['Invalid renaming attempt to \"', /* name */ '\". New column name cannot be a keyword.'],\n  renameNode_multipleRenameOfTheColumn: ['Multiple renaming attempts of column \"', /* name */ '\".'],\n\n  selectionNode_resultNotBoolean: ['Result of the selection condition ', /* condition */ ' is not a boolean value, but ', /* type */ '.'],\n  thetaJoinNode_resultNotBoolean: ['Result of the theta join condition ', /* condition */ ' is not a boolean value, but ', /* type */ '.'],\n\n  comparingOperator_differentInputTypes: ['Inputs for \"', /* operator */ '\"  have different types ', /* type */ ' and ', /* type */ '.'],\n  computingOperator_inputTypesNotNumbers: ['Inputs for \"', /* operator */ '\" are not both numbers, they are ', /* type */ ' and ', /* type */ '.'],\n  logicalOperator_leftInputNotBoolean: ['Left-hand input value for \"', /* operator */ '\" is not a boolean, but ', /* type */ '.'],\n  logicalOperator_rightInputNotBoolean: ['Right-hand input value for \"', /* operator */ '\" is not a boolean, but ', /* type */ '.'],\n}\n\nexport const EN: LanguageDef = {\n  abbr: 'EN',\n\n  relationErrors: {\n    emptyColumn: 'Column name cannot be empty',\n    duplicitColumn: 'Duplicit column name',\n    keywordColumn: 'Column name cannot be a keyword',\n    invalidColumn: 'Invalid characters in a column name',\n\n    unsupportedNull: 'Null values are not supported',\n    invalidNumber: 'Given string is not a number',\n    invalidBoolean: 'Given string is not a boolean',\n  },\n\n  codeErrors: codeErrors,\n\n  semanticErrors: semanticErrors,\n  semanticError: 'Semantic error: ',\n\n  syntaxErrors: syntaxErrors,\n  syntaxError: 'Syntax error: ',\n\n  userMessages: {\n    loadedRelationsTotalNo: 'No relations loaded in the application at the moment.',\n    loadedRelationsTotalSome: ' relations loaded at the moment: ',\n    loadRelationNew: 'Relation loaded to application.',\n    loadAllRelationsNew: [' relations loaded to application, ', /* number of skipped */ ' skipped for errors.'],\n    deleteLoadedRelations: ' relations deleted.',\n\n    relationsExportOK: 'Relations saved.',\n    relationsExportErr: 'Relations saving failed: ',\n    relationsImport: [' relations loaded, ', /* number of skipped */ ' files skipped.'],\n\n    expressionsExportOK: 'Expressions saved.',\n    expressionsExportErr: 'Expressions saving failed: ',\n    expressionsImport: [' expressions loaded from ', /* number of files */ ' files (',\n      /* number of skipped expressions */ ' expressions skipped, ', /* number of skipped files */ ' files skipped).'],\n  },\n\n  operations: {\n    selection: 'Selection',\n    projection: 'Projection',\n    rename: 'Rename',\n    union: 'Union',\n    intersection: 'Intersection',\n    difference: 'Difference',\n    naturalJoin: 'Natural join',\n    cartesianProduct: 'Cartesian product',\n    leftSemiJoin: 'Left semijoin',\n    rightSemiJoin: 'Right semijoin',\n    leftAntijoin: 'Left antijoin',\n    rightAntijoin: 'Right antijoin',\n    thetaJoin: 'Theta join',\n    leftThetaSemiJoin: 'Left theta semijoin',\n    rightThetaSemiJoin: 'Right theta semijoin',\n    fullOuterJoin: 'Full outer join',\n    leftOuterJoin: 'Left outer join',\n    rightOuterJoin: 'Right outer join',\n    division: 'Division',\n  },\n\n  managementSection: {\n    batchTitle: 'Batch',\n    batchLoad: 'Load projects',\n    batchConfig: 'Load config',\n    batchConfigInfo: ['Configuration ', /* filename */ ' with ', /* rules count */ ' rules'],\n    batchNoConfig: 'No configuration loaded',\n\n    loadButton: 'Load',\n    saveButton: 'Save',\n    samplesButton: 'Samples',\n    samplesMenuTitle: 'Sample projects',\n    settingsButton: 'Settings',\n    settingsNullValues: 'Null values',\n    settingsNullValuesAllowed: 'allowed',\n    settingsNullValuesForbidden: 'forbidden',\n    settingsCSVSeparator: 'CSV separator',\n    settingsCSVSeparatorSemicolon: 'semicolon',\n    settingsCSVSeparatorComma: 'comma',\n    settingsTheme: 'Theme',\n    settingsThemeLight: 'light',\n    settingsThemeDark: 'dark',\n    settingsLanguage: 'Language',\n    aboutButton: 'About',\n  },\n\n  relationSection: {\n    relationSectionHeader: 'Relations',\n    loadAllButton: 'Load all',\n    loadAllButtonTooltip: 'Loads all valid relation into the application',\n    removeLoadedButton: 'Remove loaded',\n    removeLoadedButtonTooltip: 'Removes all the currently loaded relations',\n    importButton: 'Import',\n    importButtonTooltip: 'Adds new relations from files',\n    exportButton: 'Export',\n    exportButtonTooltip: 'Saves all stored relations to files',\n    loadButton: 'Load',\n    loadButtonTooltip: 'Loads the selected relation into the application',\n    renameButton: 'Rename',\n    deleteButton: 'Delete',\n    deleteButtonTooltip: 'Deletes the selected relation',\n    revertButton: 'Revert',\n    revertButtonTooltip: 'Reverts the selected relation to the last loaded state',\n  },\n\n  expressionSection: {\n    expressionSectionHeader: 'Expressions',\n\n    importButton: 'Import',\n    importButtonTooltip: 'Adds new expressions from a file',\n    exportButton: 'Export',\n    exportButtonTooltip: 'Saves expressions to a file',\n\n    evaluateButton: 'Evaluate',\n    evaluateButtonTooltip: 'Evaluates the selected expression',\n    renameButton: 'Rename',\n    deleteButton: 'Delete',\n    deleteButtonTooltip: 'Deletes the selected expression',\n\n    expressionTextareaPlaceholder: 'Write relational algebra expression here...',\n\n    lineComment: 'Line comment',\n    blockComment: 'Block comment',\n  },\n\n  resultSection: {\n    resultSectionHeader: 'Result',\n\n    exportEvalTreeButton: 'Export',\n    exportEvalTreeButtonTooltip: 'Saves the evaluation tree as an image',\n    evalTreeTitle: 'Evaluation tree of',\n\n    resultRelationTitle: 'Result relation',\n    intermediateRelationTitle: 'Intermediate relation',\n    addButton: 'Add',\n    addButtonTooltip: 'Adds the given relation between the stored ones',\n    exportRelationButton: 'Export',\n    exportRelationButtonTooltip: 'Saves the selected relation to a file',\n  },\n}\n","import { LanguageDef } from './language'\nimport { EN } from './en'\nimport { SyntaxErrorMessages } from '../error/raSyntaxError'\nimport { SemanticErrorMessages } from '../error/raSemanticError'\n\n/**\n * Czech messages for RASemanticErrors mapped by their error codes.\n */\nconst semanticErrors: SemanticErrorMessages = {\n  exprParser_relationNotDefined: ['Relace \"', '\" není definována. Zkontrolujte definice relací.'],\n\n  binaryNode_commonColumns: ['Vstupní relace pro ', ' mají společné sloupce \"', '\".'],\n  setOperationNode_notEqualColumns: ['Vstupní relace \"', '\" a \"', '\" pro ', ' množin nemají stejné schéma.'],\n  divisionNode_rightColumnsNotSubset:\n        ['Schéma pravé vstupní relace \"', '\" není podmnožinou schématu levé vstupní relace \"', '\".'],\n  divisionNode_rightColumnsNotProperSubset:\n        ['Schéma pravé vstupní relace \"', '\" není vlastní podmnožinou schématu levé vstupní relace \"',\n          '. V levé relaci musí existovat sloupec, který neexistuje v pravé relaci.'],\n  renameNode_absentOriginalColumn: ['Nepovolené přejmenování, sloupec \"', '\" neexistuje ve vstupní relaci.'],\n  renameNode_changeToDuplicit: ['Nepovolené přejmenování, nový název sloupce \"', '\" je duplicitní ve změněné relaci.'],\n  projectionNode_absentColumn: ['Nepovolená projekce sloupce \"', '\". Tento sloupec neexistuje ve vstupní relaci.'],\n  projectionNode_emptyProjection: ['Nepovolená projekce, vždy musí být zachován alespoň jeden sloupec.'],\n\n  referenceValue_absentColumn: ['Sloupec \"', '\" neexistuje ve schématu se sloupci ', '.'],\n}\n\n/**\n * Czech messages for RASyntaxErrors mapped by their error codes.\n */\nconst syntaxErrors: SyntaxErrorMessages = {\n  exprParser_emptyStringGiven: ['Výraz nelze parsovat z prázdného řetězce.'],\n  exprParser_outerJoinWhenNullNotSupported: ['Nalezeno ', ', přestože null hodnoty jsou zakázány.'],\n  exprParser_unexpectedPart: ['Nečekaná část \"', '\" v RA výrazu.'],\n  exprParser_bothBranchesError: ['Všechny kombinace způsobují chybu v \"', '\". Považováno za projekci:\\n',\n    '\\nPovažováno za theta spojení:\\n', ''],\n  exprParser_invalidExpression: ['Daný výraz není korektní výraz relační algebry.'],\n  exprParser_invalidParentheses: ['Chybné uzávorkování ve výrazu.'],\n  exprParser_invalidStart: ['RA výraz nemůže začínat na ', '.'],\n  exprParser_invalidEnd: ['RA výraz nemůže končit na ', '.'],\n  exprParser_relationAfterRelation: ['Relace \"', '\" po relaci \"', '\".'],\n  exprParser_relationAfterUnary: ['Relace \"', '\" po unárním operátoru \"', '\".'],\n  exprParser_relationAfterClosing: ['Relace \"', '\" po uzavírací závorce.'],\n  exprParser_unaryAfterBinary: ['Unární operátor \"', '\" po binárním operátoru \"', '\".'],\n  exprParser_unaryAfterOpening: ['Unární operátor \"', '\" po otevírací závorce.'],\n  exprParser_binaryAfterBinary: ['Binární operátor \"', '\" po binárním operátoru \"', '\".'],\n  exprParser_binaryAfterOpening: ['Binární operátor \"', '\" po otevírací závorce.'],\n  exprParser_openingAfterRelation: ['Otevírací závorka po relaci \"', '\".'],\n  exprParser_openingAfterUnary: ['Otevírací závorka po unárním operátoru \"', '\".'],\n  exprParser_openingAfterClosing: ['Otevírací závorka po uzavírací závorce.'],\n  exprParser_closingAfterBinary: ['Uzavírací závorka po binárním operátoru \"', '\".'],\n  exprParser_closingAfterOpening: ['Uzavírací závorka po otevírací závorce.'],\n\n  valueParser_emptyInput: ['Jako podmínka nemůže být prázdný řetězec.'],\n  valueParser_unsupportedNull: ['Nalezena null konstanta, přestože null hodnoty jsou zakázány.'],\n  valueParser_unexpectedPart: ['Nečekaná část \"', '\" ve výrazu.'],\n  valueParser_missingOpeningParenthesis: ['Chybějící otevírací závorka ve výrazu.'],\n  valueParser_missingClosingParenthesis: ['Chybějící uzavírací závorka ve výrazu.'],\n  valueParser_invalidExpression: ['Daný výraz není korektní.'],\n  valueParser_invalidStart: ['Výraz nemůže začínat na \"', '\".'],\n  valueParser_invalidEnd: ['Výraz nemůže končit na \"', '\".'],\n  valueParser_literalAfterLiteral: ['Konstanta \"', '\" po konstantě \"', '\".'],\n  valueParser_literalAfterReference: ['Konstanta \"', '\" po referenci sloupce \"', '\".'],\n  valueParser_literalAfterClosing: ['Konstanta \"', '\" po uzavírací závorce.'],\n  valueParser_referenceAfterLiteral: ['Reference sloupce \"', '\" po konstantě \"', '\".'],\n  valueParser_referenceAfterReference: ['Reference sloupce \"', '\" po referenci sloupce \"', '\".'],\n  valueParser_referenceAfterClosing: ['Reference sloupce \"', '\" po uzavírací závorce.'],\n  valueParser_notAfterLiteral: ['Logická negace \"', '\" po konstantě \"', '\".'],\n  valueParser_notAfterReference: ['Logická negace \"', '\" po referenci sloupce \"', '\".'],\n  valueParser_notAfterClosing: ['Logická negace \"', '\" po uzavírací závorce.'],\n  valueParser_binaryAfterOperator: ['Binární operátor \"', '\" po binárním operátoru \"', '\".'],\n  valueParser_binaryAfterOpening: ['Binární operátor \"', '\" po otevírací závroce.'],\n  valueParser_openingAfterLiteral: ['Otevírací závorka po konstantě \"', '\".'],\n  valueParser_openingAfterReference: ['Otevírací závorka po referenci sloupce \"', '\".'],\n  valueParser_openingAfterClosing: ['Otevírací závorka po uzavírací závorce.'],\n  valueParser_closingAfterOperator: ['Uzavírací závorka po binárním operátoru \"', '\".'],\n  valueParser_closingAfterOpening: ['Uzavírací závorka po otevírací závroce.'],\n\n  stringUtils_missingClosingChar: [\"Chybějící '\", \"' po úvodní '\", \"'.\"],\n  stringUtils_charNotFound: ['Očekávaný znak \"', '\" nenalezen.'],\n\n  renameNode_missingArrow: ['Chybné přejmenování, použijte formát \"StarýNázev -> NovýNázev\" oddělený čárkami.'],\n  renameNode_invalidNewName: ['Chybné přejmenování na \"',\n    '\". Nový název sloupce musí obsahovat pouze písmena, čísla a podtržítka a začínat písmenem nebo podtržítkem.'],\n  renameNode_keywordNewName: ['Chybné přejmenování na \"', '\". Nový název nemůže být klíčové slovo.'],\n  renameNode_multipleRenameOfTheColumn: ['Vícenásobné přejmenování sloupce \"', '\".'],\n\n  selectionNode_resultNotBoolean: ['Výsledek podmínky v selekci ', ' není boolean, ale ', '.'],\n  thetaJoinNode_resultNotBoolean: ['Výsledek podmínky v theta joinu ', ' není boolean, ale ', '.'],\n\n  comparingOperator_differentInputTypes: ['Vstupy pro \"', '\" nemají stejné typy, ale ', ' a ', '.'],\n  computingOperator_inputTypesNotNumbers: ['Vstupy pro \"', '\" nejsou čísla, ale ', ' a ', '.'],\n  logicalOperator_leftInputNotBoolean: ['Levý vstup logického operátoru \"', '\" není boolean, ale ', '.'],\n  logicalOperator_rightInputNotBoolean: ['Pravý vstup logického operátoru \"', '\" není boolean, ale ', '.'],\n}\n\nexport const CS: LanguageDef = {\n  abbr: 'CS',\n\n  relationErrors: {\n    emptyColumn: 'Název sloupce nemůže být prázdný',\n    duplicitColumn: 'Duplicitní název sloupce',\n    keywordColumn: 'Název sloupce nemůže být klíčové slovo',\n    invalidColumn: 'Nepovolené znaky v názvu sloupce',\n\n    unsupportedNull: 'Null hodonoty nejsou podporovány',\n    invalidNumber: 'Daný řetězec není číslo',\n    invalidBoolean: 'Daný řetězec není boolean',\n  },\n\n  codeErrors: EN.codeErrors,\n\n  semanticErrors: semanticErrors,\n  semanticError: 'Sémantická chyba: ',\n\n  syntaxErrors: syntaxErrors,\n  syntaxError: 'Syntaktická chyba: ',\n\n  userMessages: {\n    loadedRelationsTotalNo: 'Nyní nejsou v aplikaci nahrané žádné relace.',\n    loadedRelationsTotalSome: ' relací celkově nahráno v aplikaci: ',\n    loadRelationNew: 'Relace nahrána do aplikace.',\n    loadAllRelationsNew: [' relací nahráno do aplikace, ', /* number of skipped */ ' přeskočeno kvůli chybám.'],\n    deleteLoadedRelations: ' relací odebráno.',\n\n    relationsExportOK: 'Relace staženy.',\n    relationsExportErr: 'Stahování relací selhalo: ',\n    relationsImport: [' relací nahráno, ', ' souborů přeskočeno.'],\n\n    expressionsExportOK: 'Výrazy staženy do souboru.',\n    expressionsExportErr: 'Stahování výrazů selhalo: ',\n    expressionsImport: [' výrazů nahráno z ', /* number of files */ ' souborů (',\n      /* number of skipped expressions */ ' výrazů přeskočeno, ', /* number of skipped files */ ' souborů přeskočeno).'],\n  },\n\n  operations: {\n    selection: 'Selekce',\n    projection: 'Projekce',\n    rename: 'Přejmenování',\n    union: 'Sjednocení',\n    intersection: 'Průnik',\n    difference: 'Rozdíl',\n    naturalJoin: 'Přirozené spojení',\n    cartesianProduct: 'Kartézský součin',\n    leftSemiJoin: 'Levé vnitřní spojení',\n    rightSemiJoin: 'Pravé vnitřní spojení',\n    leftAntijoin: 'Levý antijoin',\n    rightAntijoin: 'Pravý antijoin',\n    thetaJoin: 'Theta spojení',\n    leftThetaSemiJoin: 'Levé theta spojení',\n    rightThetaSemiJoin: 'Pravé theta spojení',\n    fullOuterJoin: 'Plné vnější spojení',\n    leftOuterJoin: 'Levé vnější spojení',\n    rightOuterJoin: 'Pravé vnější spojení',\n    division: 'Dělení',\n  },\n\n  managementSection: {\n    batchTitle: 'Batch',\n    batchLoad: 'Nahrát projekty',\n    batchConfig: 'Konfigurovat',\n    batchConfigInfo: ['Konfigurace ', /* filename */ ' s ', /* rules count */ ' pravidly'],\n    batchNoConfig: 'Není nahrána žádná konfigurace',\n\n    loadButton: 'Nahrát',\n    saveButton: 'Uložit',\n\n    samplesButton: 'Ukázky',\n    samplesMenuTitle: 'Připravené vzorové projekty',\n    settingsButton: 'Nastavení',\n    settingsNullValues: 'Null hodnoty',\n    settingsNullValuesAllowed: 'povoleny',\n    settingsNullValuesForbidden: 'zakázány',\n    settingsCSVSeparator: 'CSV oddělovač',\n    settingsCSVSeparatorSemicolon: 'středník',\n    settingsCSVSeparatorComma: 'čárka',\n    settingsTheme: 'Režim',\n    settingsThemeLight: 'světlý',\n    settingsThemeDark: 'tmavý',\n    settingsLanguage: 'Jazyk',\n    aboutButton: 'O aplikaci',\n  },\n\n  relationSection: {\n    relationSectionHeader: 'Relace',\n    loadAllButton: 'Nahrát všechny',\n    loadAllButtonTooltip: 'Nahraje všechny bezchybné relace do aplikace',\n    removeLoadedButton: 'Odebrat nahrané',\n    removeLoadedButtonTooltip: 'Odebere všechny nahrané relace z aplikace',\n    importButton: 'Import',\n    importButtonTooltip: 'Nahraje nové relace ze souborů',\n    exportButton: 'Export',\n    exportButtonTooltip: 'Stáhne editované relace do souborů',\n    loadButton: 'Nahrát',\n    loadButtonTooltip: 'Nahraje relaci do aplikace',\n    renameButton: 'Přejmenovat',\n    deleteButton: 'Odstranit',\n    deleteButtonTooltip: 'Odstraní vybranou relaci',\n    revertButton: 'Obnovit',\n    revertButtonTooltip: 'Obnoví relaci do posledního nahraného stavu',\n  },\n\n  expressionSection: {\n    expressionSectionHeader: 'Výrazy',\n\n    importButton: 'Import',\n    importButtonTooltip: 'Nahraje nové výrazy ze souboru',\n    exportButton: 'Export',\n    exportButtonTooltip: 'Stáhne výrazy do souboru',\n\n    evaluateButton: 'Vyhodnotit',\n    evaluateButtonTooltip: 'Vyhodnotí vybraný relační výraz',\n    renameButton: 'Přejmenovat',\n    deleteButton: 'Odstranit',\n    deleteButtonTooltip: 'Odstraní vybraný relační výraz',\n\n    expressionTextareaPlaceholder: 'Zde napište svůj relační výraz...',\n\n    lineComment: 'Řádkový komentář',\n    blockComment: 'Blokový komentář',\n  },\n\n  resultSection: {\n    resultSectionHeader: 'Výsledek',\n\n    exportEvalTreeButton: 'Export',\n    exportEvalTreeButtonTooltip: 'Uloží evaluační strom jako obrázek',\n    evalTreeTitle: 'Evaluační strom pro',\n\n    resultRelationTitle: 'Výsledná relace',\n    intermediateRelationTitle: 'Mezivýsledná relace',\n    addButton: 'Přidat',\n    addButtonTooltip: 'Přidá zvolenou relaci mezi editované',\n    exportRelationButton: 'Export',\n    exportRelationButtonTooltip: 'Stáhne zvolenou relaci do souboru',\n  },\n}\n","import { ErrorWithTextRange } from './errorWithTextRange'\nimport { language } from '../language/language'\nimport { StartEndPair } from '../types/startEndPair'\n\n/**\n * Messages for {@link RASyntaxError}.\n * The description is a string array - between its members are inserted error parameters (names of invalid relations,\n * invalid input parts, etc.). See english language definition for expected structure of each error description.\n * @category Errors\n * @public\n */\nexport interface SyntaxErrorMessages {\n  // expects 1 part\n  exprParser_emptyStringGiven: string[]\n  // expects 2 parts\n  exprParser_outerJoinWhenNullNotSupported: string[]\n  // expects 2 parts\n  exprParser_unexpectedPart: string[]\n  // expects 4 parts\n  exprParser_bothBranchesError: string[]\n  // expects 1 part\n  exprParser_invalidExpression: string[]\n  // expects 1 part\n  exprParser_invalidParentheses: string[]\n  // expects 2 parts\n  exprParser_invalidStart: string[]\n  // expects 2 parts\n  exprParser_invalidEnd: string[]\n  // expects 3 parts\n  exprParser_relationAfterRelation: string[]\n  // expects 3 parts\n  exprParser_relationAfterUnary: string[]\n  // expects 2 parts\n  exprParser_relationAfterClosing: string[]\n  // expects 3 parts\n  exprParser_unaryAfterBinary: string[]\n  // expects 2 parts\n  exprParser_unaryAfterOpening: string[]\n  // expects 3 parts\n  exprParser_binaryAfterBinary: string[]\n  // expects 2 parts\n  exprParser_binaryAfterOpening: string[]\n  // expects 2 parts\n  exprParser_openingAfterRelation: string[]\n  // expects 2 parts\n  exprParser_openingAfterUnary: string[]\n  // expects 1 part\n  exprParser_openingAfterClosing: string[]\n  // expects 2 parts\n  exprParser_closingAfterBinary: string[]\n  // expects 1 part\n  exprParser_closingAfterOpening: string[]\n\n  // expects 1 part\n  valueParser_emptyInput: string[]\n  // expects 1 part\n  valueParser_unsupportedNull: string[]\n  // expects 2 parts\n  valueParser_unexpectedPart: string[]\n  // expects 1 part\n  valueParser_missingOpeningParenthesis: string[]\n  // expects 1 part\n  valueParser_missingClosingParenthesis: string[]\n  // expects 1 part\n  valueParser_invalidExpression: string[]\n  // expects 2 parts\n  valueParser_invalidStart: string[]\n  // expects 2 parts\n  valueParser_invalidEnd: string[]\n  // expects 3 parts\n  valueParser_literalAfterLiteral: string[]\n  // expects 3 parts\n  valueParser_literalAfterReference: string[]\n  // expects 2 parts\n  valueParser_literalAfterClosing: string[]\n  // expects 3 parts\n  valueParser_referenceAfterLiteral: string[]\n  // expects 3 parts\n  valueParser_referenceAfterReference: string[]\n  // expects 2 parts\n  valueParser_referenceAfterClosing: string[]\n  // expects 3 parts\n  valueParser_notAfterLiteral: string[]\n  // expects 3 parts\n  valueParser_notAfterReference: string[]\n  // expects 2 parts\n  valueParser_notAfterClosing: string[]\n  // expects 3 parts\n  valueParser_binaryAfterOperator: string[]\n  // expects 2 parts\n  valueParser_binaryAfterOpening: string[]\n  // expects 2 parts\n  valueParser_openingAfterLiteral: string[]\n  // expects 2 parts\n  valueParser_openingAfterReference: string[]\n  // expects 1 part\n  valueParser_openingAfterClosing: string[]\n  // expects 2 parts\n  valueParser_closingAfterOperator: string[]\n  // expects 1 part\n  valueParser_closingAfterOpening: string[]\n\n  // expects 3 parts\n  stringUtils_missingClosingChar: string[]\n  // expects 2 parts\n  stringUtils_charNotFound: string[]\n\n  // expects 1 part\n  renameNode_missingArrow: string[]\n  // expects 2 parts\n  renameNode_invalidNewName: string[]\n  // expects 2 parts\n  renameNode_keywordNewName: string[]\n  // expects 2 parts\n  renameNode_multipleRenameOfTheColumn: string[]\n\n  // expects 3 parts\n  selectionNode_resultNotBoolean: string[]\n  // expects 3 parts\n  thetaJoinNode_resultNotBoolean: string[]\n\n  // expects 4 parts\n  comparingOperator_differentInputTypes: string[]\n  // expects 4 parts\n  computingOperator_inputTypesNotNumbers: string[]\n  // expects 3 parts\n  logicalOperator_leftInputNotBoolean: string[]\n  // expects 3 parts\n  logicalOperator_rightInputNotBoolean: string[]\n}\n\n/**\n * Syntax error in an expression structure.\n * @extends ErrorWithTextRange\n * @category Errors\n * @public\n */\nexport class RASyntaxError extends ErrorWithTextRange {\n  /**\n     * Creates a new RASyntaxError with the given message.\n     *\n     * @param msg error message {@type string}\n     * @param range optional text range of the error {@type StartEndPair?}\n     * @public\n     */\n  constructor (msg: string, range: StartEndPair | undefined) {\n    super(language().syntaxError + msg, range)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, RASyntaxError)\n    }\n    this.name = 'RASyntaxError'\n  }\n}\n","import { ErrorWithTextRange } from './errorWithTextRange'\nimport { language } from '../language/language'\nimport { StartEndPair } from '../types/startEndPair'\n\n/**\n * Messages for {@type RASemanticError}.\n * The description is a string array - between its members are inserted error parameters (names of invalid relations,\n * invalid input parts, etc.). See english language definition for expected structure of each error description.\n * @category Errors\n * @public\n */\nexport interface SemanticErrorMessages {\n  // expects 2 parts\n  exprParser_relationNotDefined: string[]\n\n  // expects 3 parts\n  binaryNode_commonColumns: string[]\n  // expects 4 parts\n  setOperationNode_notEqualColumns: string[]\n  // expects 3 parts\n  divisionNode_rightColumnsNotSubset: string[]\n  // expects 3 parts\n  divisionNode_rightColumnsNotProperSubset: string[]\n  // expects 2 parts\n  renameNode_absentOriginalColumn: string[]\n  // expects 2 parts\n  renameNode_changeToDuplicit: string[]\n  // expects 2 parts\n  projectionNode_absentColumn: string[]\n  // expects part\n  projectionNode_emptyProjection: string[]\n\n  // expects 3 parts\n  referenceValue_absentColumn: string[]\n}\n\n/**\n * Semantic error in an expression structure.\n * @extends ErrorWithTextRange\n * @category Errors\n * @public\n */\nexport class RASemanticError extends ErrorWithTextRange {\n  /**\n     * Creates a new RASemanticError with the given message.\n     *\n     * @param msg error message {@type string}\n     * @param range optional text range of the error {@type StartEndPair?}\n     * @public\n     */\n  constructor (msg: string, range: StartEndPair | undefined) {\n    super(language().semanticError + msg, range)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, RASemanticError)\n    }\n    this.name = 'RASemanticError'\n  }\n}\n","/**\n * Computes width (average on sample of characters) and its height of the given font with given size in pixels.\n *\n * @param fontFamily font to use {@type string}\n * @param fontSize size to use {@type string}\n * @return average width and height of the given font {@type {{fontWidth: number, fontHeight: number}}}\n * @category Utils\n * @public\n */\nexport function computeFontSizeInPx (fontFamily: string, fontSize: string): {fontWidth: number, fontHeight: number} {\n  const text = \"0123456789qwertyuiopasdfghjkllzxcvbnmQWERTYUIOOPASDFGHJKLLZXCVBNM!@#$%^&*()_+[];',./\"\n  const div = document.createElement('div')\n  div.setAttribute('style', `font-family: ${fontFamily}; font-size: ${fontSize}; position: absolute; white-space: nowrap;`)\n  div.innerText = text\n  document.documentElement.appendChild(div)\n  const divWidth: number = div.clientWidth\n  const divHeight: number = div.clientHeight\n  div.remove()\n  return { fontWidth: divWidth / text.length, fontHeight: divHeight }\n}\n","/**\n * Returns start index of the word before the given index in the given string.\n *\n * @param str string to search in {@type string}\n * @param index index before which the word starts {@type number}\n * @return start index of the word before the given index in the given string {@type number}\n * @category Utils\n * @public\n */\nexport function getStartOfWordBeforeIndex (str: string, index: number): number {\n  const prefixText: string = str.slice(0, index)\n  let i: number = prefixText.length - 1\n  while (true) {\n    // if non-name-character is reached\n    if (!(/\\w/.exec(prefixText.charAt(i)))) {\n      ++i\n      break\n    }\n    if (i === 0) {\n      break\n    }\n    --i\n  }\n  return i\n}\n\n/**\n * Returns sorted given array of whispers with respect to given last word before cursor.\n * Matched word parts in the whispers are highlighted by CSS span. Not-matched words are made grey.\n *\n * @param whispers whispers to sort (not modified) {@type string[]}\n * @param wordBeforeCursor string to use for sorting {@type string}\n * @return sorted whispers {@type string[]}\n * @category Utils\n * @public\n */\nexport function sortWhispers (whispers: string[], wordBeforeCursor: string): string[] {\n  // values for sorting whispers\n  const startsWithWord = 2\n  const containsWord = 1\n  // creates help array with whisper likelihoods and highlighted matched parts\n  const helpArray: {whisper: string, likelihood: number}[] = whispers.map(whisper => {\n    let likelihood = 0\n    const wordStart = whisper.toLowerCase().indexOf(wordBeforeCursor.toLowerCase())\n    if (wordStart > -1) {\n      likelihood += wordStart === 0 ? startsWithWord : containsWord\n      const wordEnd = wordStart + wordBeforeCursor.length\n      whisper = whisper.slice(0, wordStart) + \"<span class='whisper-matched-word'>\"\n                + whisper.slice(wordStart, wordEnd) + '</span>' + whisper.slice(wordEnd)\n    }\n    if (likelihood === 0) {\n      whisper = \"<span class='whisper-rejected-word'>\" + whisper + '</span>'\n    }\n    return { whisper, likelihood }\n  })\n  if (wordBeforeCursor !== '') {\n    helpArray.sort((x, y) => y.likelihood - x.likelihood)\n  }\n  return helpArray.map(help => help.whisper)\n}\n","import React from 'react'\nimport './css/xTextArea.css'\nimport { mod } from '../utils/math'\nimport { computeFontSizeInPx } from '../utils/fontUtils'\nimport { getStartOfWordBeforeIndex } from '../utils/whisperUtils'\nimport { StartEndPair } from '../types/startEndPair'\n\n/**\n * Description of an error located in the input text.\n * @category Components\n * @public\n */\nexport interface LocatedError {\n  /**\n     * index of the first error character\n     * @type number\n     * @public\n     */\n  start: number\n  /**\n     * index of the last error character\n     * @type number\n     * @public\n     */\n  end: number\n  /**\n     * error message\n     * @type string\n     * @public\n     */\n  msg: string\n}\n\n/**\n * Props of XTextArea component.\n * @category Components\n * @public\n */\ninterface XTextAreaProps {\n  /**\n     * id of the component\n     * @type string\n     * @public\n     */\n  id: string\n  /**\n     * current text content of the textarea\n     * @type string\n     * @public\n     */\n  text: string\n  /**\n     * text to be shown as textarea placeholder\n     * @type string\n     * @public\n     */\n  placeholder: string\n  /**\n     * error messages and ranges to be highlighted in text area\n     * @type LocatedError[]\n     * @public\n     */\n  errors: LocatedError[]\n  /**\n     * pairs of parentheses\n     * @type StartEndPair[]\n     * @public\n     */\n  parentheses: StartEndPair[]\n  /**\n     * strings whispered to the user to be added at the current position\n     * @type string[]\n     * @public\n     */\n  whispers: string[]\n  /**\n     * handler of text change\n     * @type function\n     * @public\n     */\n  onChange: (text: string, cursorIndex: number) => void\n  /**\n     * handler of input with Ctrl key\n     * @type function\n     * @public\n     */\n  onCtrlInput: (ev: KeyboardEvent) => void\n  /**\n     * true if dark theme should be applied\n     * @type boolean\n     * @public\n     */\n  darkTheme: boolean\n}\n\ninterface XTextAreaState {}\n\n/**\n * HTMLTextAreaElement extended for painting number lines, inserting strings given from parent and whispering.\n */\ntype ExtendedHTMLTextArea = HTMLTextAreaElement & {\n  /**\n     * (Re)paints line numbers next to textarea.\n     *\n     * @param darkTheme style to be applied to numbers\n     */\n  paintLineNumbers: (darkTheme: boolean) => void,\n  // reference to canvas element used to paint line numbers\n  canvasLines: HTMLCanvasElement,\n  // true when the mouse button is clicked down\n  mouseIsDown: boolean,\n\n  /**\n     * Updates textarea content to the given value. Updates number of lines.\n     */\n  update: (value: string, darkTheme: boolean) => void,\n  // number of lines in the textarea\n  linesCount: number,\n\n  /**\n     * Whispers given array of strings to the user at the current cursor position.\n     *\n     * @param toWhisper\n     */\n  createWhisper: (whispers: string[]) => void,\n  /**\n     * Moves the WhisperDiv to be located next to the current cursor position.\n     * The WhisperDiv is moved only if the whisperDiv.isShown is true.\n     */\n  moveWhisper: () => void,\n  /**\n     * Hides the WhisperDiv (whisperDiv.isShown is set to false).\n     */\n  hideWhisper: () => void,\n  /**\n     * Inserts current selected whisper.\n     *\n     * @param onChange callback to the parent after text change\n     */\n  insertCurrentSelectedWhisper: () => void,\n  // true when the whisper should not be shown automatically (e.g., after pressing Enter)\n  notAutoShowWhisper: boolean,\n  // reference to whisper div\n  whisperDiv: WhisperDiv,\n\n  /**\n     * Creates error div elements for given ranges.\n     */\n  updateErrors: (ranges: LocatedError[]) => void,\n  /**\n     * Moves error div elements to current position.\n     */\n  moveErrors: () => void,\n  // div elements for highlighting errors\n  errorDivs: ErrorDiv[],\n\n  /**\n     * Creates parentheses div elements for parentheses next to the cursor.\n     */\n  updateParentheses: () => void,\n  /**\n     * Moves parentheses div elements to current position.\n     */\n  moveParentheses: () => void,\n  // positions of parentheses pairs in text\n  parentheses: StartEndPair[],\n  // div elements for highlighting parentheses\n  parenthesesDivs: ParenthesesDiv[],\n\n  /**\n     * Insert given pair of symbols at the cursor position. If a part of text is selected, it inserts the first symbol\n     * before it and the second symbol after it.\n     */\n  insertPairSymbol: (first: string, second: string) => void,\n  /**\n     * Deletes characters before and after the cursor if the adjacent characters are pair symbols: (), [], <>, \"\".\n     * If the pair was deleted, returns true, otherwise returns false.\n     */\n  checkPairSymbolDelete: () => boolean,\n}\n\n/**\n * HTMLDivElement extended by functions for easy whispering.\n */\ntype WhisperDiv = HTMLDivElement & {\n  // true when the whisper should be shown\n  isShown: boolean,\n  // index of the selected whisper\n  selectedIndex: number,\n  /**\n     * Updates selected whisper by given difference. Removes highlights from previous highlighted whisper and\n     * highlights the new selected. The new index is modulo actual whisper count. The function does nothing, when\n     * there no whispers at the moment.\n     *\n     * @param indexDiff\n     */\n  changeSelected: (indexDiff: number) => void,\n  /**\n     * Updates selected whisper to given index. Removes highlights from previous highlighted whisper and\n     * highlights the new selected. The new index is modulo actual whisper count. The function does nothing, when\n     * there no whispers at the moment.\n     *\n     * @param newIndex\n     */\n  setSelected: (newIndex: number) => void,\n  /**\n     * Returns current selected whisper or undefined, when no whisper is selected.\n     */\n  getSelectedWhisper: () => string | undefined,\n}\n\n/**\n * HTMLDivElement extended by data for error highlighting.\n */\ntype ErrorDiv = HTMLDivElement & {\n  startLine: number,\n  startColumn: number,\n  rangeLength: number,\n  messageSpan: HTMLSpanElement,\n}\n\n/**\n * HTMLDivElement extended by data for parentheses highlighting.\n */\ntype ParenthesesDiv = HTMLDivElement & {\n  startLine: number,\n  startColumn: number,\n}\n\n// @ts-ignore\nconst cssConstants: CSSStyleDeclaration = getComputedStyle(document.querySelector(':root'))\n\nconst fontSize: string = cssConstants.getPropertyValue('--x-textarea-font-size')\nconst fontFamily: string = cssConstants.getPropertyValue('--x-textarea-font-family')\nconst { fontWidth } = computeFontSizeInPx(fontFamily, fontSize)\nconst lineHeight = Number(cssConstants.getPropertyValue('--x-textarea-line-height'))\nconst numsBackgroundLight: string = cssConstants.getPropertyValue('--light-color-b')\nconst numsBackgroundDark: string = cssConstants.getPropertyValue('--dark-color-b')\nconst numsColorLight: string = cssConstants.getPropertyValue('--text-color-light')\nconst numsColorDark: string = cssConstants.getPropertyValue('--text-color-dark')\nconst canvasWidth = 24\n\n/**\n * TextArea extended by line numbers and text highlighting. The component is maintained by JavaScript HTML functions,\n * not by React.\n * Accepts {@link XTextAreaProps} props.\n * @category Components\n * @public\n */\nexport class XTextArea extends React.Component<XTextAreaProps, XTextAreaState> {\n  // @ts-ignore - always set before usage in componentDidMount\n  private textarea: ExtendedHTMLTextArea\n\n  /**\n     * Returns current text area selection start and end.\n     * @return current text area selection start and end {@type StartEndPair}\n     * @public\n     */\n  getSelection (): StartEndPair {\n    return { start: this.textarea.selectionStart, end: this.textarea.selectionEnd }\n  }\n\n  /**\n     * Sets text area selection start and end. If end is not given, start value is used as end value as well.\n     *\n     * @param start start index {@type number}\n     * @param end end index {@type number}\n     * @public\n     */\n  setSelection (start: number, end?: number): void {\n    this.textarea.setSelectionRange(start, end || start)\n  }\n\n  /**\n     * Returns true if the textarea has focus.\n     * @return true if the textarea has focus {@type boolean}\n     * @public\n     */\n  isFocused (): boolean {\n    return document.activeElement !== null && document.activeElement.id === this.props.id + '-ta'\n  }\n\n  /**\n     * The text area gains focus in the window.\n     * @public\n     */\n  focus (): void {\n    this.textarea.focus()\n  }\n\n  /**\n     * Sets the given placeholder in the textarea.\n     * @param placeholder placeholder to be set\n     * @public\n     */\n  setPlaceholder (placeholder: string): void {\n    this.textarea.placeholder = placeholder\n  }\n\n  /**\n     * The component is build by JavaScript HTML functions after mount of the empty div in render function.\n     */\n  componentDidMount () {\n    const props: Readonly<XTextAreaProps> = this.props\n    // @ts-ignore - gets parent div\n    const div: HTMLDivElement = document.getElementById(props.id)\n\n    // LAYOUT (table with 1 row and 2 columns)\n    const table = document.createElement('table')\n    table.setAttribute('cellspacing', '0')\n    table.setAttribute('cellpadding', '0')\n    table.classList.add('x-textarea-table')\n    const tr = document.createElement('tr')\n    const td1 = document.createElement('td')\n    td1.setAttribute('id', props.id + '-td1')\n    td1.classList.add('x-textarea-table-td1')\n    const td2 = document.createElement('td')\n    td2.classList.add('x-textarea-table-td2')\n    tr.appendChild(td1)\n    tr.appendChild(td2)\n    table.appendChild(tr)\n\n    // TEXTAREA\n    // @ts-ignore - extended later in componentDidMount\n    const ta: ExtendedHTMLTextArea = document.createElement('textarea')\n    ta.setAttribute('id', props.id + '-ta')\n    ta.setAttribute('spellcheck', 'false')\n    ta.mouseIsDown = false\n    ta.setAttribute('placeholder', this.props.placeholder)\n    ta.classList.add('x-textarea', 'scrollbar-container')\n    ta.value = props.text\n\n    // TEXTAREA NUMBERS (Canvas)\n    const canvas = document.createElement('canvas')\n    canvas.width = canvasWidth + 4    // must not set width & height in css !!!\n    canvas.classList.add('x-textarea-canvas')\n    ta.canvasLines = canvas\n    td1.appendChild(canvas)\n    td2.appendChild(ta)\n    div.appendChild(table)\n\n    // TEXTAREA WHISPER DIV\n    // @ts-ignore - extended later in componentDidMount\n    const whisperDiv: WhisperDiv = document.createElement('div')\n    whisperDiv.classList.add('whisper-div')\n    whisperDiv.isShown = false\n    whisperDiv.selectedIndex = -1\n    whisperDiv.changeSelected = function (indexDiff: number) {\n      this.setSelected(this.selectedIndex + indexDiff)\n    }\n    whisperDiv.setSelected = function (newIndex: number) {\n      if (this.childElementCount > 0) {\n        // removes selected highlight from previous selected whisper (if it is valid)\n        if (this.selectedIndex > -1 && this.selectedIndex < this.childElementCount) {\n          this.children[this.selectedIndex].classList.remove('selected-whisper')\n        }\n        // updates the index modulo child count\n        this.selectedIndex = mod(newIndex, this.childElementCount)\n        // adds selected highlight\n        this.children[this.selectedIndex].classList.add('selected-whisper')\n      }\n    }\n    whisperDiv.getSelectedWhisper = function (): string | undefined {\n      if (this.selectedIndex > -1 && this.childElementCount > 0) {\n        // @ts-ignore\n        return this.children[this.selectedIndex].innerText\n      }\n      return undefined\n    }\n    ta.whisperDiv = whisperDiv\n    td2.appendChild(whisperDiv)\n\n    // Line numbers rendering inspired by: https://www.w3schools.com/code/tryit.asp?filename=G68VMFWS12UH,\n    // Nikola Bozovic, nigerija@gmail.com\n    ta.paintLineNumbers = function (darkTheme: boolean): void {\n      try {\n        const canvas = this.canvasLines\n        if (canvas.height !== this.clientHeight) {\n          canvas.height = this.clientHeight // on resize\n        }\n        // @ts-ignore\n        const ctx: CanvasRenderingContext2D = canvas.getContext('2d')\n        ctx.fillStyle = darkTheme ? numsBackgroundDark : numsBackgroundLight\n        ctx.fillRect(0, 0, canvasWidth + 2, this.scrollHeight + 1)\n        ctx.fillStyle = darkTheme ? numsColorDark : numsColorLight\n        ctx.font = fontSize + ' ' + fontFamily\n        for (let i = 0; i < this.linesCount; i++) {\n          const text = '' + (i + 1)  // line number\n          ctx.fillText(text, canvasWidth - (text.length * 8), 19 + (i * lineHeight))\n        }\n      } catch (e) {\n        console.log('XTextArea paintLineNumbers error: ' + e)\n      }\n    }\n\n    ta.update = function (value: string, darkTheme: boolean) {\n      this.value = value\n      // computes lines count\n      let lines = 1\n      for (let i = 0; i < value.length; ++i) {\n        if (value.charAt(i) === '\\n') {\n          ++lines\n        }\n      }\n      this.linesCount = lines\n      // set height to fit all lines\n      this.style.height = (lines * lineHeight + 8) + 'px'\n      // if the horizontal scrollbar is visible, fits it into the height\n      if (this.scrollHeight > this.clientHeight) {\n        this.style.height = (this.scrollHeight + lineHeight + 10) + 'px'\n      }\n      this.paintLineNumbers(darkTheme)\n      this.updateParentheses()\n    }\n\n    ta.createWhisper = function (whispers: string[]): void {\n      if (whispers.length === 0) {\n        this.hideWhisper()\n      } else {\n        this.whisperDiv.innerHTML = ''\n        whispers.forEach((whisper, i) => {\n          const div = document.createElement('div')\n          div.innerHTML = whisper\n          div.onclick = event => {\n            this.focus()\n            this.whisperDiv.setSelected(i)\n            event.stopPropagation()\n          }\n          div.ondblclick = event => {\n            this.focus()\n            this.insertCurrentSelectedWhisper()\n            this.notAutoShowWhisper = true\n            event.stopPropagation()\n          }\n          this.whisperDiv.appendChild(div)\n        })\n        // selects the first whisper after change\n        this.whisperDiv.setSelected(0)\n        // needs to be set to true before moveWhisper call\n        this.whisperDiv.isShown = true\n        // sets the div position\n        this.moveWhisper()\n      }\n    }\n\n    ta.moveWhisper = function () {\n      // updates only if the whisper is shown\n      if (this.whisperDiv.isShown) {\n        // finds cursor position in the whole string\n        const cursorLineAndColumn = getPositionLineAndColumn(this.value, this.selectionEnd)\n        // computes position of the bottom end of the cursor relative to the text\n        const cursorDistanceFromTATotalTop: number = (cursorLineAndColumn.line + 1) * lineHeight\n        const cursorDistanceFromTATotalLeft: number = cursorLineAndColumn.column * fontWidth\n        const yPos: number = cursorDistanceFromTATotalTop - this.scrollTop\n        const xPos: number = cursorDistanceFromTATotalLeft - this.scrollLeft + 4\n        // shows the div at computed position if the cursor is visible\n        if (yPos >= 0 && yPos < this.clientHeight && xPos >= 0 && xPos < this.clientWidth) {\n          // if the div is in the upper part of the screen, shows it under the cursor\n          if (this.getBoundingClientRect().y + yPos <= window.innerHeight / 2) {\n            this.whisperDiv.setAttribute('style', `display: block; top: ${yPos + 4}px; left: ${xPos}px;`)\n          }\n          // if the div is in the lower part of the screen, shows it above the cursor\n          else {\n            this.whisperDiv.setAttribute('style',\n                            `display: block; bottom: ${this.getBoundingClientRect().height - yPos + lineHeight}px; left: ${xPos}px;`)\n          }\n        }\n        // hides the div if the cursor is not visible (but DOES NOT SET whisperDiv.isShown to false to re-appear it again)\n        else {\n          this.whisperDiv.setAttribute('style', 'display: none;')\n        }\n      }\n    }\n\n    ta.hideWhisper = function () {\n      // whisperDiv.innerHTML = '';\n      this.whisperDiv.setAttribute('style', 'display: none;')\n      this.whisperDiv.isShown = false\n    }\n\n    ta.insertCurrentSelectedWhisper = function () {\n      const currWhisper: string | undefined = this.whisperDiv.getSelectedWhisper()\n      if (currWhisper !== undefined) {\n        const i: number = getStartOfWordBeforeIndex(this.value, this.selectionEnd)\n        const beforeAdd: string = this.value.slice(0, i)\n        const afterAdd: string = this.value.slice(this.selectionEnd)\n        const newCursorPos: number = i + currWhisper.length\n        props.onChange(beforeAdd + currWhisper + afterAdd, newCursorPos)\n        this.setSelectionRange(newCursorPos, newCursorPos)\n        this.hideWhisper()\n      }\n    }\n\n    ta.notAutoShowWhisper = false\n\n    // TEXTAREA ERROR RANGE HIGHLIGHTS\n    ta.errorDivs = []\n\n    ta.moveErrors = function () {\n      this.errorDivs.forEach(highlight => {\n        // computes position of the highlight relative to the text\n        const yPos: number = (highlight.startLine + 1) * lineHeight + 1 - this.scrollTop\n        // shows the div at computed position if the line is visible\n        if (yPos > 1 && yPos < this.clientHeight) {\n          let width: number = highlight.rangeLength * fontWidth\n          let xPos: number = highlight.startColumn * fontWidth + 7 - this.scrollLeft\n          // if the whole highlight is out of the width, does not display it\n          if (xPos > this.clientWidth || xPos + width < 3) {\n            highlight.setAttribute('style', 'display: none;')\n          } else {\n            // updates position of highlights starting before first visible column\n            if (xPos < 3) {\n              width += xPos - 3\n              xPos = 3\n            }\n            // updates width of highlights ending after last visible column\n            if (xPos + width > this.clientWidth) {\n              width = this.clientWidth - xPos\n            }\n            // updates the position of message span when the highlight is on the right side of the screen\n            if (this.getBoundingClientRect().x + xPos >= window.innerWidth / 2) {\n              highlight.messageSpan.setAttribute('style', 'right: 50%; left: unset;')\n            }\n            highlight.setAttribute('style', `display: block; top: ${yPos}px; left: ${xPos}px; width: ${width}px`)\n          }\n        }\n        // hides the div if the line is not visible\n        else {\n          highlight.setAttribute('style', 'display: none;')\n        }\n      })\n    }\n\n    ta.updateErrors = function (ranges: LocatedError[]) {\n      // removes old highlight divs\n      this.errorDivs.forEach(highlight => {\n        highlight.remove()\n      })\n      this.errorDivs = []\n\n      // appends the highlight div as textarea child and adds it to highlights array\n      const pushHighlight = (highlight: ErrorDiv) => {\n        // @ts-ignore - adds it to the parent element\n        this.parentElement.appendChild(highlight)\n        this.errorDivs.push(highlight)\n      }\n\n      ranges.forEach(range => {\n        // finds highlight start and end lines and columns\n        const start = getPositionLineAndColumn(this.value, range.start)\n        const end = getPositionLineAndColumn(this.value, range.end)\n        // error on one line only\n        if (start.line === end.line) {\n          pushHighlight(createHighlightDiv(start.line, start.column, end.column - start.column,\n                        range.msg, this))\n        }\n        // error on multiple lines\n        else {\n          // pushes first line part - from error start to line end\n          pushHighlight(createHighlightDiv(start.line, start.column,\n                        getLineLength(this.value, start.line) - start.column, range.msg, this))\n          // pushes middle lines\n          for (let line = start.line + 1; line < end.line; ++line) {\n            pushHighlight(createHighlightDiv(line, 0, getLineLength(this.value, line),\n                            range.msg, this))\n          }\n          // pushes last line part - from line start to error end\n          pushHighlight(createHighlightDiv(end.line, 0, end.column, range.msg, this))\n        }\n      })\n\n      // moves highlight to current positions\n      this.moveErrors()\n    }\n\n    ta.parentheses = []\n    ta.parenthesesDivs = []\n\n    ta.updateParentheses = function () {\n      ta.parenthesesDivs.forEach(div => {\n        div.remove()\n      })\n      ta.parenthesesDivs = []\n      if (ta.selectionStart === ta.selectionEnd) {\n        const c1 = ta.selectionStart\n        const c2 = c1 - 1\n        const around = ta.parentheses.filter(p => p.start === c1 || p.start === c2 || p.end === c1 || p.end === c2)\n        // true when the first pair is processed\n        let first = true\n        around.forEach(parentheses => {\n          // finds highlight start and end lines and columns\n          const start = getPositionLineAndColumn(ta.value, parentheses.start)\n          const end = getPositionLineAndColumn(ta.value, parentheses.end)\n          const div1 = createParenthesesDiv(start.line, start.column, ta)\n          const div2 = createParenthesesDiv(end.line, end.column, ta)\n          // @ts-ignore\n          ta.parentElement.appendChild(div1)\n          // @ts-ignore\n          ta.parentElement.appendChild(div2)\n          ta.parenthesesDivs.push(div1)\n          ta.parenthesesDivs.push(div2)\n          // changes color to distinguish two pairs\n          div1.classList.toggle('first-pair', first)\n          div1.classList.toggle('second-pair', !first)\n          div2.classList.toggle('first-pair', first)\n          div2.classList.toggle('second-pair', !first)\n          first = false\n        })\n        ta.moveParentheses()\n      }\n    }\n\n    ta.moveParentheses = function () {\n      ta.parenthesesDivs.forEach(div => {\n        // computes position of the highlight relative to the text\n        const yPos: number = (div.startLine + 1) * lineHeight + 1 - this.scrollTop\n        // shows the div at computed position if the line is visible\n        if (yPos > 1 && yPos < this.clientHeight) {\n          let width: number = fontWidth\n          let xPos: number = div.startColumn * fontWidth + 7 - this.scrollLeft\n          // if the whole highlight is out of the width, does not display it\n          if (xPos > this.clientWidth || xPos + width < 3) {\n            div.setAttribute('style', 'display: none;')\n          } else {\n            // updates position of highlights starting before first visible column\n            if (xPos < 3) {\n              width += xPos - 3\n              xPos = 3\n            }\n            // updates width of highlights ending after last visible column\n            if (xPos + width > this.clientWidth) {\n              width = this.clientWidth - xPos\n            }\n            div.setAttribute('style', `display: block; top: ${yPos}px; left: ${xPos}px; width: ${width}px`)\n          }\n        }\n        // hides the div if the line is not visible\n        else {\n          div.setAttribute('style', 'display: none;')\n        }\n      })\n    }\n\n    ta.insertPairSymbol = function (first: string, second: string) {\n      const before: string = ta.value.slice(0, this.selectionStart)\n      const between: string = ta.value.slice(this.selectionStart, this.selectionEnd)\n      const after: string = ta.value.slice(this.selectionEnd)\n      const newCursorPos: number = ta.selectionEnd + 1\n      props.onChange(before + first + between + second + after, newCursorPos)\n      this.setSelectionRange(newCursorPos, newCursorPos)\n      this.hideWhisper()\n    }\n\n    ta.checkPairSymbolDelete = function (): boolean {\n      // only if nothing is selected\n      if (ta.selectionStart === ta.selectionEnd) {\n        const prevI = ta.selectionStart - 1\n        const nextI = ta.selectionStart\n        if (prevI >= 0 && nextI < ta.value.length) {\n          const prev = this.value.charAt(prevI)\n          const next = this.value.charAt(nextI)\n          // if the cursor is between pair symbol\n          if ((prev === '(' && next === ')') || (prev === '[' && next === ']')\n                      || (prev === '\"' && next === '\"' && this.value.charAt(prevI - 1) !== '\\\\')) {\n            const before: string = ta.value.slice(0, prevI)\n            const after: string = ta.value.slice(nextI + 1)\n            props.onChange(before + after, prevI)\n            this.setSelectionRange(prevI, prevI)\n            return true\n          }\n        }\n      }\n      return false\n    }\n\n    // handles whisper div position when scrolling on page\n    window.addEventListener('scroll', () => ta.moveWhisper())\n    window.addEventListener('resize', () => {\n      ta.moveWhisper()\n      ta.moveErrors()\n      ta.moveParentheses()\n    })\n    window.addEventListener('click', () => ta.hideWhisper())\n    ta.onscroll = () => {\n      ta.paintLineNumbers(this.props.darkTheme)\n      ta.moveWhisper()\n      ta.moveErrors()\n      ta.moveParentheses()\n    }\n    ta.onmousedown = event => {\n      ta.mouseIsDown = true\n      setTimeout(ta.updateParentheses, 0)\n      event.stopPropagation()\n    }\n    ta.onmouseup = () => {\n      ta.mouseIsDown = false\n      ta.paintLineNumbers(this.props.darkTheme)\n      setTimeout(ta.updateParentheses, 0)\n    }\n    ta.onmousemove = () => {\n      if (ta.mouseIsDown) ta.paintLineNumbers(this.props.darkTheme)\n    }\n    ta.oninput = (ev) => {\n      // @ts-ignore\n      this.props.onChange(ev.target.value, ev.target.selectionStart)\n    }\n    // prevents default behavior of special keys input when whisperDiv is shown, passes key event to the parent\n    ta.onkeydown = (ev) => {\n      if (ta.whisperDiv.isShown) {\n        if (ev.key === 'ArrowDown') {\n          ta.whisperDiv.changeSelected(1)\n          ev.preventDefault()\n        }\n        if (ev.key === 'ArrowUp') {\n          ta.whisperDiv.changeSelected(-1)\n          ev.preventDefault()\n        }\n        if (ev.key === 'PageDown') {\n          // moves selected whisper to bottom\n          ta.whisperDiv.setSelected(-1)\n          ev.preventDefault()\n        }\n        if (ev.key === 'PageUp') {\n          // moves selected whisper to top\n          ta.whisperDiv.setSelected(0)\n          ev.preventDefault()\n        }\n        if (ev.key === 'End' || ev.key === 'Home') {\n          ta.hideWhisper()\n          // keeps default behaviour\n        }\n        if (ev.key === 'Escape' || ev.key === 'Esc') {\n          ta.hideWhisper()\n          ev.preventDefault()\n        }\n        if (ev.key === 'Enter' && !ev.ctrlKey) {\n          ta.insertCurrentSelectedWhisper()\n          ev.preventDefault()\n        }\n        if (ev.key === 'Enter' && ev.ctrlKey) {\n          ta.hideWhisper()\n          ev.preventDefault()\n        }\n        if (ev.key === 'Tab') {\n          ta.insertCurrentSelectedWhisper()\n          ev.preventDefault()\n        }\n        if (ev.key === 'ArrowLeft') {\n          const cursor = (ta.selectionStart === 0) ? 0 : (ta.selectionStart - 1)\n          // forces update to recompute whispers if needed\n          this.props.onChange(ta.value, cursor)\n          // keeps default behaviour\n        }\n        if (ev.key === 'ArrowRight') {\n          const cursor = (ta.selectionStart === ta.value.length) ? ta.selectionStart : ta.selectionStart + 1\n          // forces update to recompute whispers if needed\n          this.props.onChange(ta.value, cursor)\n          // keeps default behaviour\n        }\n      }\n      if (ev.key === 'Enter' || ev.key === 'Tab') {\n        // does not show whisper after pressing Enter or Tab\n        ta.notAutoShowWhisper = true\n      }\n      if (ev.key === 'Backspace' && !ta.whisperDiv.isShown) {\n        // does not show whisper after pressing Backspace when it is closed\n        ta.notAutoShowWhisper = true\n      }\n      if (ev.ctrlKey) {\n        if (ev.key === ' ') {\n          if (ta.whisperDiv.isShown) {\n            ta.hideWhisper()\n          } else {\n            this.props.onChange(ta.value, ta.selectionStart)\n          }\n        }\n        this.props.onCtrlInput(ev)\n      }\n      if (ev.key === 'ArrowLeft' || ev.key === 'ArrowRight' || ev.key === 'ArrowUp' || ev.key === 'ArrowDown'\n                || ev.key === 'Home' || ev.key === 'End' || ev.key === 'PageUp' || ev.key === 'PageDown') {\n        setTimeout(ta.updateParentheses, 0)\n      }\n      if (ev.key === '(') {\n        ta.insertPairSymbol('(', ')')\n        ev.preventDefault()\n      }\n      if (ev.key === '[') {\n        ta.insertPairSymbol('[', ']')\n        ev.preventDefault()\n      }\n      if (ev.key === '\"' && ta.value.charAt(ta.selectionStart - 1) !== '\\\\') {\n        ta.insertPairSymbol('\"', '\"')\n        ev.preventDefault()\n      }\n      // if the text area deletes pair symbol, default backspace behavior is prevented\n      if (ev.key === 'Backspace' && ta.checkPairSymbolDelete()) {\n        ev.preventDefault()\n      }\n    }\n\n    // make sure numbers are painted\n    ta.update(this.props.text, this.props.darkTheme)\n    // shows highlights\n    ta.updateErrors(this.props.errors)\n    this.textarea = ta\n  }\n\n  /**\n     * Updates text content and component style.\n     */\n  componentDidUpdate (prevProps: Readonly<XTextAreaProps>) {\n    this.textarea.update(this.props.text, this.props.darkTheme)\n    if (prevProps.darkTheme !== this.props.darkTheme) {\n      this.textarea.paintLineNumbers(this.props.darkTheme)\n    }\n    // whispers\n    if (this.props.whispers !== prevProps.whispers) {\n      if (this.textarea.notAutoShowWhisper) {\n        this.textarea.notAutoShowWhisper = false\n      } else {\n        this.textarea.createWhisper(this.props.whispers)\n      }\n    }\n    // highlights error\n    if (this.props.errors !== undefined) {\n      this.textarea.updateErrors(this.props.errors)\n    }\n    // first undefined highlight removes 'x-textarea-err' from textarea.className to show selection with blue color\n    else if (this.props.errors !== prevProps.errors) {\n      this.textarea.classList.remove('x-textarea-err')\n    }\n    // highlights parentheses\n    if (this.props.parentheses !== prevProps.parentheses) {\n      this.textarea.parentheses = this.props.parentheses\n      this.textarea.updateParentheses()\n    }\n  }\n\n  /**\n     * Renders only an empty div. Other maintaining is not provided by React.\n     */\n  render () {\n    return <div id={this.props.id} className=\"x-textarea-div\" />\n  }\n}\n\n/**\n * Computes line and column number for given position in text.\n */\nfunction getPositionLineAndColumn (text: string, position: number): {line: number, column: number} {\n  const textBeforeCursor: string = text.slice(0, position)\n  const line: number = (textBeforeCursor.match(/\\n/g) || []).length\n  const lastNewLine: number = textBeforeCursor.lastIndexOf('\\n')\n  const column: number = textBeforeCursor.length - lastNewLine - 1\n  return { line, column }\n}\n\n/**\n * Returns number of characters on the given line.\n */\nfunction getLineLength (text: string, line: number): number {\n  let newLinesFound = 0\n  let lineStart = 0  // index of line-th newline\n  let lineEnd = 0    // index of (line+1)-th newline\n  for (let i = 0; i < text.length; ++i) {\n    if (text.charAt(i) === '\\n') {\n      ++newLinesFound\n      if (newLinesFound === line) {\n        lineStart = i\n      } else if (newLinesFound === line + 1) {\n        lineEnd = i\n        break\n      }\n    }\n  }\n  if (lineEnd === 0) {\n    lineEnd = text.length // handles case of last line in text\n  }\n  return lineEnd - lineStart\n}\n\n/**\n * Creates a div for highlighting errors in the given textarea.\n */\nfunction createHighlightDiv (startLine: number, startColumn: number, rangeLength: number, msg: string,\n                            textarea: ExtendedHTMLTextArea): ErrorDiv {\n  // @ts-ignore\n  const highlight: ErrorDiv = document.createElement('div')\n  highlight.classList.add('x-textarea-highlight')\n  highlight.startLine = startLine\n  highlight.startColumn = startColumn\n  highlight.rangeLength = rangeLength\n  // dispatches click event to not block textarea underneath highlights\n  highlight.onclick = (ev: MouseEvent) => {\n    const newEvent: MouseEvent = new MouseEvent(ev.type, { ...ev })\n    textarea.dispatchEvent(newEvent)\n    ev.stopPropagation()\n  }\n  const span: HTMLSpanElement = document.createElement('span')\n  span.classList.add('highlight-tooltip')\n  span.innerText = msg\n  highlight.messageSpan = span\n  highlight.appendChild(span)\n  return highlight\n}\n\n/**\n * Creates a div for highlighting parentheses in the given textarea.\n */\nfunction createParenthesesDiv (startLine: number, startColumn: number, textarea: ExtendedHTMLTextArea): ParenthesesDiv {\n  // @ts-ignore\n  const div: ParenthesesDiv = document.createElement('div')\n  div.classList.add('x-textarea-parentheses')\n  div.startLine = startLine\n  div.startColumn = startColumn\n  // dispatches click event to not block textarea underneath highlights\n  div.onclick = (ev: MouseEvent) => {\n    const newEvent: MouseEvent = new MouseEvent(ev.type, { ...ev })\n    textarea.dispatchEvent(newEvent)\n    ev.stopPropagation()\n  }\n  return div\n}\n","/**\n * Modulo operation with positive result for negative numbers (as % in JavaScript can give negative results).\n * If m is non-positive or any given number is NaN, Infinity or -Infinity, returns NaN.\n *\n * @param n base number {@type number}\n * @param m dividing number {@type number}\n * @return n modulo m {@type number}\n * @category Utils\n * @public\n */\nexport function mod (n: number, m: number): number {\n  if (m > 0) {\n    return ((n % m) + m) % m\n  }\n  return NaN\n}\n","import { Row } from './row'\nimport { SupportedColumnType } from './columnType'\nimport { isEqual } from 'lodash'\n\n/**\n * Formal relational algebra relation. It contains relational schema (set of column names and types)\n * and data tuples (set of rows). For editable representation which may happen to be invalid, use {@link StoredRelation}.\n *\n * @category Relation\n * @public\n */\nexport class Relation {\n\n  readonly name: string\n  private readonly columns = new Map<string, SupportedColumnType>()\n  private readonly columnNames: string[] = [] // array to have an ordered printing of columns\n  private readonly rows: Row[] = []\n  private finishedSchema = false\n\n  /**\n     * Creates an empty relation of the given name.\n     *\n     * @param name name of the relation {@type string}\n     * @public\n     */\n  constructor (name: string) {\n    this.name = name\n  }\n\n  /**\n     * Returns name of the relation.\n     *\n     * @return relation name {@type string}\n     * @public\n     */\n  getName (): string {\n    return this.name\n  }\n\n  /**\n     * Returns true if the relational schema is finished (no more columns can be added).\n     *\n     * @return true if the relational schema is finished (no more columns can be added) {@type boolean}\n     * @public\n     */\n  hasFinishedSchema (): boolean {\n    return this.finishedSchema\n  }\n\n  /**\n     * Sets the relational schema finished (no more columns can be added).\n     * @public\n     */\n  finishSchema (): void {\n    this.finishedSchema = true\n  }\n\n  /**\n     * Adds a column to a relational schema if the relational schema is not finished yet.\n     *\n     * @param name name of the column {@type string}\n     * @param type type of the column {@type SupportedColumnType}\n     * @return true if the column was added (relation did not contain a column with the same name before) {@type boolean}\n     * @public\n     */\n  addColumn (name: string, type: SupportedColumnType): boolean {\n    if (!this.hasColumn(name) && !this.hasFinishedSchema()) {\n      this.columns.set(name, type)\n      this.columnNames.push(name)\n      return true\n    }\n    return false\n  }\n\n  /**\n     * Checks whether the relation has a column with the same name\n     * (NOTE: type of the column does not matter).\n     *\n     * @param name Column name to be checked {@type string}\n     * @return true if the relation has a column with the same name {@type boolean}\n     * @public\n     */\n  hasColumn (name: string): boolean {\n    return this.columnNames.some(cn => cn === name)\n  }\n\n  /**\n     * Returns map (name -> value) of column values in a relation.\n     *\n     * @return map of column values in a relation {@type Map<String, SupportedColumnType>}\n     * @public\n     */\n  getColumns (): Map<string, SupportedColumnType> {\n    return this.columns\n  }\n\n  /**\n     * Applies the given function to each column in the relation.\n     *\n     * @param f function to be applied to each column in the relation {@type function}\n     * @public\n     */\n  forEachColumn (f: (type: SupportedColumnType, name: string) => void): void {\n    return this.columns.forEach(f)\n  }\n\n  /**\n     * Return column names  in a relation.\n     *\n     * @return array of column names in a relation {@type string[]}\n     * @public\n     */\n  getColumnNames (): string[] {\n    return this.columnNames\n  }\n\n  /**\n     * Returns number of columns in a relation.\n     *\n     * @return number of columns in a relation {@type number}\n     * @public\n     */\n  getColumnsCount (): number {\n    return this.columnNames.length\n  }\n\n  /**\n     * Adds a row to a relation. The row must have the same column set as the relation. If the row was added,\n     * sets the row finished and returns true. Also the relational schema of this relation\n     * is set finished (no more columns can be added). If the row was not added, returns false.\n     * NOTE: Rows in a relation cannot be duplicit, adding a duplicit row returns true, but only one is kept.\n     *\n     * @param row row to be added {@type Row}\n     * @return true if the row was added, false otherwise {@type boolean}\n     * @public\n     */\n  addRow (row: Row): boolean {\n    if (isEqual(row.getTypes(), this.columns)) {\n      this.finishSchema()\n      row.finish()\n      if (!this.rows.some(r => r.equals(row))) {\n        this.rows.push(row)\n      }\n      return true\n    }\n    return false\n  }\n\n  /**\n     * Returns all rows in a relation.\n     *\n     * @return array of rows in a relation {@type Row[]}\n     * @public\n     */\n  getRows (): Row[] {\n    return this.rows\n  }\n\n  /**\n     * Returns the number of rows in a relation.\n     *\n     * @return number of rows in a relation {@type number}\n     * @public\n     */\n  getRowsCount (): number {\n    return this.rows.length\n  }\n\n  /**\n     * Returns a relational schema in a format: RelationName(ColumnOneName: ColumnOneType, ...) - both column names\n     * and column types are used.\n     *\n     * @return relational schema as a string {@type string}\n     * @public\n     */\n  getSchemaString (): string {\n    return this.name + '(' + [...this.columns].map(s => s[0] + ': ' + s[1]).join(', ') + ')'\n  }\n\n  /**\n     * Returns a relational schema in a format: RelationName(ColumnOneName, ...) - only column names are used.\n     *\n     * @return relational schema as a string {@type string}\n     * @public\n     */\n  getNamesSchemaString (): string {\n    return this.name + '(' + this.columnNames.join(', ') + ')'\n  }\n\n  /**\n     * Returns a formatted string representation of the relation content (column names, column types and rows).\n     *\n     * @return string representation of the relation {@type string}\n     * @public\n     */\n  contentString (): string {\n    // @ts-ignore - prepares array representation of types and rows\n    const columnTypes: SupportedColumnType[] = this.columnNames.map(name => this.columns.get(name))\n    const rows = [...this.rows].map(row => row.getOrderedPrintValues(this.columnNames))\n    // finds longest inputs in each column\n    const longest = this.columnNames.map(n => n.length)\n    columnTypes.forEach((type, i) => {\n      if (type.length > longest[i]) {\n        longest[i] = type.length\n      }\n    })\n    rows.forEach(r => {\n      r.forEach((d, i) => {\n        if (longest[i] < d.length) {\n          longest[i] = d.length\n        }\n      })\n    })\n    // function for end-padding strings with spaces\n    const pad = (ss: string[]) => ss.map((s, i) => s.padEnd(longest[i], ' ')).join(' | ')\n    return pad(this.columnNames) + '\\n'\n            + pad(columnTypes) + '\\n'\n            + longest.map(n => '-'.repeat(n)).join('-+-') + '\\n'\n            + rows.map(r => pad(r)).join('\\n')\n  }\n\n  /**\n     * Custom equals function for testing purposes.\n     *\n     * @param other an object to compare {@type any}\n     * @return true if this and given objects have same name, columns, and rows {@type boolean}\n     * @public\n     */\n  equals (other: any): boolean {\n    if (other instanceof Relation) {\n      return this.name === other.name\n                && isEqual(this.columns, other.columns)\n                && isEqual(new Set(this.rows), new Set(other.rows))\n    }\n    return false\n  }\n}\n","/**\n * Messages for {@link CodeError}.\n * The description is a string array - between its members are inserted error parameters (names of invalid relations,\n * invalid input parts, etc.). See english language definition for expected structure of each error description.\n * @category Errors\n * @public\n */\nexport interface CodeErrorMessages {\n  // expects 1 part\n  resultSection_nodeIndexNotFound: string[]\n  // expects 2 part\n  resultSection_evalError: string[]\n  // expects 1 part\n  resultSection_nullRelationToSave: string[]\n  // expects 1 part\n  resultSection_nullRelationToAdd: string[]\n\n  // expects 3 parts\n  row_absentColumn: string[]\n\n  // expects 2 parts\n  valueParser_unexpectedToken: string[]\n\n  // expects 2 parts\n  exprParser_unexpectedToken: string[]\n  // expects 2 parts\n  exprParser_thetaJoinBranchError: string[]\n  // expects 2 parts\n  exprParser_projectionBranchError: string[]\n}\n\n/**\n * Error caused by an unexpected error in code of the application.\n * @extends Error\n * @category Errors\n * @public\n */\nexport class CodeError extends Error {\n  /**\n     * Creates a new CodeError with the given message.\n     *\n     * @param msg error message {@type string}\n     * @public\n     */\n  constructor (msg: string) {\n    super(msg)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, CodeError)\n    }\n    this.name = 'CodeError'\n  }\n}\n","import { RASemanticError } from './raSemanticError'\nimport { RASyntaxError } from './raSyntaxError'\nimport { CodeError } from './codeError'\nimport { StartEndPair } from '../types/startEndPair'\n\n/**\n * Factory for creating custom application errors: CodeError, RASemanticError, RASyntaxError.\n * It creates an error message by given error code and string parameters.\n * @category Errors\n * @public\n */\nexport class ErrorFactory {\n\n  /**\n     * Creates a new code error. Params are used to join error messages.\n     *\n     * @param msg predefined error description {@link CodeErrorMessages} {@type string[]}\n     * @param params textual specification {@type ...string}\n     * @public\n     */\n  static codeError (msg: string[], ...params: string[]): CodeError {\n    assertParamsCount(msg.length - 1, params)\n    return new CodeError(joinStringArrays(msg, params))\n  }\n\n  /**\n     * Creates a new RASemanticError. Params are used to join error messages.\n     *\n     * @param msg predefined error description {@link SemanticErrorMessages} {@type string[]}\n     * @param range text range of the error in the input when defined {@type StartEndPair?}\n     * @param params textual specification {@type ...string}\n     * @public\n     */\n  static semanticError (msg: string[], range: StartEndPair | undefined, ...params: string[]): RASemanticError {\n    assertParamsCount(msg.length - 1, params)\n    return new RASemanticError(joinStringArrays(msg, params), range)\n  }\n\n  /**\n     * Creates a new RASyntaxError. Params are used to join error messages.\n     *\n     * @param msg predefined error description {@link SyntaxErrorMessages} {@type string[]}\n     * @param range text range of the error in the input when defined {@type StartEndPair?}\n     * @param params textual specification {@type ...string}\n     * @public\n     */\n  static syntaxError (msg: string[], range: StartEndPair | undefined, ...params: string[]): RASyntaxError {\n    assertParamsCount(msg.length - 1, params)\n    return new RASyntaxError(joinStringArrays(msg, params), range)\n  }\n}\n\n/**\n * Extends the given params array with empty strings to have the length of expectedCount. When the initial length of the\n * given params array is the same or greater, the array is not changed.\n */\nexport function assertParamsCount (expectedCount: number, params: string[]): void {\n  if (params.length !== expectedCount) {\n    console.log('Unexpected params count, expected ' + expectedCount + ', given ' + params.length)\n    while (params.length < expectedCount) {\n      params.push('')\n    }\n  }\n}\n\n/**\n * Joins given string arrays [a1, a2, ..., an] and [b1, b2, ..., bn-1] to one string \"a1b1a2b2...an-1bn-1an\".\n * WARNING: a.length is expected to be at least 1. b.length is expected to be at least \"a.length - 1\".\n *\n * @param a array of length at least 1\n * @param b array of length at least \"a.length - 1\"\n */\nexport function joinStringArrays (a: string[], b: string[]): string {\n  const aLen: number = a.length\n  const toConcat: string[] = Array<string>(2 * aLen - 2)\n  for (let i = 1; i < aLen; i++) {\n    toConcat[2 * i - 2] = b[i - 1]\n    toConcat[2 * i - 1] = a[i]\n  }\n  return a[0].concat(...toConcat)\n}\n","import { BinaryNodeClass } from '../ratree/binaryNode'\nimport { IndexedString } from '../types/indexedString'\nimport { UnaryNodeClass } from '../ratree/unaryNode'\nimport { StartEndPair } from '../types/startEndPair'\n\n/**\n * Abstract parent class for all RATokens.\n */\nexport abstract class ExprToken {\n  protected constructor (public readonly str: IndexedString, public readonly type: string) {}\n\n  /**\n     * Gets token start and end index in the text (if the token has IndexedString representation) or undefined.\n     */\n  getRange (): StartEndPair | undefined {\n    return this.str.getRange()\n  }\n}\n\n/**\n * Parentheses.\n */\nexport abstract class ParenthesisToken extends ExprToken {}\n\nexport class OpeningParenthesis extends ParenthesisToken {\n  constructor (str: IndexedString) {\n    super(str, 'OpeningParenthesis')\n  }\n}\n\nexport class ClosingParenthesis extends ParenthesisToken {\n  constructor (str: IndexedString) {\n    super(str, 'ClosingParenthesis')\n  }\n}\n\n/**\n * Relation reference.\n */\nexport class RelationToken extends ExprToken {\n  constructor (name: IndexedString) {\n    super(name, 'RelationToken')\n  }\n}\n\n/**\n * Unary operators.\n */\nexport class UnaryOperatorToken extends ExprToken {\n\n  static selection (selection: IndexedString) {\n    return new UnaryOperatorToken(selection, 'selection')\n  }\n\n  static projection (projection: IndexedString) {\n    return new UnaryOperatorToken(projection, 'projection')\n  }\n\n  static rename (rename: IndexedString) {\n    return new UnaryOperatorToken(rename, 'rename')\n  }\n\n  private constructor (str: IndexedString, type: UnaryNodeClass) {\n    super(str, type)\n  }\n}\n\n/**\n * Precedence values for binary operators (highest to lowest).\n */\nconst precedenceLevelA = 10\nconst cartesianPrecedence: number = precedenceLevelA\nconst naturalPrecedence: number = precedenceLevelA\nconst thetaPrecedence: number = precedenceLevelA\nconst semiPrecedence: number = precedenceLevelA\nconst antiPrecedence: number = precedenceLevelA\nconst thetaSemiPrecedence: number = precedenceLevelA\nconst outerPrecedence: number = precedenceLevelA\nconst divisionPrecedence: number = precedenceLevelA\n\nconst precedenceLevelB: number = precedenceLevelA - 1\nconst intersectionPrecedence: number = precedenceLevelB\n\nconst precedenceLevelC: number = precedenceLevelB - 1\nconst differencePrecedence: number = precedenceLevelC\nconst unionPrecedence: number = precedenceLevelC\n\n/**\n * Binary operators.\n */\nexport class BinaryOperatorToken extends ExprToken {\n\n  static naturalJoin (str: IndexedString): BinaryOperatorToken {\n    return new BinaryOperatorToken(str, naturalPrecedence, 'natural join')\n  }\n\n  static cartesianProduct (str: IndexedString): BinaryOperatorToken {\n    return new BinaryOperatorToken(str, cartesianPrecedence, 'cartesian product')\n  }\n\n  static union (str: IndexedString): BinaryOperatorToken {\n    return new BinaryOperatorToken(str, unionPrecedence, 'union')\n  }\n\n  static intersection (str: IndexedString): BinaryOperatorToken {\n    return new BinaryOperatorToken(str, intersectionPrecedence, 'intersection')\n  }\n\n  static difference (str: IndexedString): BinaryOperatorToken {\n    return new BinaryOperatorToken(str, differencePrecedence, 'difference')\n  }\n\n  static leftSemijoin (str: IndexedString): BinaryOperatorToken {\n    return new BinaryOperatorToken(str, semiPrecedence, 'left semijoin')\n  }\n\n  static rightSemijoin (str: IndexedString): BinaryOperatorToken {\n    return new BinaryOperatorToken(str, semiPrecedence, 'right semijoin')\n  }\n\n  static leftAntijoin (str: IndexedString): BinaryOperatorToken {\n    return new BinaryOperatorToken(str, antiPrecedence, 'left antijoin')\n  }\n\n  static rightAntijoin (str: IndexedString): BinaryOperatorToken {\n    return new BinaryOperatorToken(str, antiPrecedence, 'right antijoin')\n  }\n\n  static thetaJoin (str: IndexedString): BinaryOperatorToken {\n    return new BinaryOperatorToken(str, thetaPrecedence, 'theta join')\n  }\n\n  static leftThetaSemijoin (str: IndexedString): BinaryOperatorToken {\n    return new BinaryOperatorToken(str, thetaSemiPrecedence, 'left theta semijoin')\n  }\n\n  static rightThetaSemijoin (str: IndexedString): BinaryOperatorToken {\n    return new BinaryOperatorToken(str, thetaSemiPrecedence, 'right theta semijoin')\n  }\n\n  static fullOuterJoin (str: IndexedString): BinaryOperatorToken {\n    return new BinaryOperatorToken(str, outerPrecedence, 'full outer join')\n  }\n\n  static leftOuterJoin (str: IndexedString): BinaryOperatorToken {\n    return new BinaryOperatorToken(str, outerPrecedence, 'left outer join')\n  }\n\n  static rightOuterJoin (str: IndexedString): BinaryOperatorToken {\n    return new BinaryOperatorToken(str, outerPrecedence, 'right outer join')\n  }\n\n  static division (str: IndexedString): BinaryOperatorToken {\n    return new BinaryOperatorToken(str, divisionPrecedence, 'division')\n  }\n\n  private constructor (str: IndexedString, public readonly precedence: number, type: BinaryNodeClass) {\n    super(str, type)\n  }\n}\n","import { ErrorFactory } from '../error/errorFactory'\nimport { RASyntaxError } from '../error/raSyntaxError'\nimport { language } from '../language/language'\nimport { Pair } from '../types/pair'\n\n/**\n * Class providing general helper functions for strings.\n * @category Utils\n * @public\n */\nexport class StringUtils {\n\n  /**\n     * Returns true if the string contains letters only and has length at least 1.\n     *\n     * @param str Checked string {@type string}\n     * @return true if the string contains letters only and has length at least 1 {@type boolean}\n     * @public\n     */\n  static isWord (str: string): boolean {\n    return str.length > 0 && str.split('').every(c => StringUtils.isLetter(c))\n  }\n\n  /**\n     * Returns true if the string contains letters, numbers and underscores only, has length at least 1 and starts with\n     * a letter or an underscore.\n     *\n     * @param str Checked string {@type string}\n     * @return true if the string contains letters, numbers and underscores only, has length at least 1 and starts with\n     * a letter or an underscore {@type boolean}\n     * @public\n     */\n  static isName (str: string): boolean {\n    if (str.length === 0) {\n      return false\n    }\n    if (!StringUtils.isLetter(str.charAt(0)) && !str.startsWith('_')) {\n      return false\n    }\n    return str.split('').every(c => StringUtils.isNameChar(c))\n  }\n\n  /**\n     * Returns true if the string contains whitespaces only.\n     *\n     * @param str Checked string {@type string}\n     * @return true if the string contains whitespaces only {@type boolean}\n     * @public\n     */\n  static isWhitespacesOnly (str: string): boolean {\n    const regex = /\\s*/\n    const res = regex.exec(str)\n    return res === null ? false : res[0] === str\n  }\n\n  /**\n     * Returns true if the given string has length one and the character is a letter.\n     *\n     * @param c Checked character {@type string}\n     * @return true if the given string has length one and the character is a letter {@type boolean}\n     * @public\n     */\n  static isLetter (c: string): boolean {\n    return c.length === 1 && c.toLowerCase() !== c.toUpperCase()\n  }\n\n  /**\n     * Returns true if the given string has length one and the character is a letter, a number or an underscore.\n     *\n     * @param c Checked character {@type string}\n     * @return true if the given string has length one and the character is a letter, a number or an underscore {@type boolean}\n     * @public\n     */\n  static isNameChar (c: string): boolean {\n    return StringUtils.isLetter(c) || StringUtils.isDigit(c) || c === '_'\n  }\n\n  /**\n     * Returns true if the given string has length one and the character is a digit.\n     *\n     * @param c Checked character {@type string}\n     * @return true if the given string has length one and the character is a digit {@type boolean}\n     * @public\n     */\n  static isDigit (c: string): boolean {\n    return c.length === 1 && (/\\d/.exec(c)) !== null\n  }\n\n  /**\n     * Returns true if the string represents a decimal number.\n     *\n     * @param str Checked string {@type string}\n     * @return true if the string represents a decimal number {@type boolean}\n     * @public\n     */\n  static isNumber (str: string): boolean {\n    return /^[-]?[\\d]+([.][\\d]+)?$/.test(str)\n  }\n\n  /**\n     * Splits given string to a starting sequence of letters and its rest and returns these parts in a pair.\n     * NOTE: if the string does not start with a letter, as a word is returned an empty string.\n     *\n     * @param str string to be split {@type string}\n     * @return split string in a pair (word, rest) {@type Pair<string>}\n     * @public\n     */\n  static nextWord (str: string): Pair<string> {\n    if (str === '') {\n      return { first: '', second: '' }\n    }\n    let i = 0\n    while (i < str.length) {\n      if (!StringUtils.isLetter(str.charAt(i))) {\n        return { first: str.substring(0, i), second: str.substring(i) }\n      }\n      ++i\n    }\n    return { first: str, second: '' }\n  }\n\n  /**\n     * Splits given string to a starting sequence of letters, numbers and underscores, which starts with a letter or\n     * an underscore and its rest and returns these parts in a pair.\n     * NOTE: if the string does not start with a letter, or an underscore, as a name is returned an empty string.\n     *\n     * @param str string to be split {@type string}\n     * @return split string in a pair (name, rest) {@type Pair<string>}\n     * @public\n     */\n  static nextName (str: string): Pair<string> {\n    if (str === '') {\n      return { first: '', second: '' }\n    }\n    if (!StringUtils.isLetter(str.charAt(0)) && !str.startsWith('_')) {\n      return { first: '', second: str }\n    }\n    let i = 0\n    while (i < str.length) {\n      const char: string = str.charAt(i)\n      if (!StringUtils.isLetter(char) && !StringUtils.isDigit(char) && char !== '_') {\n        return { first: str.substring(0, i), second: str.substring(i) }\n      }\n      ++i\n    }\n    return { first: str, second: '' }\n  }\n\n  /**\n     * Splits given string to a starting sequence of non-whitespace characters and its rest and returns these parts in a pair.\n     *\n     * @param str string to be split {@type string}\n     * @return split string in a pair (start, rest) {@type Pair<string>}\n     * @public\n     */\n  static nextNonWhitespacePart (str: string): Pair<string> {\n    if (str === '') {\n      return { first: '', second: '' }\n    }\n    let i = 0\n    while (i < str.length) {\n      if (/\\s/.exec(str.charAt(i))) {\n        return { first: str.substring(0, i), second: str.substring(i) }\n      }\n      ++i\n    }\n    return { first: str, second: '' }\n  }\n\n  /**\n     * Splits given string to a starting number and its rest and returns these parts in a pair.\n     * NOTE: if the string does not start with a digit, as a number is returned an empty string.\n     *\n     * @param str string to be split {@type string}\n     * @return split string in a pair (word, rest) {@type Pair<string>}\n     * @public\n     */\n  static nextNumber (str: string): Pair<string> {\n    if (str === '') {\n      return { first: '', second: '' }\n    }\n    let i = 0\n    // string starts with '-' sign\n    if (str.startsWith('-')) {\n      // if there is a digit after '-', shifts the start\n      if (str.length > 1 && StringUtils.isDigit(str.charAt(1))) {\n        i = 1\n      }\n      // there is no digit\n      else {\n        return { first: '', second: str }\n      }\n    }\n    let digitFound = false\n    let dotFound = false\n    while (i < str.length) {\n      if (StringUtils.isDigit(str.charAt(i))) {\n        digitFound = true\n        ++i\n      } else if (str.charAt(i) === '.') {\n        // second dot or a dot without previous digits\n        if (dotFound || !digitFound) {\n          break\n        } else {\n          dotFound = true\n          ++i\n        }\n      } else {\n        break\n      }\n    }\n    const numStr = str.substring(0, i)\n    const rest = str.substring(i)\n    return { first: numStr, second: rest }\n  }\n\n  /**\n     * Splits the given string into starting quoted part and the rest. Quotes can be escaped by an odd count of\n     * backslashes.\n     * NOTE: When the closing quote is not found until the rest of the line, unclosed string is returned\n     * => the error is not thrown, it is only added to the return object.\n     * NOTE: First character of the string is expected to be '\"'.\n     *\n     * @param str string to be split {@type string}\n     * @return the starting quoted part, the rest, and optimal error {@type Object}\n     * @public\n     */\n  static nextQuotedString (str: string): { first: string, second: string, error: RASyntaxError | undefined } {\n    let i = 1\n    // backslashes escape the quote character only in odd count\n    let backslashes = 0\n    while (i < str.length) {\n      const curChar = str.charAt(i)\n      // increases index for using \"i\" in slicing\n      ++i\n      if (curChar === '\"' && (backslashes % 2) === 0) {\n        return { first: str.slice(0, i), second: str.slice(i), error: undefined }\n      }\n      // end of line breaks the string\n      if (curChar === '\\n') {\n        return {\n          first: str.slice(0, i),\n          second: str.slice(i),\n          error: ErrorFactory.syntaxError(language().syntaxErrors.stringUtils_missingClosingChar,\n                        undefined, '\"', '\"'),\n        }\n      }\n      // updates backslash count\n      if (curChar === '\\\\') {\n        ++backslashes\n      } else {\n        backslashes = 0\n      }\n    }\n    return {\n      first: str,\n      second: '',\n      error: ErrorFactory.syntaxError(language().syntaxErrors.stringUtils_missingClosingChar,\n                undefined, '\"', '\"'),\n    }\n  }\n\n  /**\n     * Splits the string to the starting bordered part and the rest and returns these parts in a pair.\n     * If there is only one ending character and it differs from the starting one, nested bordering is supported.\n     * Characters after an odd count of escape characters are ignored and cannot start or end a bordered part.\n     * Starting and ending characters in quoted part are ignored, quotes can be escaped by an odd count of backslashes.\n     * NOTE: First character of the string is expected to be 'start'.\n     * NOTE: Should not be used for slicing quoted strings, use nextQuotedString instead.\n     * NOTE: It is expected, that there are no comments in the given string.\n     *\n     * @param str string to be split {@type string}\n     * @param start starting character of the string and also starting character of the bordered part (one character) {@type string}\n     * @param end ending characters of the bordered part (one or more characters) {@type string}\n     * @param escape character which makes next character being ignored (default '\\0') {@type string}\n     * @return pair of the starting bordered part and the rest {@type Pair<string>}\n     * @public\n     */\n  static nextBorderedPart (str: string, start: string, end: string, escape = '\\0'): Pair<string> {\n    let depth = 1\n    let i = 1\n    // to ignore special characters\n    let inQuotes = false\n    // nested bordering is supported if there is only one ending character\n    const nesting: boolean = end.length === 1\n    // backslashes escape the quote character only in odd count\n    let backslashes = 0\n    // escape characters escape the end character only in odd count\n    let escapeCount = 0\n    while (i < str.length) {\n      const curChar = str.charAt(i)\n      // checks end of the part (before checking start for a case when start == end)\n      if (end.includes(curChar) && (escapeCount % 2) === 0 && !inQuotes) {\n        --depth\n      }\n      // checks start of the bordered part (if only one ending character was given)\n      else if (curChar === start && (escapeCount % 2) === 0 && nesting && !inQuotes) {\n        ++depth\n      }\n      // found quote if even number of backslashes before\n      else if (curChar === '\"' && (backslashes % 2) === 0) {\n        inQuotes = !inQuotes\n      }\n      // updates escape chars count\n      if (curChar === escape) {\n        ++escapeCount\n      } else {\n        escapeCount = 0\n      }\n      // updates backslash count\n      if (curChar === '\\\\') {\n        ++backslashes\n      } else {\n        backslashes = 0\n      }\n      // increases index for before slicing\n      ++i\n      if (depth === 0) {\n        return { first: str.slice(0, i), second: str.slice(i) }\n      }\n    }\n    throw ErrorFactory.syntaxError(language().syntaxErrors.stringUtils_missingClosingChar, undefined,\n            end.split('').join(\"' / '\"), start)\n  }\n\n  /**\n     * Skips all whitespaces and exactly one given character and returns rest of the string.\n     * If the string does not match this pattern, throws error.\n     *\n     * @param str string to be skipped in {@type string}\n     * @param char char to be skipped exactly one time (expected to be string of length 1) {@type string}\n     * @return given string without starting sequence of whitespaces and exactly one char {@type string}\n     * @public\n     */\n  static skipWhitespacesAndChar (str: string, char: string): string {\n    let charFound = false\n    let i = 0\n    while (i < str.length) {\n      if (/\\s/.exec(str.charAt(i))) {\n        ++i\n      } else if (str.charAt(i) === char && !charFound) {\n        charFound = true\n        ++i\n      } else {\n        break\n      }\n    }\n    if (!charFound) {\n      throw ErrorFactory.syntaxError(language().syntaxErrors.stringUtils_charNotFound, undefined, char)\n    }\n    return str.substring(i)\n  }\n}\n","import { Relation } from '../relation/relation'\nimport { ErrorWithTextRange } from '../error/errorWithTextRange'\n\n/**\n * Result of fake evaluation of RATreeNode.\n * @category RATree\n * @public\n */\nexport interface NodeFakeEvalResult {\n  /**\n     * Result relation\n     * @type Relation\n     * @public\n     */\n  result: Relation\n  /**\n     * Found column names to whisper\n     * @type string[]\n     * @public\n     */\n  whispers: string[]\n  /**\n     * Detected errors\n     * @type ErrorWithTextRange[]\n     * @public\n     */\n  errors: ErrorWithTextRange[]\n}\n\n/**\n * Abstract general node of the relational algebra syntactic tree.\n * @category RATree\n * @public\n */\nexport abstract class RATreeNode {\n\n  protected resultRelation: Relation | undefined\n\n  protected constructor () {}\n\n  /**\n     * Evaluates the RA query in this node and its subtree.\n     * After successful call, this.resultRelation must be set to valid Relation.\n     * @public\n     */\n  public abstract eval (): void\n\n  /**\n     * Evaluates the RA query in this node and its subtree.\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\n     * Otherwise returns the result relation schema (only column names, no rows).\n     * When an error occurs, it is faked to work, and adds it to the errors array.\n     *\n     * @param cursorIndex index of the cursor in original text input {@type number}\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper {@type NodeFakeEvalResult}\n     * @public\n     */\n  public abstract fakeEval (cursorIndex: number): NodeFakeEvalResult\n\n  /**\n     * Returns true if this node and its subtree was already evaluated.\n     *\n     * @return true if this node and its subtree was already evaluated {@type boolean}\n     * @public\n     */\n  isEvaluated (): boolean {\n    return this.resultRelation !== undefined\n  }\n\n  /**\n     * Returns the resulting relation. The node and its subtree is evaluated if it was not evaluated before.\n     *\n     * @return resulting relation gained by evaluating this node and its subtree {@type Relation}\n     * @public\n     */\n  getResult (): Relation {\n    if (this.resultRelation === undefined) {\n      this.eval()\n    }\n    // @ts-ignore\n    return this.resultRelation\n  }\n\n  /**\n     * Creates a string with a structure of the RA tree in one line.\n     *\n     * @return string with a structure of the RA tree in one line {@type string}\n     * @public\n     */\n  public abstract printInLine (): string\n\n  /**\n     * Return the word name of the RA operation of the node.\n     * Example: returns \"Selection\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n  public abstract getOperationName (): string\n\n  /**\n     * Return the symbolic representation of the RA operation of the node.\n     * Example: returns \"(some + expr = 15)\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n  public abstract getOperationSymbol (): string\n}\n","import { Relation } from '../relation/relation'\nimport { RATreeNode } from './raTreeNode'\n\n/**\n * Leave node of the relational algebra syntactic tree with reference to a source relation.\n * @extends RATreeNode\n * @category RATree\n * @public\n */\nexport class RelationNode extends RATreeNode {\n\n  /**\n     * Creates a new RelationNode.\n     *\n     * @param relation source relation {@type Relation}\n     * @public\n     */\n  constructor (relation: Relation) {\n    super()\n    this.resultRelation = relation\n  }\n\n  /**\n     * Evaluates the RA query in this node and its subtree.\n     * After successful call, this.resultRelation must be set to valid Relation.\n     * @public\n     */\n  eval (): void {\n    // nothing to evaluate\n  }\n\n  /**\n     * Evaluates the RA query in this node and its subtree.\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\n     * Otherwise returns the result relation schema (only column names, no rows).\n     * When an error occurs, it is faked to work, and adds it to the errors array.\n     *\n     * @param cursorIndex index of the cursor in original text input {@type number}\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper {@type NodeFakeEvalResult}\n     * @public\n     */\n  fakeEval (cursorIndex: number) {\n    // @ts-ignore\n    const relation: Relation = this.resultRelation\n    return { result: relation, whispers: [], errors: [] }\n  }\n\n  /**\n     * Creates a string with a structure of the RA tree in one line.\n     *\n     * @return string with a structure of the RA tree in one line {@type string}\n     * @public\n     */\n  printInLine (): string {\n    // @ts-ignore\n    return this.resultRelation.getName()\n  }\n\n  /**\n     * Return the word name of the RA operation of the node.\n     * Example: returns \"Selection\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n  getOperationName (): string {\n    // @ts-ignore\n    return this.resultRelation.getName()\n  }\n\n  /**\n     * Return the symbolic representation of the RA operation of the node.\n     * Example: returns \"(some + expr = 15)\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n  getOperationSymbol (): string {\n    return ''\n  }\n}\n","import { StartEndPair } from './startEndPair'\n\n/**\n * String representation with index of each character. The index is not changed by the mutating the string.\n * Provides some usual string functions. Uses array of {@link IndexedChar}.\n * @category Types\n * @public\n */\nexport class IndexedString {\n\n  /**\n     * Creates a new IndexedString instance representing the given string. StartIndex is used as the offset for indexes.\n     * When the startIndex is omitted, 0 is used. When NaN is given, all indexes are NaN.\n     * Indexes of the characters are (0 + startIndex, ..., str.length - 1 + startIndex).\n     * NOTE: Each character has its own index. That means '\\r\\n' line separator has two indexes. For expected behavior, use\n     * '\\n' separator instead.\n     *\n     * @param str string to store {@type string}\n     * @param startIndex index of the first character {@type number}\n     * @return new IndexedString instance {@type IndexedString}\n     * @public\n     */\n  static new (str: string, startIndex = 0): IndexedString {\n    return new IndexedString(str, str.split('').map((char, index) => { return { char: char, index: index + startIndex } }))\n  }\n\n  /**\n     * Creates a new IndexedString instance representing an empty string \"\".\n     *\n     * @return new IndexedString instance {@type IndexedString}\n     * @public\n     */\n  static empty (): IndexedString {\n    return new IndexedString('', [])\n  }\n\n  /**\n     * Creates a new IndexedString instance representing the given array of IndexedChars.\n     *\n     * @param arr array of IndexedChars {@type IndexedChar[]}\n     * @return new IndexedString instance {@type IndexedString}\n     * @public\n     */\n  static newFromArray (arr: IndexedChar[]): IndexedString {\n    return new IndexedString(arr.map(ic => ic.char).join(''), arr)\n  }\n\n  /**\n     * Private constructor to ensure compatible string and IndexCharArray.\n     *\n     * @param str string representation {@type string}\n     * @param chars IndexedChar representation {@type IndexedChar[]}\n     */\n  private constructor (private readonly str: string, private readonly chars: IndexedChar[]) { }\n\n  /**\n     * Returns string representation of the IndexedString.\n     *\n     * @return string representation of the IndexedString {@type string}\n     * @public\n     */\n  toString (): string {\n    return this.str\n  }\n\n  /**\n     * Returns length of the string.\n     *\n     * @return length of the string {@type number}\n     * @public\n     */\n  length (): number {\n    return this.str.length\n  }\n\n  /**\n     * Returns true if the IndexedString represents an empty string \"\".\n     *\n     * @return true if the IndexedString represents an empty string \"\" {@type boolean}\n     * @public\n     */\n  isEmpty (): boolean {\n    return this.length() === 0\n  }\n\n  /**\n     * Returns IndexedChar array representing the IndexedString.\n     * The array is reference to inner IndexedString structure.\n     *\n     * @return IndexedChar array representation {@type IndexedChar[]}\n     * @public\n     */\n  getChars (): IndexedChar[] {\n    return this.chars\n  }\n\n  /**\n     * Returns the original index of the first character of the IndexedString. Returns NaN if empty.\n     *\n     * @return original index of the first character {@type number}\n     * @public\n     */\n  getFirstIndex (): number {\n    if (this.isEmpty()) {\n      return NaN\n    }\n    return this.chars[0].index\n  }\n\n  /**\n     * Returns the original index of the last character of the IndexedString. Returns NaN if empty.\n     *\n     * @return original index of the last character {@type number}\n     * @public\n     */\n  getLastIndex (): number {\n    if (this.isEmpty()) {\n      return NaN\n    }\n    return this.chars[this.length() - 1].index\n  }\n\n  /**\n     * Returns indexes of the first and the last character of the IndexedString. Returns undefined if empty.\n     *\n     * @return indexes of the first and the last character {@type StartEndPair?}\n     * @public\n     */\n  getRange (): StartEndPair | undefined {\n    if (this.isEmpty()) {\n      return undefined\n    }\n    return { start: this.chars[0].index, end: this.chars[this.length() - 1].index }\n  }\n\n  /**\n     * Returns a string representation of the character at the given current index. Throws RangeError if the index is\n     * out of IndexedString bounds.\n     *\n     * @param index current index {@type number}\n     * @return char at the given index {@type string}\n     * @public\n     */\n  charAt (index: number): string {\n    if (index < 0 || index >= this.length()) {\n      throw new RangeError()\n    }\n    return this.chars[index].char\n  }\n\n  /**\n     * Returns an original position index of the character at the given current index. Throws RangeError if the given index is\n     * out of IndexedString bounds.\n     *\n     * @param index current index {@type number}\n     * @return original index {@type number}\n     * @public\n     */\n  indexAt (index: number): number {\n    if (index < 0 || index >= this.length()) {\n      throw new RangeError()\n    }\n    return this.chars[index].index\n  }\n\n  /**\n     * Split a string into substrings using the specified separator and return them as an array.\n     * It does not accept RegEx separators and array limit as built-in string.\n     *\n     * @param separator string separator {@type string}\n     * @return separated substrings {@type IndexedString[]}\n     * @public\n     */\n  split (separator: string): IndexedString[] {\n    if (this.isEmpty()) {\n      if (separator === '') {\n        return []\n      }\n      return [IndexedString.empty()]\n    }\n    const sepLen: number = separator.length\n    const strSplit: string[] = this.str.split(separator)\n    const prefixSum: number[] = Array<number>(strSplit.length)\n    prefixSum[0] = 0\n    for (let i = 1; i < strSplit.length; i++) {\n      prefixSum[i] = prefixSum[i - 1] + strSplit[i - 1].length + sepLen\n    }\n\n    return strSplit.map((strSplit, index) => {\n      return new IndexedString(strSplit, this.chars.slice(prefixSum[index], prefixSum[index] + strSplit.length))\n    })\n  }\n\n  /**\n     * Returns a section of a IndexedString.\n     *\n     * @param start index of the beginning of the specified portion of stringObj {@type number}\n     * @param end index of the end of the specified portion of IndexedString. The substring includes the characters\n     * up to, but not including, the character indicated by end. If this value is not specified, the substring\n     * continues to the end of IndexedString {@type number}\n     * @return section of a IndexedString {@type IndexedString}\n     * @public\n     */\n  slice (start: number, end?: number): IndexedString {\n    const _start = start < 0 ? this.length() + start : start\n    const _end = end !== undefined ? (end < 0 ? this.length() + end : end) : this.length()\n    if (_start > _end || _start < 0 || _end > this.length()) {\n      throw new RangeError()\n    }\n    return IndexedString.newFromArray(this.chars.slice(_start, _end))\n  }\n\n  /**\n     * Removes the leading and trailing white space and line terminator characters from a string.\n     *\n     * @return returns an IndexedString without leading and trailing white space and line terminator characters {@type IndexedString[]}\n     * @public\n     */\n  trim (): IndexedString {\n    const trimStr: string = this.str.trim()\n    if (trimStr === '') {\n      return new IndexedString('', [])\n    }\n    const start: number = this.str.indexOf(trimStr.charAt(0))\n    return IndexedString.newFromArray(this.chars.slice(start, start + trimStr.length))\n  }\n\n  /**\n     * Returns a string that contains the concatenation of this IndexedString with multiple other.\n     *\n     * @param strings IndexedStrings to append to the end of the string {@type ...IndexedString}\n     * @return string that contains the concatenation of this IndexedString with multiple other {@type IndexedString}\n     * @public\n     */\n  concat (...strings: IndexedString[]): IndexedString {\n    return IndexedString.newFromArray(this.chars.concat(...strings.map(is => is.chars)))\n  }\n\n  /**\n     * Returns true if the searchString sequence is the same as the corresponding\n     * elements of this object starting at position. Otherwise returns false.\n     *\n     * @param searchString checked value {@type string}\n     * @param position position to start the IndexedString {@type number?}\n     * @return true if the IndexedString starts with the given searchString {@type boolean}\n     * @public\n     */\n  startsWith (searchString: string, position?: number | undefined): boolean {\n    return this.str.startsWith(searchString, position)\n  }\n\n  /**\n     * Returns true if the searchString sequence is the same as the corresponding\n     * elements of this object starting at endPosition – searchString.length. Otherwise returns false.\n     *\n     * @param searchString checked value {@type string}\n     * @param endPosition position to end the IndexedString {@type number?}\n     * @return true if the IndexedString ends with the given searchString {@type boolean}\n     * @public\n     */\n  endsWith (searchString: string, endPosition?: number | undefined): boolean {\n    return this.str.endsWith(searchString, endPosition)\n  }\n\n  /**\n     * Replaces text in a string, using a regular expression or search string.\n     * NOTE: Returns built-in string, the IndexedString is not modified.\n     *\n     * @param searchValue string or RegEx to search for {@type string}\n     * @param replaceValue string containing the text to replace for every successful match of searchValue in this string {@type string}\n     * @return built-in string with replaced values {@type string}\n     * @public\n     */\n  replace (searchValue: string | RegExp, replaceValue: string): string {\n    return this.str.replace(searchValue, replaceValue)\n  }\n\n  /**\n     * Creates a deep copy of this IndexedString.\n     *\n     * @return deep copy of this IndexedString {@type IndexedString}\n     * @public\n     */\n  copy (): IndexedString {\n    return new IndexedString(this.str, this.chars.map(ic => { return { char: ic.char, index: ic.index } }))\n  }\n\n  /**\n     * Returns true if it contains any of the characters from string chars. Otherwise, returns false.\n     *\n     * @param chars characters to search for {@type string}\n     * @return true if it contains any of the characters from string chars {@type boolean}\n     * @public\n     */\n  containsAny (chars: string): boolean {\n    for (let i = 0; i < chars.length; ++i) {\n      if (this.str.includes(chars[i])) {\n        return true\n      }\n    }\n    return false\n  }\n}\n\n/**\n * Indexed representation of one character in {@link IndexedString}.\n * WARNING: It is always assumed that IndexedChar.char is a string of length 1.\n * @category Types\n * @public\n */\nexport interface IndexedChar {\n  /**\n     * char - string of length 1\n     * @type string\n     * @public\n     */\n  char: string\n  /**\n     * index\n     * @type number\n     * @public\n     */\n  index: number\n}\n","import { IndexedString } from '../types/indexedString'\nimport { StringUtils } from './stringUtils'\nimport { insertRangeIfUndefined } from '../error/errorWithTextRange'\nimport { RASyntaxError } from '../error/raSyntaxError'\nimport { ErrorFactory } from '../error/errorFactory'\nimport { language } from '../language/language'\nimport { Pair } from '../types/pair'\n\n/**\n * Class providing general helper functions for IndexedString.\n * @category Utils\n * @public\n */\nexport class IndexedStringUtils {\n\n  /**\n     * Returns true if the string contains letters only and has length at least 1.\n     *\n     * @param str Checked indexed string {@type IndexedString}\n     * @return true if the string contains letters only and has length at least 1 {@type boolean}\n     * @public\n     */\n  static isWord (str: IndexedString): boolean {\n    return StringUtils.isWord(str.toString())\n  }\n\n  /**\n     * Returns true if the string contains letters, numbers and underscores only, has length at least 1 and starts with\n     * a letter or an underscore.\n     *\n     * @param str Checked string {@type IndexedString}\n     * @return true if the string contains letters, numbers and underscores only, has length at least 1 and starts with\n     * a letter or an underscore {@type boolean}\n     * @public\n     */\n  static isName (str: IndexedString): boolean {\n    return StringUtils.isName(str.toString())\n  }\n\n  /**\n     * Returns true if the string contains whitespaces only.\n     *\n     * @param str Checked string {@type IndexedString}\n     * @return true if the string contains whitespaces only {@type boolean}\n     * @public\n     */\n  static isWhitespacesOnly (str: IndexedString): boolean {\n    return StringUtils.isWhitespacesOnly(str.toString())\n  }\n\n  /**\n     * Returns true if the given string has length one and the character is a letter.\n     *\n     * @param c Checked character {@type IndexedString}\n     * @return true if the given string has length one and the character is a letter {@type boolean}\n     * @public\n     */\n  static isLetter (c: IndexedString): boolean {\n    return StringUtils.isLetter(c.toString())\n  }\n\n  /**\n     * Returns true if the given string has length one and the character is a letter, a number or an underscore.\n     *\n     * @param c Checked character {@type IndexedString}\n     * @return true if the given string has length one and the character is a letter, a number or an underscore {@type boolean}\n     * @public\n     */\n  static isNameChar (c: IndexedString): boolean {\n    return StringUtils.isNameChar(c.toString())\n  }\n\n  /**\n     * Returns true if the given string has length one and the character is a digit.\n     *\n     * @param c Checked character {@type IndexedString}\n     * @return true if the given string has length one and the character is a digit {@type boolean}\n     * @public\n     */\n  static isDigit (c: IndexedString): boolean {\n    return StringUtils.isDigit(c.toString())\n  }\n\n  /**\n     * Returns true if the string represents a decimal number.\n     *\n     * @param str Checked string {@type IndexedString}\n     * @return true if the string represents a decimal number {@type boolean}\n     * @public\n     */\n  static isNumber (str: IndexedString): boolean {\n    return StringUtils.isNumber(str.toString())\n  }\n\n  /**\n     * Splits given indexed string to a starting sequence of letters and its rest and returns these parts in a pair.\n     * NOTE: if the string does not start with a letter, as a word is returned an empty string.\n     *\n     * @param str indexed string to be split {@type IndexedString}\n     * @return split indexed string in a pair (word, rest) {@type Pair<IndexedString>}\n     * @public\n     */\n  static nextWord (str: IndexedString): Pair<IndexedString> {\n    const strParts: Pair<string> = StringUtils.nextWord(str.toString())\n    return { first: str.slice(0, strParts.first.length), second: str.slice(strParts.first.length) }\n  }\n\n  /**\n     * Splits given indexed string to a starting sequence of letters, numbers and underscores, which starts with a letter or\n     * an underscore and its rest and returns these parts in a pair.\n     * NOTE: if the string does not start with a letter, or an underscore, as a name is returned an empty string.\n     *\n     * @param str string to be split {@type IndexedString}\n     * @return split indexed string in a pair (name, rest) {@type Pair<IndexedString>}\n     * @public\n     */\n  static nextName (str: IndexedString): Pair<IndexedString> {\n    const strParts: Pair<string> = StringUtils.nextName(str.toString())\n    return { first: str.slice(0, strParts.first.length), second: str.slice(strParts.first.length) }\n  }\n\n  /**\n     * Splits given indexed string to a starting sequence of non-whitespace characters and its rest and returns these\n     * parts in a pair.\n     *\n     * @param str string to be split {@type IndexedString}\n     * @return split indexed string in a pair (name, rest) {@type Pair<IndexedString>}\n     * @public\n     */\n  static nextNonWhitespacePart (str: IndexedString): Pair<IndexedString> {\n    const strParts: Pair<string> = StringUtils.nextNonWhitespacePart(str.toString())\n    return { first: str.slice(0, strParts.first.length), second: str.slice(strParts.first.length) }\n  }\n\n  /**\n     * Splits given indexed string to a starting number and its rest and returns these parts in a pair.\n     * NOTE: if the string does not start with a digit, as a number is returned an empty string.\n     *\n     * @param str indexed string to be split {@type IndexedString}\n     * @return split indexed string in a pair (word, rest) {@type Pair<IndexedString>}\n     * @public\n     */\n  static nextNumber (str: IndexedString): Pair<IndexedString> {\n    const strParts: Pair<string> = StringUtils.nextNumber(str.toString())\n    return { first: str.slice(0, strParts.first.length), second: str.slice(strParts.first.length) }\n  }\n\n  /**\n     * Splits the given indexed string into starting quoted part and the rest. Quotes can be escaped by an odd count of\n     * backslashes.\n     * NOTE: When the closing quote is not found until the rest of the line, unclosed string is returned\n     * => the error is not thrown, it is only added to the return object.\n     * NOTE: First character of the string is expected to be '\"'.\n     *\n     * @param str string to be split {@type IndexedString}\n     * @return pair of the starting bordered part and the rest {@type Object}\n     * @public\n     */\n  static nextQuotedString (str: IndexedString): { first: IndexedString, second: IndexedString, error: RASyntaxError | undefined } {\n    const strParts: { first: string, second: string, error: RASyntaxError | undefined } = StringUtils.nextQuotedString(str.toString())\n    return {\n      first: str.slice(0, strParts.first.length),\n      second: str.slice(strParts.first.length),\n      error: insertRangeIfUndefined(strParts.error, { start: str.getFirstIndex(), end: str.getFirstIndex() }),\n    }\n  }\n\n  /**\n     * Splits the indexed string to the starting bordered part and the rest and returns these parts in a pair.\n     * If there is only one ending character and it differs from the starting one, nested bordering is supported.\n     * Characters after escape character are ignored and cannot start or end a bordered part.\n     * Starting and ending characters in quoted part are ignored.\n     * NOTE: First character of the string is expected to be 'start'.\n     * NOTE: Should not be used for slicing quoted strings, use nextQuotedString instead.\n     * NOTE: It is expected, that there are no comments in the given string.\n     *\n     * @param str indexed string to be split {@type IndexedString}\n     * @param start starting character of the string and also starting character of the bordered part (one character) {@type string}\n     * @param end ending characters of the bordered part (one or more characters) {@type string}\n     * @param escape character which makes next character being ignored (default '\\0') {@type string}\n     * @return pair of the starting bordered part and the rest as indexed strings {@type Pair<IndexedString>}\n     * @public\n     */\n  static nextBorderedPart (str: IndexedString, start: string, end: string, escape = '\\0'): Pair<IndexedString> {\n    try {\n      const strParts: Pair<string> = StringUtils.nextBorderedPart(str.toString(), start, end, escape)\n      return { first: str.slice(0, strParts.first.length), second: str.slice(strParts.first.length) }\n    } catch (err) {\n      throw insertRangeIfUndefined(err, { start: str.getFirstIndex(), end: str.getFirstIndex() })\n    }\n  }\n\n  /**\n     * Deletes all line and block comments from the given IndexedString.\n     * If there is unclosed block comment, return the error as well.\n     * Line comment \"//comment\\n\" will be changed to \"\\n\" - new line is kept.\n     * Block comment \"/\\*comment* /\" will be changed to \" \" - it is replaced by a space to ensure splitting of the content around.\n     *\n     * @param str string to delete comments in {@type IndexedString}\n     * @return string with deleted comments and optimal error {@type Object}\n     * @public\n     */\n  static deleteAllComments (str: IndexedString): {str: IndexedString, err: RASyntaxError | undefined} {\n    const chars = str.copy().getChars()\n    // to ignore special characters\n    let inQuotes = false\n    let inLineComment = false\n    let blockCommentStart = -1\n    let backslashes = 0\n\n    for (let i = 0; i < chars.length; ++i) {\n      const curChar = chars[i].char\n      // found quote if even number of backslashes before\n      if (curChar === '\"' && (backslashes % 2) === 0 && !inLineComment && blockCommentStart === -1) {\n        inQuotes = !inQuotes\n      }\n      // found start of a line comment if it is not in a comment already\n      else if (curChar === '/' && i + 1 < chars.length && chars[i + 1].char === '/' && !inQuotes && !inLineComment && blockCommentStart === -1) {\n        inLineComment = true\n        chars[i].char = '\\0'\n        ++i    // skips '/'\n      }\n      // newlines ends the line comment\n      else if (curChar === '\\n') {\n        inLineComment = false\n      }\n      // found start of a block comment if it is not in a comment already\n      else if (curChar === '/' && i + 1 < chars.length && chars[i + 1].char === '*' && !inQuotes && !inLineComment && blockCommentStart === -1) {\n        blockCommentStart = i\n        chars[i].char = '\\0'\n        ++i    // skips '*'\n        chars[i].char = ' '\n      }\n      // found end of a block comment\n      else if (curChar === '*' && i + 1 < chars.length && chars[i + 1].char === '/' && blockCommentStart !== -1) {\n        blockCommentStart = -1\n        chars[i].char = '\\0'\n        ++i    // replaces '/' with space to force splitting of string in the comment place\n        chars[i].char = ' '\n      }\n      // updates backslash count\n      if (curChar === '\\\\') {\n        ++backslashes\n      } else {\n        backslashes = 0\n      }\n      if (inLineComment || blockCommentStart !== -1) {\n        chars[i].char = '\\0'\n      }\n    }\n    let err\n    if (blockCommentStart !== -1) {\n      const errStart = chars[blockCommentStart].index\n      err = ErrorFactory.syntaxError(language().syntaxErrors.stringUtils_missingClosingChar,\n              { start: errStart, end: errStart + 1 }, '*/', '/*')\n    }\n    // creates a new string from non-null characters\n    return { str: IndexedString.newFromArray(chars.filter(c => c.char !== '\\0')), err: err }\n  }\n\n  /**\n     * Skips all whitespaces and exactly one given character and returns rest of the string.\n     * If the string does not match this pattern, throws error.\n     *\n     * @param str string to be skipped in {@type IndexedString}\n     * @param char char to be skipped exactly one time (expected to be string of length 1) {@type string}\n     * @return given string without starting sequence of whitespaces and exactly one char {@type IndexedString}\n     * @public\n     */\n  static skipWhitespacesAndChar (str: IndexedString, char: string): IndexedString {\n    try {\n      const skippedStr: string = StringUtils.skipWhitespacesAndChar(str.toString(), char)\n      return str.slice(str.length() - skippedStr.length)\n    } catch (err) {\n      throw insertRangeIfUndefined(err, str.getRange())\n    }\n  }\n}\n","import { RATreeNode } from './raTreeNode'\n\n/**\n * Classes extending unary node.\n * @category RATree\n * @public\n */\nexport type UnaryNodeClass = 'rename' | 'projection' | 'selection'\n\n/**\n * Abstract node of the relational algebra syntactic tree with one subtree.\n * @extends RATreeNode\n * @category RATree\n * @public\n */\nexport abstract class UnaryNode extends RATreeNode {\n\n  protected subtree: RATreeNode\n\n  /**\n     * Creates a new UnaryNode.\n     *\n     * @param subtree subtree of the node {@type RATreeNode}\n     * @public\n     */\n  protected constructor (subtree: RATreeNode) {\n    super()\n    this.subtree = subtree\n  }\n\n  /**\n     * Returns subtree of the unary node.\n     *\n     * @return subtree of the unary node {@type RATreeNode}\n     * @public\n     */\n  getSubtree (): RATreeNode {\n    return this.subtree\n  }\n}\n","import { ColumnContent, SupportedColumnType } from './columnType'\nimport { isEqual } from 'lodash'\nimport { ErrorFactory } from '../error/errorFactory'\nimport { language } from '../language/language'\n\n/**\n * Row stores a set of column values in a formal {@link Relation} representation.\n *\n * @category Relation\n * @public\n */\nexport class Row {\n\n  private readonly types = new Map<string, SupportedColumnType>()\n  private readonly values = new Map<string, ColumnContent>()\n  private finished: boolean\n\n  /**\n     * Creates a new row with given columns. Given column set is final, no more column can be added.\n     * Given column values are set to null. They can be set to a new value by addColumn function, as long as the row\n     * is not set finished.\n     *\n     * @param columns set of columns in a row {@type Map<String, SupportedColumnType>}\n     * @public\n     */\n  constructor (columns: Map<string, SupportedColumnType>) {\n    // adds empty columns\n    columns.forEach((value, name) => {\n      this.values.set(name, null)\n    })\n    this.types = columns\n    this.finished = false\n  }\n\n  /**\n     * Returns whether the row is finished and no more column change is possible.\n     *\n     * @return true if the row is finished {@type boolean}\n     * @public\n     */\n  isFinished (): boolean {\n    return this.finished\n  }\n\n  /**\n     * Sets the row as finished, no more changes in column values are possible.\n     * @public\n     */\n  finish (): void {\n    this.finished = true\n  }\n\n  /**\n     * Gets names of all columns in a row.\n     *\n     * @return set of all column names {@type IterableIterator<String>}\n     * @public\n     */\n  getColumnNames (): IterableIterator<string> {\n    return this.types.keys()\n  }\n\n  /**\n     * Adds a value to the row. If the addition succeeded, returns true. It can fail, if the row is finished,\n     * if there is no column of the given name or if there is a column with the name, but different type.\n     *\n     * @param name name of the column {@type string}\n     * @param value new value of the column {@type ColumnContent}\n     * @return true if addition succeeded {@type boolean}\n     * @public\n     */\n  addValue (name: string, value: ColumnContent): boolean {\n    // finished row or not present column\n    if (this.finished || !this.types.has(name)) {\n      return false\n    }\n    const givenType = typeof value\n    // null can be set all column types\n    if (value !== null && givenType !== this.types.get(name)) {\n      return false\n    }\n    this.values.set(name, value)\n    return true\n  }\n\n  /**\n     * Gets the value (possibly null) of the column with the given name. If there is no column with this name, undefined is returned.\n     *\n     * @param name name of the column {@type string}\n     * @return value of the column or undefined if there is no such column {@type ColumnContent?}\n     * @public\n     */\n  getValue (name: string): ColumnContent | undefined {\n    return this.values.get(name)\n  }\n\n  /**\n     * Returns the type of the given column or undefined if the column is absent.\n     *\n     * @param name name of the column {@type string}\n     * @return the type of the column {@type SupportedColumnType?}\n     * @public\n     */\n  getType (name: string): SupportedColumnType | undefined {\n    return this.types.get(name)\n  }\n\n  /**\n     * Gets types of all columns.\n     *\n     * @return map of columns {@type Map<String, SupportedColumnType>}\n     * @public\n     */\n  getTypes (): Map<string, SupportedColumnType> {\n    return this.types\n  }\n\n  /**\n     * Gets values of all columns.\n     *\n     * @return map of columns {@type Map<String, ColumnContent>}\n     * @public\n     */\n  getValues (): Map<string, ColumnContent> {\n    return this.values\n  }\n\n  /**\n     * Returns values of all columns ordered by given array of column names. OrderedColumns are expected to be from the\n     * relation that contains the row. The returned values are converted to string type. String column values are\n     * changed to printing representation - escaped '\\\\' and '\"' are returned without the escape '\\\\'.\n     *\n     * @param orderedColumns order of columns to be returned {@type string[]}\n     * @return ordered array of values {@type string[]}\n     * @public\n     */\n  getOrderedPrintValues (orderedColumns: string[]): string[] {\n    const ret: string[] = []\n    orderedColumns.forEach(column => {\n      const value = this.values.get(column)\n      const type = this.types.get(column)\n      // should be handled before call\n      if (value === undefined || type === undefined) {\n        throw ErrorFactory.codeError(language().codeErrors.row_absentColumn, column, [...this.types.values()].join(', '))\n      }\n      if (type === 'string') {\n        const str = String(value).replace(/\\\\\"/g, '\"').replace(/\\\\\\\\/g, '\\\\')\n        ret.push(str)\n      } else {\n        ret.push(String(value))\n      }\n    })\n    return ret\n  }\n\n  /**\n     * Custom equals function.\n     *\n     * @param other object to compare to {@type any}\n     * @return whether this and given object has the same values and types\n     * @public\n     */\n  equals (other: Object): boolean {\n    if (other instanceof Row) {\n      return isEqual(this.types, other.types) && isEqual(this.values, other.values)\n    }\n    return false\n  }\n}\n","import { UnaryNode } from './unaryNode'\nimport { RATreeNode } from './raTreeNode'\nimport { Relation } from '../relation/relation'\nimport { Row } from '../relation/row'\nimport { IndexedString } from '../types/indexedString'\nimport { ErrorFactory } from '../error/errorFactory'\nimport { language } from '../language/language'\nimport { StartEndPair } from '../types/startEndPair'\n\n/**\n * Projection node of the relational algebra syntactic tree.\n * @extends UnaryNode\n * @category RATree\n * @public\n */\nexport class ProjectionNode extends UnaryNode {\n\n  private readonly projection: IndexedString\n  private readonly stringRange: StartEndPair\n\n  /**\n     * Creates a new ProjectionNode.\n     * Expects the projection string to start with '[' and end with ']'.\n     *\n     * @param projection string describing projected columns {@type IndexedString}\n     * @param subtree source subtree {@type RATreeNode}\n     * @public\n     */\n  constructor (projection: IndexedString, subtree: RATreeNode) {\n    super(subtree)\n    this.projection = projection\n    // @ts-ignore - should never be empty\n    this.stringRange = projection.getRange()\n  }\n\n  /**\n     * Parses projection string to set of projected columns and their ranges.\n     */\n  private parseProjection (): Set<{str: string, range: StartEndPair}> {\n    const ret = new Set<{str: string, range: StartEndPair}>()\n    const str: string = this.projection.toString().replace(/]/g, ',')\n    const projStart: number = this.stringRange.start\n    let start = 1\n    for (let i = 1; i < this.projection.length(); ++i) {\n      if (str.charAt(i) === ',') {\n        const range = (start === i)\n          ? { start: projStart + start - 1, end: projStart + i - 1 }\n          : { start: projStart + start, end: projStart + i - 1 }\n        ret.add({ str: str.slice(start, i).trim(), range })\n        start = i + 1\n      }\n    }\n    return ret\n  }\n\n  /**\n     * Evaluates the RA query in this node and its subtree.\n     * After successful call, this.resultRelation must be set to valid Relation.\n     * Expectations: projected names are subset of source schema\n     * @public\n     */\n  eval (): void {\n    if (this.isEvaluated()) {\n      return\n    }\n    // handles empty projection\n    if (this.projection.toString().slice(1, -1).trim().length === 0) {\n      throw ErrorFactory.semanticError(language().semanticErrors.projectionNode_emptyProjection, this.stringRange)\n    }\n    const source: Relation = this.subtree.getResult()\n    const projectedIndexed: {str: string, range: StartEndPair}[] = [...this.parseProjection()]\n    // checks if projected columns really exist in source relation\n    projectedIndexed.forEach(proj => {\n      if (!source.hasColumn(proj.str)) {\n        throw ErrorFactory.semanticError(language().semanticErrors.projectionNode_absentColumn, proj.range, proj.str)\n      }\n    })\n\n    const projected: string[] = projectedIndexed.map(p => p.str)\n    const result: Relation = new Relation(source.getName() + '[...]')\n    // projection of relational schema\n    source.forEachColumn((type, name) => {\n      if (projected.includes(name)) {\n        result.addColumn(name, type)\n      }\n    })\n    // projection of relation rows\n    source.getRows().forEach(row => {\n      const newRow: Row = new Row(result.getColumns())\n      row.getValues().forEach((value, name) => {\n        if (projected.includes(name)) {\n          newRow.addValue(name, value)\n        }\n      })\n      result.addRow(newRow)\n    })\n    this.resultRelation = result\n  }\n\n  /**\n     * Evaluates the RA query in this node and its subtree.\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\n     * Otherwise returns the result relation schema (only column names, no rows).\n     * When an error occurs, it is faked to work, and adds it to the errors array.\n     *\n     * Strict expectations: projected names are subset of source schema\n     * Returned schema: intersection of projected names and source schema\n     *\n     * @param cursorIndex index of the cursor in original text input {@type number}\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper {@type NodeFakeEvalResult}\n     * @public\n     */\n  fakeEval (cursorIndex: number) {\n    const source = this.subtree.fakeEval(cursorIndex)\n    // checks whether the cursor is in this projection block - saves current available columns\n    let whispers = source.whispers\n    if (this.stringRange !== undefined && this.stringRange.start < cursorIndex && cursorIndex <= this.stringRange.end) {\n      whispers = source.result.getColumnNames()\n    }\n    // adds errors from current expression\n    const errors = source.errors\n    // creates relational schema - \"projected columns\"\n    const result: Relation = new Relation(source.result.name + '[...]')\n    // handles empty projection\n    if (this.projection.toString().slice(1, -1).trim().length === 0) {\n      errors.push(ErrorFactory.semanticError(language().semanticErrors.projectionNode_emptyProjection, this.stringRange))\n      return { result, whispers, errors }\n    }\n    const projected: Set<{str: string, range: StartEndPair}> = this.parseProjection()\n    // adds only projected, which exist in source\n    const absent: {str: string, range: StartEndPair}[] = []\n    projected.forEach(proj => {\n      const strName = proj.str\n      if (source.result.hasColumn(strName)) {\n        // @ts-ignore - strName must be in the source now\n        result.addColumn(strName, source.result.getColumns().get(strName))\n      } else {\n        absent.push(proj)\n      }\n    })\n    absent.forEach(proj => {\n      errors.push(ErrorFactory.semanticError(language().semanticErrors.projectionNode_absentColumn, proj.range, proj.str))\n    })\n    return { result, whispers, errors }\n  }\n\n  /**\n     * Creates a string with a structure of the RA tree in one line.\n     *\n     * @return string with a structure of the RA tree in one line {@type string}\n     * @public\n     */\n  printInLine (): string {\n    return this.subtree.printInLine() + this.getOperationSymbol()\n  }\n\n  /**\n     * Return the word name of the RA operation of the node.\n     * Example: returns \"Selection\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n  getOperationName (): string {\n    return language().operations.projection\n  }\n\n  /**\n     * Return the symbolic representation of the RA operation of the node.\n     * Example: returns \"(some + expr = 15)\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n  getOperationSymbol (): string {\n    return this.projection.replace(/\\s+/g, ' ')\n  }\n}\n","import { IndexedString } from '../types/indexedString'\n\n/**\n * Lowercase reserved keywords which cannot be used for column names. They are:\n * - Null value: null\n * - Boolean values: true, false\n * - Empty string: \"\"\n */\nconst forbiddenColumnNames: string[] = ['null', 'true', 'false', '']\n\n/**\n * Reserved keywords which cannot be used for relation names. They are:\n * - First characters of outer joins: F, L, R\n * - Empty string: \"\"\n */\nconst forbiddenRelationNames: string[] = ['F', 'L', 'R', '']\n\n/**\n * Returns lowercase reserved keywords which cannot be used for column names. They are:\n * - Null value: null\n * - Boolean values: true, false\n * - Empty string: \"\"\n *\n * @return lowercase reserved column-keywords {@type string[]}\n * @category Utils\n * @public\n */\nexport function getForbiddenColumnNames (): string[] {\n  return forbiddenColumnNames\n}\n\n/**\n * Returns reserved keywords which cannot be used for relation names. They are:\n * - First characters of outer joins: F, L, R, f, l, r\n * - Empty string: \"\"\n *\n * @return lowercase reserved relation-keywords {@type string[]}\n * @category Utils\n * @public\n */\nexport function getForbiddenRelationNames (): string[] {\n  return forbiddenRelationNames\n}\n\n/**\n * Returns true if the given string is forbidden as a column name.\n *\n * @param str string to check {@type (string | IndexedString)}\n * @return true if the given string is forbidden as a column name {@type boolean}\n * @category Utils\n * @public\n */\nexport function isForbiddenColumnName (str: string | IndexedString): boolean {\n  return forbiddenColumnNames.includes(str.toString().toLowerCase())\n}\n\n/**\n * Returns true if the given string is forbidden as a relation name.\n *\n * @param str string to check {@type (string | IndexedString)}\n * @return true if the given string is forbidden as a relation name {@type boolean}\n * @category Utils\n * @public\n */\nexport function isForbiddenRelationName (str: string | IndexedString): boolean {\n  // does not use to lower because forbidden names are upper\n  return forbiddenRelationNames.includes(str.toString())\n}\n","import { IndexedString } from './indexedString'\n\n\nexport interface KeyValue {\n  key: IndexedString\n  value: IndexedString\n}\n\n/**\n * Wrapper of JavaScript Map object to provide usage of object {@link IndexedString} as a key for {@link IndexedString} values.\n * @category Types\n * @public\n */\nexport class ISToISMap {\n  protected map: Map<string, KeyValue> = new Map<string, KeyValue>()\n\n  /**\n     * Gets the value for the given key.\n     *\n     * @param key key of the value to get {@type (string | IndexedString)}\n     * @return value of the given key or undefined {@type IndexedString?}\n     * @public\n     */\n  get (key: string | IndexedString): IndexedString | undefined {\n    const keyValue = this.map.get(key.toString())\n    return keyValue === undefined ? undefined : keyValue.value\n  }\n\n  /**\n     * Sets the value for the given key.\n     *\n     * @param key key of the value to set {@type IndexedString}\n     * @param value value to set {@type IndexedString}\n     * @public\n     */\n  set (key: IndexedString, value: IndexedString): void {\n    this.map.set(key.toString(), { key, value })\n  }\n\n  /**\n     * Deletes the value for the given key.\n     *\n     * @param key key of the value to delete {@type IndexedString}\n     * @return true if an element in the Map object existed and has been removed, or false if the element does not exist {@type boolean}\n     * @public\n     */\n  delete (key: IndexedString): boolean {\n    return this.map.delete(key.toString())\n  }\n\n  /**\n     * Returns true, if the given key is in the map.\n     *\n     * @param key key to check {@type (string | IndexedString)}\n     * @return true, if the given key is in the map {@type boolean}\n     * @public\n     */\n  has (key: string | IndexedString): boolean {\n    return this.map.has(key.toString())\n  }\n\n  /**\n     * Removes all values from the map.\n     * @public\n     */\n  clear (): void {\n    this.map.clear()\n  }\n\n  /**\n     * Returns the size og the map.\n     *\n     * @return size of the map {@type number}\n     * @public\n     */\n  size (): number {\n    return this.map.size\n  }\n\n  /**\n     * Performs the given function for each (value, key, index) in the map.\n     *\n     * @param f function to perform {@type function}\n     * @public\n     */\n  forEach (f: (value: IndexedString, key: IndexedString, index?: number) => void): void {\n    [...this.map.values()].forEach((keyValue, index) => f(keyValue.value, keyValue.key, index))\n  }\n}\n","import { Row } from '../relation/row'\nimport { VEResult, VETreeNode } from './veTreeNode'\nimport { ErrorFactory } from '../error/errorFactory'\nimport { IndexedString } from '../types/indexedString'\nimport { language } from '../language/language'\n\n/**\n * Enum of types of ComparingOperator class.\n * @enum {number}\n * @category VETree\n * @public\n */\nexport enum ComparingOperatorType {\n  equal,\n  nonEqual,\n  less,\n  more,\n  lessOrEqual,\n  moreOrEqual\n}\n\n/**\n * Comparing operator compares two values and returns boolean.\n * @extends VETreeNode\n * @category VETree\n * @public\n */\nexport class ComparingOperator extends VETreeNode {\n\n  /**\n     * Creates new ComparingOperator instance of equality type (type = ComparingOperatorType.equal).\n     *\n     * @param operator used string representation of equality operator {@type IndexedString}\n     * @param left left subtree producing a value {@type VETreeNode}\n     * @param right right subtree producing a value {@type VETreeNode}\n     * @return new ComparingOperator instance of equality type {@type ComparingOperator}\n     * @public\n     */\n  static equal (operator: IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\n    return new ComparingOperator(ComparingOperatorType.equal, operator, left, right)\n  }\n\n  /**\n     * Creates new ComparingOperator instance of non-equality type (type = ComparingOperatorType.nonEqual).\n     *\n     * @param operator used string representation of non-equality operator {@type IndexedString}\n     * @param left left subtree producing a value {@type VETreeNode}\n     * @param right right subtree producing a value {@type VETreeNode}\n     * @return new ComparingOperator instance of non-equality type {@type ComparingOperator}\n     * @public\n     */\n  static nonEqual (operator: IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\n    return new ComparingOperator(ComparingOperatorType.nonEqual, operator, left, right)\n  }\n\n  /**\n     * Creates new ComparingOperator instance of less type (type = ComparingOperatorType.less).\n     *\n     * @param operator used string representation of less operator {@type IndexedString}\n     * @param left left subtree producing a value {@type VETreeNode}\n     * @param right right subtree producing a value {@type VETreeNode}\n     * @return new ComparingOperator instance of less type {@type ComparingOperator}\n     * @public\n     */\n  static less (operator: IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\n    return new ComparingOperator(ComparingOperatorType.less, operator, left, right)\n  }\n\n  /**\n     * Creates new ComparingOperator instance of more type (type = ComparingOperatorType.more).\n     *\n     * @param operator used string representation of more operator {@type IndexedString}\n     * @param left left subtree producing a value {@type VETreeNode}\n     * @param right right subtree producing a value {@type VETreeNode}\n     * @return new ComparingOperator instance of more type {@type ComparingOperator}\n     * @public\n     */\n  static more (operator: IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\n    return new ComparingOperator(ComparingOperatorType.more, operator, left, right)\n  }\n\n  /**\n     * Creates new ComparingOperator instance of less-or-equal type (type = ComparingOperatorType.lessOrEqual).\n     *\n     * @param operator used string representation of less-or-equal operator {@type IndexedString}\n     * @param left left subtree producing a value {@type VETreeNode}\n     * @param right right subtree producing a value {@type VETreeNode}\n     * @return new ComparingOperator instance of less-or-equal type {@type ComparingOperator}\n     * @public\n     */\n  static lessOrEqual (operator: IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\n    return new ComparingOperator(ComparingOperatorType.lessOrEqual, operator, left, right)\n  }\n\n  /**\n     * Creates new ComparingOperator instance of more-or-equal type (type = ComparingOperatorType.moreOrEqual).\n     *\n     * @param operator used string representation of more-or-equal operator {@type IndexedString}\n     * @param left left subtree producing a value {@type VETreeNode}\n     * @param right right subtree producing a value {@type VETreeNode}\n     * @return new ComparingOperator instance of more-or-equal type {@type ComparingOperator}\n     * @public\n     */\n  static moreOrEqual (operator: IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\n    return new ComparingOperator(ComparingOperatorType.moreOrEqual, operator, left, right)\n  }\n\n  /**\n     * Creates new ComparingOperator of the given type.\n     *\n     * @param type ComparingOperator type {@type ComparingOperatorType}\n     * @param operator used string representation of the operator {@type IndexedString}\n     * @param left left subtree producing a value {@type VETreeNode}\n     * @param right right subtree producing a value {@type VETreeNode}\n     * @public\n     */\n  constructor (private readonly type: ComparingOperatorType, private readonly operator: IndexedString,\n                       private readonly left: VETreeNode, private readonly right: VETreeNode) {\n    super()\n  }\n\n  /**\n     * Evaluate the node and its subtrees and compares their value results to produce a boolean value. It needs to\n     * receive results of the same type from its subtrees.\n     * NOTE: If one of the subtree results is null, only equality and non-equality are valid. Other comparing\n     * operations returns always false.\n     *\n     * @param source row with actual values of columns recursively passed to leaf reference nodes {@type Row}\n     * @return boolean comparing left and right subtree values {@type VEResult}\n     * @public\n     */\n  eval (source: Row): VEResult {\n    const leftResult: VEResult = this.left.eval(source)\n    const rightResult: VEResult = this.right.eval(source)\n\n    if (leftResult.type !== 'null' && rightResult.type !== 'null' && leftResult.type !== rightResult.type) {\n      throw ErrorFactory.syntaxError(language().syntaxErrors.comparingOperator_differentInputTypes,\n                this.operator.getRange(), this.operator.toString(), leftResult.type, rightResult.type)\n    }\n\n    // if both values are null but both types are not null, returns false\n    if (leftResult.value === null && rightResult.value === null && leftResult.type !== 'null' && rightResult.type !== 'null') {\n      return { value: false, type: 'boolean' }\n    }\n    if (this.type === ComparingOperatorType.equal) {\n      return { value: leftResult.value === rightResult.value, type: 'boolean' }\n    }\n    if (this.type === ComparingOperatorType.nonEqual) {\n      // if any value of non-null type is null, returns false\n      if ((leftResult.value === null && leftResult.type !== 'null') || (rightResult.value === null && rightResult.type !== 'null')) {\n        return { value: false, type: 'boolean' }\n      }\n      return { value: leftResult.value !== rightResult.value, type: 'boolean' }\n    }\n    if (this.type === ComparingOperatorType.less) {\n      if (leftResult.value === null || rightResult.value === null) {\n        return { value: false, type: 'boolean' }\n      }\n      return { value: leftResult.value < rightResult.value, type: 'boolean' }\n    }\n    if (this.type === ComparingOperatorType.more) {\n      if (leftResult.value === null || rightResult.value === null) {\n        return { value: false, type: 'boolean' }\n      }\n      return { value: leftResult.value > rightResult.value, type: 'boolean' }\n    }\n    if (this.type === ComparingOperatorType.lessOrEqual) {\n      if (leftResult.value === null || rightResult.value === null) {\n        return { value: false, type: 'boolean' }\n      }\n      return { value: leftResult.value <= rightResult.value, type: 'boolean' }\n    }\n    // if (this.type === ComparingOperatorType.moreOrEqual)\n    if (leftResult.value === null || rightResult.value === null) {\n      return { value: false, type: 'boolean' }\n    }\n    return { value: leftResult.value >= rightResult.value, type: 'boolean' }\n  }\n\n  /**\n     * Returns string representation of the node.\n     *\n     * @return string representation of the node {@type string}\n     * @public\n     */\n  toString (): string {\n    return '(' + this.left.toString() + ' ' + this.operator.toString() + ' ' + this.right.toString() + ')'\n  }\n}\n","import { UnaryNode } from './unaryNode'\nimport { RATreeNode } from './raTreeNode'\nimport { StringUtils } from '../utils/stringUtils'\nimport { Relation } from '../relation/relation'\nimport { SupportedColumnType } from '../relation/columnType'\nimport { Row } from '../relation/row'\nimport { IndexedString } from '../types/indexedString'\nimport { ErrorFactory } from '../error/errorFactory'\nimport { isForbiddenColumnName } from '../utils/keywords'\nimport { ErrorWithTextRange } from '../error/errorWithTextRange'\nimport { ISToISMap } from '../types/isToISMap'\nimport { language } from '../language/language'\nimport { StartEndPair } from '../types/startEndPair'\n\n/**\n * Renaming node of the relational algebra syntactic tree.\n * @extends UnaryNode\n * @category RATree\n * @public\n */\nexport class RenameNode extends UnaryNode {\n\n  private readonly rename: IndexedString\n  private readonly stringRange: StartEndPair | undefined\n\n  /**\n     * Creates a new RenameNode.\n     * The rename string is expected to start with '<' and end with '>'.\n     *\n     * @param rename string describing each renaming {@type IndexedString}\n     * @param subtree source subtree {@type RATreeNode}\n     * @public\n     */\n  constructor (rename: IndexedString, subtree: RATreeNode) {\n    super(subtree)\n    this.rename = rename\n    this.stringRange = rename.getRange()\n  }\n\n  private parseChanges (doThrow: boolean, errors: ErrorWithTextRange[] = []): ISToISMap {\n    const handleError = (error: SyntaxError) => {\n      if (doThrow) {\n        throw error\n      } else {\n        errors.push(error)\n      }\n    }\n    const parts: IndexedString[] = this.rename.slice(1, -1).split(',')\n    const ret: ISToISMap = new ISToISMap()\n    for (const part of parts) {\n      // @ts-ignore\n      const words: IndexedString[] = part.split('->').map(w => w.trim())\n      let beforeError = false // true when there was an error in before in \"before -> after\"\n      let afterError = false  // true when there was an error in after in \"before -> after\"\n      if (words.length !== 2) {\n        let range = part.getRange()\n        if (part.isEmpty() && this.stringRange !== undefined) {\n          range = { start: this.stringRange.start, end: this.stringRange.start }\n        }\n        handleError(ErrorFactory.syntaxError(language().syntaxErrors.renameNode_missingArrow, range))\n        beforeError = true\n        afterError = true\n      }\n      if (!beforeError && ret.has(words[0])) {\n        handleError(ErrorFactory.syntaxError(language().syntaxErrors.renameNode_multipleRenameOfTheColumn,\n                    words[0].getRange(), words[0].toString()))\n        beforeError = true\n      }\n      if (!afterError && !StringUtils.isName(words[1].toString())) {\n        handleError(ErrorFactory.syntaxError(language().syntaxErrors.renameNode_invalidNewName,\n                    words[1].getRange(), words[1].toString()))\n        afterError = true\n      }\n      if (!afterError && isForbiddenColumnName(words[1])) {\n        handleError(ErrorFactory.syntaxError(language().syntaxErrors.renameNode_keywordNewName,\n                    words[1].getRange(), words[1].toString()))\n        afterError = true\n      }\n      // if no error found, adds original rename pair\n      if (!beforeError && !afterError) {\n        ret.set(words[0], words[1])\n      }\n      // if no before error, fakes rename \"before -> before\"\n      else if (!beforeError) {\n        ret.set(words[0], words[0])\n      }\n      // if no after error, fakes rename \"\"\" -> before\", where empty string has undefined range\n      else if (!afterError) {\n        ret.set(IndexedString.empty(), words[0])\n      }\n      // if both errors, adds nothing\n    }\n    return ret\n  }\n\n  /**\n     * Evaluates the RA query in this node and its subtree.\n     * After successful call, this.resultRelation must be set to valid Relation.\n     * Expectations: original names in projection pair (original -> new) are subset of the source schema,\n     * new names with rest of the source schema contain no duplicity\n     * @public\n     */\n  eval (): void {\n    if (this.isEvaluated()) {\n      return\n    }\n    const changes: ISToISMap = this.parseChanges(true)\n    const source: Relation = this.subtree.getResult()\n    // check whether all columns to rename are in source relation\n    changes.forEach((value, key) => {\n      if (!source.getColumnNames().includes(key.toString())) {\n        throw ErrorFactory.semanticError(language().semanticErrors.renameNode_absentOriginalColumn,\n                     key.getRange(), key.toString())\n      }\n    })\n    // rename of relational schema\n    const result: Relation = new Relation(source.getName() + '<...>')\n    const toChange: Map<string, SupportedColumnType> = new Map<string, SupportedColumnType>()\n    // in first loop adds unchanged columns only\n    source.forEachColumn((type, name) => {\n      if (changes.has(name)) {\n        toChange.set(name, type)\n      } else {\n        result.addColumn(name, type)\n      }\n    })\n    // in second loop adds changed columns\n    toChange.forEach((type, name) => {\n      // @ts-ignore (changes must contain 'name' key now)\n      if (!result.addColumn(changes.get(name).toString(), type)) {\n        const newName = changes.get(name)\n        throw ErrorFactory.semanticError(language().semanticErrors.renameNode_changeToDuplicit,\n                    this.rename.getRange(), newName ? newName.toString() : '')\n      }\n    })\n    // rename of relation rows\n    source.getRows().forEach(row => {\n      const newRow: Row = new Row(result.getColumns())\n      row.getValues().forEach((value, name) => {\n        const returned = changes.get(name)\n        if (typeof returned === 'undefined') {\n          newRow.addValue(name, value)\n        } else {\n          newRow.addValue(returned.toString(), value)\n        }\n      })\n      result.addRow(newRow)\n    })\n    this.resultRelation = result\n  }\n\n  /**\n     * Evaluates the RA query in this node and its subtree.\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\n     * Otherwise returns the result relation schema (only column names, no rows).\n     * When an error occurs, it is faked to work, and adds it to the errors array.\n     *\n     * Strict expectations: original names in projection pair (original -> new) are subset of the source schema,\n     * new names with rest of the source schema contain no duplicity\n     * Returned schema: if the cursor is not after the arrow '->' returns\n     * (source schema minus originals) union (news whose originals were in source schema),\n     * otherwise returns empty array (does not whisper to what the user should rename)\n     *\n     * @param cursorIndex index of the cursor in original text input {@type number}\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper {@type NodeFakeEvalResult}\n     * @public\n     */\n  fakeEval (cursorIndex: number) {\n    const source = this.subtree.fakeEval(cursorIndex)\n    // checks whether the cursor is in this rename block\n    let whispers = source.whispers\n    if (this.stringRange !== undefined && this.stringRange.start < cursorIndex && cursorIndex <= this.stringRange.end) {\n      whispers = source.result.getColumnNames()\n    }\n    // adds errors from current expression\n    const errors = source.errors\n    const changes: ISToISMap = this.parseChanges(false, errors)\n    // creates relational schema - \"(source minus to-rename) union (renamed existing in source)\"\n    const result: Relation = new Relation(source.result.getName() + '<...>')\n    // in first loop adds source columns which are not in changes.keys\n    source.result.forEachColumn((type, name) => {\n      if (!changes.has(name)) {\n        result.addColumn(name, type)\n      }\n    })\n    // in second loop adds changes.values whose changes.keys are in source\n    const absent: IndexedString[] = []\n    const duplicit: IndexedString[] = []\n    changes.forEach((after, before) => {\n      const beforeStr = before.toString()\n      const afterStr = after.toString()\n      if (!source.result.hasColumn(beforeStr) && !before.isEmpty()) {\n        absent.push(before)\n      }\n      // @ts-ignore source must have beforeStr now\n      else if (!result.addColumn(afterStr, source.result.getColumns().get(beforeStr))) {\n        duplicit.push(after)\n      }\n    })\n    absent.forEach(column => {\n      errors.push(ErrorFactory.semanticError(language().semanticErrors.renameNode_absentOriginalColumn,\n                column.getRange(), column.toString()))\n    })\n    duplicit.forEach(column => {\n      errors.push(ErrorFactory.semanticError(language().semanticErrors.renameNode_changeToDuplicit,\n                column.getRange(), column.toString()))\n    })\n    return { result, whispers, errors }\n  }\n\n  /**\n     * Creates a string with a structure of the RA tree in one line.\n     *\n     * @return string with a structure of the RA tree in one line {@type string}\n     * @public\n     */\n  printInLine (): string {\n    return this.subtree.printInLine() + this.getOperationSymbol()\n  }\n\n  /**\n     * Return the word name of the RA operation of the node.\n     * Example: returns \"Selection\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n  getOperationName (): string {\n    return language().operations.rename\n  }\n\n  /**\n     * Return the symbolic representation of the RA operation of the node.\n     * Example: returns \"(some + expr = 15)\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n  getOperationSymbol (): string {\n    return this.rename.replace(/\\s+/g, ' ')\n  }\n}\n","import { Row } from '../relation/row'\nimport { ColumnContent, SupportedColumnType } from '../relation/columnType'\n\n/**\n * Result of the VETreeNode evaluation.\n * @category VETree\n * @public\n */\nexport interface VEResult {\n  /**\n     * result value\n     * @type ColumnContent\n     * @public\n     */\n  value: ColumnContent\n  /**\n     * result type\n     * @type (SupportedColumnType | \"null\")\n     * @public\n     */\n  type: SupportedColumnType | 'null'\n}\n\n/**\n * Abstract class for value-evaluating nodes producing new values.\n * @category VETree\n * @public\n */\nexport abstract class VETreeNode {\n\n  /**\n     * Evaluates this value-evaluating tree.\n     *\n     * @param source row with values to be used to reference to {@type Row}\n     * @return evaluated value and its type {@type VEResult}\n     * @public\n     */\n  public abstract eval (source: Row): VEResult\n\n  /**\n     * Returns string representation of the node.\n     *\n     * @return string representation of the node {@type string}\n     * @public\n     */\n  public abstract toString (): string\n}\n","import { Row } from '../relation/row'\nimport { VEResult, VETreeNode } from './veTreeNode'\nimport { ErrorFactory } from '../error/errorFactory'\nimport { IndexedString } from '../types/indexedString'\nimport { language } from '../language/language'\n\n/**\n * Enum of types of LogicalOperator class.\n * @category VETree\n * @public\n */\nexport enum LogicalOperatorType {\n  and = 'and',\n  or = 'or',\n  not = 'not',\n}\n\n/**\n * Logical operator chains boolean values and produces new ones.\n * @extends VETreeNode\n * @category VETree\n * @public\n */\nexport class LogicalOperator extends VETreeNode {\n\n  /**\n     * Creates an 'and' logical operator.\n     *\n     * @param operator String representing an 'and' in input (used to printing) {@type IndexedString}\n     * @param left Left subtree evaluating to a boolean value {@type VETreeNode}\n     * @param right Right subtree evaluating to a boolean value {@type VETreeNode}\n     * @return new LogicalOperator instance of and type {@type LogicalOperator}\n     * @public\n     */\n  static and (operator: IndexedString, left: VETreeNode, right: VETreeNode): LogicalOperator {\n    return new LogicalOperator(LogicalOperatorType.and, operator, left, right)\n  }\n\n  /**\n     * Creates an 'or' logical operator.\n     *\n     * @param operator String representing an 'or' in input (used to printing) {@type IndexedString}\n     * @param left Left subtree evaluating to a boolean value {@type VETreeNode}\n     * @param right Right subtree evaluating to a boolean value {@type VETreeNode}\n     * @return new LogicalOperator instance of and type {@type LogicalOperator}\n     * @public\n     */\n  static or (operator: IndexedString, left: VETreeNode, right: VETreeNode): LogicalOperator {\n    return new LogicalOperator(LogicalOperatorType.or, operator, left, right)\n  }\n\n  /**\n     * Creates a 'not' logical operator.\n     *\n     * @param operator String representing a 'not' in input (used to printing) {@type IndexedString}\n     * @param subtree Subtree evaluating to a boolean value {@type VETreeNode}\n     * @return new LogicalOperator instance of and type {@type LogicalOperator}\n     * @public\n     */\n  static not (operator: IndexedString, subtree: VETreeNode): LogicalOperator {\n    return new LogicalOperator(LogicalOperatorType.not, operator, subtree)\n  }\n\n  private constructor (private readonly type: LogicalOperatorType, private readonly operator: IndexedString,\n                        private readonly left: VETreeNode, private readonly right?: VETreeNode) {\n    super()\n  }\n\n  /**\n     * Evaluates recursively subtrees and transforms their boolean results into a new boolean.\n     * If any subtree evaluates to string or number, throws error.\n     *\n     * @param source row with actual values of columns recursively passed to leaf reference nodes {@type Row}\n     * @return boolean comparing left and right subtree values {@type VEResult}\n     * @public\n     */\n  eval (source: Row): { value: boolean, type: 'boolean' } {\n    const leftResult: VEResult = this.left.eval(source)\n    if (leftResult.type !== 'boolean') {\n      throw ErrorFactory.syntaxError(language().syntaxErrors.logicalOperator_leftInputNotBoolean,\n                this.operator.getRange(), this.operator.toString(), leftResult.type)\n    }\n\n    if (this.type === LogicalOperatorType.not) {\n      if (leftResult.value === null) {\n        return { value: false, type: 'boolean' }\n      }\n      return { value: !leftResult.value, type: 'boolean' }\n    } else {\n      // @ts-ignore (in and/or operations right subtree must exist)\n      const rightResult: VEResult = this.right.eval(source)\n      if (rightResult.type !== 'boolean') {\n        throw ErrorFactory.syntaxError(language().syntaxErrors.logicalOperator_rightInputNotBoolean,\n                    this.operator.getRange(), this.operator.toString(), rightResult.type)\n      }\n\n      if (this.type === LogicalOperatorType.and) {\n        if (leftResult.value === null || rightResult.value === null) {\n          return { value: false, type: 'boolean' }\n        }\n        // @ts-ignore (they must be both booleans now)\n        return { value: leftResult.value && rightResult.value, type: 'boolean' }\n      } else /* if (this.type === LogicalOperatorType.or)*/ {\n        if (leftResult.value === null && rightResult.value === null) {\n          return { value: false, type: 'boolean' }\n        }\n        if (leftResult.value === null) {\n          // @ts-ignore (it must be boolean now)\n          return { value: rightResult.value, type: 'boolean' }\n        }\n        if (rightResult.value === null) {\n          // @ts-ignore (it must be boolean now)\n          return { value: leftResult.value, type: 'boolean' }\n        }\n        // @ts-ignore (they must be both booleans now)\n        return { value: leftResult.value || rightResult.value, type: 'boolean' }\n      }\n    }\n  }\n\n  /**\n     * Returns string representation of the node.\n     *\n     * @return string representation of the node {@type string}\n     * @public\n     */\n  toString (): string {\n    if (this.type === LogicalOperatorType.not) {\n      return this.operator.toString() + '(' + this.left.toString() + ')'\n    }\n    // @ts-ignore (in and, or operations right subtree must exist)\n    return '(' + this.left.toString() + ' ' + this.operator.toString() + ' ' + this.right.toString() + ')'\n  }\n}\n","import { Row } from '../relation/row'\nimport { VEResult, VETreeNode } from './veTreeNode'\nimport { ErrorFactory } from '../error/errorFactory'\nimport { language } from '../language/language'\nimport { StartEndPair } from '../types/startEndPair'\n\n/**\n * Enum of types of ComputingOperator class.\n * @category VETree\n * @public\n */\nexport enum ComputingOperatorType {\n  plus = '+',\n  minus = '-',\n  multiplication = '*',\n  division = '/'\n}\n\n/**\n * Comparing operator takes two number values and returns a new computed number.\n * @extends VETreeNode\n * @category VETree\n * @public\n */\nexport class ComputingOperator extends VETreeNode {\n\n  /**\n     * Creates an addition (+) computing operator.\n     *\n     * @param left Left subtree evaluating to a number value {@type VETreeNode}\n     * @param right Right subtree evaluating to a number value {@type VETreeNode}\n     * @param range Range of the operator in the input string to highlight errors {@type StartEndPair?}\n     * @return new ComputingOperator instance of add type {@type ComputingOperator}\n     * @public\n     */\n  static add (left: VETreeNode, right: VETreeNode, range: StartEndPair | undefined): ComputingOperator {\n    return new ComputingOperator(ComputingOperatorType.plus, left, right, range)\n  }\n\n  /**\n     * Creates a deduction (-) computing operator.\n     *\n     * @param left Left subtree evaluating to a number value {@type VETreeNode}\n     * @param right Right subtree evaluating to a number value {@type VETreeNode}\n     * @param range Range of the operator in the input string to highlight errors {@type StartEndPair?}\n     * @return new ComputingOperator instance of deduct type {@type ComputingOperator}\n     * @public\n     */\n  static deduct (left: VETreeNode, right: VETreeNode, range: StartEndPair | undefined): ComputingOperator {\n    return new ComputingOperator(ComputingOperatorType.minus, left, right, range)\n  }\n\n  /**\n     * Creates a multiplication (*) computing operator.\n     *\n     * @param left Left subtree evaluating to a number value {@type VETreeNode}\n     * @param right Right subtree evaluating to a number value {@type VETreeNode}\n     * @param range Range of the operator in the input string to highlight errors {@type StartEndPair?}\n     * @return new ComputingOperator instance of multiply type {@type ComputingOperator}\n     * @public\n     */\n  static multiply (left: VETreeNode, right: VETreeNode, range: StartEndPair | undefined): ComputingOperator {\n    return new ComputingOperator(ComputingOperatorType.multiplication, left, right, range)\n  }\n\n  /**\n     * Creates a division (/) computing operator.\n     *\n     * @param left Left subtree evaluating to a number value {@type VETreeNode}\n     * @param right Right subtree evaluating to a number value {@type VETreeNode}\n     * @param range Range of the operator in the input string to highlight errors {@type StartEndPair?}\n     * @return new ComputingOperator instance of divide type {@type ComputingOperator}\n     * @public\n     */\n  static divide (left: VETreeNode, right: VETreeNode, range: StartEndPair | undefined): ComputingOperator {\n    return new ComputingOperator(ComputingOperatorType.division, left, right, range)\n  }\n\n  private constructor (private readonly type: ComputingOperatorType, private readonly left: VETreeNode,\n                        private readonly right: VETreeNode, private readonly range: StartEndPair | undefined) {\n    super()\n  }\n\n  /**\n     * Evaluates recursively subtrees and transforms their number results into a new number.\n     * If any subtree evaluates to string or boolean, throws error.\n     * If any subtree evaluates to null, returns null.\n     *\n     * @param source row with actual values of columns recursively passed to leaf reference nodes {@type Row}\n     * @return number produced from subtrees with given operation, or null if any subtree returned null {@type VEResult}\n     */\n  eval (source: Row): { value: number | null, type: 'number' } {\n    const leftResult: VEResult = this.left.eval(source)\n    const rightResult: VEResult = this.right.eval(source)\n\n    if (leftResult.type !== 'number' || rightResult.type !== 'number') {\n      throw ErrorFactory.syntaxError(language().syntaxErrors.computingOperator_inputTypesNotNumbers, this.range,\n                this.type, leftResult.type, rightResult.type)\n    }\n\n    if (leftResult.value === null || rightResult.value === null) {\n      return { value: null, type: 'number' }\n    }\n\n    switch (this.type) {\n      case ComputingOperatorType.plus:\n        // @ts-ignore (ensured by first if)\n        return { value: leftResult.value + rightResult.value, type: 'number' }\n      case ComputingOperatorType.minus:\n        // @ts-ignore (ensured by first if)\n        return { value: leftResult.value - rightResult.value, type: 'number' }\n      case ComputingOperatorType.multiplication:\n        // @ts-ignore (ensured by first if)\n        return { value: leftResult.value * rightResult.value, type: 'number' }\n      case ComputingOperatorType.division:\n        // @ts-ignore (ensured by first if)\n        return { value: leftResult.value / rightResult.value, type: 'number' }\n    }\n  }\n\n  /**\n     * Returns string representation of the node.\n     *\n     * @return string representation of the node {@type string}\n     * @public\n     */\n  toString (): string {\n    return '(' + this.left.toString() + ' ' + this.type + ' ' + this.right.toString() + ')'\n  }\n}\n","import { Row } from '../relation/row'\nimport { VEResult, VETreeNode } from './veTreeNode'\nimport { ColumnContent, SupportedColumnType } from '../relation/columnType'\n\n/**\n * Class storing literal value of number, string or null type.\n * @extends VETreeNode\n * @category VETree\n * @public\n */\nexport class LiteralValue extends VETreeNode {\n\n  /**\n     * Creates a literal storing given value.\n     *\n     * @param value value to be returned by eval(...) function {@type ColumnContent}\n     * @param type type of the literal value {@type (SupportedColumnType | \"null\")}\n     */\n  constructor (private readonly value: ColumnContent, private readonly type: SupportedColumnType | 'null') {\n    super()\n  }\n\n  /**\n     * Returns stored value.\n     *\n     * @param source row with actual values of columns (note: not used in literals) {@type Row}\n     * @return stored value and its type {@type VEResult}\n     * @public\n     */\n  eval (source: Row): VEResult {\n    return { value: this.value, type: this.type }\n  }\n\n  /**\n     * Returns string representation of the node.\n     *\n     * @return string representation of the node {@type string}\n     * @public\n     */\n  toString (): string {\n    if (this.value === null) {\n      return 'null'\n    }\n    return this.value.toString()\n  }\n}\n","import { Row } from '../relation/row'\nimport { VETreeNode } from './veTreeNode'\nimport { ColumnContent, SupportedColumnType } from '../relation/columnType'\nimport { ErrorFactory } from '../error/errorFactory'\nimport { IndexedString } from '../types/indexedString'\nimport { language } from '../language/language'\n\n/**\n * Class storing reference to a column.\n * @extends VETreeNode\n * @category VETree\n * @public\n */\nexport class ReferenceValue extends VETreeNode {\n\n  /**\n     * Creates a reference to the given column.\n     *\n     * @param columnName name of the referenced column {@type IndexedString}\n     * @public\n     */\n  constructor (private readonly columnName: IndexedString) {\n    super()\n  }\n\n  /**\n     * Returns value (expected to be string, number, or boolean) of the referenced column from given source row.\n     *\n     * @param source row with actual values of columns {@type Row}\n     * @return referenced value and its type {@type VEResult}\n     * @public\n     */\n  eval (source: Row): { value: ColumnContent, type: SupportedColumnType } {\n    const value: ColumnContent | undefined = source.getValue(this.columnName.toString())\n    const type: SupportedColumnType | undefined = source.getType(this.columnName.toString())\n    if (value === undefined || type === undefined) {\n      throw ErrorFactory.semanticError(language().semanticErrors.referenceValue_absentColumn,\n                this.columnName.getRange(), this.columnName.toString(), [...source.getColumnNames()].join(', '))\n    }\n    return { value: value, type: type }\n  }\n\n  /**\n     * Returns string representation of the node.\n     *\n     * @return string representation of the node {@type string}\n     * @public\n     */\n  toString (): string {\n    return this.columnName.toString()\n  }\n}\n","import { ComparingOperatorType } from '../vetree/comparingOperator'\nimport { ColumnContent, SupportedColumnType } from '../relation/columnType'\nimport { IndexedString } from '../types/indexedString'\nimport { StartEndPair } from '../types/startEndPair'\n\n/**\n * Precedence value for all token types.\n */\nconst precedenceNot = 50\nconst precedenceMulDiv = 30\nconst precedencePlusMinus = 25\nconst precedenceComparison = 20\nconst precedenceAnd = 10\nconst precedenceOr = 5\n\n/**\n * Tokens used for parsing of string expression to BooleanEvaluating tree.\n */\nexport abstract class ValueToken {\n  protected constructor (public readonly str: IndexedString) {}\n\n  /**\n     * Gets token start and end index in the text (if the token has IndexedString representation) or undefined.\n     */\n  getRange (): StartEndPair | undefined {\n    return this.str.getRange()\n  }\n}\n\nexport abstract class OperatorToken extends ValueToken {\n  protected constructor (str: IndexedString, readonly precedence: number) {\n    super(str)\n  }\n}\n\nexport class LogicalNotToken extends OperatorToken {\n  constructor (operator: IndexedString) {\n    super(operator, precedenceNot)\n  }\n}\n\nexport class LogicalAndToken extends OperatorToken {\n  constructor (operator: IndexedString) {\n    super(operator, precedenceAnd)\n  }\n}\n\nexport class LogicalOrToken extends OperatorToken {\n  constructor (operator: IndexedString) {\n    super(operator, precedenceOr)\n  }\n}\n\nexport class ComputingMultiplicationToken extends OperatorToken {\n  constructor (operator: IndexedString) {\n    super(operator, precedenceMulDiv)\n  }\n}\n\nexport class ComputingDivisionToken extends OperatorToken {\n  constructor (operator: IndexedString) {\n    super(operator, precedenceMulDiv)\n  }\n}\n\nexport class ComputingPlusToken extends OperatorToken {\n  constructor (operator: IndexedString) {\n    super(operator, precedencePlusMinus)\n  }\n}\n\nexport class ComputingMinusToken extends OperatorToken {\n  constructor (operator: IndexedString) {\n    super(operator, precedencePlusMinus)\n  }\n}\n\nexport class ComparingToken extends OperatorToken {\n  constructor (readonly type: ComparingOperatorType, operator: IndexedString) {\n    super(operator, precedenceComparison)\n  }\n}\n\nexport abstract class ParenthesisToken extends ValueToken {\n  protected constructor (operator: IndexedString) {\n    super(operator)\n  }\n}\n\nexport class OpeningParentheses extends ParenthesisToken {\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor (operator: IndexedString) {\n    super(operator)\n  }\n}\n\nexport class ClosingParentheses extends ParenthesisToken {\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor (operator: IndexedString) {\n    super(operator)\n  }\n}\n\nexport class LiteralToken extends ValueToken {\n  constructor (str: IndexedString, readonly value: ColumnContent, readonly type: SupportedColumnType | 'null') {\n    super(str)\n  }\n}\n\nexport class ReferenceToken extends ValueToken {\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor (columnName: IndexedString) {\n    super(columnName)\n  }\n}\n","import { StringUtils } from '../utils/stringUtils'\nimport { ComparingOperator, ComparingOperatorType } from '../vetree/comparingOperator'\nimport { LogicalOperator } from '../vetree/logicalOperator'\nimport { LiteralValue } from '../vetree/literalValue'\nimport { ReferenceValue } from '../vetree/referenceValue'\nimport { ComputingOperator } from '../vetree/computingOperator'\nimport {\n  ClosingParentheses,\n  ComparingToken,\n  ComputingDivisionToken,\n  ComputingMinusToken,\n  ComputingMultiplicationToken,\n  ComputingPlusToken,\n  LiteralToken,\n  LogicalAndToken,\n  LogicalNotToken,\n  LogicalOrToken,\n  OpeningParentheses,\n  OperatorToken,\n  ParenthesisToken,\n  ReferenceToken,\n  ValueToken,\n} from './valueTokens'\nimport { VETreeNode } from '../vetree/veTreeNode'\nimport { IndexedString } from '../types/indexedString'\nimport { IndexedStringUtils } from '../utils/indexedStringUtils'\nimport { ErrorWithTextRange, insertRangeIfUndefined } from '../error/errorWithTextRange'\nimport { ErrorFactory } from '../error/errorFactory'\nimport { RASyntaxError } from '../error/raSyntaxError'\nimport { language } from '../language/language'\n\n/**\n * Parser of the logic-algebraic subexpressions in relational algebra expressions.\n * @category Expression\n * @public\n */\nexport class ValueParser {\n\n  /**\n     * Parses given string infix boolean and algebraic expression into a value-evaluating tree and returns the tree.\n     * Uses Shunting-yard algorithm (first, it transforms the string into reverse polish notation).\n     * Supported expressions:\n     * - logical: and (&&, &), or (||, |), not (!, ~)\n     * - computing: addition (+), deduction (-), multiplication (*), division (/)\n     * - comparing: equal (==, =), non-equal (!=, <>), less (<), more (>), less-or-equal (<=), more-or-equal (>=)\n     * - literals: numbers (1, 5.02, etc.), strings (\"String\", \"With inner \\\" symbol\", etc.), nulls (null),\n     * booleans (true, false)\n     * - column references (ColumnNameAsStringWithoutQuotes, Id, etc.)\n     *\n     * @param str infix boolean and algebraic expression to be parsed {@type IndexedString}\n     * @param nullValuesSupport whether null values are supported {@type boolean}\n     * @return VETreeNode root of the evaluation tree {@type VETreeNode}\n     * @public\n     */\n  static parse (str: IndexedString, nullValuesSupport: boolean): VETreeNode {\n    let tokens: ValueToken[] = ValueParser.parseTokens(str, nullValuesSupport, true)\n    this.assertValidInfixTokens(tokens, true)\n    tokens = this.simplify(tokens)\n    try {\n      const rpn: ValueToken[] = ValueParser.toRPN(tokens)\n      return ValueParser.rpnToVETree(rpn)\n    } catch (err) {\n      throw insertRangeIfUndefined(err, str.getRange())\n    }\n  }\n\n  /**\n     * Parses given string infix boolean and algebraic expression and returns errors in it.\n     * For supported operations see {@link parse}.\n     *\n     * @param str infix boolean and algebraic expression to be parsed {@type IndexedString}\n     * @param nullValuesSupport whether null values are supported {@type boolean}\n     * @param columns available source column names {@type string[]}\n     * @return detected errors {@type ErrorWithTextRange[]}\n     * @public\n     */\n  static fakeParse (str: IndexedString, nullValuesSupport: boolean, columns: string[]): ErrorWithTextRange[] {\n    const errors: ErrorWithTextRange[] = []\n    const tokens: ValueToken[] = ValueParser.parseTokens(str, nullValuesSupport, false, errors)\n    tokens.forEach(token => {\n      if (token instanceof ReferenceToken && !columns.includes(token.str.toString())) {\n        errors.push(ErrorFactory.semanticError(language().semanticErrors.referenceValue_absentColumn,\n                    token.str.getRange(), token.str.toString(), columns.join(', ')))\n      }\n    })\n    this.assertValidInfixTokens(tokens, false, errors)\n    return errors\n  }\n\n  /**\n     * Parses given string infix boolean and algebraic expression into an array of Tokens.\n     * Tokens are returned infix (in order parsed from string).\n     * If doThrow is true, found errors are thrown. Otherwise, they are added in errors array and ignored.\n     *\n     * @param str infix boolean and algebraic expression to be parsed\n     * @param nullValuesSupport whether null values are supported\n     * @param doThrow true if errors should be thrown\n     * @param errors array for storing not thrown errors\n     * @return infix array of parsed Tokens\n     */\n  static parseTokens (str: IndexedString, nullValuesSupport: boolean, doThrow: boolean,\n                              errors: ErrorWithTextRange[] = []): ValueToken[] {\n    const handleError = (error: RASyntaxError) => {\n      if (doThrow) {\n        throw error\n      } else {\n        errors.push(error)\n      }\n    }\n    let rest: IndexedString = str.trim()\n    if (rest.isEmpty()) {\n      handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_emptyInput, undefined))\n    }\n    const tokens: ValueToken[] = []\n    while (!rest.isEmpty()) {\n      // PARENTHESES\n      if (rest.startsWith('(')) {\n        tokens.push(new OpeningParentheses(rest.slice(0, 1)))\n        rest = rest.slice(1)\n      } else if (rest.startsWith(')')) {\n        tokens.push(new ClosingParentheses(rest.slice(0, 1)))\n        rest = rest.slice(1)\n      }\n      // COMPUTING OPERATORS\n      else if (rest.startsWith('+')) {\n        tokens.push(new ComputingPlusToken(rest.slice(0, 1)))\n        rest = rest.slice(1)\n      } else if (rest.startsWith('-')) {\n        tokens.push(new ComputingMinusToken(rest.slice(0, 1)))\n        rest = rest.slice(1)\n      } else if (rest.startsWith('*')) {\n        tokens.push(new ComputingMultiplicationToken(rest.slice(0, 1)))\n        rest = rest.slice(1)\n      } else if (rest.startsWith('/')) {\n        tokens.push(new ComputingDivisionToken(rest.slice(0, 1)))\n        rest = rest.slice(1)\n      }\n      // COMPARING OPERATORS\n      else if (rest.startsWith('==')) {\n        tokens.push(new ComparingToken(ComparingOperatorType.equal, rest.slice(0, 2)))\n        rest = rest.slice(2)\n      } else if (rest.startsWith('=')) {     // NOTE: needs to be after '==' check\n        tokens.push(new ComparingToken(ComparingOperatorType.equal, rest.slice(0, 1)))\n        rest = rest.slice(1)\n      } else if (rest.startsWith('!=')) {\n        tokens.push(new ComparingToken(ComparingOperatorType.nonEqual, rest.slice(0, 2)))\n        rest = rest.slice(2)\n      } else if (rest.startsWith('<>')) {\n        tokens.push(new ComparingToken(ComparingOperatorType.nonEqual, rest.slice(0, 2)))\n        rest = rest.slice(2)\n      } else if (rest.startsWith('<=')) {\n        tokens.push(new ComparingToken(ComparingOperatorType.lessOrEqual, rest.slice(0, 2)))\n        rest = rest.slice(2)\n      } else if (rest.startsWith('>=')) {\n        tokens.push(new ComparingToken(ComparingOperatorType.moreOrEqual, rest.slice(0, 2)))\n        rest = rest.slice(2)\n      } else if (rest.startsWith('<')) {\n        tokens.push(new ComparingToken(ComparingOperatorType.less, rest.slice(0, 1)))\n        rest = rest.slice(1)\n      } else if (rest.startsWith('>')) {\n        tokens.push(new ComparingToken(ComparingOperatorType.more, rest.slice(0, 1)))\n        rest = rest.slice(1)\n      }\n      // LOGICAL OPERATORS\n      else if (rest.startsWith('!') || rest.startsWith('~')\n                || rest.startsWith('\\u00ac')) { // NOTE: needs to be after '!=' check\n        tokens.push(new LogicalNotToken(rest.slice(0, 1)))\n        rest = rest.slice(1)\n      } else if (rest.startsWith('&&')) {\n        tokens.push(new LogicalAndToken(rest.slice(0, 2)))\n        rest = rest.slice(2)\n      } else if (rest.startsWith('&') || rest.startsWith('\\u2227')) { // NOTE: needs to be after '&&' check\n        tokens.push(new LogicalAndToken(rest.slice(0, 1)))\n        rest = rest.slice(1)\n      } else if (rest.startsWith('||')) {\n        tokens.push(new LogicalOrToken(rest.slice(0, 2)))\n        rest = rest.slice(2)\n      } else if (rest.startsWith('|') || rest.startsWith('\\u2228')) { // NOTE: needs to be after '||' check\n        tokens.push(new LogicalOrToken(rest.slice(0, 1)))\n        rest = rest.slice(1)\n      }\n      // LITERALS\n      else if (rest.startsWith('\"')) {\n        const split = IndexedStringUtils.nextQuotedString(rest)\n        if (split.error !== undefined) {\n          handleError(split.error)\n        }\n        const end = split.first.length() > 1 ? -1 : undefined\n        const str = split.first.slice(1, end)\n        tokens.push(new LiteralToken(str, str.toString(), 'string'))\n        rest = split.second\n      } else if (StringUtils.isDigit(rest.charAt(0))) {\n        const split = IndexedStringUtils.nextNumber(rest)\n        tokens.push(new LiteralToken(split.first, Number(split.first.toString()), 'number'))\n        rest = split.second\n      } else if (rest.startsWith('null')) {\n        if (!nullValuesSupport) {\n          handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_unsupportedNull,\n                        rest.slice(0, 4).getRange()))\n        }\n        tokens.push(new LiteralToken(rest.slice(0, 4), null, 'null'))\n        rest = rest.slice(4)\n      } else if (rest.startsWith('true') || rest.startsWith('True') || rest.startsWith('TRUE')) {\n        tokens.push(new LiteralToken(rest.slice(0, 4), true, 'boolean'))\n        rest = rest.slice(4)\n      } else if (rest.startsWith('false') || rest.startsWith('False') || rest.startsWith('FALSE')) {\n        tokens.push(new LiteralToken(rest.slice(0, 5), false, 'boolean'))\n        rest = rest.slice(5)\n      }\n      // COLUMN REFERENCE\n      else if (StringUtils.isLetter(rest.charAt(0)) || rest.charAt(0) === '_') {\n        const split = IndexedStringUtils.nextName(rest)\n        tokens.push(new ReferenceToken(split.first))\n        rest = split.second\n      }\n      // UNEXPECTED PART\n      else {\n        const split = IndexedStringUtils.nextNonWhitespacePart(rest)\n        handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_unexpectedPart,\n                    split.first.getRange(), split.first.toString()))\n        rest = rest.slice(split.first.length())\n      }\n      rest = rest.trim()\n    }\n    return tokens\n  }\n\n  /**\n     * It checks whether all adjacent pairs of tokens are possible and if the array start and end are valid\n     * (e.i., it starts with '(', literal, column reference or '!' and it ends with ')', literal or column reference).\n     * If doThrow is true, found errors are thrown. Otherwise, they are added in errors array and ignored.\n     */\n  static assertValidInfixTokens (tokens: ValueToken[], doThrow: boolean, errors: ErrorWithTextRange[] = []) {\n    if (tokens.length === 0) {\n      return\n    }\n\n    const handleError = (error: RASyntaxError) => {\n      if (doThrow) {\n        throw error\n      } else {\n        errors.push(error)\n      }\n    }\n\n    // checks start of an array: it must start with '(', literal, reference or '!'\n    // it cannot start with binary operator or ')'\n    if ((tokens[0] instanceof ClosingParentheses) || ((tokens[0] instanceof OperatorToken) && !(tokens[0] instanceof LogicalNotToken))) {\n      handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_invalidStart,\n                tokens[0].getRange(), tokens[0].str.toString()))\n    }\n    // checks end of an array: it must end with ')', literal or reference\n    // it cannot end with operator or '('\n    if ((tokens[tokens.length - 1] instanceof OpeningParentheses) || (tokens[tokens.length - 1] instanceof OperatorToken)) {\n      handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_invalidEnd,\n                tokens[tokens.length - 1].getRange(), tokens[tokens.length - 1].str.toString()))\n    }\n    // checks adjacent pairs of tokens\n    let i2 = 1\n    while (i2 < tokens.length) {\n      const token1: ValueToken = tokens[i2 - 1]\n      const token2: ValueToken = tokens[i2]\n      ++i2\n\n      // valid predecessors: operator or '('\n      // invalid predecessors: literal, reference or ')'\n      if (token2 instanceof LiteralToken) {\n        if (token1 instanceof LiteralToken) {\n          handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_literalAfterLiteral,\n                        token2.getRange(), token2.str.toString(), token1.str.toString()))\n        }\n        if (token1 instanceof ReferenceToken) {\n          handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_literalAfterReference,\n                        token2.getRange(), token2.str.toString(), token1.str.toString()))\n        }\n        if (token1 instanceof ClosingParentheses) {\n          handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_literalAfterClosing,\n                        token2.getRange(), token2.str.toString()))\n        }\n      }\n      // valid predecessors: operator or '('\n      // invalid predecessors: literal, reference or ')'\n      else if (token2 instanceof ReferenceToken) {\n        if (token1 instanceof LiteralToken) {\n          handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_referenceAfterLiteral,\n                        token2.getRange(), token2.str.toString(), token1.str.toString()))\n        }\n        if (token1 instanceof ReferenceToken) {\n          handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_referenceAfterReference,\n                        token2.getRange(), token2.str.toString(), token1.str.toString()))\n        }\n        if (token1 instanceof ClosingParentheses) {\n          handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_referenceAfterClosing,\n                        token2.getRange(), token2.str.toString()))\n        }\n      }\n      // valid predecessors: operator or '('\n      // invalid predecessors: literal, reference or ')'\n      else if (token2 instanceof LogicalNotToken) {\n        if (token1 instanceof LiteralToken) {\n          handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_notAfterLiteral,\n                        token2.getRange(), token2.str.toString(), token1.str.toString()))\n        }\n        if (token1 instanceof ReferenceToken) {\n          handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_notAfterReference,\n                        token2.getRange(), token2.str.toString(), token1.str.toString()))\n        }\n        if (token1 instanceof ClosingParentheses) {\n          handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_notAfterClosing,\n                        token2.getRange(), token2.str.toString()))\n        }\n      }\n      // valid predecessors: literal, reference or ')'\n      // invalid predecessors: operator or '('\n      else if (token2 instanceof OperatorToken /* only binary (without LogicalNotToken) */) {\n        if (token1 instanceof OperatorToken) {\n          handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_binaryAfterOperator,\n                        token2.getRange(), token2.str.toString(), token1.str.toString()))\n        }\n        if (token1 instanceof OpeningParentheses) {\n          handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_binaryAfterOpening,\n                        token2.getRange(), token2.str.toString()))\n        }\n      }\n      // valid predecessors: operator or '('\n      // invalid predecessors: literal, reference or ')'\n      else if (token2 instanceof OpeningParentheses) {\n        if (token1 instanceof LiteralToken) {\n          handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_openingAfterLiteral,\n                        token2.getRange(), token1.str.toString()))\n        }\n        if (token1 instanceof ReferenceToken) {\n          handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_openingAfterReference,\n                        token2.getRange(), token1.str.toString()))\n        }\n        if (token1 instanceof ClosingParentheses) {\n          handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_openingAfterClosing,\n                        token2.getRange()))\n        }\n      }\n      // valid predecessors: literal or reference\n      // invalid predecessors: operator, '(' or ')'\n      else if (token2 instanceof ClosingParentheses) {\n        if (token1 instanceof OperatorToken) {\n          handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_closingAfterOperator,\n                        token2.getRange(), token1.str.toString()))\n        }\n        if (token1 instanceof OpeningParentheses) {\n          handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_closingAfterOpening,\n                        token2.getRange()))\n        }\n      }\n    }\n  }\n\n  /**\n     * Simplifies given token array in infix form. That means all groups of LogicalNotTokens ('!') are reduced to 1 or 0\n     * tokens (\"!\" => \"!\", \"!!\" => \"\", \"!!!\" => \"!\", \"!!!!\" => \"\", ...).\n     *\n     * @param tokens tokens to simplify\n     */\n  static simplify (tokens: ValueToken[]): ValueToken[] {\n    const notIndexes: number[] = []\n    const indexesToRemove: Set<number> = new Set<number>()\n    // finds indexes in tokens where '!'s are\n    tokens.forEach((token, i) => {\n      if (token instanceof LogicalNotToken) {\n        notIndexes.push(i)\n      }\n    })\n    for (let i = 1; i < notIndexes.length; ++i) {\n      // if there is \"x - 1\" and \"x\" next to each other, adds them to remove\n      if (notIndexes[i - 1] + 1 === notIndexes[i]) {\n        indexesToRemove.add(notIndexes[i - 1])\n        indexesToRemove.add(notIndexes[i])\n        notIndexes[i] = NaN // sets to NaN to not remove possible third '!' in a row\n      }\n    }\n    if (indexesToRemove.size === 0) {\n      return tokens\n    }\n    return tokens.filter((t, i) => !indexesToRemove.has(i))\n  }\n\n  /**\n     * Transforms given infix boolean and algebraic expression into postfix (reverse polish) form.\n     *\n     * @param tokens infix boolean and algebraic expression as Token array\n     * @return postfix (reverse polish) form of given array\n     */\n  static toRPN (tokens: ValueToken[]): ValueToken[] {\n    const rpnQueue: ValueToken[] = []\n    const operatorsStack: Array<OperatorToken | ParenthesisToken> = []\n    tokens.forEach(token => {\n      if (token instanceof LiteralToken || token instanceof ReferenceToken) {\n        rpnQueue.push(token)\n      } else if (token instanceof OperatorToken) {\n        while (operatorsStack.length > 0 && operatorsStack[operatorsStack.length - 1] instanceof OperatorToken) {\n          // @ts-ignore (token must be of OperatorToken class)\n          const other: OperatorToken = operatorsStack[operatorsStack.length - 1]\n          // all used operators have left associativity\n          if (token.precedence <= other.precedence) {\n            // @ts-ignore (token must be present)\n            rpnQueue.push(operatorsStack.pop())\n          } else {\n            break\n          }\n        }\n        operatorsStack.push(token)\n      } else if (token instanceof OpeningParentheses) {\n        operatorsStack.push(token)\n      } else if (token instanceof ClosingParentheses) {\n        while (true) {\n          if (operatorsStack.length === 0) {\n            throw ErrorFactory.syntaxError(language().syntaxErrors.valueParser_missingOpeningParenthesis,\n                            undefined)\n          }\n          if (operatorsStack[operatorsStack.length - 1] instanceof OpeningParentheses) {\n            operatorsStack.pop()\n            break\n          }\n          // @ts-ignore (token must be present)\n          rpnQueue.push(operatorsStack.pop())\n        }\n      }\n    })\n    while (operatorsStack.length > 0) {\n      // @ts-ignore (token must be present)\n      const curToken: ValueToken = operatorsStack.pop()\n      if (curToken instanceof OpeningParentheses) {\n        throw ErrorFactory.syntaxError(language().syntaxErrors.valueParser_missingClosingParenthesis,\n                    undefined)\n      } else {\n        rpnQueue.push(curToken)\n      }\n    }\n    return rpnQueue\n  }\n\n  /**\n     * Creates a value-evaluating tree from the given array of tokens in reverse polish form.\n     * Wraps recursive function rpnToVETreeRecursive(tokens), when not all tokens are used, throws error.\n     *\n     * @param tokens value-evaluating expression in reverse polish form\n     * @return VETreeNode tree (its root)\n     */\n  static rpnToVETree (tokens: ValueToken[]): VETreeNode {\n    const ret: VETreeNode = this.rpnToVETreeRecursive(tokens)\n    // not all tokens were used\n    if (tokens.length > 0) {\n      throw ErrorFactory.syntaxError(language().syntaxErrors.valueParser_invalidExpression, undefined)\n    }\n    return ret\n  }\n\n  /**\n     * Creates a value-evaluating tree from the given array of tokens in reverse polish form.\n     *\n     * @param tokens value-evaluating expression in reverse polish form\n     * @return VETreeNode tree (its root)\n     */\n  static rpnToVETreeRecursive (tokens: ValueToken[]): VETreeNode {\n    if (tokens.length === 0) {\n      throw ErrorFactory.syntaxError(language().syntaxErrors.valueParser_invalidExpression, undefined)\n    }\n    // @ts-ignore (there must be a token)\n    const token: ValueToken = tokens.pop()\n    if (token instanceof LogicalNotToken) {\n      const subtree: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens)\n      return LogicalOperator.not(token.str, subtree)\n    }\n    if (token instanceof LogicalAndToken) {\n      const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens)\n      const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens)\n      return LogicalOperator.and(token.str, left, right)\n    }\n    if (token instanceof LogicalOrToken) {\n      const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens)\n      const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens)\n      return LogicalOperator.or(token.str, left, right)\n    }\n    if (token instanceof ComparingToken) {\n      const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens)\n      const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens)\n      return new ComparingOperator(token.type, token.str, left, right)\n    }\n    if (token instanceof LiteralToken) {\n      return new LiteralValue(token.value, token.type)\n    }\n    if (token instanceof ReferenceToken) {\n      return new ReferenceValue(token.str)\n    }\n    if (token instanceof ComputingPlusToken) {\n      const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens)\n      const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens)\n      return ComputingOperator.add(left, right, token.getRange())\n    }\n    if (token instanceof ComputingMinusToken) {\n      const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens)\n      const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens)\n      return ComputingOperator.deduct(left, right, token.getRange())\n    }\n    if (token instanceof ComputingMultiplicationToken) {\n      const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens)\n      const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens)\n      return ComputingOperator.multiply(left, right, token.getRange())\n    }\n    if (token instanceof ComputingDivisionToken) {\n      const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens)\n      const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens)\n      return ComputingOperator.divide(left, right, token.getRange())\n    }\n    // should never happen\n    throw ErrorFactory.codeError(language().codeErrors.valueParser_unexpectedToken, JSON.stringify(token))\n  }\n}\n","import { NodeFakeEvalResult, RATreeNode } from './raTreeNode'\nimport { Relation } from '../relation/relation'\n\n/**\n * Classes extending binary node.\n * @category RATree\n * @public\n */\nexport type BinaryNodeClass = 'left antijoin' | 'right antijoin' | 'cartesian product' | 'division' | 'natural join'\n| 'left outer join' | 'right outer join' | 'full outer join' | 'left semijoin' | 'right semijoin' | 'union'\n| 'intersection' | 'difference' | 'theta join' | 'left theta semijoin' | 'right theta semijoin'\n\n/**\n * Abstract node of the relational algebra syntactic tree with two subtrees.\n * @extends RATreeNode\n * @category RATree\n * @public\n */\nexport abstract class BinaryNode extends RATreeNode {\n\n  protected leftSubtree: RATreeNode\n  protected rightSubtree: RATreeNode\n\n  /**\n     * Creates a new BinaryNode.\n     *\n     * @param left left subtree {@type RATreeNode}\n     * @param right right subtree {@type RATreeNode}\n     * @public\n     */\n  protected constructor (left: RATreeNode, right: RATreeNode) {\n    super()\n    this.leftSubtree = left\n    this.rightSubtree = right\n  }\n\n  /**\n     * Returns left subtree of the binary node.\n     * @return left subtree {@type RATreeNode}\n     * @public\n     */\n  getLeftSubtree (): RATreeNode {\n    return this.leftSubtree\n  }\n\n  /**\n     * Returns right subtree of the binary node.\n     * @return right subtree {@type RATreeNode}\n     * @public\n     */\n  getRightSubtree (): RATreeNode {\n    return this.rightSubtree\n  }\n\n  /**\n     * Fake evaluates left and right subtrees of the current not-parametrized binary node.\n     * Returns new simple faked schema with empty \"\" name:\n     * - type = union: returns union of source schemas\n     * - type = left: returns left source schema\n     * - type = right: returns right source schema\n     *\n     * @param cursorIndex index of the cursor in original text input {@type number}\n     * @param type type of the returned relational schema {@type (\"union\" | \"left\" | \"right\")}\n     * @return fake evaluation information {@type NodeFakeEvalResult}\n     * @public\n     */\n  protected fakeEvalBinary (cursorIndex: number, type: 'union' | 'left' | 'right'): NodeFakeEvalResult {\n    // evaluates the subtrees\n    const left = this.leftSubtree.fakeEval(cursorIndex)\n    const right = this.rightSubtree.fakeEval(cursorIndex)\n    // creates return relation\n    const result: Relation = new Relation('Binary')\n    if (type === 'left' || type === 'union') {\n      left.result.forEachColumn((type, name) => result.addColumn(name, type))\n    }\n    if (type === 'right' || type === 'union') {\n      right.result.forEachColumn((type, name) => result.addColumn(name, type))\n    }\n    left.errors.push(...right.errors)\n    return {\n      result,\n      whispers: left.whispers.length !== 0 ? left.whispers : right.whispers,\n      errors: left.errors,\n    }\n  }\n}\n","import { RATreeNode } from './raTreeNode'\nimport { UnaryNode } from './unaryNode'\nimport { BinaryNode } from './binaryNode'\nimport { IndexedString } from '../types/indexedString'\nimport { StartEndPair } from '../types/startEndPair'\n\n\n/**\n * Finds the root in the given tree with the given index with respect to depth first search. Root has index 0.\n *\n * @param root root of the searched tree {@type RATreeNode}\n * @param index index to be found {@type number}\n * @return found root with given index or null if not found {@type RATreeNode?}\n * @category RATree\n * @public\n */\nexport function depthSearch (root: RATreeNode, index: number): RATreeNode | null {\n  let i = 0\n  const findIndexInTree = (node: RATreeNode): RATreeNode | null => {\n    // wanted index found\n    if (i === index) {\n      return node\n    }\n    i++\n    if (node instanceof UnaryNode) {\n      return findIndexInTree(node.getSubtree())\n    }\n    if (node instanceof BinaryNode) {\n      const leftSearch = findIndexInTree(node.getLeftSubtree())\n      if (leftSearch === null) {\n        return findIndexInTree(node.getRightSubtree())\n      }\n      return leftSearch\n    }\n    // end of the branch without the result\n    return null\n  }\n  return findIndexInTree(root)\n}\n\n/**\n * Computes depth of the tree. One node has depth 0.\n *\n * @param root root of the tree to compute the depth for {@type RATreeNode}\n * @return tree depth {@type number}\n * @category RATree\n * @public\n */\nexport function getTreeDepth (root: RATreeNode): number {\n  if (root instanceof BinaryNode) {\n    const left: number = getTreeDepth(root.getLeftSubtree())\n    const right: number = getTreeDepth(root.getRightSubtree())\n    return Math.max(left, right) + 1\n  }\n  if (root instanceof UnaryNode) {\n    return getTreeDepth(root.getSubtree()) + 1\n  }\n  return 0\n}\n\n/**\n * Returns true if the given cursor position is in the given range, it is not inside quotes, and the character at the\n * cursor position is present (i.e., was not removed as comment).\n * Note: given range is expected to be computed from given string.\n *\n * @param cursor index of the cursor {@type number}\n * @param range range of the string {@type StartEndPair?}\n * @param str string to search in {@type IndexedString}\n * @return true if the given cursor position is in the given range, it is not inside quotes, and the character at the\n * cursor position is present {@type boolean}\n * @category RATree\n * @public\n */\nexport function isInRangeAndNotInQuotes (cursor: number, range: StartEndPair | undefined, str: IndexedString): boolean {\n  if (range !== undefined && range.start < cursor && cursor <= range.end) {\n    const len = range.end - range.start\n    const s = str.toString()\n    const cursorIndexInStr = cursor - range.start\n    let insideQuotes = false\n    let backslashes = 0\n    for (let i = 0; i < len; ++i) {\n      const curChar = s.charAt(i)\n      // quotes found\n      if (curChar === '\"' && (backslashes % 2) === 0) {\n        insideQuotes = !insideQuotes\n      }\n      if (insideQuotes && curChar === '\\\\') {\n        ++backslashes\n      } else {\n        backslashes = 0\n      }\n      if (i === cursorIndexInStr - 1) {\n        // when the cursor was reached, returns true, if it is not in quotes and the position is present (was not removed as comment)\n        return !insideQuotes && str.getChars().some(c => c.index === cursor - 1)\n      }\n    }\n    console.warn('isInRangeAndNotInQuotes outside range')\n  }\n  return false\n}\n","import { UnaryNode } from './unaryNode'\nimport { RATreeNode } from './raTreeNode'\nimport { Relation } from '../relation/relation'\nimport { VEResult, VETreeNode } from '../vetree/veTreeNode'\nimport { IndexedString } from '../types/indexedString'\nimport { ValueParser } from '../expression/valueParser'\nimport { ErrorFactory } from '../error/errorFactory'\nimport { insertRangeIfUndefined } from '../error/errorWithTextRange'\nimport { isInRangeAndNotInQuotes } from './raTreeTools'\nimport { language } from '../language/language'\nimport { StartEndPair } from '../types/startEndPair'\n\n/**\n * Selection node of the relational algebra syntactic tree.\n * @extends UnaryNode\n * @category RATree\n * @public\n */\nexport class SelectionNode extends UnaryNode {\n\n  private readonly selection: IndexedString\n  private readonly stringRange: StartEndPair | undefined\n  private readonly nullValuesSupport: boolean\n\n  /**\n     * Creates a new SelectionNode.\n     * Expects the selection string to start with '(' and end with ')'.\n     *\n     * @param selection logic-algebraic expression {@type IndexedString}\n     * @param subtree source subtree for renaming {@type RATreeNode}\n     * @param nullValuesSupport whether null values are supported {@type boolean}\n     * @public\n     */\n  constructor (selection: IndexedString, subtree: RATreeNode, nullValuesSupport: boolean) {\n    super(subtree)\n    this.selection = selection\n    this.stringRange = selection.getRange()\n    this.nullValuesSupport = nullValuesSupport\n  }\n\n  /**\n     * Evaluates the RA query in this node and its subtree.\n     * After successful call, this.resultRelation must be set to valid Relation.\n     * Expectations: condition is valid expression which evaluates to boolean\n     * @public\n     */\n  eval (): void {\n    if (this.isEvaluated()) {\n      return\n    }\n\n    let boolExpr: VETreeNode\n    try {\n      boolExpr = ValueParser.parse(this.selection.slice(1, -1), this.nullValuesSupport)\n    } catch (e) {\n      throw insertRangeIfUndefined(e, this.stringRange)\n    }\n\n    const source: Relation = this.subtree.getResult()\n    const result: Relation = new Relation(source.name + '(...)')\n    source.forEachColumn((type, name) => result.addColumn(name, type))\n\n    source.getRows().forEach(row => {\n      const bool: VEResult = boolExpr.eval(row)\n      if (bool.type !== 'boolean') {\n        throw ErrorFactory.syntaxError(language().syntaxErrors.selectionNode_resultNotBoolean,\n                    this.stringRange, this.selection.replace(/\\s+/g, ' '), bool.type)\n      }\n      if (bool.value) {\n        result.addRow(row)\n      }\n    })\n    this.resultRelation = result\n  }\n\n  /**\n     * Evaluates the RA query in this node and its subtree.\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\n     * Otherwise returns the result relation schema (only column names, no rows).\n     * When an error occurs, it is faked to work, and adds it to the errors array.\n     *\n     * Strict expectations: columns names used in the condition exists in source schema\n     * Returned schema: source schema\n     * Usage of absent column names does not affect returned schema.\n     *\n     * @param cursorIndex index of the cursor in original text input {@type number}\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper {@type NodeFakeEvalResult}\n     * @public\n     */\n  fakeEval (cursorIndex: number) {\n    let { result, whispers, errors } = this.subtree.fakeEval(cursorIndex)\n    const newResult = new Relation(result.getName() + '(...)')\n    result.forEachColumn((type, name) => {\n      newResult.addColumn(name, type)\n    })\n    result = newResult\n    // checks whether the cursor is in this selection block (and not in the string) - saves current available columns\n    if (isInRangeAndNotInQuotes(cursorIndex, this.stringRange, this.selection)) {\n      whispers = result.getColumnNames()\n    }\n    // checks empty selection input\n    if (this.selection.toString().slice(1, -1).trim().length === 0) {\n      errors.push(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_emptyInput, this.stringRange))\n    }\n    // adds errors from current expression\n    else {\n      errors.push(...ValueParser.fakeParse(this.selection.slice(1, -1), this.nullValuesSupport, result.getColumnNames()))\n    }\n    // result schema is the same as the source\n    return { result, whispers, errors }\n  }\n\n  /**\n     * Creates a string with a structure of the RA tree in one line.\n     *\n     * @return string with a structure of the RA tree in one line {@type string}\n     * @public\n     */\n  printInLine (): string {\n    return this.subtree.printInLine() + this.getOperationSymbol()\n  }\n\n  /**\n     * Return the word name of the RA operation of the node.\n     * Example: returns \"Selection\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n  getOperationName (): string {\n    return language().operations.selection\n  }\n\n  /**\n     * Return the symbolic representation of the RA operation of the node.\n     * Example: returns \"(some + expr = 15)\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n  getOperationSymbol (): string {\n    return this.selection.replace(/\\s+/g, ' ')\n  }\n}\n","import { BinaryNode } from './binaryNode'\nimport { RATreeNode } from './raTreeNode'\nimport { Relation } from '../relation/relation'\nimport { Row } from '../relation/row'\nimport { language } from '../language/language'\n\n/**\n * Enum of types of antijoin node: left, right.\n * @enum {string}\n * @category RATree\n * @public\n */\nexport enum AntijoinType {\n  left = '\\u22b3',\n  right = '\\u22b2'\n}\n\n/**\n * Antijoin node of the relational algebra syntactic tree.\n * @extends BinaryNode\n * @category RATree\n * @public\n */\nexport class AntijoinNode extends BinaryNode {\n\n  private readonly type: AntijoinType\n\n  /**\n     * Creates a new AntijoinNode.\n     *\n     * @param operator type of antijoin {@type AntijoinType}\n     * @param leftSubtree left subtree {@type RATreeNode}\n     * @param rightSubtree right subtree {@type RATreeNode}\n     * @public\n     */\n  constructor (operator: AntijoinType, leftSubtree: RATreeNode, rightSubtree: RATreeNode) {\n    super(leftSubtree, rightSubtree)\n    this.type = operator\n  }\n\n  /**\n     * Evaluates the RA query in this node and its subtree.\n     * Expectations on source schemas: none\n     * @public\n     */\n  eval (): void {\n    if (this.isEvaluated()) {\n      return\n    }\n    const leftSource: Relation = this.leftSubtree.getResult()\n    const rightSource: Relation = this.rightSubtree.getResult()\n    // intersection of columns in left and right subtree\n    const commonColumns: string[] = leftSource.getColumnNames().filter(lc => rightSource.hasColumn(lc))\n    let rowsToKeep: Row[]   // rows from the subtree, which have to be kept in result\n    let rowsToHelp: Row[]\n    // change of relational schema\n    const result: Relation = new Relation('(' + leftSource.getName() + this.type + rightSource.getName() + ')')\n    if (this.type === AntijoinType.left) {\n      leftSource.forEachColumn((type, name) => result.addColumn(name, type))\n      rowsToKeep = leftSource.getRows()\n      rowsToHelp = rightSource.getRows()\n    } else {\n      rightSource.forEachColumn((type, name) => result.addColumn(name, type))\n      rowsToKeep = rightSource.getRows()\n      rowsToHelp = leftSource.getRows()\n    }\n    // join of relation rows\n    rowsToKeep.forEach(keptRow => {\n      const someMatch: boolean = rowsToHelp.some(helpRow => {\n        // if all common columns match, the row should not be added\n        return commonColumns.every(c => keptRow.getValue(c) === helpRow.getValue(c))\n      })\n      if (!someMatch) {\n        const newRow: Row = new Row(result.getColumns())\n        keptRow.getValues().forEach((value, name) => newRow.addValue(name, value))\n        result.addRow(newRow)\n      }\n    })\n    this.resultRelation = result\n  }\n\n  /**\n     * Evaluates the RA query in this node and its subtree.\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\n     * Otherwise returns the result relation schema (only column names, no rows).\n     * When an error occurs, it is faked to work, and adds it to the errors array.\n     *\n     * Strict expectations: none\n     * Returned schema: left/right source schema (for left/right antijoin)\n     *\n     * @param cursorIndex index of the cursor in original text input {@type number}\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper {@type NodeFakeEvalResult}\n     * @public\n     */\n  fakeEval (cursorIndex: number) {\n    const type = this.type === AntijoinType.left ? 'left' : 'right'\n    return this.fakeEvalBinary(cursorIndex, type)\n  }\n\n  /**\n     * Creates a string with a structure of the RA tree in one line.\n     *\n     * @return string with a structure of the RA tree in one line {@type string}\n     * @public\n     */\n  printInLine (): string {\n    return '(' + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + ')'\n  }\n\n  /**\n     * Return the word name of the RA operation of the node.\n     * Example: returns \"Selection\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n  getOperationName (): string {\n    const lang = language().operations\n    return this.type === AntijoinType.left ? lang.leftAntijoin : lang.rightAntijoin\n  }\n\n  /**\n     * Return the symbolic representation of the RA operation of the node.\n     * Example: returns \"(some + expr = 15)\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n  getOperationSymbol (): string {\n    return this.type\n  }\n}\n","import { BinaryNode } from './binaryNode'\nimport { RATreeNode } from './raTreeNode'\nimport { Relation } from '../relation/relation'\nimport { Row } from '../relation/row'\nimport { language } from '../language/language'\n\n/**\n * Enum of types of outer join node: full, left, right.\n * @enum {string}\n * @category RATree\n * @public\n */\nexport enum OuterJoinType {\n  left = '*L*',\n  right = '*R*',\n  full = '*F*'\n}\n\n/**\n * Outer join node of the relational algebra syntactic tree.\n * @extends BinaryNode\n * @category RATree\n * @public\n */\nexport class OuterJoinNode extends BinaryNode {\n\n  private readonly type: OuterJoinType\n\n  /**\n     * Creates a new OuterJoinNode.\n     *\n     * @param operator type of outer join {@type OuterJoinType}\n     * @param leftSubtree left subtree {@type RATreeNode}\n     * @param rightSubtree right subtree {@type RATreeNode}\n     * @public\n     */\n  constructor (operator: OuterJoinType, leftSubtree: RATreeNode, rightSubtree: RATreeNode) {\n    super(leftSubtree, rightSubtree)\n    this.type = operator\n  }\n\n  /**\n     * Evaluates the RA query in this node and its subtree.\n     * Expectations on source schemas: none\n     */\n  eval (): void {\n    if (this.isEvaluated()) {\n      return\n    }\n    const leftSource: Relation = this.leftSubtree.getResult()\n    const rightSource: Relation = this.rightSubtree.getResult()\n    // change of relational schema\n    const result: Relation = new Relation('(' + leftSource.getName() + this.type + rightSource.getName() + ')')\n    leftSource.forEachColumn((type, name) => result.addColumn(name, type))\n    rightSource.forEachColumn((type, name) => result.addColumn(name, type))\n    // join of relation rows\n    const leftRows: Row[] = leftSource.getRows()\n    const rightRows: Row[] = rightSource.getRows()\n    // intersection of columns in left and right subtree\n    const commonColumns: string[] = leftSource.getColumnNames().filter(lc => rightSource.hasColumn(lc))\n    // adds naturally joined rows\n    leftRows.forEach(leftRow => {\n      rightRows.forEach(rightRow => {\n        // if all common columns have the same value\n        if (commonColumns.every(c => leftRow.getValue(c) === rightRow.getValue(c))) {\n          const newRow: Row = new Row(result.getColumns())\n          leftRow.getValues().forEach((value, name) => newRow.addValue(name, value))\n          rightRow.getValues().forEach((value, name) => newRow.addValue(name, value))\n          result.addRow(newRow)\n        }\n      })\n    })\n    // adds left source rows with right null values\n    if (this.type === OuterJoinType.left || this.type === OuterJoinType.full) {\n      leftRows.forEach(leftRow => {\n        const someMatch: boolean = rightRows.some(rightRow => {\n          // if all common columns match, the row should not be added\n          return commonColumns.every(c => leftRow.getValue(c) === rightRow.getValue(c))\n        })\n        if (!someMatch) {\n          const newRow: Row = new Row(result.getColumns())\n          leftRow.getValues().forEach((value, name) => newRow.addValue(name, value))\n          result.addRow(newRow)\n        }\n      })\n    }\n    // adds right source rows with left null values\n    if (this.type === OuterJoinType.right || this.type === OuterJoinType.full) {\n      rightRows.forEach(rightRow => {\n        const someMatch: boolean = leftRows.some(leftRow => {\n          // if all common columns match, the row should not be added\n          return commonColumns.every(c => leftRow.getValue(c) === rightRow.getValue(c))\n        })\n        if (!someMatch) {\n          const newRow: Row = new Row(result.getColumns())\n          rightRow.getValues().forEach((value, name) => newRow.addValue(name, value))\n          result.addRow(newRow)\n        }\n      })\n    }\n    this.resultRelation = result\n  }\n\n  /**\n     * Evaluates the RA query in this node and its subtree.\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\n     * Otherwise returns the result relation schema (only column names, no rows).\n     * When an error occurs, it is faked to work, and adds it to the errors array.\n     *\n     * Strict expectations: none\n     * Returned schema: union of source schemas (in all cases - full/left/right)\n     *\n     * @param cursorIndex index of the cursor in original text input {@type number}\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper {@type NodeFakeEvalResult}\n     * @public\n     */\n  fakeEval (cursorIndex: number) {\n    return this.fakeEvalBinary(cursorIndex, 'union')\n  }\n\n  /**\n     * Creates a string with a structure of the RA tree in one line.\n     *\n     * @return string with a structure of the RA tree in one line {@type string}\n     * @public\n     */\n  printInLine (): string {\n    return '(' + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + ')'\n  }\n\n  /**\n     * Return the word name of the RA operation of the node.\n     * Example: returns \"Selection\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n  getOperationName (): string {\n    const lang = language().operations\n    if (this.type === OuterJoinType.left) {\n      return lang.leftOuterJoin\n    } else if (this.type === OuterJoinType.right) {\n      return lang.rightOuterJoin\n    } else {\n      return lang.fullOuterJoin\n    }\n  }\n\n  /**\n     * Return the symbolic representation of the RA operation of the node.\n     * Example: returns \"(some + expr = 15)\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n  getOperationSymbol (): string {\n    return this.type\n  }\n}\n","import { BinaryNode } from './binaryNode'\nimport { RATreeNode } from './raTreeNode'\nimport { Relation } from '../relation/relation'\nimport { Row } from '../relation/row'\nimport { ErrorFactory } from '../error/errorFactory'\nimport { language } from '../language/language'\nimport { StartEndPair } from '../types/startEndPair'\n\n/**\n * Cartesian product node of the relational algebra syntactic tree.\n * @extends BinaryNode\n * @category RATree\n * @public\n */\nexport class CartesianProductNode extends BinaryNode {\n\n  /**\n     * Creates a new CartesianProductNode.\n     *\n     * @param leftSubtree left subtree {@type RATreeNode}\n     * @param rightSubtree right subtree {@type RATreeNode}\n     * @param stringRange position of the operator in the original text {@type StartEndPair?}\n     * @public\n     */\n  constructor (leftSubtree: RATreeNode, rightSubtree: RATreeNode, private readonly stringRange: StartEndPair | undefined) {\n    super(leftSubtree, rightSubtree)\n  }\n\n  /**\n     * Evaluates the RA query in this node and its subtree.\n     * Expectations on source schemas: disjointness\n     * @public\n     */\n  eval (): void {\n    if (this.isEvaluated()) {\n      return\n    }\n    const leftSource: Relation = this.leftSubtree.getResult()\n    const rightSource: Relation = this.rightSubtree.getResult()\n    // join of relational schema\n    const result: Relation = new Relation('(' + leftSource.getName() + '\\u2a2f' + rightSource.getName() + ')')\n    leftSource.forEachColumn((type, name) => result.addColumn(name, type))\n    rightSource.forEachColumn((type, name) => {\n      if (!result.addColumn(name, type)) {\n        throw ErrorFactory.semanticError(language().semanticErrors.binaryNode_commonColumns,\n                    this.stringRange, 'cartesian product', name)\n      }\n    })\n    // join of relation rows\n    leftSource.getRows().forEach(leftRow => {\n      rightSource.getRows().forEach(rightRow => {\n        const newRow: Row = new Row(result.getColumns())\n        leftRow.getValues().forEach((value, name) => newRow.addValue(name, value))\n        rightRow.getValues().forEach((value, name) => newRow.addValue(name, value))\n        result.addRow(newRow)\n      })\n    })\n    this.resultRelation = result\n  }\n\n  /**\n     * Evaluates the RA query in this node and its subtree.\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\n     * Otherwise returns the result relation schema (only column names, no rows).\n     * When an error occurs, it is faked to work, and adds it to the errors array.\n     *\n     * Strict expectations: disjointness\n     * Returned schema: union of source schemas\n     * Returned fake schema is not affected when disjointness is not held\n     *\n     * @param cursorIndex index of the cursor in original text input {@type number}\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper {@type NodeFakeEvalResult}\n     * @public\n     */\n  fakeEval (cursorIndex: number) {\n    // evaluates the subtrees\n    const left = this.leftSubtree.fakeEval(cursorIndex)\n    const right = this.rightSubtree.fakeEval(cursorIndex)\n    // creates return relation\n    const result: Relation = new Relation('')\n    left.result.forEachColumn((type, name) => result.addColumn(name, type))\n    right.result.forEachColumn((type, name) => result.addColumn(name, type))\n    // checks errors\n    left.errors.push(...right.errors)\n    const commonColumns: string[] = []\n    left.result.getColumnNames().forEach(leftColumn => {\n      if (right.result.hasColumn(leftColumn)) {\n        commonColumns.push(leftColumn)\n      }\n    })\n    if (commonColumns.length > 0) {\n      left.errors.push(ErrorFactory.semanticError(language().semanticErrors.binaryNode_commonColumns,\n                this.stringRange, 'cartesian product', commonColumns.join('\", \"')))\n    }\n    return {\n      result,\n      whispers: left.whispers.length !== 0 ? left.whispers : right.whispers,\n      errors: left.errors,\n    }\n  }\n\n  /**\n     * Creates a string with a structure of the RA tree in one line.\n     *\n     * @return string with a structure of the RA tree in one line {@type string}\n     * @public\n     */\n  printInLine (): string {\n    return '(' + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + ')'\n  }\n\n  /**\n     * Return the word name of the RA operation of the node.\n     * Example: returns \"Selection\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n  getOperationName (): string {\n    return language().operations.cartesianProduct\n  }\n\n  /**\n     * Return the symbolic representation of the RA operation of the node.\n     * Example: returns \"(some + expr = 15)\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n  getOperationSymbol (): string {\n    return '⨯'\n  }\n}\n","import { BinaryNode } from './binaryNode'\nimport { RATreeNode } from './raTreeNode'\nimport { Relation } from '../relation/relation'\nimport { Row } from '../relation/row'\nimport { SupportedColumnType } from '../relation/columnType'\nimport { ErrorFactory } from '../error/errorFactory'\nimport { language } from '../language/language'\nimport { StartEndPair } from '../types/startEndPair'\n\n/**\n * Division node of the relational algebra syntactic tree.\n * @extends BinaryNode\n * @category RATree\n * @public\n */\nexport class DivisionNode extends BinaryNode {\n\n  /**\n     * Creates a new DivisionNode.\n     *\n     * @param leftSubtree left subtree {@type RATreeNode}\n     * @param rightSubtree right subtree {@type RATreeNode}\n     * @param stringRange position of the operator in the original text {@type StartEndPair?}\n     * @public\n     */\n  constructor (leftSubtree: RATreeNode, rightSubtree: RATreeNode, private readonly stringRange: StartEndPair | undefined) {\n    super(leftSubtree, rightSubtree)\n  }\n\n  /**\n     * Evaluates the RA query in this node and its subtree.\n     * Expectations on source schemas: right source schema is a proper subset of left source schema\n     */\n  eval (): void {\n    if (this.isEvaluated()) {\n      return\n    }\n    const leftSource: Relation = this.leftSubtree.getResult()\n    const rightSource: Relation = this.rightSubtree.getResult()\n    const leftColumns: Map<string, SupportedColumnType> = leftSource.getColumns()\n    const rightColumns: Map<string, SupportedColumnType> = rightSource.getColumns()\n\n    if (![...rightColumns].every(value => leftColumns.has(value[0]) && leftColumns.get(value[0]) === value[1])) {\n      throw ErrorFactory.semanticError(language().semanticErrors.divisionNode_rightColumnsNotSubset,\n                this.stringRange, rightSource.getSchemaString(), leftSource.getSchemaString())\n    }\n\n    // difference of columns in left and right subtree\n    const resultColumns: Map<string, SupportedColumnType> = new Map<string, SupportedColumnType>()\n    leftColumns.forEach((type, name) => {\n      if (!rightColumns.has(name)) {\n        resultColumns.set(name, type)\n      }\n    })\n\n    if (resultColumns.size === 0) {\n      throw ErrorFactory.semanticError(language().semanticErrors.divisionNode_rightColumnsNotProperSubset,\n                this.stringRange, rightSource.getNamesSchemaString(), leftSource.getNamesSchemaString())\n    }\n\n    // join of relational schema\n    const result: Relation = new Relation('(' + leftSource.getName() + '\\u00f7' + rightSource.getName() + ')')\n    resultColumns.forEach((type, name) => result.addColumn(name, type))\n    // filter relation rows\n    const leftRows: Row[] = leftSource.getRows()\n    const rightRows: Row[] = rightSource.getRows()\n    leftRows.forEach(leftRow => {\n      if (rightRows.every(rightRow => {\n        // creates a row with left row's extra columns and right row's common columns\n        const testRow: Row = new Row(leftColumns)\n        // left row's extra columns\n        // @ts-ignore ('name' must be present in left row)\n        resultColumns.forEach((type, name) => testRow.addValue(name, leftRow.getValue(name)))\n        // right row's common columns\n        rightRow.getValues().forEach((type, name) => testRow.addValue(name, type))\n        // tests if the created row exists in left relation\n        return [...leftRows].some(lr => lr.equals(testRow))\n      })) {\n        const newRow: Row = new Row(result.getColumns())\n        // @ts-ignore ('name' must be present in left row)\n        resultColumns.forEach((value, name) => newRow.addValue(name, leftRow.getValue(name)))\n        result.addRow(newRow)\n      }\n    })\n    this.resultRelation = result\n  }\n\n  /**\n     * Evaluates the RA query in this node and its subtree.\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\n     * Otherwise returns the result relation schema (only column names, no rows).\n     * When an error occurs, it is faked to work, and adds it to the errors array.\n     *\n     * Strict expectations: right source schema is a proper subset of left source schema\n     * Returned schema: left source schema minus right source schema\n     * Returned fake schema may be empty (right source schema may contain all left source columns).\n     *\n     * @param cursorIndex index of the cursor in original text input {@type number}\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper {@type NodeFakeEvalResult}\n     * @public\n     */\n  fakeEval (cursorIndex: number) {\n    const left = this.leftSubtree.fakeEval(cursorIndex)\n    const right = this.rightSubtree.fakeEval(cursorIndex)\n    const leftColumns = left.result.getColumns()\n    const rightColumns = right.result.getColumns()\n    // creates relation schema - \"left columns minus right columns\"\n    const resultColumns = new Map([...leftColumns.entries()].filter(([key, _]) => !rightColumns.has(key)))\n    const result = new Relation('(' + left.result.getName() + '\\u00f7' + right.result.getName() + ')')\n    resultColumns.forEach((type, name) => result.addColumn(name, type))\n    // checks errors in schema\n    const errors = left.errors\n    errors.push(...right.errors)\n    if (![...rightColumns].every(value => leftColumns.has(value[0]) && leftColumns.get(value[0]) === value[1])\n            && left.result.getName() !== '') {\n      errors.push(ErrorFactory.semanticError(language().semanticErrors.divisionNode_rightColumnsNotSubset,\n                this.stringRange, right.result.getSchemaString(), left.result.getSchemaString()))\n    } else if (resultColumns.size === 0 && left.result.getName() !== '') {\n      errors.push(ErrorFactory.semanticError(language().semanticErrors.divisionNode_rightColumnsNotProperSubset,\n                this.stringRange, right.result.getNamesSchemaString(), left.result.getNamesSchemaString()))\n    }\n    return {\n      result,\n      whispers: left.whispers.length !== 0 ? left.whispers : right.whispers,\n      errors: left.errors,\n    }\n  }\n\n  /**\n     * Creates a string with a structure of the RA tree in one line.\n     *\n     * @return string with a structure of the RA tree in one line {@type string}\n     * @public\n     */\n  printInLine (): string {\n    return '(' + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + ')'\n  }\n\n  /**\n     * Return the word name of the RA operation of the node.\n     * Example: returns \"Selection\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n  getOperationName (): string {\n    return language().operations.division\n  }\n\n  /**\n     * Return the symbolic representation of the RA operation of the node.\n     * Example: returns \"(some + expr = 15)\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n  getOperationSymbol (): string {\n    return '÷'\n  }\n}\n","import { BinaryNode } from './binaryNode'\nimport { RATreeNode } from './raTreeNode'\nimport { Relation } from '../relation/relation'\nimport { Row } from '../relation/row'\nimport { language } from '../language/language'\n\n/**\n * Enum of types of natural join node: natural, left semi, right semi.\n * @enum {string}\n * @category RATree\n * @public\n */\nexport enum NaturalJoinType {\n  natural = '*',\n  leftSemi = '<*',\n  rightSemi = '*>'\n}\n\n/**\n * Natural join or semi join node of the relational algebra syntactic tree.\n * @extends BinaryNode\n * @category RATree\n * @public\n */\nexport class NaturalJoinNode extends BinaryNode {\n\n  private readonly type: NaturalJoinType\n\n  /**\n     * Creates a new NaturalJoinNode.\n     *\n     * @param operator type of natural join {@type NaturalJoinNode}\n     * @param leftSubtree left subtree {@type RATreeNode}\n     * @param rightSubtree right subtree {@type RATreeNode}\n     * @public\n     */\n  constructor (operator: NaturalJoinType, leftSubtree: RATreeNode, rightSubtree: RATreeNode) {\n    super(leftSubtree, rightSubtree)\n    this.type = operator\n  }\n\n  /**\n     * Evaluates the RA query in this node and its subtree.\n     * Expectations on source schemas: none\n     * @public\n     */\n  eval (): void {\n    if (this.isEvaluated()) {\n      return\n    }\n    const leftSource: Relation = this.leftSubtree.getResult()\n    const rightSource: Relation = this.rightSubtree.getResult()\n    // intersection of columns in left and right subtree\n    const commonColumns: string[] = leftSource.getColumnNames().filter(lc => rightSource.hasColumn(lc))\n    // change of relational schema\n    const result: Relation = new Relation('(' + leftSource.getName() + this.type + rightSource.getName() + ')')\n    if (this.type === NaturalJoinType.leftSemi || this.type === NaturalJoinType.natural) {\n      leftSource.forEachColumn((type, name) => result.addColumn(name, type))\n    }\n    if (this.type === NaturalJoinType.rightSemi || this.type === NaturalJoinType.natural) {\n      rightSource.forEachColumn((type, name) => result.addColumn(name, type))\n    }\n    // join of relation rows\n    leftSource.getRows().forEach(leftRow => {\n      rightSource.getRows().forEach(rightRow => {\n        // if all common columns have the same value\n        if ([...commonColumns].every(c => leftRow.getValue(c) === rightRow.getValue(c))) {\n          const newRow: Row = new Row(result.getColumns())\n          if (this.type === NaturalJoinType.leftSemi || this.type === NaturalJoinType.natural) {\n            leftRow.getValues().forEach((value, name) => newRow.addValue(name, value))\n          }\n          if (this.type === NaturalJoinType.rightSemi || this.type === NaturalJoinType.natural) {\n            rightRow.getValues().forEach((value, name) => newRow.addValue(name, value))\n          }\n          result.addRow(newRow)\n        }\n      })\n    })\n    this.resultRelation = result\n  }\n\n  /**\n     * Evaluates the RA query in this node and its subtree.\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\n     * Otherwise returns the result relation schema (only column names, no rows).\n     * When an error occurs, it is faked to work, and adds it to the errors array.\n     *\n     * Strict expectations: none\n     * Returned schema: left/right/both source schema (for left-semijoin/right-semijoin/natural join)\n     *\n     * @param cursorIndex index of the cursor in original text input {@type number}\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper {@type NodeFakeEvalResult}\n     * @public\n     */\n  fakeEval (cursorIndex: number) {\n    let type: 'union' | 'left' | 'right' = 'union'\n    if (this.type === NaturalJoinType.leftSemi) {\n      type = 'left'\n    } else if (this.type === NaturalJoinType.rightSemi) {\n      type = 'right'\n    }\n    return this.fakeEvalBinary(cursorIndex, type)\n  }\n\n  /**\n     * Creates a string with a structure of the RA tree in one line.\n     *\n     * @return string with a structure of the RA tree in one line {@type string}\n     * @public\n     */\n  printInLine (): string {\n    return '(' + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + ')'\n  }\n\n  /**\n     * Return the word name of the RA operation of the node.\n     * Example: returns \"Selection\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n  getOperationName (): string {\n    const lang = language().operations\n    if (this.type === NaturalJoinType.leftSemi) {\n      return lang.leftSemiJoin\n    } else if (this.type === NaturalJoinType.rightSemi) {\n      return lang.rightSemiJoin\n    } else {\n      return lang.naturalJoin\n    }\n  }\n\n  /**\n     * Return the symbolic representation of the RA operation of the node.\n     * Example: returns \"(some + expr = 15)\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n  getOperationSymbol (): string {\n    return '*'\n  }\n\n  /**\n     * Returns type of the NaturalJoinNode.\n     *\n     * @return type of the node {@type NaturalJoinType}\n     * @public\n     */\n  getType (): NaturalJoinType {\n    return this.type\n  }\n}\n","import { BinaryNode } from './binaryNode'\nimport { RATreeNode } from './raTreeNode'\nimport { Relation } from '../relation/relation'\nimport { Row } from '../relation/row'\nimport { isEqual } from 'lodash'\nimport { ErrorFactory } from '../error/errorFactory'\nimport { language } from '../language/language'\nimport { StartEndPair } from '../types/startEndPair'\n\n/**\n * Enum of types of set operation node: union, intersection, difference.\n * @enum {string}\n * @category RATree\n * @public\n */\nexport enum SetOperationType {\n  union = '\\u222a',\n  intersection = '\\u2229',\n  difference = '\\\\'\n}\n\n/**\n * Set operation node of the relational algebra syntactic tree.\n * @extends BinaryNode\n * @category RATree\n * @public\n */\nexport class SetOperationNode extends BinaryNode {\n\n  private readonly type: SetOperationType\n\n  /**\n     * Creates a new SetOperationNode.\n     *\n     * @param operator type of set operation {@type SetOperationType}\n     * @param leftSubtree left subtree {@type RATreeNode}\n     * @param rightSubtree right subtree {@type RATreeNode}\n     * @param stringRange position of the operator in the original text {@type StartEndPair?}\n     * @public\n     */\n  constructor (operator: SetOperationType, leftSubtree: RATreeNode, rightSubtree: RATreeNode,\n                       private readonly stringRange: StartEndPair | undefined) {\n    super(leftSubtree, rightSubtree)\n    this.type = operator\n  }\n\n  /**\n     * Evaluates the RA query in this node and its subtree.\n     * Expectations on source schemas: equality\n     */\n  eval (): void {\n    if (this.isEvaluated()) {\n      return\n    }\n    const leftSource: Relation = this.leftSubtree.getResult()\n    const rightSource: Relation = this.rightSubtree.getResult()\n\n    if (!isEqual(leftSource.getColumns(), rightSource.getColumns())) {\n      const typeStr: string = this.getOperationName().toLowerCase()\n      throw ErrorFactory.semanticError(language().semanticErrors.setOperationNode_notEqualColumns,\n                this.stringRange, leftSource.getSchemaString(), rightSource.getSchemaString(), typeStr)\n    }\n    // copy of relational schema\n    const result: Relation = new Relation('(' + leftSource.getName() + this.type + rightSource.getName() + ')')\n    leftSource.forEachColumn((type, name) => result.addColumn(name, type))\n    // change of relation rows\n    let resultRows: Row[]\n    const leftRows: Row[] = leftSource.getRows()\n    const rightRows: Row[] = rightSource.getRows()\n    if (this.type === SetOperationType.union) {\n      resultRows = [...leftRows, ...rightRows]\n    } else if (this.type === SetOperationType.intersection) {\n      resultRows = [...leftRows].filter(lr => [...rightRows].some(rr => lr.equals(rr)))\n    } else /* this.type === SetOperationType.difference */ {\n      resultRows = [...leftRows].filter(lr => ![...rightRows].some(rr => lr.equals(rr)))\n    }\n    resultRows.forEach(row => result.addRow(row))\n    this.resultRelation = result\n  }\n\n  /**\n     * Evaluates the RA query in this node and its subtree.\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\n     * Otherwise returns the result relation schema (only column names, no rows).\n     * When an error occurs, it is faked to work, and adds it to the errors array.\n     *\n     * Strict expectations: equality\n     * Returned schema: intersection of source schemas\n     * Returned schema may be empty (when there is no common column in sources).\n     *\n     * @param cursorIndex index of the cursor in original text input {@type number}\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper {@type NodeFakeEvalResult}\n     * @public\n     */\n  fakeEval (cursorIndex: number) {\n    const left = this.leftSubtree.fakeEval(cursorIndex)\n    const right = this.rightSubtree.fakeEval(cursorIndex)\n    // join of relational schema - \"left intersection right\"\n    const result: Relation = new Relation('(' + left.result.getName() + this.type + right.result.getName() + ')')\n    left.result.forEachColumn((type, name) => {\n      if (right.result.hasColumn(name)) {\n        result.addColumn(name, type)\n      }\n    })\n    // checks errors in schema\n    const errors = left.errors\n    errors.push(...right.errors)\n    if (!isEqual(left.result.getColumns(), right.result.getColumns()) && left.result.getName() !== '' && right.result.getName() !== '') {\n      const typeStr: string = this.getOperationName().toLowerCase()\n      errors.push(ErrorFactory.semanticError(language().semanticErrors.setOperationNode_notEqualColumns,\n                this.stringRange, left.result.getSchemaString(), right.result.getSchemaString(), typeStr))\n    }\n    return {\n      result,\n      whispers: left.whispers.length !== 0 ? left.whispers : right.whispers,\n      errors: left.errors,\n    }\n  }\n\n  /**\n     * Creates a string with a structure of the RA tree in one line.\n     *\n     * @return string with a structure of the RA tree in one line {@type string}\n     * @public\n     */\n  printInLine (): string {\n    return '(' + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + ')'\n  }\n\n  /**\n     * Return the word name of the RA operation of the node.\n     * Example: returns \"Selection\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n  getOperationName (): string {\n    const lang = language().operations\n    if (this.type === SetOperationType.union) {\n      return lang.union\n    } else if (this.type === SetOperationType.intersection) {\n      return lang.intersection\n    } else {\n      return lang.difference\n    }\n  }\n\n  /**\n     * Return the symbolic representation of the RA operation of the node.\n     * Example: returns \"(some + expr = 15)\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n  getOperationSymbol (): SetOperationType {\n    return this.type\n  }\n}\n","import { BinaryNode } from './binaryNode'\nimport { RATreeNode } from './raTreeNode'\nimport { Relation } from '../relation/relation'\nimport { Row } from '../relation/row'\nimport { SupportedColumnType } from '../relation/columnType'\nimport { VEResult, VETreeNode } from '../vetree/veTreeNode'\nimport { IndexedString } from '../types/indexedString'\nimport { ValueParser } from '../expression/valueParser'\nimport { ErrorFactory } from '../error/errorFactory'\nimport { insertRangeIfUndefined } from '../error/errorWithTextRange'\nimport { isInRangeAndNotInQuotes } from './raTreeTools'\nimport { language } from '../language/language'\nimport { StartEndPair } from '../types/startEndPair'\n\n/**\n * Enum of types of theta join node: full (theta), left (theta semi), right (theta semi).\n * @enum {string}\n * @category RATree\n * @public\n */\nexport enum ThetaJoinType {\n  full = '[]',\n  left = '\\u27e8]',\n  right = '[\\u27e9'\n}\n\n/**\n * Theta join or theta semijoin node of the relational algebra syntactic tree.\n * @extends BinaryNode\n * @category RATree\n * @public\n */\nexport class ThetaJoinNode extends BinaryNode {\n\n  private readonly type: ThetaJoinType\n  private readonly condition: IndexedString\n  private readonly stringRange: StartEndPair | undefined\n  private readonly nullValuesSupport: boolean\n\n  /**\n     * Creates a new ThetaJoinNode.\n     * Expects the condition string to start with '[' and end with ']' or start with'⟨' and end with ']' or start\n     * with '[' and end with '⟩'.\n     *\n     * @param type type of natural join {@type ThetaJoinType}\n     * @param condition logic-algebraic condition {@type IndexedString}\n     * @param leftSubtree left subtree {@type RATreeNode}\n     * @param rightSubtree right subtree {@type RATreeNode}\n     * @param nullValuesSupport whether null values are supported\n     * @public\n     */\n  constructor (type: ThetaJoinType, condition: IndexedString,\n                       leftSubtree: RATreeNode, rightSubtree: RATreeNode, nullValuesSupport: boolean) {\n    super(leftSubtree, rightSubtree)\n    this.condition = condition\n    this.stringRange = condition.getRange()\n    this.nullValuesSupport = nullValuesSupport\n    this.type = type\n  }\n\n  /**\n     * Evaluates the RA query in this node and its subtree.\n     * Expectations on source schemas: disjointness\n     * Other expectations: condition is valid expression which evaluates to boolean\n     * @public\n     */\n  eval (): void {\n    if (this.isEvaluated()) {\n      return\n    }\n\n    let boolExpr: VETreeNode\n    try {\n      boolExpr = ValueParser.parse(this.condition.slice(1, -1), this.nullValuesSupport)   // slices brackets out\n    } catch (e) {\n      throw insertRangeIfUndefined(e, this.stringRange)\n    }\n\n    const leftSource: Relation = this.leftSubtree.getResult()\n    const rightSource: Relation = this.rightSubtree.getResult()\n\n    leftSource.getColumnNames().forEach(leftColumn => {\n      if (rightSource.hasColumn(leftColumn)) {\n        throw ErrorFactory.semanticError(language().semanticErrors.binaryNode_commonColumns, this.stringRange,\n                    this.getOperationName().toLowerCase(), leftColumn)\n      }\n    })\n    // change of relational schema\n    const result: Relation = new Relation('(' + leftSource.getName() + this.type.charAt(0) + '...' + this.type.charAt(1) + rightSource.getName() + ')')\n    if (this.type === ThetaJoinType.left || this.type === ThetaJoinType.full) {\n      leftSource.forEachColumn((type, name) => result.addColumn(name, type))\n    }\n    if (this.type === ThetaJoinType.right || this.type === ThetaJoinType.full) {\n      rightSource.forEachColumn((type, name) => result.addColumn(name, type))\n    }\n    // combine columns of both source relations to use it in testing row\n    const bothSourceColumns: Map<string, SupportedColumnType> = new Map<string, SupportedColumnType>(leftSource.getColumns())\n    rightSource.forEachColumn((type, name) => bothSourceColumns.set(name, type))\n\n    leftSource.getRows().forEach(leftRow => {\n      rightSource.getRows().forEach(rightRow => {\n        const testRow: Row = new Row(bothSourceColumns)\n        leftRow.getValues().forEach((value, name) => testRow.addValue(name, value))\n        rightRow.getValues().forEach((value, name) => testRow.addValue(name, value))\n        // checks whether the combined row from both relation columns satisfies the condition\n        const booleanResult: VEResult = boolExpr.eval(testRow)\n        if (booleanResult.type !== 'boolean') {\n          throw ErrorFactory.syntaxError(language().syntaxErrors.thetaJoinNode_resultNotBoolean,\n                        this.stringRange, this.condition.replace(/\\s+/g, ' '), booleanResult.type)\n        }\n        if (booleanResult.value) {\n          const newRow: Row = new Row(result.getColumns())\n          if (this.type === ThetaJoinType.left || this.type === ThetaJoinType.full) {\n            leftRow.getValues().forEach((value, name) => newRow.addValue(name, value))\n          }\n          if (this.type === ThetaJoinType.right || this.type === ThetaJoinType.full) {\n            rightRow.getValues().forEach((value, name) => newRow.addValue(name, value))\n          }\n          result.addRow(newRow)\n        }\n      })\n    })\n    this.resultRelation = result\n  }\n\n  /**\n     * Evaluates the RA query in this node and its subtree.\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\n     * Otherwise returns the result relation schema (only column names, no rows).\n     * When an error occurs, it is faked to work, and adds it to the errors array.\n     *\n     * Strict expectations: disjointness\n     * Returned schema: left/right/both source schema (for left/right/full semijoin)\n     * Returned fake schema is not affected when disjointness is not held\n     *\n     * @param cursorIndex index of the cursor in original text input {@type number}\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper {@type NodeFakeEvalResult}\n     * @public\n     */\n  fakeEval (cursorIndex: number) {\n    const left = this.leftSubtree.fakeEval(cursorIndex)\n    const right = this.rightSubtree.fakeEval(cursorIndex)\n    const sourceColumns: string[] = []\n    sourceColumns.push(...left.result.getColumnNames())\n    sourceColumns.push(...right.result.getColumnNames())\n    // creates return relation\n    const result: Relation = new Relation(this.type)\n    if (this.type === ThetaJoinType.left || this.type === ThetaJoinType.full) {\n      left.result.forEachColumn((type, name) => result.addColumn(name, type))\n    }\n    if (this.type === ThetaJoinType.right || this.type === ThetaJoinType.full) {\n      right.result.forEachColumn((type, name) => result.addColumn(name, type))\n    }\n    // checks whether the cursor is in this condition block (and not in the string) - saves current available columns\n    let whispers = left.whispers.length !== 0 ? left.whispers : right.whispers\n    if (isInRangeAndNotInQuotes(cursorIndex, this.stringRange, this.condition)) {\n      whispers = sourceColumns\n    }\n    // adds errors from current expression\n    const errors = left.errors\n    errors.push(...right.errors)\n    const commonColumns: string[] = []\n    left.result.getColumnNames().forEach(leftColumn => {\n      if (right.result.hasColumn(leftColumn)) {\n        commonColumns.push(leftColumn)\n      }\n    })\n    if (commonColumns.length > 0 && this.stringRange !== undefined) {\n      errors.push(ErrorFactory.semanticError(language().semanticErrors.binaryNode_commonColumns,\n                { start: this.stringRange.start, end: this.stringRange.start },   // highlight only opening bracket\n                this.getOperationName().toLowerCase(), commonColumns.join('\", \"')))\n    }\n    // checks empty condition input\n    if (this.condition.toString().slice(1, -1).trim().length === 0) {\n      errors.push(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_emptyInput, this.stringRange))\n    } else {\n      errors.push(...ValueParser.fakeParse(this.condition.slice(1, -1), this.nullValuesSupport, sourceColumns))\n    }\n    return { result, whispers, errors }\n  }\n\n  /**\n     * Creates a string with a structure of the RA tree in one line.\n     *\n     * @return string with a structure of the RA tree in one line {@type string}\n     * @public\n     */\n  printInLine (): string {\n    return '(' + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + ')'\n  }\n\n  /**\n     * Return the word name of the RA operation of the node.\n     * Example: returns \"Selection\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n  getOperationName (): string {\n    const lang = language().operations\n    if (this.type === ThetaJoinType.left) {\n      return lang.leftThetaSemiJoin\n    } else if (this.type === ThetaJoinType.right) {\n      return lang.rightThetaSemiJoin\n    } else {\n      return lang.thetaJoin\n    }\n  }\n\n  /**\n     * Return the symbolic representation of the RA operation of the node.\n     * Example: returns \"(some + expr = 15)\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n  getOperationSymbol (): string {\n    return this.condition.replace(/\\s+/g, ' ')\n  }\n\n  /**\n     * Returns type of ThetaJoinNode.\n     *\n     * @return type of the node {@type ThetaJoinType}\n     * @public\n     */\n  getType (): ThetaJoinType {\n    return this.type\n  }\n}\n","import { RATreeNode } from './raTreeNode'\nimport { ProjectionNode } from './projectionNode'\nimport { RenameNode } from './renameNode'\nimport { SelectionNode } from './selectionNode'\nimport { UnaryNode, UnaryNodeClass } from './unaryNode'\nimport { AntijoinNode, AntijoinType } from './antijoinNode'\nimport { CartesianProductNode } from './cartesianProductNode'\nimport { DivisionNode } from './divisionNode'\nimport { OuterJoinNode, OuterJoinType } from './outerJoinNode'\nimport { NaturalJoinNode, NaturalJoinType } from './naturalJoinNode'\nimport { SetOperationNode, SetOperationType } from './setOperationNode'\nimport { BinaryNode, BinaryNodeClass } from './binaryNode'\nimport { IndexedString } from '../types/indexedString'\nimport { ThetaJoinNode, ThetaJoinType } from './thetaJoinNode'\n\n/**\n * Factory for creating unary and binary nodes of given class.\n * @category RATree\n * @public\n */\nexport class RATreeFactory {\n\n  /**\n     * Creates new unary node of given class.\n     *\n     * @param unaryClass wanted class {@type UnaryNodeClass}\n     * @param subtree source subtree for a node {@type RATreeNode}\n     * @param nullValuesSupport whether null values are supported {@type boolean}\n     * @param expr expression used to specify node's behavior {@type IndexedString}\n     * @return created unary node {@type UnaryNode}\n     * @public\n     */\n  static createUnary (unaryClass: UnaryNodeClass, subtree: RATreeNode,\n                              nullValuesSupport: boolean, expr: IndexedString): UnaryNode {\n    switch (unaryClass) {\n      case 'projection':\n        return new ProjectionNode(expr, subtree)\n      case 'rename':\n        return new RenameNode(expr, subtree)\n      case 'selection':\n        return new SelectionNode(expr, subtree, nullValuesSupport)\n    }\n  }\n\n  /**\n     * Creates new binary node of given class.\n     *\n     * @param binaryClass wanted class {@type BinaryNodeClass}\n     * @param left left source subtree for a node {@type RATreeNode}\n     * @param right right source subtree for a node {@type RATreeNode}\n     * @param nullValuesSupport whether null values are supported {@type boolean}\n     * @param expr expression used to specify node's behavior {@type IndexedString}\n     * @return created binary node {@type BinaryNode}\n     * @public\n     */\n  static createBinary (binaryClass: BinaryNodeClass, left: RATreeNode, right: RATreeNode,\n                               nullValuesSupport: boolean, expr: IndexedString): BinaryNode {\n    switch (binaryClass) {\n      case 'left antijoin':\n        return new AntijoinNode(AntijoinType.left, left, right)\n      case 'right antijoin':\n        return new AntijoinNode(AntijoinType.right, left, right)\n      case 'cartesian product':\n        return new CartesianProductNode(left, right, expr.getRange())\n      case 'division':\n        return new DivisionNode(left, right, expr.getRange())\n      case 'natural join':\n        return new NaturalJoinNode(NaturalJoinType.natural, left, right)\n      case 'left outer join':\n        return new OuterJoinNode(OuterJoinType.left, left, right)\n      case 'right outer join':\n        return new OuterJoinNode(OuterJoinType.right, left, right)\n      case 'full outer join':\n        return new OuterJoinNode(OuterJoinType.full, left, right)\n      case 'left semijoin':\n        return new NaturalJoinNode(NaturalJoinType.leftSemi, left, right)\n      case 'right semijoin':\n        return new NaturalJoinNode(NaturalJoinType.rightSemi, left, right)\n      case 'union':\n        return new SetOperationNode(SetOperationType.union, left, right, expr.getRange())\n      case 'intersection':\n        return new SetOperationNode(SetOperationType.intersection, left, right, expr.getRange())\n      case 'difference':\n        return new SetOperationNode(SetOperationType.difference, left, right, expr.getRange())\n      case 'theta join':\n        return new ThetaJoinNode(ThetaJoinType.full, expr, left, right, nullValuesSupport)\n      case 'left theta semijoin':\n        return new ThetaJoinNode(ThetaJoinType.left, expr, left, right, nullValuesSupport)\n      case 'right theta semijoin':\n        return new ThetaJoinNode(ThetaJoinType.right, expr, left, right, nullValuesSupport)\n    }\n  }\n}\n","import { Relation } from '../relation/relation'\nimport { ErrorFactory } from '../error/errorFactory'\nimport {\n  BinaryOperatorToken,\n  ClosingParenthesis,\n  ExprToken,\n  OpeningParenthesis,\n  ParenthesisToken,\n  RelationToken,\n  UnaryOperatorToken,\n} from './exprTokens'\nimport { StringUtils } from '../utils/stringUtils'\nimport { RATreeNode } from '../ratree/raTreeNode'\nimport { RelationNode } from '../ratree/relationNode'\nimport { IndexedString } from '../types/indexedString'\nimport { IndexedStringUtils } from '../utils/indexedStringUtils'\nimport { ErrorWithTextRange } from '../error/errorWithTextRange'\nimport { RATreeFactory } from '../ratree/raTreeFactory'\nimport { language } from '../language/language'\nimport { StartEndPair } from '../types/startEndPair'\n\n/**\n * Fake parsing result in {@link ExprParser}.\n * @category Expression\n * @public\n */\nexport interface ExprFakeParseResult {\n  /**\n     * found words to whisper (relation or column names)\n     * @type string[]\n     * @public\n     */\n  whispers: string[]\n  /**\n     * detected errors\n     * @type ErrorWithTextRange[]\n     * @public\n     */\n  errors: ErrorWithTextRange[]\n  /**\n     * pairs of indexes with parentheses\n     * @type StartEndPair[]\n     * @public\n     */\n  parentheses: StartEndPair[]\n}\n\n/**\n * Parser of relational algebra expressions from textual inputs.\n * @category Expression\n * @public\n */\nexport class ExprParser {\n\n  /**\n     * Creates a parser with given source relations.\n     *\n     * @param relations map of relations used as source for leave nodes {@type Map<String, Relation>}\n     * @param nullValuesSupport whether to support null values {@type boolean}\n     * @public\n     */\n  constructor (readonly relations: Map<string, Relation>, readonly nullValuesSupport: boolean) {}\n\n  /**\n     * Parses given relational algebra expression 'expr' and returns tree of RA operations.\n     * Expression is expected to respect following constraints:\n     * - all relation's and column's names contain letters, numbers and underscores only\n     * - all relation's and column's names start with a letter\n     * - used operations must be in a simplified notation and be well-structured\n     * - line comments begin with '//' and ends with newline\n     * - block comments begins with '/*' and ends with '* /'\n     *\n     * Supported operations are:\n     * - projection of columns: Relation[projectedColumn1, ...]\n     * - selection of rows: Relation(condition)\n     * - rename of columns: Relation<oldName -> newName, ...>\n     * - cartesian product: A ⨯ B\n     * - natural join: A * B\n     * - theta join: A [condition] B\n     * - left and right semijoin: A <* B and A *> B\n     * - left and right antijoin: A ⊳ B and A ⊲ B\n     * - left and right theta semijoin: A <condition] B and A [condition> B\n     * - division: A ÷ B\n     * - left, right and full outer join: A *L* B, A *R* B and A *F* B\n     * - union, intersection and difference: A ∪ B, A ∩ B and A \\ B\n     *\n     * See {@link ValueParser} for condition-subexpressions constraints.\n     *\n     * @param expr relational algebra expression in expected format {@type string}\n     * @return tree structure of the given expression {@type RATreeNode}\n     * @public\n     */\n  parse (expr: string): RATreeNode {\n    const { str, err } = IndexedStringUtils.deleteAllComments(IndexedString.new(expr))\n    if (err !== undefined) {\n      throw err\n    }\n    const { tokens } = this.parseTokens(str)\n    if (tokens.length === 0) {\n      throw ErrorFactory.syntaxError(language().syntaxErrors.exprParser_emptyStringGiven, undefined)\n    }\n    this.assertValidInfixTokens(tokens)\n    const rpn: ExprToken[] = this.toRPN(tokens)\n    return this.rpnToRATree(rpn)\n  }\n\n  /**\n     * Parses given expression and finds words to whisper for the given cursorIndex.\n     * If the cursor is located next to any RA operator, returns list of all defined relation names.\n     * If the cursor is located inside any RA operator, which uses relation columns, returns list of available column\n     * names at given place.\n     * If a parsing error occurs, it is faked to work or ignored and reported in returning errors array.\n     * For supported operations see {@link parse}.\n     *\n     * @param expr input expression to fake parse {@type string}\n     * @param cursorIndex current index of the cursor {@type number}\n     * @return parsed information {@type ExprFakeParseResult}\n     * @public\n     */\n  fakeParse (expr: string, cursorIndex: number): ExprFakeParseResult {\n    if (expr.trim() === '') {\n      return { whispers: [...this.relations.keys()], errors: [], parentheses: [] }\n    }\n    const { str, err } = IndexedStringUtils.deleteAllComments(IndexedString.new(expr))\n    const { whispers, tokens, errors, parentheses } = this.parseTokens(str, false, cursorIndex)\n    if (err !== undefined) {\n      errors.push(err)\n    }\n    // prevent errors in creation of RPN\n    if (tokens.length === 0) {\n      return { whispers: whispers, errors: errors, parentheses: parentheses }\n    }\n    // fakes found errors to valid parse\n    this.assertValidInfixTokens(tokens, false, errors)\n    const rpn: ExprToken[] = this.toRPN(tokens)\n    const raTree: RATreeNode = this.rpnToRATree(rpn, false, errors)\n    // tries to find whispers inside RA operations with parameters\n    const innerResult: {whispers: string[], errors: ErrorWithTextRange[]} = raTree.fakeEval(cursorIndex)\n    errors.push(...innerResult.errors)\n    // if there are whispers from inner operators, returns them\n    if (innerResult.whispers.length > 0) {\n      return { whispers: innerResult.whispers, errors: errors, parentheses: parentheses }\n    }\n    // otherwise returns outer whispers (or empty array if no were found)\n    return { whispers: whispers, errors: errors, parentheses: parentheses }\n  }\n\n  /**\n     * Parses given expression to ExprToken array. While parsing, it tries to find cursor index and returns whispers.\n     * When doThrow is false, parsing errors are not thrown but stored in errors array. Returns found pair characters\n     * (e.g., parentheses).\n     *\n     * @param expr IndexedString to parse the expression from\n     * @param cursorIndex current cursor index\n     * @param doThrow whether to throw encountered errors was a relation or an unary operator (default false)\n     */\n  parseTokens (expr: IndexedString, doThrow = true, cursorIndex = NaN):\n  { tokens: ExprToken[], whispers: string[], errors: ErrorWithTextRange[], parentheses: StartEndPair[] } {\n    // handles empty string\n    if (expr.isEmpty()) {\n      return { tokens: [], whispers: [...this.relations.keys()], errors: [], parentheses: [] }\n    }\n\n    const tokens: ExprToken[] = []\n    let whispers: string[] = cursorIndex === 0 ? [...this.relations.keys()] : []\n    const errors: ErrorWithTextRange[] = []\n    const parentheses: StartEndPair[] = []\n\n    // throws the error if doThrow is true, otherwise adds it to the errors array\n    const handleError = (err: ErrorWithTextRange) => {\n      if (doThrow) {\n        throw err\n      }\n      errors.push(err)\n    }\n\n    // adds new pair of parentheses from margins of the given string\n    const pushParentheses = (str: IndexedString) => {\n      parentheses.push({ start: str.getFirstIndex(), end: str.getLastIndex() })\n    }\n\n    let selectionExpected = false\n    let rest: IndexedString = expr\n    while (!rest.isEmpty()) {\n      // checks whether the cursor was reached\n      const restStartIndex: number = rest.getFirstIndex()\n      if (restStartIndex === cursorIndex) {\n        whispers = [...this.relations.keys()]\n      }\n\n      // '(' can be a selection or a parentheses\n      if (rest.startsWith('(')) {\n        let split: {first: IndexedString, second: IndexedString}\n        try {\n          split = IndexedStringUtils.nextBorderedPart(rest, '(', ')')\n        }\n        // catches error from nextBorderedPart\n        catch (err) {\n          // saves error\n          if (err instanceof ErrorWithTextRange) {\n            handleError(err)\n          }\n\n          if (selectionExpected) {\n            // it fakes the unclosed expression part as a selection operator\n            tokens.push(UnaryOperatorToken.selection(rest.concat(IndexedString.new(')', rest.getLastIndex() + 1))))\n          } else {\n            // it fakes the unclosed expression as nested expression in parentheses\n            tokens.push(new OpeningParenthesis(rest.slice(0, 1)))\n            // parses inner part between parentheses\n            const recursiveReturn = this.parseTokens(rest.slice(1), doThrow, cursorIndex)\n            errors.push(...recursiveReturn.errors)\n            if (whispers.length === 0) {\n              whispers.push(...recursiveReturn.whispers)\n            }\n            tokens.push(...recursiveReturn.tokens)\n            parentheses.push(...recursiveReturn.parentheses)\n            // gives invalid index (NaN for not reporting errors with this imaginary parentheses\n            tokens.push(new ClosingParenthesis(IndexedString.new(')', NaN)))\n          }\n          // breaks the while cycle because rest was parsed recursively\n          break\n        }\n\n        // saves parentheses\n        pushParentheses(split.first)\n\n        // whole \"(...)\" part pushed as selection\n        if (selectionExpected) {\n          tokens.push(UnaryOperatorToken.selection(split.first))\n        }\n        // inner of \"(...)\" part parsed as parentheses structure\n        else {\n          tokens.push(new OpeningParenthesis(split.first.slice(0, 1)))\n          const recursiveReturn = this.parseTokens(split.first.slice(1, -1), doThrow, cursorIndex)\n          errors.push(...recursiveReturn.errors)\n          if (whispers.length === 0) {\n            whispers.push(...recursiveReturn.whispers)\n          }\n          tokens.push(...recursiveReturn.tokens)\n          parentheses.push(...recursiveReturn.parentheses)\n          tokens.push(new ClosingParenthesis(split.first.slice(-1)))\n          selectionExpected = true\n        }\n        rest = split.second\n      }\n      // '[' can be a projection, theta join, or right theta semi join\n      else if (rest.startsWith('[')) {\n        let split: {first: IndexedString, second: IndexedString}\n        let error = false\n        try {\n          split = IndexedStringUtils.nextBorderedPart(rest, '[', ']\\u27e9')\n        }\n        // catches error from nextBorderedPart\n        catch (err) {\n          error = true\n          // saves error\n          if (err instanceof ErrorWithTextRange) {\n            handleError(err)\n          }\n          // it fakes the unclosed expression part as a projection operator\n          split = { first: rest.concat(IndexedString.new(']', rest.getLastIndex() + 1)), second: IndexedString.empty() }\n        }\n\n        // saves parentheses\n        pushParentheses(split.first)\n\n        // checks whether the cursor was reached\n        if (!error && split.first.getLastIndex() === cursorIndex - 1) {\n          whispers = [...this.relations.keys()]\n        }\n\n        // right theta semijoin found \"[...⟩\"\n        if (split.first.endsWith('\\u27e9')) {\n          tokens.push(BinaryOperatorToken.rightThetaSemijoin(split.first))\n          selectionExpected = false\n          rest = split.second\n        }\n        // if the next part contains any character from =<>+/*&|~\"()! it cannot be a valid Projection\n        else if (split.first.containsAny('=<>+/*&|~\"()!')) {\n          tokens.push(BinaryOperatorToken.thetaJoin(split.first))\n          selectionExpected = false\n          rest = split.second\n        }\n        // else suppose it is a projection\n        else {\n          tokens.push(UnaryOperatorToken.projection(split.first))\n          selectionExpected = true\n          rest = split.second\n        }\n      }\n      // BINARY OPERATORS\n      else if (rest.startsWith('*F*') || rest.startsWith('*L*') || rest.startsWith('*R*')) {\n        const operator: IndexedString = rest.slice(0, 3)\n        // checks whether the cursor was reached\n        if (operator.getLastIndex() === cursorIndex - 1) {\n          whispers = [...this.relations.keys()]\n        }\n\n        if (rest.startsWith('*F')) {\n          tokens.push(BinaryOperatorToken.fullOuterJoin(operator))\n        } else if (rest.startsWith('*L')) {\n          tokens.push(BinaryOperatorToken.leftOuterJoin(operator))\n        } else {\n          tokens.push(BinaryOperatorToken.rightOuterJoin(operator))\n        }\n        rest = rest.slice(3)\n        selectionExpected = false\n      }\n      // operators of 2 characters\n      else if (rest.startsWith('<*') || rest.startsWith('*>')) {\n        const operator: IndexedString = rest.slice(0, 2)\n        // checks whether the cursor was reached\n        if (operator.getLastIndex() === cursorIndex - 1) {\n          whispers = [...this.relations.keys()]\n        }\n\n        if (rest.startsWith('<*')) {\n          tokens.push(BinaryOperatorToken.leftSemijoin(operator))\n        } else {\n          tokens.push(BinaryOperatorToken.rightSemijoin(operator))\n        }\n        rest = rest.slice(2)\n        selectionExpected = false\n      }\n      // operators of 1 character\n      else if ('*\\u2a2f\\u222a\\u2229\\\\\\u22b3\\u22b2\\u00f7'.includes(rest.charAt(0))) {\n        const operator: IndexedString = rest.slice(0, 1)\n        // checks whether the cursor was reached\n        if (operator.getLastIndex() === cursorIndex - 1) {\n          whispers = [...this.relations.keys()]\n        }\n\n        if (rest.startsWith('*')) {\n          tokens.push(BinaryOperatorToken.naturalJoin(operator))\n        } else if (rest.startsWith('\\u2a2f')) {\n          tokens.push(BinaryOperatorToken.cartesianProduct(operator))\n        } else if (rest.startsWith('\\u222a')) {\n          tokens.push(BinaryOperatorToken.union(operator))\n        } else if (rest.startsWith('\\u2229')) {\n          tokens.push(BinaryOperatorToken.intersection(operator))\n        } else if (rest.startsWith('\\\\')) {\n          tokens.push(BinaryOperatorToken.difference(operator))\n        } else if (rest.startsWith('\\u22b3')) {\n          tokens.push(BinaryOperatorToken.leftAntijoin(operator))\n        } else if (rest.startsWith('\\u22b2')) {\n          tokens.push(BinaryOperatorToken.rightAntijoin(operator))\n        } else if (rest.startsWith('\\u00f7')) {\n          tokens.push(BinaryOperatorToken.division(operator))\n        }\n        rest = rest.slice(1)\n        selectionExpected = false\n      }\n      // '<' can be a rename or left theta semi join - this \"if\" must be after <*\n      else if (rest.startsWith('<')) {\n        try {\n          const split = IndexedStringUtils.nextBorderedPart(rest, '<', '>', '-')\n          // saves parentheses\n          pushParentheses(split.first)\n          // checks whether the cursor was reached\n          if (split.first.getLastIndex() === cursorIndex - 1) {\n            whispers = [...this.relations.keys()]\n          }\n          tokens.push(UnaryOperatorToken.rename(split.first))\n          selectionExpected = true\n          rest = split.second\n        }\n        // catches error from nextBorderedPart\n        catch (err) {\n          // saves error\n          if (err instanceof ErrorWithTextRange) {\n            handleError(err)\n          }\n          // it fakes the unclosed expression part as a rename operator\n          tokens.push(UnaryOperatorToken.rename(rest.concat(IndexedString.new('>', rest.getLastIndex() + 1))))\n          // breaks the while cycle as all was used\n          break\n        }\n      }\n      // '⟨' can be a rename or left theta semi join - this \"if\" must be after <*\n      else if (rest.startsWith('\\u27e8')) {\n        try {\n          const split = IndexedStringUtils.nextBorderedPart(rest, '\\u27e8', ']')\n          // saves parentheses\n          pushParentheses(split.first)\n          // checks whether the cursor was reached\n          if (split.first.getLastIndex() === cursorIndex - 1) {\n            whispers = [...this.relations.keys()]\n          }\n          tokens.push(BinaryOperatorToken.leftThetaSemijoin(split.first))\n          selectionExpected = false\n          rest = split.second\n        }\n        // catches error from nextBorderedPart\n        catch (err) {\n          // saves error\n          if (err instanceof ErrorWithTextRange) {\n            handleError(err)\n          }\n          // it fakes the unclosed expression part as a theta join operator\n          tokens.push(BinaryOperatorToken.leftThetaSemijoin(rest.concat(IndexedString.new(']', rest.getLastIndex() + 1))))\n          // breaks the while cycle as all was used\n          break\n        }\n      }\n      // RELATION REFERENCE\n      else if (StringUtils.isLetter(rest.charAt(0)) || rest.charAt(0) === '_') {\n        const split = IndexedStringUtils.nextName(rest)\n\n        // checks whether the cursor was reached in the relation reference string\n        if (split.first.getFirstIndex() <= cursorIndex - 1 && cursorIndex - 1 <= split.first.getLastIndex()) {\n          whispers = [...this.relations.keys()]\n        }\n\n        tokens.push(new RelationToken(split.first))\n        rest = split.second\n        selectionExpected = true\n      }\n      // WHITE SPACE\n      else if (/\\s/.exec(rest.charAt(0))) {\n        let i = 0\n        while (i < rest.length() && (/\\s/.exec(rest.charAt(i)))) {\n          if (rest.indexAt(i) === cursorIndex - 1) {\n            whispers = [...this.relations.keys()]\n          }\n          ++i\n        }\n        rest = rest.slice(i)\n      }\n      // UNEXPECTED PART\n      else {\n        const split = IndexedStringUtils.nextNonWhitespacePart(rest)\n        handleError(ErrorFactory.syntaxError(language().syntaxErrors.exprParser_unexpectedPart,\n                    split.first.getRange(), split.first.toString()))\n        // tries to skip first unexpected character\n        rest = rest.slice(split.first.length())\n      }\n    }\n    return { tokens, whispers, errors, parentheses }\n  }\n\n  /**\n     * Checks the validity of the given infix token array. If doThrow is false, pushes found errors to the given errors\n     * array. Fake tokens are relations with empty name \"\", or natural joins \"*\", their error ranges are undefined.\n     * All faked errors are pushed in given errors array.\n     * Expects validly nested parentheses: yes \"(()())\", no \")()\", \")(\". Expects not empty array.\n     *\n     * @param tokens token array to check\n     * @param doThrow whether to throw found errors\n     * @param errors array for pushing faked errors for NOT_THROW type\n     */\n  assertValidInfixTokens (tokens: ExprToken[], doThrow = true, errors: ErrorWithTextRange[] = []): void {\n    /**\n         * Handles the error described by given error code, params and range. If doThrow is true, throws the described\n         * error. Otherwise, fakes it by inserting a new token at given index. The token is binary (natural join) if\n         * missing is \"binary\", otherwise, it is a relation with empty name.\n         */\n    const handleError = (index: number, missing: 'binary' | 'relation',\n                             msg: string[], range: StartEndPair | undefined, ...params: string[]) => {\n      const error = ErrorFactory.syntaxError(msg, range, ...params)\n      if (doThrow) {\n        throw error\n      } else if (missing === 'binary') {\n        errors.push(error)\n        tokens.splice(index, 0, BinaryOperatorToken.naturalJoin(IndexedString.new('*')))\n      } else {\n        errors.push(error)\n        tokens.splice(index, 0, new RelationToken(IndexedString.new('')))\n      }\n    }\n\n    // checks start of an array: it must start with '(' or relation\n    if (tokens[0] instanceof UnaryOperatorToken || tokens[0] instanceof BinaryOperatorToken || tokens[0] instanceof ClosingParenthesis) {\n      handleError(0, 'relation', language().syntaxErrors.exprParser_invalidStart,\n                tokens[0].getRange(), tokens[0].str.toString())\n    }\n\n    // checks end of an array: it must end with ')', relation or an unary operator\n    if (tokens[tokens.length - 1] instanceof OpeningParenthesis || tokens[tokens.length - 1] instanceof BinaryOperatorToken) {\n      handleError(tokens.length, 'relation', language().syntaxErrors.exprParser_invalidEnd,\n                tokens[tokens.length - 1].getRange(), tokens[tokens.length - 1].str.toString())\n    }\n\n    // checks adjacent pairs of tokens\n    let i2 = 1\n    while (i2 < tokens.length) {\n      const token1: ExprToken = tokens[i2 - 1]\n      const token2: ExprToken = tokens[i2]\n\n      // valid predecessors: binary operator or '('\n      if (token2 instanceof RelationToken) {\n        if (token1 instanceof RelationToken) {\n          handleError(i2, 'binary', language().syntaxErrors.exprParser_relationAfterRelation,\n                        token2.getRange(), token2.str.toString(), token1.str.toString())\n        }\n        if (token1 instanceof UnaryOperatorToken) {\n          handleError(i2, 'binary', language().syntaxErrors.exprParser_relationAfterUnary,\n                        token2.getRange(), token2.str.toString(), token1.str.toString())\n        }\n        if (token1 instanceof ClosingParenthesis) {\n          handleError(i2, 'binary', language().syntaxErrors.exprParser_relationAfterClosing,\n                        token2.getRange(), token2.str.toString())\n        }\n      }\n      // valid predecessors: relation, unary operator or ')'\n      else if (token2 instanceof UnaryOperatorToken) {\n        if (token1 instanceof BinaryOperatorToken) {\n          handleError(i2, 'relation', language().syntaxErrors.exprParser_unaryAfterBinary,\n                        token2.getRange(), token2.str.toString(), token1.str.toString())\n        }\n        if (token1 instanceof OpeningParenthesis) {\n          handleError(i2, 'relation', language().syntaxErrors.exprParser_unaryAfterOpening,\n                        token2.getRange(), token2.str.toString())\n        }\n      }\n      // valid predecessors: relation, unary operator or ')'\n      else if (token2 instanceof BinaryOperatorToken) {\n        if (token1 instanceof BinaryOperatorToken) {\n          handleError(i2, 'relation', language().syntaxErrors.exprParser_binaryAfterBinary,\n                        token2.getRange(), token2.str.toString(), token1.str.toString())\n        }\n        if (token1 instanceof OpeningParenthesis) {\n          handleError(i2, 'relation', language().syntaxErrors.exprParser_binaryAfterOpening,\n                        token2.getRange(), token2.str.toString())\n        }\n      }\n      // valid predecessors: binary operator or '('\n      else if (token2 instanceof OpeningParenthesis) {\n        if (token1 instanceof RelationToken) {\n          handleError(i2, 'binary', language().syntaxErrors.exprParser_openingAfterRelation,\n                        token2.getRange(), token1.str.toString())\n        }\n        if (token1 instanceof UnaryOperatorToken) {\n          handleError(i2, 'binary', language().syntaxErrors.exprParser_openingAfterUnary,\n                        token2.getRange(), token1.str.toString())\n        }\n        if (token1 instanceof ClosingParenthesis) {\n          handleError(i2, 'binary', language().syntaxErrors.exprParser_openingAfterClosing,\n                        token2.getRange())\n        }\n      }\n      // valid predecessors: relation, unary operator or ')'\n      else if (token2 instanceof ClosingParenthesis) {\n        if (token1 instanceof BinaryOperatorToken) {\n          handleError(i2, 'relation', language().syntaxErrors.exprParser_closingAfterBinary,\n                        token2.getRange(), token1.str.toString())\n        }\n        if (token1 instanceof OpeningParenthesis) {\n          handleError(i2, 'relation', language().syntaxErrors.exprParser_closingAfterOpening,\n                        token2.getRange())\n        }\n      } else {\n        throw ErrorFactory.codeError(language().codeErrors.exprParser_unexpectedToken, JSON.stringify(token2))\n      }\n      ++i2\n    }\n  }\n\n  /**\n     * Transforms given infix relation algebra expression into postfix (reverse polish) form.\n     * Throws error when invalid parentheses structure is given.\n     *\n     * @param tokens infix relational algebra expression as Token array\n     * @return postfix (reverse polish) form of given array\n     */\n  toRPN (tokens: ExprToken[]): ExprToken[] {\n    const rpnQueue: ExprToken[] = []\n    const operatorsStack: Array<BinaryOperatorToken | ParenthesisToken> = []\n    tokens.forEach(token => {\n      if (token instanceof RelationToken || token instanceof UnaryOperatorToken) {\n        rpnQueue.push(token)\n      } else if (token instanceof BinaryOperatorToken) {\n        while (operatorsStack.length > 0 && operatorsStack[operatorsStack.length - 1] instanceof BinaryOperatorToken) {\n          // @ts-ignore (token must be of BinaryOperatorToken class)\n          const other: BinaryOperatorToken = operatorsStack[operatorsStack.length - 1]\n          // all used operators have left associativity\n          if (token.precedence <= other.precedence) {\n            // @ts-ignore (token must be present)\n            rpnQueue.push(operatorsStack.pop())\n          } else {\n            break\n          }\n        }\n        operatorsStack.push(token)\n      } else if (token instanceof OpeningParenthesis) {\n        operatorsStack.push(token)\n      } else if (token instanceof ClosingParenthesis) {\n        while (true) {\n          if (operatorsStack.length === 0) {\n            throw ErrorFactory.syntaxError(language().syntaxErrors.exprParser_invalidParentheses,\n                            undefined)\n          }\n          if (operatorsStack[operatorsStack.length - 1] instanceof OpeningParenthesis) {\n            operatorsStack.pop()\n            break\n          }\n          // @ts-ignore (token must be present)\n          rpnQueue.push(operatorsStack.pop())\n        }\n      }\n    })\n    while (operatorsStack.length > 0) {\n      // @ts-ignore (token must be present)\n      const curToken: ExprToken = operatorsStack.pop()\n      if (curToken instanceof OpeningParenthesis) {\n        throw ErrorFactory.syntaxError(language().syntaxErrors.exprParser_invalidParentheses,\n                    undefined)\n      } else {\n        rpnQueue.push(curToken)\n      }\n    }\n    return rpnQueue\n  }\n\n  /**\n     * Creates a RA expression evaluating tree from the given array of tokens in reverse polish form.\n     * Wraps recursive function rpnToRATreeRecursive(tokens).\n     * Possible errors:\n     * - not all tokens were used (invalid RPN structure was given, should not happen if the previous infix structure\n     * was asserted/faked) - if doThrow = false, returns a RelationNode with an empty relation\n     * - reference to a relation which does not exist found - if doThrow = false, replaces it with an empty relation\n     *\n     * @param tokens value-evaluating expression in reverse polish form\n     * @param doThrow if true and an error occurs, throws an error, if false and an error occurs, fakes it and does\n     * not throw\n     * @param errors array to store found errors when doThrow = false\n     * @return RATreeNode tree (its root)\n     */\n  rpnToRATree (tokens: ExprToken[], doThrow = true, errors: ErrorWithTextRange[] = []): RATreeNode {\n    const ret: RATreeNode = this.rpnToRATreeRecursive(tokens, doThrow, errors)\n    // not all tokens were used\n    if (tokens.length > 0) {\n      if (doThrow) {\n        throw ErrorFactory.syntaxError(language().syntaxErrors.exprParser_invalidExpression, undefined)\n      } else {\n        return new RelationNode(new Relation(''))\n      }\n    }\n    return ret\n  }\n\n  /**\n     * Helper function for rpnToRATree.\n     */\n  rpnToRATreeRecursive (tokens: ExprToken[], doThrow: boolean, errors: ErrorWithTextRange[]): RATreeNode {\n    if (tokens.length === 0) {\n      throw ErrorFactory.syntaxError(language().syntaxErrors.exprParser_invalidExpression, undefined)\n    }\n    // @ts-ignore (there must be a token)\n    const token: ExprToken = tokens.pop()\n    // RELATION REFERENCE\n    if (token instanceof RelationToken) {\n      const relation: Relation | undefined = this.relations.get(token.str.toString())\n      // when the relation does not exist, throws or fakes it with an empty relation\n      if (relation === undefined) {\n        const error = ErrorFactory.semanticError(language().semanticErrors.exprParser_relationNotDefined,\n                    token.getRange(), token.str.toString())\n        if (doThrow) {\n          throw error\n        } else {\n          errors.push(error)\n          return new RelationNode(new Relation(''))\n        }\n      }\n      return new RelationNode(relation)\n    }\n    // UNARY OPERATORS\n    if (token instanceof UnaryOperatorToken) {\n      const subtree: RATreeNode = this.rpnToRATreeRecursive(tokens, doThrow, errors)\n      // @ts-ignore\n      return RATreeFactory.createUnary(token.type, subtree, this.nullValuesSupport, token.str)\n    }\n    // BINARY OPERATORS\n    if (token instanceof BinaryOperatorToken) {\n      const right: RATreeNode = this.rpnToRATreeRecursive(tokens, doThrow, errors)\n      const left: RATreeNode = this.rpnToRATreeRecursive(tokens, doThrow, errors)\n      // @ts-ignore\n      return RATreeFactory.createBinary(token.type, left, right, this.nullValuesSupport, token.str)\n    }\n    // should never happen\n    throw ErrorFactory.codeError(language().codeErrors.exprParser_unexpectedToken, JSON.stringify(token))\n  }\n}\n","import React from 'react'\n\n/**\n * Props of TextInput component.\n * @category Components\n * @public\n */\ninterface TextInputProps {\n  /**\n     * initial value for the input\n     * @type string\n     * @public\n     */\n  value: string\n  /**\n     * text on the submit button\n     * @type string\n     * @public\n     */\n  buttonText: string\n  /**\n     * handler of input submit\n     * @type function\n     * @public\n     */\n  onSubmit: (text: string) => void\n  /**\n     * function which returns true for forbidden inputs which cannot be submitted\n     * @type function\n     * @public\n     */\n  forbidden: (text: string) => boolean\n  /**\n     * id of the input\n     * @type string\n     * @public\n     */\n  id: string\n}\n\ninterface TextInputState {\n  value: string\n  buttonDisable: boolean\n}\n\n/**\n * Basic text input with submit button (without label). The input cannot be submit if the current value is forbidden.\n * All inserted tabulators are replaced by 4 spaces.\n * Accepts {@link TextInputProps} props.\n * @category Components\n * @public\n */\nexport class TextInput extends React.Component<TextInputProps, TextInputState> {\n\n  private readonly inputRef: React.RefObject<HTMLInputElement>\n\n  constructor (props: TextInputProps) {\n    super(props)\n    this.state = {\n      value: this.props.value,\n      buttonDisable: this.props.forbidden(this.props.value),\n    }\n    this.inputRef = React.createRef()\n  }\n\n  componentDidUpdate (prevProps: Readonly<TextInputProps>) {\n    if (prevProps.value !== this.props.value) {\n      this.setState({ value: this.props.value })\n    }\n  }\n\n  private readonly handleChange = (value: string): void => {\n    value = value.replace(/\\t/g, '    ')\n    const disable: boolean = this.props.forbidden(value)\n    this.setState({\n      value: value,\n      buttonDisable: disable,\n    })\n  }\n\n  private readonly handleKeyDown = (event: React.KeyboardEvent<HTMLInputElement>): void => {\n    if (event.key === 'Enter') {\n      if (!this.state.buttonDisable) {\n        this.handleSubmit()\n      }\n    } else if (event.key === 'Escape' || event.key === 'Esc') {\n      if (this.inputRef.current !== null) {\n        this.inputRef.current.blur()\n      }\n    }\n  }\n\n  private readonly handleSubmit = (): void => {\n    this.props.onSubmit(this.state.value)\n  }\n\n  render () {\n    return (\n      <>\n        <input\n          ref={this.inputRef}\n          type='text'\n          id={this.props.id}\n          spellCheck={false}\n          autoComplete={'off'}\n          value={this.state.value}\n          onChange={event => this.handleChange(event.target.value)}\n          onKeyDown={this.handleKeyDown}\n          className={'text-input'}\n        />\n        <button\n          onClick={this.handleSubmit}\n          disabled={this.state.buttonDisable}\n        >{this.props.buttonText}</button>\n      </>\n    )\n  }\n}\n","import './css/messageBox.css'\n\n// @ts-ignore\nconst cssConstants: CSSStyleDeclaration = getComputedStyle(document.querySelector(':root'))\nconst boxMargin = Number(cssConstants.getPropertyValue('--message-box-margin-num'))\n\n/**\n * Class for displaying messages and errors to the user in a pop-up box.\n * @category Components\n * @public\n */\nexport class MessageBox {\n\n  private static readonly hideTimeout: number = 5000\n\n  private static readonly box: HTMLDivElement = MessageBox.init()\n  private static hideIntervalId: NodeJS.Timeout\n\n  private static init (): HTMLDivElement {\n    const box = document.createElement('div')\n    box.classList.add('message-box')\n    box.style.visibility = 'hidden'\n    box.onmouseenter = () => {\n      MessageBox.clearHideTimeout()\n    }\n    box.onmouseleave = () => {\n      MessageBox.setHideTimeout()\n    }\n\n    const paragraph = document.createElement('p')\n    box.appendChild(paragraph)\n\n    const button = document.createElement('button')\n    button.innerText = '\\u2716'\n    button.onclick = () => {\n      MessageBox.hideBox()\n    }\n    box.appendChild(button)\n\n    window.addEventListener('resize', () => {\n      MessageBox.moveBox()\n    })\n\n    document.body.appendChild(box)\n    return box\n  }\n\n  private static readonly setHideTimeout = () => {\n    // clears previous hide interval\n    MessageBox.clearHideTimeout()\n    MessageBox.hideIntervalId = setTimeout(MessageBox.hideBox, MessageBox.hideTimeout)\n  }\n\n  private static readonly clearHideTimeout = () => {\n    clearTimeout(MessageBox.hideIntervalId)\n  }\n\n  private static readonly hideBox = () => {\n    MessageBox.box.style.visibility = 'hidden'\n  }\n\n  private static readonly moveBox = () => {\n    if (MessageBox.box.style.visibility === 'visible') {\n      MessageBox.box.style.width = (document.body.clientWidth - 2 * boxMargin) + 'px'\n    }\n  }\n\n  private static display (msg: string, error: boolean): void {\n    const box = MessageBox.box\n    // @ts-ignore - first element is paragraph\n    box.firstElementChild.innerText = msg\n    box.style.visibility = 'visible'\n    box.classList.toggle('message-box-message', !error)\n    box.classList.toggle('message-box-error', error)\n    MessageBox.moveBox()\n    MessageBox.setHideTimeout()\n  }\n\n  /**\n     * Displays given message in a message box fixed on the page bottom.\n     * @param msg message to display {@type string}\n     * @public\n     */\n  static message (msg: string): void {\n    MessageBox.display(msg, false)\n  }\n\n  /**\n     * Displays given error in a message box fixed on the page bottom.\n     * @param msg error to display {@type string}\n     * @public\n     */\n  static error (msg: string): void {\n    MessageBox.display(msg, true)\n  }\n}\n","import React from 'react'\nimport './css/expressionSection.css'\nimport { Relation } from '../relation/relation'\nimport { TooltipButton } from './tooltipButton'\nimport { RASyntaxError } from '../error/raSyntaxError'\nimport { RASemanticError } from '../error/raSemanticError'\nimport { LocatedError, XTextArea } from './xTextArea'\nimport { ExprParser } from '../expression/exprParser'\nimport { getStartOfWordBeforeIndex, sortWhispers } from '../utils/whisperUtils'\nimport { Expression } from '../expression/expression'\nimport { TextInput } from './textInput'\nimport { ErrorWithTextRange } from '../error/errorWithTextRange'\nimport { RATreeNode } from '../ratree/raTreeNode'\nimport { MessageBox } from './messageBox'\nimport { LanguageDef } from '../language/language'\nimport { StartEndPair } from '../types/startEndPair'\n\n/**\n * Props of ExpressionSection component.\n * @category Components\n * @public\n */\ninterface ExpressionSectionProps {\n  /**\n     * available expressions\n     * @type Expression[]\n     * @public\n     */\n  expressions: Expression[]\n  /**\n     * index of the current selected expression in the expression list\n     * @type number\n     * @public\n     */\n  currentExpressionIndex: number\n  /**\n     * loaded relations user as sources for expression evaluation\n     * @type Map<String, Relation>\n     * @public\n     */\n  relations: Map<string, Relation>,\n  /**\n     * handler of selecting different expression as current\n     * @type function\n     * @public\n     */\n  onSelectDifferentExpression: (newIndex: number) => void\n  /**\n     * handler of moving an expression on a new position using drag and drop\n     * @type function\n     * @public\n     */\n  onDragExpression: (from: number, to: number) => void,\n  /**\n     * handler of creating the new expression\n     * @type function\n     * @public\n     */\n  onNewExpression: () => void\n  /**\n     * handler of deleting the current expression\n     * @type function\n     * @public\n     */\n  onDeleteExpression: (onDone: () => void) => void\n  /**\n     * handler of saving the expressions\n     * @type function\n     * @public\n     */\n  onExportExpressions: (onDone: (msg: string) => void) => void\n  /**\n     * handler of loading the expressions\n     * @type function\n     * @public\n     */\n  onImportExpressions: (onDone: (msg: string) => void) => void\n  /**\n     * handler of change in the current selected expression\n     * @type function\n     * @public\n     */\n  onChange: (name: string, text: string) => void,\n  /**\n     * handler of evaluation, it accepts the parsed tree from the expression text\n     * @type function\n     * @public\n     */\n  onEval: (tree: RATreeNode) => void\n  /**\n     * handler of unexpected errors\n     * @type function\n     * @public\n     */\n  onUnexpectedError: (e: Error) => void\n  /**\n     * whether to support null values\n     * @type boolean\n     * @public\n     */\n  nullValuesSupport: boolean\n  /**\n     * true if dark theme should be applied\n     * @type boolean\n     * @public\n     */\n  darkTheme: boolean\n  /**\n     * current application language\n     * @type LanguageDef\n     * @public\n     */\n  language: LanguageDef\n}\n\ninterface ExpressionSectionState {\n  sectionClicked: boolean\n  whispers: string[]\n  errors: LocatedError[]\n  parentheses: StartEndPair[]\n  cursorIndex: number\n}\n\n/**\n * Identifier of elements drag-and-dropped from the ExpressionSection.\n */\nconst dndId = 'E'\n\n/**\n * Section to edit, manage, and eval relational algebra expressions.\n * Accepts {@link ExpressionSectionProps} props.\n * @category Components\n * @public\n */\nexport class ExpressionSection extends React.Component<ExpressionSectionProps, ExpressionSectionState> {\n\n  // reference to child textarea element\n  private readonly textAreaRef: React.RefObject<XTextArea>\n  // timestamp of last expression text change\n  private lastChange = 0\n  // timestamp of last display of whispers and errors\n  private lastWhisperAndErrorsUpdate = 0\n  // update rate of whispers and errors (in ms)\n  private readonly whispersAndErrorsUpdateRate: number = 400\n\n  constructor (props: ExpressionSectionProps) {\n    super(props)\n    this.state = {\n      sectionClicked: false,\n      whispers: [],\n      errors: [],\n      parentheses: [],\n      cursorIndex: 0,\n    }\n    this.textAreaRef = React.createRef<XTextArea>()\n    setInterval(() => this.updateWhispersAndErrors(), this.whispersAndErrorsUpdateRate)\n  }\n\n  componentDidUpdate (prevProps: Readonly<ExpressionSectionProps>) {\n    if (this.props.language !== prevProps.language) {\n      const textarea = this.textAreaRef.current\n      if (textarea !== null) {\n        textarea.setPlaceholder(this.props.language.expressionSection.expressionTextareaPlaceholder)\n      }\n    }\n  }\n\n  /**\n     * Updates displayed errors and parentheses pairs in the text area input.\n     * @public\n     */\n  updateErrorsAndParentheses = () => {\n    const text = this.getCurExpr().text\n    const exprParser: ExprParser = new ExprParser(this.props.relations, this.props.nullValuesSupport)\n    const { errors, parentheses } = exprParser.fakeParse(text, this.state.cursorIndex)\n    this.setState({\n      errors: errors.filter(err => err.range !== undefined && !isNaN(err.range.start) && !isNaN(err.range.end))\n      // @ts-ignore\n        .map(err => { return { start: err.range.start, end: err.range.end + 1, msg: err.message } }),\n      parentheses: parentheses.filter(p => !isNaN(p.start) && !isNaN(p.end)),\n    })\n  }\n\n  private getCurExpr (): Expression {\n    return this.props.expressions[this.props.currentExpressionIndex]\n  }\n\n  private handleSelectDifferentExpression (index: number): void {\n    this.props.onSelectDifferentExpression(index)\n  }\n\n  private readonly evalExpr = (): void => {\n    try {\n      const exprParser: ExprParser = new ExprParser(this.props.relations, this.props.nullValuesSupport)\n      const tree = exprParser.parse(this.props.expressions[this.props.currentExpressionIndex].text)\n      tree.eval()\n      this.setState({ errors: [] })\n      this.props.onEval(tree)\n    } catch (err) {\n      if (err instanceof ErrorWithTextRange) {\n        if (err.range !== undefined) {\n          // change end to also highlight the last char\n          err.range.end += 1\n          this.setState(state => {\n            const errorRanges = state.errors\n            // does not push duplicate error range\n            if (errorRanges.every(er => er.start !== err.range.start || er.end !== err.range.end)) {\n              errorRanges.push({ ...err.range, msg: err.message })\n            }\n            return { errors: errorRanges }\n          })\n        }\n      }\n      this.showError(err)\n    }\n  }\n\n  private readonly newExpression = (): void => {\n    this.props.onNewExpression()\n  }\n\n  private readonly deleteExpression = (): void => {\n    this.props.onDeleteExpression(this.updateErrorsAndParentheses)\n  }\n\n  private readonly exportExpressions = (): void => {\n    this.props.onExportExpressions(MessageBox.message)\n  }\n\n  private readonly importExpressions = (): void => {\n    this.props.onImportExpressions((msg) => {\n      MessageBox.message(msg)\n      this.updateErrorsAndParentheses()\n    })\n  }\n\n  /**\n     * Adds given special string into RA expression at the current cursor position.\n     *\n     * @param str string to be added\n     * @param shift move of the cursor from added string end position (to the beginning)\n     */\n  private readonly addSpecialString = (str: string, shift: number): void => {\n    // @ts-ignore\n    const { start, end } = this.textAreaRef.current.getSelection()\n    const firstPart: string = this.getCurExpr().text.substring(0, start)\n    const secondPart: string = this.getCurExpr().text.substring(end)\n    const newPosition: number = firstPart.length + str.length - shift\n    const newStr: string = firstPart + str + secondPart\n    // updates text in textarea\n    this.handleExprChange(newStr, newPosition, () => {\n      // @ts-ignore - moves cursor to expected position\n      this.textAreaRef.current.setSelection(newPosition)\n      // @ts-ignore\n      this.textAreaRef.current.focus()\n    })\n  }\n\n  /**\n     * Handles change of expression text. Updates text and notifies the parent.\n     *\n     * @param text\n     * @param cursorIndex\n     * @param onDone callback after updating the state\n     */\n  private readonly handleExprChange = (text: string, cursorIndex: number, onDone: () => void = () => {}): void => {\n    this.props.onChange(this.getCurExpr().name, text)  // must be called before setState for proper functionality of XTextArea\n    this.setState({ cursorIndex: cursorIndex }, onDone)\n    this.lastChange = Date.now()\n  }\n\n  /**\n     * Handles input with Ctrl key pressed from textarea.\n     */\n  private readonly handleCtrlInput = (ev: KeyboardEvent): void => {\n    if (ev.key === 'Enter') {\n      this.evalExpr()\n    }\n  }\n\n  /**\n     * Shows current whispers and errors, if the text area is focused and there was a text change after last update.\n     */\n  private readonly updateWhispersAndErrors = () => {\n    const textArea = this.textAreaRef.current\n    if (textArea !== null && textArea.isFocused() && this.lastChange > this.lastWhisperAndErrorsUpdate) {\n      const text = this.getCurExpr().text\n      const exprParser: ExprParser = new ExprParser(this.props.relations, this.props.nullValuesSupport)\n      const fakeParseResult = exprParser.fakeParse(text, this.state.cursorIndex)\n      const wordBeforeCursor: string = text.slice(getStartOfWordBeforeIndex(text, this.state.cursorIndex), this.state.cursorIndex)\n      const whispers = sortWhispers(fakeParseResult.whispers, wordBeforeCursor)\n      this.setState({\n        whispers: whispers,\n        errors: fakeParseResult.errors.filter(err => err.range !== undefined && !isNaN(err.range.start) && !isNaN(err.range.end))\n        // @ts-ignore\n          .map(err => { return { start: err.range.start, end: err.range.end + 1, msg: err.message } }),\n        parentheses: fakeParseResult.parentheses.filter(p => !isNaN(p.start) && !isNaN(p.end)),\n      })\n      this.lastWhisperAndErrorsUpdate = Date.now()\n    }\n  }\n\n  private readonly handleExprNameChange = (name: string) => {\n    this.props.onChange(name, this.getCurExpr().text)\n  }\n\n  /**\n     * Handles and shows the given error. If the error is not of RASyntaxError or RASemanticError class, it is passed\n     * to the parent as unexpected error.\n     *\n     * @param err the error to handle\n     */\n  private readonly showError = (err: Error) => {\n    // common user's errors\n    if (err instanceof RASyntaxError || err instanceof RASemanticError) {\n      MessageBox.error(err.message)\n    } else {\n      this.props.onUnexpectedError(err)\n      MessageBox.error('UNEXPECTED ERROR: ' + err.message + '\\n'\n                + 'Please, help us and report your last actions, thank you!')\n    }\n  }\n\n  /**\n     * Requests expressions move when the drag ends.\n     */\n  // @ts-ignore\n  private readonly handleDragDrop = (e: DragEvent<HTMLDivElement>, i: number) => {\n    e.preventDefault()\n    const data = e.dataTransfer.getData('text/plain')\n    const fromIndex = Number(data.slice(1))\n    if (data.charAt(0) === dndId && !isNaN(fromIndex)) {\n      this.props.onDragExpression(fromIndex, i)\n    }\n  }\n\n  render () {\n    const lang = this.props.language.expressionSection\n    const ops = this.props.language.operations\n\n    const createExprMenuButtons = () => {\n      return this.props.expressions.map((expr, i) => {\n        const className: string = (this.props.currentExpressionIndex === i ? 'button-clicked' : '')\n        return (<button\n          key={i}\n          onClick={() => this.handleSelectDifferentExpression(i)}\n          className={className}\n          draggable={true}\n          onDragStart={e => e.dataTransfer.setData('text/plain', dndId + String(i))}\n          onDragOver={e => e.preventDefault()}\n          onDrop={e => this.handleDragDrop(e, i)}\n        >{expr.name}</button>)\n      })\n    }\n\n    const createButton = (text: string, onClick: () => void, tooltip: string, style?: React.CSSProperties) => {\n      return (<TooltipButton\n        key={text}\n        text={text}\n        onClick={onClick}\n        style={style}\n        tooltip={tooltip}\n      />)\n    }\n\n    const createOpButton = (key: string, char: string, text: string, tooltip: string, shift: number, style: React.CSSProperties = {}) => {\n      return (<TooltipButton\n        key={key}\n        text={text}\n        onClick={() => this.addSpecialString(char, shift)}\n        tooltip={tooltip}\n        style={style}\n      />)\n    }\n    const buttonGroupMargin = { marginRight: '10px' }\n\n    return (\n      <section className=\"page-section\">\n        <header>\n          <h2>{lang.expressionSectionHeader}</h2>\n          {createButton(lang.importButton, this.importExpressions, lang.importButtonTooltip)}\n          {createButton(lang.exportButton, this.exportExpressions, lang.exportButtonTooltip)}\n        </header>\n\n        <menu className=\"page-section-tab-menu\">\n          {createExprMenuButtons()}\n          <button onClick={this.newExpression}\n            style={{ minWidth: '0', marginLeft: '10px', padding: '2px 6px 1px 6px' }}>\n            <strong>+</strong>\n          </button>\n        </menu>\n\n        <XTextArea\n          ref={this.textAreaRef}\n          id=\"expression-section-textarea\"\n          text={this.getCurExpr().text}\n          placeholder={lang.expressionTextareaPlaceholder}\n          errors={this.state.errors}\n          whispers={this.state.whispers}\n          parentheses={this.state.parentheses}\n\n          onChange={this.handleExprChange}\n          onCtrlInput={this.handleCtrlInput}\n\n          darkTheme={this.props.darkTheme}\n        />\n\n        <menu className=\"expressions-operators-menu\">\n          {createOpButton('unary_a', '()', '()', ops.selection, 1)}\n          {createOpButton('unary_b', '[]', '[]', ops.projection, 1)}\n          {createOpButton('unary_c', '< -> >', '<>', ops.rename, 5, buttonGroupMargin)}\n\n          {createOpButton('set_a', '\\u222a', '\\u222a', ops.union, 0)}\n          {createOpButton('set_b', '\\u2229', '\\u2229', ops.intersection, 0)}\n          {createOpButton('set_c', '\\\\', '\\\\', ops.difference, 0, buttonGroupMargin)}\n\n          {createOpButton('inner_a', '*', '*', ops.naturalJoin, 0)}\n          {createOpButton('inner_b', '\\u2a2f', '\\u2a2f', ops.cartesianProduct, 0)}\n          {createOpButton('inner_c', '<*', '<*', ops.leftSemiJoin, 0)}\n          {createOpButton('inner_d', '*>', '*>', ops.rightSemiJoin, 0)}\n          {createOpButton('inner_e', '\\u22b3', '\\u22b3', ops.leftAntijoin, 0)}\n          {createOpButton('inner_f', '\\u22b2', '\\u22b2', ops.rightAntijoin, 0)}\n          {createOpButton('inner_g', '[]', '[]', ops.thetaJoin, 1)}\n          {createOpButton('inner_h', '\\u27e8]', '\\u27e8]', ops.leftThetaSemiJoin, 1)}\n          {createOpButton('inner_i', '[\\u27e9', '[\\u27e9', ops.rightThetaSemiJoin, 1, buttonGroupMargin)}\n\n          {this.props.nullValuesSupport && createOpButton('outer_a', '*F*', '*F*', ops.fullOuterJoin, 0)}\n          {this.props.nullValuesSupport && createOpButton('outer_b', '*L*', '*L*', ops.leftOuterJoin, 0)}\n          {this.props.nullValuesSupport && createOpButton('outer_c', '*R*', '*R*', ops.rightOuterJoin, 0, buttonGroupMargin)}\n\n          {createOpButton('division', '\\u00f7', '\\u00f7', ops.division, 0, buttonGroupMargin)}\n\n          {createOpButton('line_comment', '//', '//', lang.lineComment, 0)}\n          {createOpButton('block_comment', '/**/', '/*', lang.blockComment, 2)}\n        </menu>\n\n        <menu className=\"page-section-management-menu\">\n          <TooltipButton\n            text={lang.evaluateButton}\n            onClick={this.evalExpr}\n            className={'action-button'}\n            style={{ marginRight: '40px' }}\n            tooltip={lang.evaluateButtonTooltip}\n          />\n          <TextInput\n            value={this.getCurExpr().name}\n            buttonText={lang.renameButton}\n            onSubmit={this.handleExprNameChange}\n            forbidden={() => false}\n            id=\"expression-name-input\"\n          />\n          {createButton(lang.deleteButton, this.deleteExpression, lang.deleteButtonTooltip)}\n        </menu>\n      </section>\n    )\n  }\n}\n","import React from 'react'\nimport { Relation } from '../relation/relation'\nimport './css/resultRelationTable.css'\nimport { Row } from '../relation/row'\n\n/**\n * Props of RelationTable component.\n * @category Components\n * @public\n */\ninterface RelationTableProps {\n  /**\n     * relation to be shown\n     * @type Relation\n     * @public\n     */\n  relation: Relation\n}\n\ninterface RelationTableState {\n  // index of the column which is used to order the table (or -1 if none is used)\n  orderBy: number\n  // 1 = ascending, -1 = descending\n  orderDir: number\n}\n\n/**\n * Table which shows given relation. The relation cannot be edited\n * Rows can be ordered by column values when the column header is clicked.\n * When the same column header is clicked for the second time, the order direction is changed (asc, des, asc, des, ...).\n * Accepts {@link RelationTableProps} props.\n * @category Components\n * @public\n */\nexport class ResultRelationTable extends React.Component<RelationTableProps, RelationTableState> {\n\n  constructor (props: RelationTableProps) {\n    super(props)\n    this.state = {\n      orderBy: -1,\n      orderDir: 1,\n    }\n  }\n\n  componentDidUpdate (prevProps: Readonly<RelationTableProps>, prevState: Readonly<RelationTableState>, snapshot?: any) {\n    if (prevProps.relation !== this.props.relation) {\n      this.setState({\n        orderDir: 1,\n        orderBy: -1,\n      })\n    }\n  }\n\n  /**\n     * Updates ordering column or direction. If the given orderBy index is already selected, switches ASC/DESC order.\n     * Otherwise, sets ASC ordering by new orderBy column index.\n     */\n  private updateOrderBy (orderBy: number): void {\n    this.setState(state => {\n      if (state.orderBy === orderBy) {\n        return {\n          orderDir: -state.orderDir,\n          orderBy: orderBy,\n        }\n      } else {\n        return {\n          orderDir: 1,\n          orderBy: orderBy,\n        }\n      }\n    })\n  }\n\n  private readonly getOrderByText = (): string => {\n    return this.state.orderDir === 1 ? ' ▼' : ' ▲'\n  }\n\n  /**\n     * Creates a header row for a table (with given column names).\n     *\n     * @param columns\n     */\n  private createHeaderRow (columns: string[]) {\n    return (\n      <tr>\n        <td className=\"row-number-td\"/>\n        {columns.map((columnName, index) => {\n          const text: string = this.state.orderBy === index\n            ? (columnName + this.getOrderByText())\n            : columnName\n          return <th key={index} onClick={() => this.updateOrderBy(index)}>{text}</th>\n        })}\n      </tr>\n    )\n  }\n\n  /**\n     * Creates rows for a table. If there is no row in a resultRelation, returns one cell \"<<NO ROWS>>\".\n     *\n     * @param columns\n     */\n  private createRows (columns: string[]) {\n    // creates default row if no exists\n    if (this.props.relation.getRowsCount() === 0) {\n      return (\n        <tr key='1'>\n          <td className=\"row-number-td\"/>\n          <td key='1' colSpan={columns.length}>{'<<NO ROWS>>'}</td>\n        </tr>\n      )\n    }\n    const rows: Row[] = this.props.relation.getRows()\n    // sorts rows if orderBy is given (null values are after other values)\n    if (this.state.orderBy > -1 && this.state.orderBy < columns.length) {\n      const sortCol: string = columns[this.state.orderBy]\n      // @ts-ignore cannot be undefined\n      const type: 'string' | 'number' | 'boolean' = rows[0].getType(sortCol)\n      if (type === 'number') {\n        rows.sort((a, b) => {\n          // @ts-ignore\n          const aValue: number | null = a.getValue(sortCol)\n          // @ts-ignore\n          const bValue: number | null = b.getValue(sortCol)\n          // a is null\n          if (aValue === null && bValue !== null) {\n            return this.state.orderDir * Number.MAX_SAFE_INTEGER\n          }\n          // b is null\n          if (aValue !== null && bValue === null) {\n            return this.state.orderDir * Number.MIN_SAFE_INTEGER\n          }\n          // no is null - compares as numbers\n          if (aValue !== null && bValue !== null) {\n            // @ts-ignore\n            return this.state.orderDir * (a.getValue(sortCol) - b.getValue(sortCol))\n          }\n          // both are null\n          return 0\n        })\n      } else {\n        rows.sort((a, b) => {\n          // @ts-ignore\n          const aValue: string | boolean | null = a.getValue(sortCol)\n          // @ts-ignore\n          const bValue: string | boolean | null = b.getValue(sortCol)\n          // a is null\n          if (aValue === null && bValue !== null) {\n            return this.state.orderDir * Number.MAX_SAFE_INTEGER\n          }\n          // b is null\n          if (aValue !== null && bValue === null) {\n            return this.state.orderDir * Number.MIN_SAFE_INTEGER\n          }\n          // no is null - compares as strings\n          if (aValue !== null && bValue !== null) {\n            return this.state.orderDir * String(a.getValue(sortCol)).localeCompare(String(b.getValue(sortCol)))\n          }\n          // both are null\n          return 0\n        })\n      }\n    }\n    // creates all rows if any\n    return rows.map((row, index) => (\n      <tr key={index}>\n        <td className=\"row-number-td\">{index + 1}</td>\n        {row.getOrderedPrintValues(columns).map((value, index) => (\n          <td key={index}>{value}</td>\n        ))}\n      </tr>\n    ))\n  }\n\n  render () {\n    // creates header row\n    const columns: string[] = this.props.relation.getColumnNames()\n    const headerRow = this.createHeaderRow(columns)\n    const rows = this.createRows(columns)\n\n    return (\n      <div className=\"result-table-container scrollbar-container\">\n        <table className=\"result-table\">\n          <thead>\n            {headerRow}\n          </thead>\n          <tbody>\n            {rows}\n          </tbody>\n        </table>\n      </div>\n    )\n  }\n}\n","import React from 'react'\nimport { Group } from '@visx/group'\nimport { hierarchy, Tree } from '@visx/hierarchy'\nimport { HierarchyPointLink, HierarchyPointNode } from '@visx/hierarchy/lib/types'\nimport { LinkVertical } from '@visx/shape'\nimport ParentSize from '@visx/responsive/lib/components/ParentSize'\nimport { useTooltip } from '@visx/tooltip'\nimport './css/evaluationTree.css'\nimport { RATreeNode } from '../ratree/raTreeNode'\nimport { UnaryNode } from '../ratree/unaryNode'\nimport { BinaryNode } from '../ratree/binaryNode'\nimport { getTreeDepth } from '../ratree/raTreeTools'\nimport { computeFontSizeInPx } from '../utils/fontUtils'\n\n/**\n * Id of the SVG element for evaluation tree rendering.\n * @type string\n * @category Components\n * @public\n */\nexport const evalTreeSVGId = 'eval-tree-svg'\n\n/**\n * Props of EvaluationTree component.\n * @category Components\n * @public\n */\ninterface EvaluationTreeProps {\n  /**\n     * root of the evaluation tree to be displayed\n     * @type RATreeNode\n     * @public\n     */\n  tree: RATreeNode\n  /**\n     * index of the current selected node (with respect to depth first search)\n     * @type number\n     * @public\n     */\n  selected: number\n  /**\n     * handler of click on nodes, it receives the index of the clicked node (with respect to depth first search)\n     * @type function\n     * @public\n     */\n  onClick: (index: number) => void\n  /**\n     * true if dark theme should be applied\n     * @type boolean\n     * @public\n     */\n  darkTheme: boolean\n}\n\n/**\n * Component displaying an evaluation tree. The tree is interactive and handles clicking on the nodes.\n * Accepts {@link EvaluationTreeProps} props.\n * @category Components\n * @public\n */\nexport class EvaluationTree extends React.Component<EvaluationTreeProps, {}> {\n  render () {\n    return (\n      <ParentSize>{({ width }) =>\n        <TreeComponent\n          raTree={this.props.tree}\n          selected={this.props.selected}\n          width={width}\n          onClick={this.props.onClick}\n          darkTheme={this.props.darkTheme}\n        />}\n      </ParentSize>\n    )\n  }\n}\n\n// @ts-ignore\nconst cssConstants: CSSStyleDeclaration = getComputedStyle(document.querySelector(':root'))\n\nconst fontSize: string = cssConstants.getPropertyValue('--eval-tree-font-size')\nconst fontFamily: string = cssConstants.getPropertyValue('--eval-tree-font-family')\nconst { fontWidth, fontHeight } = computeFontSizeInPx(fontFamily, fontSize)\nconst nodePaddingX2 = 24\nconst nodeHeight = 2 * fontHeight + nodePaddingX2\nconst maxNodeTextLength = 30\n\nconst backgroundColorLight = cssConstants.getPropertyValue('--light-color-a')\nconst backgroundColorDark = cssConstants.getPropertyValue('--dark-color-a')\nconst textColorLight = cssConstants.getPropertyValue('--text-color-light')\nconst textColorDark = cssConstants.getPropertyValue('--text-color-dark')\nconst selectedNodeColorLight = cssConstants.getPropertyValue('--light-color-c')\nconst unselectedNodeColorLight = cssConstants.getPropertyValue('--light-color-b')\nconst selectedNodeColorDark = cssConstants.getPropertyValue('--dark-color-d')\nconst unselectedNodeColorDark = cssConstants.getPropertyValue('--dark-color-c')\n\n/**\n * Data for evaluation tree nodes.\n */\ninterface DisplayTreeNode {\n  title: string\n  symbol: string\n  index: number\n  children?: this[]\n}\n\n/**\n * Creates a DisplayTreeNode tree from the given RATreeNode tree.\n *\n * @param tree RATreeNode tree to parse to DisplayTreeNode tree\n * @return parsed DisplayTreeNode tree\n */\nfunction parseTreeForDisplay (tree: RATreeNode): DisplayTreeNode {\n  let indexes = 0\n  function parseTreeForDisplayHelper (node: RATreeNode): DisplayTreeNode {\n    let symbol: string = node.getOperationSymbol()\n    if (symbol.length > maxNodeTextLength) {\n      symbol = symbol.slice(0, maxNodeTextLength - 4) + '...' + symbol.charAt(symbol.length - 1)\n    }\n\n    if (node instanceof UnaryNode) {\n      return {\n        title: node.getOperationName(),\n        symbol: symbol,\n        index: indexes++,\n        children: [\n          parseTreeForDisplayHelper(node.getSubtree()),\n        ],\n      }\n    } else if (node instanceof BinaryNode) {\n      return {\n        title: node.getOperationName(),\n        symbol: symbol,\n        index: indexes++,\n        children: [\n          parseTreeForDisplayHelper(node.getLeftSubtree()),\n          parseTreeForDisplayHelper(node.getRightSubtree()),\n        ],\n      }\n    } else /* (tree instanceof RelationNode) */ {\n      return {\n        title: node.getOperationName(),\n        symbol: symbol,\n        index: indexes++,\n      }\n    }\n  }\n  return parseTreeForDisplayHelper(tree)\n}\n\n/**\n * Component representing individual nodes of the displayed tree.\n *\n * Props:\n * - node: HierarchyPointNode<DisplayTreeNode>: node to be displayed wrapped as visx HierarchyPointNode.\n * - selected: boolean: boolean whether the given node is currently selected by the user\n * - onClick: (index: number) => void: handler of click on the node, it receives the index of the node (with\n * respect to depth first search)\n */\nfunction TreeNodeComponent ({ node, selected, onClick, darkTheme }:\n{ node: HierarchyPointNode<DisplayTreeNode>, selected: boolean, onClick: (index: number) => void, darkTheme: boolean }): JSX.Element {\n  const {\n    tooltipOpen, // true when mouse is over\n    showTooltip,\n    hideTooltip,\n  } = useTooltip()\n\n  const handleMouseOver = () => {\n    showTooltip({ tooltipLeft: 0, tooltipTop: 0 })\n  }\n\n  // computes node width with respect to the text length and asserts it wider than taller\n  let nodeWidth = Math.max(node.data.title.length, node.data.symbol.length) * fontWidth + nodePaddingX2\n  if (nodeWidth < nodeHeight) {\n    nodeWidth = nodeHeight\n  }\n\n  return (\n  // top=y, left=x for vertical layout; top=x, left=y for horizontal layout\n    <Group top={node.y} left={node.x}>\n      <rect\n        height={nodeHeight} width={nodeWidth}\n        y={-nodeHeight / 2} x={-nodeWidth / 2} rx={5}\n        fill={darkTheme\n          ? (selected ? selectedNodeColorDark : (tooltipOpen ? selectedNodeColorDark : unselectedNodeColorDark))\n          : (selected ? selectedNodeColorLight : (tooltipOpen ? selectedNodeColorLight : unselectedNodeColorLight))}\n        onClick={() => {\n          onClick(node.data.index)\n        }}\n        cursor=\"pointer\"\n        onMouseOver={handleMouseOver}\n        onMouseOut={hideTooltip}\n      />\n      <text\n        y=\"-4px\"\n        dy=\".2em\"\n        fontSize={fontSize}\n        fontFamily={fontFamily}\n        textAnchor=\"middle\"\n        style={{ pointerEvents: 'none' }}\n        fill={darkTheme ? textColorDark : textColorLight}\n      >\n        {node.data.symbol === ''\n          ? <tspan x=\"0\" dy=\".5em\">{node.data.title}</tspan>\n          : (<>\n            <tspan x=\"0\" dy=\"0\">{node.data.title}</tspan>\n            <tspan x=\"0\" dy=\"1.2em\">{node.data.symbol}</tspan>\n          </>)}\n      </text>\n    </Group>\n  )\n}\n\n/**\n * Internal component for displaying the evaluation tree. It uses visx Tree component.\n *\n * Props:\n * - tree: RATreeNode: root of the evaluation tree to be displayed\n * - selected: number: index of the current selected node (with respect to depth first search)\n * - width: number: width of the parent container\n * - onClick: (index: number) => void: handler of click on nodes, it receives the index of the clicked node (with\n * respect to depth first search)\n */\nfunction TreeComponent ({ raTree, selected, width, onClick, darkTheme }:\n{raTree: RATreeNode, selected: number, width: number, onClick: (index: number) => void, darkTheme: boolean}): JSX.Element | null {\n  const treeDepth: number = getTreeDepth(raTree)\n  // height = \"nodes height\" + \"gaps between nodes\" + \"margin up and under\"\n  const height = (treeDepth + 1) * nodeHeight + treeDepth * nodeHeight / 2 + nodeHeight\n  const margin = { top: nodeHeight, left: 0 / 2, right: 0 / 2, bottom: nodeHeight }\n  const yMax = height - margin.top - margin.bottom\n  const xMax = width - margin.left - margin.right\n\n  const tree: DisplayTreeNode = parseTreeForDisplay(raTree)\n  const data = hierarchy<DisplayTreeNode>(tree)\n\n  return width < 10\n    ? null\n    : (\n      <svg id=\"eval-tree-svg\" width={width} height={height}>\n        <rect width={width} height={height} rx={14} fill={darkTheme ? backgroundColorDark : backgroundColorLight} />\n        <Tree<DisplayTreeNode> root={data} size={[xMax, yMax]}>\n          {tree => (\n            <Group top={margin.top} left={margin.left}>\n              {tree.links().map((link, i) => (\n                <LinkVertical<HierarchyPointLink<DisplayTreeNode>, HierarchyPointNode<DisplayTreeNode>>\n                  key={`cluster-link-${i}`}\n                  data={link}\n                  stroke={darkTheme ? textColorDark : textColorLight}\n                  strokeWidth=\"1\"\n                  strokeOpacity={1}\n                  fill=\"none\"\n                />\n              ))}\n              {tree.descendants().map((node) => (\n                <TreeNodeComponent\n                  key={`node-${node.data.index}`}\n                  node={node}\n                  selected={node.data.index === selected}\n                  onClick={onClick}\n                  darkTheme={darkTheme}\n                />\n              ))}\n            </Group>\n          )}\n        </Tree>\n      </svg>\n    )\n}\n","/**\n * Textual file information.\n * @category Utils\n * @public\n */\nexport interface File {\n  /**\n     * name of the file\n     * @type string\n     * @public\n     */\n  name: string\n  /**\n     * textual content of the file\n     * @type string?\n     * @public\n     */\n  text: string | null\n}\n\n/**\n * FileDialog for loading files to the application.\n * @category Utils\n * @public\n */\nexport class FileDialog {\n\n  /**\n     * Loads asynchronously a Blob content of one ZIP file selected by the user in the file browser.\n     *\n     * @return a Zip file as a Blob in a promise {@type Promise<Blob>}\n     * @public\n     */\n  static async openZip (): Promise<Blob> {\n    return await new Promise<Blob>(resolve => {\n      const element = document.createElement('div')\n      element.innerHTML = '<input type=\"file\" accept=\".zip\">'\n      const fileInput = element.firstChild\n      // @ts-ignore\n      fileInput.addEventListener('change', function () {\n        // @ts-ignore\n        resolve(fileInput.files[0])\n      })\n      // @ts-ignore\n      fileInput.click()\n    })\n  }\n\n  /**\n     * Loads asynchronously a textual content from one file selected by the user in the file browser.\n     *\n     * @param accept comma-separated list of extensions for filter (default are all extensions) {@type string}\n     * @return a file in a promise {@type Promise<File>}\n     * @public\n     */\n  static async openFile (accept = '*'): Promise<File> {\n    return await new Promise<File>(resolve => {\n      const element = document.createElement('div')\n      element.innerHTML = `<input type=\"file\" accept=${accept}>`\n      const fileInput = element.firstChild\n      // @ts-ignore\n      fileInput.addEventListener('change', function () {\n        // @ts-ignore\n        const file = fileInput.files[0]\n        const reader = new FileReader()\n        reader.onload = function () {\n          // @ts-ignore\n          resolve({ name: file.name, text: reader.result })\n        }\n        reader.readAsText(file)\n      })\n      // @ts-ignore\n      fileInput.click()\n    })\n  }\n\n  /**\n     * Asynchronously loads textual content from multiple files selected by the user in the file browser.\n     *\n     * @param accept comma-separated list of extensions for filter (default are all extensions) {@type string}\n     * @return array of files in a promise {@type Promise<File[]>}\n     * @public\n     */\n  static async openFiles (accept = '*'): Promise<File[]> {\n    return await new Promise<File[]>(resolve => {\n      FileDialog.openFilesHelper(resolve, accept)\n    })\n  }\n\n  /**\n     * Loads textual content from multiple files selected by the user in the file browser.\n     * Multiple file input handling inspired by xaedes on https://stackoverflow.com/a/13975217.\n     *\n     * @param resolve - resolving function accepting an array of file information\n     * @param accept comma-separated list of extensions for filter\n     */\n  private static openFilesHelper (resolve: (files: File[]) => void, accept: string): void {\n    const element = document.createElement('div')\n    element.innerHTML = `<input type=\"file\" accept=${accept} multiple>`\n    // @ts-ignore\n    const fileInput: HTMLInputElement = element.firstChild\n    const fileInfo: {name: string, text: string | null}[] = []\n    fileInput.addEventListener('change', function () {\n      // @ts-ignore\n      const files: FileList = fileInput.files\n      function readFile (index: number) {\n        if (index === files.length) {\n          return resolve(fileInfo)\n        }\n        const file = files[index]\n        const reader = new FileReader()\n        reader.onload = function (e) {\n          // @ts-ignore\n          fileInfo.push({ name: file.name, text: e.target.result })\n          readFile(index + 1)\n          console.log('File ' + (index + 1) + '/' + files.length + ' loaded')\n        }\n        reader.readAsText(file)\n      }\n      readFile(0)\n    })\n    fileInput.click()\n  }\n}\n","/**\n * Two possible CSV value separators: comma (,) and semicolon (;).\n * @typedef {(\",\" | \";\")} CsvValueSeparator\n */\nexport type CsvValueSeparator = ',' | ';'\n\n/**\n * Returns the first found value separator character: (,) or (;). If no separator is found, returns undefined.\n *\n * @param str string to search in {@type string}\n * @return found separator or undefined {@type CsvValueSeparator?}\n * @category Types\n * @public\n */\nexport function findValueSeparator (str: string): CsvValueSeparator | undefined {\n  let inQuotes = false\n  for (let i = 0; i < str.length; ++i) {\n    const char: string = str.charAt(i)\n    // quotes found\n    if (char === '\"') {\n      if (!inQuotes) {\n        inQuotes = true\n      } else {\n        const c2 = str.charAt(i + 1)\n        if (c2 === ',' || c2 === ';') {\n          return c2\n        }\n        // double-quotes mean one quote in cell\n        else if (c2 === '\"') {\n          // skips second quote\n          ++i\n        }\n        // error\n        else {\n          return undefined\n        }\n      }\n    }\n    if (!inQuotes && (char === ',' || char === ';')) {\n      return char\n    }\n  }\n  return undefined\n}\n\n/**\n * Splits the given line using the given CSV separator. It follows CSV rules:\n * - a cell with a separator (as value) needs to be enclosed in quotes.\n * - a cell with a quote (as value) needs to be enclosed in additional quotes. The value quote needs to be typed twice.\n *\n * @param line line of CSV file to be split {@type string}\n * @param separator CSV separator to use {@type CsvValueSeparator}\n * @return split line to individual cells {@type string[]}\n * @category Types\n * @public\n */\nexport function splitCSVLine (line: string, separator: CsvValueSeparator): string[] {\n  // adds separator to simply handle the last cell\n  line += separator\n  const ret: string[] = []\n  let inQuotes = false\n  let partStart = 0\n  let i = 0\n  while (i < line.length) {\n    const c = line.charAt(i)\n    // quotes found\n    if (c === '\"') {\n      // first quotes (after separator)\n      if (!inQuotes) {\n        inQuotes = true\n        partStart = i\n      } else {\n        const c2 = line.charAt(i + 1)\n        if (c2 === separator) {\n          ret.push(line.slice(partStart + 1, i).replace(/\"\"/g, '\"'))\n          inQuotes = false\n          partStart = i + 2\n        }\n        // double-quotes mean one quote in cell, else error\n        else if (c2 !== '\"') {\n          throw new Error()\n        }\n        i += 2\n        continue\n      }\n    } else if (c === separator && !inQuotes) {\n      ret.push(line.slice(partStart, i).replace(/\"\"/g, '\"'))\n      partStart = i + 1\n    }\n    ++i\n  }\n  return ret\n}\n","/**\n * Wrapper of JavaScript Map object to provide usage of object (row: number | \"name\", column: number) as a key for\n * string values.\n * @category Types\n * @public\n */\nexport class NNToSMap {\n  protected map: Map<string, string> = new Map<string, string>()\n\n  /**\n     * Gets the value for the given key (row, column).\n     *\n     * @param row row part of the key {@type (number | \"name\")}\n     * @param column row column of the key {@type number}\n     * @return value of the given key or undefined {@type string?}\n     * @public\n     */\n  get (row: number | 'name', column: number): string | undefined {\n    return this.map.get(row + ':' + column)\n  }\n\n  /**\n     * Sets the value of the given key (row, column).\n     *\n     * @param row row part of the key {@type (number | \"name\")}\n     * @param column row column of the key {@type number}\n     * @param value value to set {@type string}\n     * @public\n     */\n  set (row: number | 'name', column: number, value: string): void {\n    this.map.set(row + ':' + column, value)\n  }\n\n  /**\n     * Deletes the value for the given key (row, column).\n     *\n     * @param row row part of the key {@type (number | \"name\")}\n     * @param column row column of the key {@type number}\n     * @return true if an element in the Map object existed and has been removed, or false if the element does not exist {@type boolean}\n     * @public\n     */\n  delete (row: number | 'name', column: number): boolean {\n    return this.map.delete(row + ':' + column)\n  }\n\n  /**\n     * Returns true, if the given row and column is in the map.\n     *\n     * @param row row part of the key {@type (number | \"name\")}\n     * @param column row column of the key {@type number}\n     * @return true, if the given key is in the map {@type boolean}\n     * @public\n     */\n  has (row: number | 'name', column: number): boolean {\n    return this.map.has(row + ':' + column)\n  }\n\n  /**\n     * Removes all values from the map.\n     * @public\n     */\n  clear (): void {\n    this.map.clear()\n  }\n\n  /**\n     * Returns the size og the map.\n     *\n     * @return size of the map {@type number}\n     * @public\n     */\n  size (): number {\n    return this.map.size\n  }\n\n  /**\n     * Performs the given function for each (value, row, column, index) in the map.\n     *\n     * @param f function to perform {@type function}\n     * @public\n     */\n  forEach (f: (value: string, row: number | 'name', column: number, index?: number) => void): void {\n    [...this.map.entries()]\n      .map((entry) => { return { value: entry[1], key: NNToSMap.parseKey(entry[0]) } })\n      .forEach((entry, index) => f(entry.value, entry.key.row, entry.key.column, index))\n  }\n\n  private static parseKey (key: string): {row: number | 'name', column: number} {\n    const split = key.split(':')\n    const rowNumber = Number(split[0])\n    return { row: isNaN(rowNumber) ? 'name' : rowNumber, column: Number(split[1]) }\n  }\n}\n","import { isSupportedColumnType, SupportedColumnType } from './columnType'\nimport { StringUtils } from '../utils/stringUtils'\nimport { NNToSMap } from '../types/nnToSMap'\nimport { Relation } from './relation'\nimport { Row } from './row'\nimport { isForbiddenColumnName } from '../utils/keywords'\nimport { language } from '../language/language'\n\n/**\n * Plain object representation of the stored relation.\n *\n * @category Relation\n * @public\n */\nexport interface StoredRelationData {\n  name: string\n  columnNames: string[]\n  columnTypes: SupportedColumnType[]\n  rows: string[][]\n  columnCount: number\n  rowCount: number\n}\n\n/**\n * Creates a copy of the given stored relation data.\n *\n * @param data stored relation data to copy {@type StoredRelationData}\n * @return deep copied stored relation data {@type StoredRelationData}\n * @category Relation\n * @public\n */\nexport function copyStoredRelationData (data: StoredRelationData): StoredRelationData {\n  return {\n    name: data.name,\n    columnNames: [...data.columnNames],\n    columnTypes: [...data.columnTypes],\n    rows: data.rows.map(row => [...row]),\n    columnCount: data.columnCount,\n    rowCount: data.rowCount,\n  }\n}\n\n/**\n * String-arrays representation of the relation for its storing. The relation may happen to be in inconsistent state.\n * For formal representation (sets of concrete types) use {@link Relation}.\n * @category Relation\n * @public\n */\nexport class StoredRelation {\n\n  /**\n     * Creates a new stored relation with given name, one column and no rows.\n     *\n     * @param name name of the relation {@type string}\n     * @param nullValuesSupport whether null values are supported {@type boolean}\n     * @return stored relation {@type StoredRelation}\n     * @public\n     */\n  static new (name: string, nullValuesSupport: boolean): StoredRelation {\n    return new StoredRelation(name, ['Column1'], ['number'], [], nullValuesSupport)\n  }\n\n  /**\n     * Creates a new stored relation from given plain relation object. If the object is not a valid StoredRelationData,\n     * throws error.\n     *\n     * @param data input object {@type any}\n     * @param nullValuesSupport whether null values are supported {@type boolean}\n     * @return stored relation {@type StoredRelation}\n     * @public\n     */\n  static fromData (data: any, nullValuesSupport: boolean): StoredRelation {\n    if (isStoredRelationData(data)) {\n      const d: StoredRelationData = data as StoredRelationData\n      return new StoredRelation(d.name, d.columnNames, d.columnTypes, d.rows, nullValuesSupport)\n    }\n    throw new Error('Given object is not a valid relation.')\n  }\n\n  /**\n     * Creates a new stored relation from given full relation representation.\n     *\n     * @param name name to overwrite original relation name {@type string}\n     * @param relation formal relation representation {@type Relation}\n     * @param nullValuesSupport whether null values are supported {@type boolean}\n     * @return stored relation {@type StoredRelation}\n     * @public\n     */\n  static fromRelation (name: string, relation: Relation, nullValuesSupport: boolean): StoredRelation {\n    const columnNames: string[] = []\n    const columnTypes: SupportedColumnType[] = []\n    relation.getColumns().forEach((type, name) => {\n      columnNames.push(name)\n      columnTypes.push(type)\n    })\n    const rows: string[][] = relation.getRows().map(row => {\n      return row.getOrderedPrintValues(columnNames)\n    })\n    return new StoredRelation(name, columnNames, columnTypes, rows, nullValuesSupport)\n  }\n\n  /**\n     * Creates a new relation with the same name, columns, rows a null values support.\n     *\n     * @param relation relation to copy {@type StoredRelation}\n     * @return deep copied relation {@type StoredRelation}\n     * @public\n     */\n  static copy (relation: StoredRelation): StoredRelation {\n    const name = relation.name\n    const columnNames = [...relation.columnNames]\n    const columnTypes = [...relation.columnTypes]\n    const rows = relation.rows.map(row => [...row])\n    const nullValuesSupport = relation.nullValuesSupport\n    return new StoredRelation(name, columnNames, columnTypes, rows, nullValuesSupport)\n  }\n\n  /**\n     * Returns formatted string representation of StoredRelation or StoredRelationData.\n     *\n     * @param rel relation to stringify {@type StoredRelation}\n     * @return formatted string representation {@type string}\n     * @public\n     */\n  static format (rel: StoredRelation | StoredRelationData): string {\n    // finds longest inputs in each column\n    const longest = rel.columnNames.map(n => n.length)\n    rel.columnTypes.forEach((t, i) => {\n      if (longest[i] < t.length) {\n        longest[i] = t.length\n      }\n    })\n    rel.rows.forEach(r => {\n      r.forEach((d, i) => {\n        if (longest[i] < d.length) {\n          longest[i] = d.length\n        }\n      })\n    })\n    // function for end-padding strings with spaces\n    const pad = (ss: string[]) => ss.map((s, i) => s.padEnd(longest[i], ' ')).join(' | ')\n    return pad(rel.columnNames) + '\\n'\n            + pad(rel.columnTypes) + '\\n'\n            + longest.map(n => '-'.repeat(n)).join('-+-') + '\\n'\n            + rel.rows.map(r => pad(r)).join('\\n') + '\\n\\n'\n  }\n\n  private name: string\n  columnNames: string[]\n  columnTypes: SupportedColumnType[]\n  rows: string[][]\n  private columnCount: number\n  private rowCount: number\n  private readonly errors: NNToSMap\n  private nullValuesSupport: boolean\n  private actual: boolean\n  private revertState: StoredRelationData\n\n  /**\n     * Creates new relation with given name, one default column and no rows.\n     *\n     * @param name relation name {@type string}\n     * @param columnNames column names {@type string[]}\n     * @param columnTypes column types {@type SupportedColumnType[]}\n     * @param rows data tuples as 2D string array [row, column] {@type string[][]}\n     * @param nullValuesSupport whether null values are supported {@type boolean}\n     * @public\n     */\n  constructor (name: string, columnNames: string[], columnTypes: SupportedColumnType[],\n                        rows: string[][], nullValuesSupport: boolean) {\n    this.name = name\n    this.columnNames = columnNames\n    this.columnTypes = columnTypes\n    this.rows = rows\n    this.columnCount = columnNames.length\n    this.rowCount = rows.length\n    this.errors = new NNToSMap()\n    this.nullValuesSupport = nullValuesSupport\n    this.actual = false\n    this.revertState = this.toDataObject()\n    this.recomputeErrors()\n  }\n\n  /**\n     * Checks all possible errors in the relation.\n     * @public\n     */\n  recomputeErrors (): void {\n    this.errors.clear()\n    this.checkColumnNames()\n    for (let c = 0; c < this.columnCount; ++c) {\n      [...new Array(this.rowCount).keys()].forEach(r => this.checkRowInput(c, r))\n    }\n  }\n\n  /**\n     * Checks whether the column name on given index is valid and not duplicit and updates error map.\n     */\n  private checkColumnNames (): void {\n    const lang = language().relationErrors\n    for (let columnIndex = 0; columnIndex < this.columnCount; ++columnIndex) {\n      const columnName: string = this.columnNames[columnIndex].trim()\n      if (columnName === '') {\n        this.errors.set('name', columnIndex, lang.emptyColumn)\n        continue\n      }\n      const nameCount: number = this.columnNames.reduce((agg, name) => {\n        return (name === columnName) ? (agg + 1) : agg\n      }, 0)\n      if (nameCount > 1) {\n        this.errors.set('name', columnIndex, lang.duplicitColumn)\n        continue\n      }\n      if (isForbiddenColumnName(columnName)) {\n        this.errors.set('name', columnIndex, lang.keywordColumn)\n        continue\n      }\n      if (!StringUtils.isName(columnName)) {\n        this.errors.set('name', columnIndex, lang.invalidColumn)\n        continue\n      }\n      this.errors.delete('name', columnIndex)\n    }\n  }\n\n  /**\n     * Checks whether the row input on given index is valid and updates error map.\n     */\n  private checkRowInput (columnIndex: number, rowIndex: number): void {\n    const lang = language().relationErrors\n    this.errors.delete(rowIndex, columnIndex)\n    const input: string = this.rows[rowIndex][columnIndex].trim()\n    // empty input = null in non-string columns\n    if (input === 'null' || (input === '' && this.columnTypes[columnIndex] !== 'string')) {\n      if (!this.nullValuesSupport) {\n        this.errors.set(rowIndex, columnIndex, lang.unsupportedNull)\n      }\n    } else if (this.columnTypes[columnIndex] === 'number') {\n      if (!StringUtils.isNumber(input.replace(/\\s/g, ''))) {\n        this.errors.set(rowIndex, columnIndex, lang.invalidNumber)\n      }\n    } else if (this.columnTypes[columnIndex] === 'boolean') {\n      const lower = input.toLowerCase()\n      if (lower !== 'true' && lower !== 't' && lower !== 'false' && lower !== 'f') {\n        this.errors.set(rowIndex, columnIndex, lang.invalidBoolean)\n      }\n    }\n    /* STRING COLUMNS CANNOT BE INVALID */\n  }\n\n  /**\n     * Checks whether all row inputs on given column index are valid and updates error map.\n     */\n  private checkColumnTypes (columnIndex: number): void {\n    this.rows.forEach((_, i) => this.checkRowInput(columnIndex, i))\n  }\n\n  /**\n     * Creates a relation with full schema.\n     * WARNING: It expects that there are no errors in the stored relation before call.\n     *\n     * @return formal relation representation {@type Relation}\n     * @public\n     */\n  createRelation (): Relation {\n    const relation: Relation = new Relation(this.name)\n    for (let c = 0; c < this.columnCount; ++c) {\n      relation.addColumn(this.columnNames[c], this.columnTypes[c])\n    }\n    this.rows.forEach(rowInput => {\n      const row: Row = new Row(relation.getColumns())\n      rowInput.forEach((input, c) => {\n        input = input.trim()\n        if (input === 'null') {\n          row.addValue(this.columnNames[c], null)\n        } else if (this.columnTypes[c] === 'string') {\n          // changes input representation to expected in inner relations\n          // replaces all used '\\' by two '\\\\' and all used '\"' by '\\\"'\n          input = input.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"')\n          row.addValue(this.columnNames[c], input)\n        } else if (input === '') {\n          row.addValue(this.columnNames[c], null)\n        } else if (this.columnTypes[c] === 'number') {\n          row.addValue(this.columnNames[c], Number(input.replace(/\\s/g, '')))\n        } else /* this.columnTypes[c] === \"boolean\" */ {\n          const lower = input.toLowerCase()\n          row.addValue(this.columnNames[c], lower === 't' || lower === 'true')\n        }\n      })\n      relation.addRow(row)\n    })\n    relation.finishSchema()\n    return relation\n  }\n\n  /**\n     * Creates plain object representation of the stored relation.\n     *\n     * @return compressed representation {@type StoredRelationData}\n     * @public\n     */\n  toDataObject (): StoredRelationData {\n    return {\n      name: this.name,\n      columnNames: [...this.columnNames],\n      columnTypes: [...this.columnTypes],\n      rows: this.rows.map(row => [...row]),\n      columnCount: this.columnCount,\n      rowCount: this.rowCount,\n    }\n  }\n\n  /**\n     * Returns map \"row/column => error\". Numeric row keys are for relation rows, row key \"name\" is for column name row.\n     *\n     * @return map of errors in the relation {@type NNToSMap}\n     * @public\n     */\n  getErrors (): NNToSMap {\n    return this.errors\n  }\n\n  /**\n     * Returns true if there are no errors in the relation.\n     *\n     * @return true if there are no errors in the relation {@type boolean}\n     * @public\n     */\n  isValid (): boolean {\n    return this.errors.size() === 0\n  }\n\n  /**\n     * Sets null values support to check null errors in the relation.\n     *\n     * @param nullValuesSupport whether null values are supported {@type boolean}\n     * @public\n     */\n  setNullValuesSupport (nullValuesSupport: boolean): void {\n    if (nullValuesSupport !== this.nullValuesSupport) {\n      this.nullValuesSupport = nullValuesSupport\n      this.recomputeErrors()\n    }\n  }\n\n  /**\n     * Adds a new column with default name \"Column n\", default type \"number\", and empty inputs \"\" in all rows.\n     * @public\n     */\n  addNewColumn (): void {\n    let i = (this.columnNames.length + 1)\n    let name = 'Column' + i\n    while (this.columnNames.includes(name)) {\n      name = 'Column' + ++i\n    }\n    this.columnNames.push(name)\n    this.columnTypes.push('number')\n    if (this.nullValuesSupport) {\n      this.rows.forEach(r => r.push(''))\n    } else {\n      this.rows.forEach(r => r.push('0'))\n    }\n    ++this.columnCount\n    this.checkColumnNames()\n    this.actual = false\n  }\n\n  /**\n     * Adds a new row with empty inputs \"\" in all columns.\n     * @public\n     */\n  addNewRow (): void {\n    if (this.nullValuesSupport) {\n      this.rows.push([...new Array(this.columnCount).keys()].map(_ => ''))\n    } else {\n      this.rows.push([...new Array(this.columnCount).keys()].map(i => {\n        if (this.columnTypes[i] === 'number') {\n          return '0'\n        } else if (this.columnTypes[i] === 'boolean') {\n          return 'false'\n        }\n        return ''\n      }))\n    }\n    ++this.rowCount\n    this.actual = false\n  }\n\n  /**\n     * Deletes a column with the given index. If the last column was deleted, removes all rows and creates\n     * new default column.\n     *\n     * @param columnIndex column to delete {@type number}\n     * @public\n     */\n  deleteColumn (columnIndex: number): void {\n    this.columnNames.splice(columnIndex, 1)\n    this.columnTypes.splice(columnIndex, 1)\n    this.rows.forEach(row => row.splice(columnIndex, 1))\n    --this.columnCount\n    // if last column was deleted, removes all rows and creates new default column\n    if (this.columnCount === 0) {\n      this.rows = []\n      this.addNewColumn()\n    }\n    this.errors.forEach((value, row, column) => {\n      // removes errors for given row\n      if (column === columnIndex) {\n        this.errors.delete(row, column)\n      }\n      // updates row index for errors in rows under deleted one\n      else if (column > columnIndex) {\n        this.errors.delete(row, column)\n        this.errors.set(row, column, value)\n      }\n    })\n    this.actual = false\n  }\n\n  /**\n     * Deletes a row with given index.\n     *\n     * @param rowIndex row to delete {@type number}\n     * @public\n     */\n  deleteRow (rowIndex: number): void {\n    this.rows.splice(rowIndex, 1)\n    --this.rowCount\n    this.errors.forEach((value, row, column) => {\n      // removes errors for given row\n      if (row === rowIndex) {\n        this.errors.delete(row, column)\n      }\n      // updates row index for errors in rows under deleted one\n      else if (typeof row === 'number' && row > rowIndex) {\n        this.errors.delete(row, column)\n        this.errors.set(row - 1, column, value)\n      }\n    })\n    this.actual = false\n  }\n\n  /**\n     * Returns row count.\n     *\n     * @return row count {@type number}\n     * @public\n     */\n  getRowCount (): number {\n    return this.rowCount\n  }\n\n  /**\n     * Returns column count.\n     *\n     * @return column count {@type number}\n     * @public\n     */\n  getColumnCount (): number {\n    return this.columnCount\n  }\n\n  /**\n     * Sets relation name.\n     *\n     * @param name new relation name {@type string}\n     * @public\n     */\n  setName (name: string): void {\n    this.name = name\n    this.actual = false\n  }\n\n  /**\n     * Gets relation name.\n     *\n     * @return relation name {@type string}\n     * @public\n     */\n  getName (): string {\n    return this.name\n  }\n\n  /**\n     * Gets column names.\n     *\n     * @return column names {@type string[]}\n     * @public\n     */\n  getColumnNames (): string[] {\n    return this.columnNames\n  }\n\n  /**\n     * Sets column name on the given index.\n     *\n     * @param columnName name to set {@type string}\n     * @param columnIndex column to update {@type number}\n     * @public\n     */\n  setColumnName (columnName: string, columnIndex: number): void {\n    this.columnNames[columnIndex] = columnName\n    this.checkColumnNames()\n    this.actual = false\n  }\n\n  /**\n     * Gets column types.\n     *\n     * @return column types {@type SupportedColumnType[]}\n     * @public\n     */\n  getColumnTypes (): SupportedColumnType[] {\n    return this.columnTypes\n  }\n\n  /**\n     * Sets column type on the given index.\n     *\n     * @param columnType type to set {@type SupportedColumnType}\n     * @param columnIndex column to update {@type number}\n     * @public\n     */\n  setColumnType (columnType: SupportedColumnType, columnIndex: number): void {\n    this.columnTypes[columnIndex] = columnType\n    this.checkColumnTypes(columnIndex)\n    this.actual = false\n  }\n\n  /**\n     * Gets all rows.\n     *\n     * @return data tuples as 2D string array [row, column] {@type string[][]}\n     * @public\n     */\n  getRows (): string[][] {\n    return this.rows\n  }\n\n  /**\n     * Sets value in the row in the given row and column.\n     *\n     * @param input value to set {@type string}\n     * @param rowIndex row to insert {@type number}\n     * @param columnIndex column to insert {@type number}\n     * @public\n     */\n  setRowInput (input: string, rowIndex: number, columnIndex: number): void {\n    this.rows[rowIndex][columnIndex] = input\n    this.checkRowInput(columnIndex, rowIndex)\n    this.actual = false\n  }\n\n  /**\n     * Returns true if no changes were made after last setActual(true) call.\n     * The StoredRelation is created with isActual() = false.\n     *\n     * @return actual value {@type boolean}\n     * @public\n     */\n  isActual (): boolean {\n    return this.actual\n  }\n\n  /**\n     * Sets current StoredRelation state as actual. Any change sets the state as not actual automatically.\n     * If it is set to actual, the current state is saved as the revert state.\n     *\n     * @param actual set relation actual value to the given value {@type boolean}\n     * @public\n     */\n  setActual (actual: boolean): void {\n    this.actual = actual\n    if (actual) {\n      this.revertState = this.toDataObject()\n    }\n  }\n\n  /**\n     * Returns name of the saved relation state to revert or empty string.\n     *\n     * @return name of the saver relation state to revert or empty string {@type string}\n     * @public\n     */\n  getRevertName (): string {\n    if (this.revertState !== undefined) {\n      return this.revertState.name\n    } else {\n      return ''\n    }\n  }\n\n  /**\n     * Reverts the current relation to its last loaded state (if any exists, call canRevert() to check).\n     * The relation is set as not actual, null values support and saved revert state is not reverted.\n     * @public\n     */\n  revert (): void {\n    if (this.revertState !== undefined) {\n      this.name = this.revertState.name\n      this.columnNames = [...this.revertState.columnNames]\n      this.columnTypes = [...this.revertState.columnTypes]\n      this.rows = this.revertState.rows.map(row => [...row])\n      this.columnCount = this.revertState.columnCount\n      this.rowCount = this.revertState.rowCount\n      this.actual = false\n      this.recomputeErrors()\n    }\n  }\n}\n\n/**\n * Returns true if the given object is a {@link StoredRelationData}, has at least one column, and all rows has the same length.\n * @param obj checked object {@type any}\n * @return whether the given object is a valid StoredRelationData {@type boolean}\n * @category Relation\n * @public\n */\nexport function isStoredRelationData (obj: any): boolean {\n  if (typeof obj !== 'object') {\n    return false\n  }\n  if (!('name' in obj) || typeof obj.name !== 'string') {\n    return false\n  }\n  if (!('columnCount' in obj) || typeof obj.columnCount !== 'number' || obj.columnCount < 1) {\n    return false\n  }\n  if (!('rowCount' in obj) || typeof obj.rowCount !== 'number') {\n    return false\n  }\n  if (!('columnNames' in obj) || !Array.isArray(obj.columnNames) || obj.columnNames.length !== obj.columnCount\n        || obj.columnNames.some((o: any) => typeof o !== 'string')) {\n    return false\n  }\n  if (!('columnTypes' in obj) || !Array.isArray(obj.columnTypes) || obj.columnTypes.length !== obj.columnCount\n        || obj.columnTypes.some((o: any) => !isSupportedColumnType(o))) {\n    return false\n  }\n  return ('rows' in obj && Array.isArray(obj.rows) && obj.rows.every((o: any) => {\n    return Array.isArray(o) && o.length === obj.columnCount && o.every((d: any) => typeof d === 'string')\n  }))\n}\n","/**\n * Specifies supported column types in the application. When changed, update the keywords.ts file.\n */\n\n/**\n * Supported string names of types of columns for a relational schema.\n * @typedef SupportedColumnType\n * @category Relation\n * @public\n */\nexport type SupportedColumnType = 'string' | 'number' | 'boolean'\n\n/**\n * Possible types of the content of columns (null values included).\n * @typedef ColumnContent\n * @category Relation\n * @public\n */\nexport type ColumnContent = string | number | boolean | null\n\n/**\n * Returns true if the given obj is string with value SupportedColumnType value.\n * @param obj checked object {@type any}\n * @return whether the given obj is string with value SupportedColumnType value {@type boolean}\n * @category Relation\n * @public\n */\nexport function isSupportedColumnType (obj: any): boolean {\n  if (typeof obj !== 'string') {\n    return false\n  }\n  return obj === 'string' || obj === 'number' || obj === 'boolean'\n}\n","import { FileDialog } from '../utils/fileDialog'\nimport { CsvValueSeparator, findValueSeparator, splitCSVLine } from '../types/csvSupport'\nimport { StoredRelation } from './storedRelation'\nimport { SupportedColumnType } from './columnType'\nimport { saveAs } from 'file-saver'\nimport JSZip from 'jszip'\nimport { StringUtils } from '../utils/stringUtils'\n\n/**\n * Class for loading and saving relation definitions as {@link StoredRelation}.\n * @category Relation\n * @public\n */\nexport class RelationStoreManager {\n\n  /**\n     * Loads textual relation representations from multiple CSV files selected by the user. If the csv does not have\n     * valid stricture, it is skipped. Loaded CSVs are parsed to StoredRelations and returned in a promise.\n     *\n     * @param nullValuesSupport null values support to set in created StoredRelations {@type boolean}\n     * @return parsed StoredRelations and number of skipped files in a promise {@type Promise}\n     * @public\n     */\n  static async load (nullValuesSupport: boolean): Promise<{relations: StoredRelation[], skipped: number}> {\n    return await new Promise<{relations: StoredRelation[], skipped: number}>(resolve => {\n      FileDialog.openFiles('.csv').then(files => {\n        const relations: StoredRelation[] = []\n        let skipped = 0\n        files.forEach(file => {\n          if (/\\.csv$/.exec(file.name)) {\n            try {\n              relations.push(this.csvToRelation(RelationStoreManager.createValidName(file.name.slice(0, -4)),\n                                file.text, nullValuesSupport))\n            } catch (err) {\n              console.log('File ' + file.name + ' skipped for bad format of csv')\n              skipped += 1\n            }\n          } else {\n            console.log('Unsupported filetype: ' + file.name)\n            skipped += 1\n          }\n        })\n        resolve({ relations: relations, skipped: skipped })\n      })\n    })\n  }\n\n  /**\n     * Saves given relations into csv files (in one csv file each relation). Uses given value separator.\n     *\n     * @param relations map of the relations to be  {@type StoredRelation[]}\n     * @param filename name of the downloaded file (without .zip/.csv extension) {@type string}\n     * @param valueSeparator the separator of values {@type CsvValueSeparator}\n     * @public\n     */\n  static save (relations: StoredRelation[], filename: string, valueSeparator: CsvValueSeparator): void {\n    if (relations.length === 0) {\n      return\n    }\n    if (relations.length === 1) {\n      const blob = new Blob([this.relationToCsv(relations[0], valueSeparator)], { type: 'text/plain;charset=utf-8' })\n      saveAs(blob, relations[0].getName() + '.csv')\n      return\n    }\n    const zip: JSZip = JSZip()\n    relations.forEach(relation => {\n      zip.file(relation.getName() + '.csv', this.relationToCsv(relation, valueSeparator))\n    })\n    zip.generateAsync({ type: 'blob' }).then(content => {\n      saveAs(content, filename + '.zip')\n    }).catch(err => {\n      throw err\n    })\n  }\n\n  /**\n     * Parses a StoredRelation from given csv text. If the text is invalid, throws error.\n     *\n     * @param name name of the relation\n     * @param text csv content to parse a relation from\n     * @param nullValuesSupport null values support to set in created StoredRelation\n     */\n  private static csvToRelation (name: string, text: string | null, nullValuesSupport: boolean): StoredRelation {\n    if (text === null || text === '') {\n      console.log('null or empty string read from file ' + name)\n      throw Error()\n    }\n\n    text = text.trim().replace(/\\r\\n/g, '\\n')\n      .replace(/\\r/g, '\\n').replace(/\\t/g, '    ')\n\n    const lines: string[] = text.split('\\n')\n\n    if (lines.length < 2) {\n      console.log('file ' + name + ' has only one line')\n      throw new Error()  // at least two lines are expected (names and types)\n    }\n\n    lines[0] = lines[0].replace(/\\s/g, '')\n    lines[1] = lines[1].replace(/\\s/g, '')\n\n    let separator = findValueSeparator(lines[1])\n    // if no separator is found, only one column is expected - sets separator to not defined value to unify the\n    // following process\n    if (separator === undefined) {\n      separator = ';'\n    }\n\n    const columnNames: string[] = splitCSVLine(lines[0], separator)\n    const columnTypes: SupportedColumnType[] = splitCSVLine(lines[1], separator).map(str => {\n      const lower = str.toLowerCase()\n      if (lower === 'string' || lower === 'str' || lower === 's') {\n        return 'string'\n      } else if (lower === 'number' || lower === 'num' || lower === 'n') {\n        return 'number'\n      }\n      return 'boolean'\n    })\n    // @ts-ignore - separator cannot be undefined\n    const rows: string[][] = lines.slice(2).map(line => splitCSVLine(line, separator))\n\n    // all rows must have equal column count\n    const columnCount = columnNames.length\n    if (columnTypes.length !== columnCount || rows.some(row => row.length !== columnCount)) {\n      console.log('rows in file ' + name + ' do not have the same number of columns')\n      throw new Error()\n    }\n\n    return new StoredRelation(name, columnNames, columnTypes, rows, nullValuesSupport)\n  }\n\n  /**\n     * Removes invalid characters for name. If the filtered name is empty, returns string \"relation\".\n     */\n  private static createValidName (name: string): string {\n    name = name.split('').filter(char => StringUtils.isNameChar(char)).join('')\n    if (name === '') {\n      return 'relation'\n    }\n    return name\n  }\n\n  /**\n     * Creates a csv representation for the given relation.\n     */\n  private static relationToCsv (relation: StoredRelation, valueSeparator: CsvValueSeparator): string {\n    const names: string = relation.getColumnNames().map(\n            n => '\"' + n.replace(/\"/g, '\"\"') + '\"'\n    ).join(valueSeparator)\n    const types: string = relation.getColumnTypes().join(valueSeparator)\n    const rows: string[] = relation.getRows().map(row => row.map(\n            data => '\"' + data.replace(/\"/g, '\"\"') + '\"'\n    ).join(valueSeparator))\n    return [names, types, ...rows].join('\\n')\n  }\n}\n","import React from 'react'\n// @ts-ignore - type declaration is not needed for its short usage\nimport downloadSVG from 'export-svg-with-styles'\nimport { Relation } from '../relation/relation'\nimport { ResultRelationTable } from './resultRelationTable'\nimport { TooltipButton } from './tooltipButton'\nimport { RATreeNode } from '../ratree/raTreeNode'\nimport { CsvValueSeparator } from '../types/csvSupport'\nimport { evalTreeSVGId, EvaluationTree } from './evaluationTree'\nimport { depthSearch } from '../ratree/raTreeTools'\nimport { ErrorFactory } from '../error/errorFactory'\nimport { RelationStoreManager } from '../relation/relationStoreManager'\nimport { StoredRelation } from '../relation/storedRelation'\nimport './css/resultSection.css'\nimport { language, LanguageDef } from '../language/language'\n\n/**\n * Props of ResultSection component.\n * @category Components\n * @public\n */\ninterface ResultSectionProps {\n  /**\n     * the root of the current evaluation tree to display\n     * @type RATreeNode\n     * @public\n     */\n  evaluationTreeRoot: RATreeNode\n  /**\n     * name of the evaluated expression\n     * @type string\n     * @public\n     */\n  expressionName: string\n  /**\n     * handler of adding the given relation to defined relations\n     * @type function\n     * @public\n     */\n  onAddResult: (relation: Relation) => void\n  /**\n     * handler of unexpected errors\n     * @type function\n     * @public\n     */\n  onUnexpectedError: (e: Error) => void\n  /**\n     * current selected value separator in csv files\n     * @type CsvValueSeparator\n     * @public\n     */\n  csvValueSeparator: CsvValueSeparator\n  /**\n     * true if dark theme should be applied\n     * @type boolean\n     * @public\n     */\n  darkTheme: boolean\n  /**\n     * current application language\n     * @type LanguageDef\n     * @public\n     */\n  language: LanguageDef\n}\n\ninterface ResultSectionState {\n  selectedIndex: number\n}\n\n/**\n * Section to show the evaluation result. It contains a table with a result and text input and buttons to save it.\n * The component is hidden if given resultRelation is null.\n * Accepts {@link ResultSectionProps} props.\n * @category Components\n * @public\n */\nexport class ResultSection extends React.Component<ResultSectionProps, ResultSectionState> {\n\n  // reference to this section element\n  private readonly sectionRef: React.RefObject<HTMLDivElement>\n\n  constructor (props: ResultSectionProps) {\n    super(props)\n    this.state = {\n      selectedIndex: 0,\n    }\n    this.sectionRef = React.createRef<HTMLDivElement>()\n  }\n\n  componentDidUpdate (prevProps: Readonly<ResultSectionProps>) {\n    if (prevProps.evaluationTreeRoot !== this.props.evaluationTreeRoot) {\n      this.setState({ selectedIndex: 0 })\n    }\n  }\n\n  /**\n     * Gets the result relation for the current selected node.\n     */\n  private readonly getCurrentRelation = (): Relation | null => {\n    let currentNode: RATreeNode | null = depthSearch(this.props.evaluationTreeRoot, this.state.selectedIndex)\n    if (currentNode === null) {\n      currentNode = depthSearch(this.props.evaluationTreeRoot, 0)\n      if (currentNode === null) {\n        this.props.onUnexpectedError(ErrorFactory.codeError(language().codeErrors.resultSection_nodeIndexNotFound))\n        return null\n      }\n    }\n    try {\n      return currentNode.getResult()\n    } catch (err) {\n      // errors should be handled in expression section\n      this.props.onUnexpectedError(ErrorFactory.codeError(language().codeErrors.resultSection_evalError, err.message))\n      return null\n    }\n  }\n\n  private readonly handleSelectedNodeChange = (index: number): void => {\n    this.setState({ selectedIndex: index })\n  }\n\n  /**\n     * Saves the displayed evaluation tree as png picture.\n     */\n  private readonly exportEvalTreeAsPng = (): void => {\n    const svg = document.getElementById(evalTreeSVGId)\n    if (svg !== null) {\n      const rect = svg.getBoundingClientRect()\n      const options = {\n        width: rect.width * 3,\n        height: rect.height * 3,\n        svg: svg,\n        filename: this.props.expressionName + ' - evaluation tree.png',\n      }\n      downloadSVG(options)\n    }\n  }\n\n  /**\n     * Saves the current selected relation to a file.\n     */\n  private readonly exportRelation = (): void => {\n    if (this.getCurrentRelation() === null) {\n      this.props.onUnexpectedError(ErrorFactory.codeError(language().codeErrors.resultSection_nullRelationToSave))\n      return\n    }\n    try {\n      RelationStoreManager.save(\n                [StoredRelation.fromRelation('rachel_result', this.getCurrentRelation() as Relation, true)],\n                'rachel_result', this.props.csvValueSeparator)\n    } catch (err) {\n      console.warn('Saving error: ' + err, true)\n    }\n  }\n\n  /**\n     * Passes the current selected relation with the given name to the parent.\n     */\n  private readonly addRelation = (): void => {\n    if (this.getCurrentRelation() === null) {\n      this.props.onUnexpectedError(\n                ErrorFactory.codeError(language().codeErrors.resultSection_nullRelationToAdd)\n      )\n      return\n    }\n    // @ts-ignore\n    this.props.onAddResult(this.getCurrentRelation())\n  }\n\n  render () {\n    const relation = this.getCurrentRelation()\n    // does not show null result\n    if (relation === null) {\n      return null\n    }\n    const lang = this.props.language.resultSection\n\n    const relationType: string = this.state.selectedIndex === 0 ? lang.resultRelationTitle : lang.intermediateRelationTitle\n    const selectedNode: RATreeNode | null = depthSearch(this.props.evaluationTreeRoot, this.state.selectedIndex)\n    const tableTitle: string | null = selectedNode === null ? null : selectedNode.printInLine()\n\n    return (\n      <section\n        ref={this.sectionRef}\n        className=\"page-section result-section\">\n        <header>\n          <h2>{lang.resultSectionHeader}</h2>\n          <TooltipButton\n            text={lang.exportEvalTreeButton}\n            onClick={this.exportEvalTreeAsPng}\n            tooltip={lang.exportEvalTreeButtonTooltip}\n          />\n        </header>\n\n        <p className=\"upper-p\">\n          <strong>{lang.evalTreeTitle + ' ' + this.props.evaluationTreeRoot.printInLine() + ':'}</strong>\n        </p>\n\n        <EvaluationTree\n          tree={this.props.evaluationTreeRoot}\n          selected={this.state.selectedIndex}\n          onClick={this.handleSelectedNodeChange}\n          darkTheme={this.props.darkTheme}\n        />\n\n        <p className=\"lower-p\"><strong>{relationType} {tableTitle}:</strong></p>\n\n        <menu className=\"page-section-tab-menu\">\n          <TooltipButton\n            text={lang.addButton}\n            onClick={this.addRelation}\n            tooltip={lang.addButtonTooltip}\n          />\n          <TooltipButton\n            text={lang.exportRelationButton}\n            onClick={this.exportRelation}\n            tooltip={lang.exportRelationButtonTooltip}\n          />\n        </menu>\n\n        <ResultRelationTable relation={relation} />\n      </section>\n    )\n  }\n}\n","import { FileDialog } from '../utils/fileDialog'\nimport { saveAs } from 'file-saver'\nimport { Expression } from './expression'\n\n/**\n * Promised expression information in {@link ExpressionStoreManager}.load() function.\n * @category Expression\n * @public\n */\nexport interface ExpressionLoadData {\n  /**\n     * successfully parsed expressions\n     * @type Expression[]\n     * @public\n     */\n  expressions: Expression[]\n  /**\n     * number of skipped expressions (from successfully loaded files)\n     * @type number\n     * @public\n     */\n  skippedExpressions: number\n  /**\n     * number of successfully loaded files\n     * @type number\n     * @public\n     */\n  loadedFiles: number\n  /**\n     * number of skipped files (not .txt, null loaded...)\n     * @type number\n     * @public\n     */\n  skippedFiles: number\n}\n\n/**\n * Class for loading and saving expressions.\n * @category Expression\n * @public\n */\nexport class ExpressionStoreManager {\n\n  /**\n     * Loads expressions from multiple textual files selected by the user. Each file can contain multiple expressions,\n     * split by '\\n###\\n'. When different line separator is used (\\r, \\r\\n), it is replaced by \\n before return.\n     * All tabulators are replaces by 4 spaces.\n     *\n     * @return information about loaded expressions in a promise {@type Promise<ExpressionLoadData>}\n     * @public\n     */\n  static async load (): Promise<ExpressionLoadData> {\n    return await new Promise<ExpressionLoadData>(resolve => {\n      FileDialog.openFiles('.txt').then(files => {\n        const expressions: Expression[] = []\n        let skippedExpressions = 0\n        let loadedFiles = 0\n        let skippedFiles = 0\n        files.forEach(file => {\n          if (file.text === null) {\n            console.log('Null read from file ' + file.name)\n            skippedFiles += 1\n          } else if (/\\.txt$/.exec(file.name)) {\n            // replaces line separators to expected '\\n' and tabulators to four spaces\n            file.text = file.text.replace(/\\r\\n/g, '\\n')\n              .replace(/\\r/g, '\\n').replace(/\\t/g, '    ');\n            // prepends newline for first expected splitting of the first expression\n            ('\\n'.concat(file.text)).split('\\n### ').forEach(part => {\n              try {\n                if (part.trim().length !== 0) {\n                  expressions.push(this.splitExpressionNameAndText(part))\n                }\n              } catch (err) {\n                skippedExpressions += 1\n              }\n            })\n            loadedFiles += 1\n          } else {\n            console.log('Unsupported filetype: ' + file.name)\n            skippedFiles += 1\n          }\n        })\n        resolve({ expressions, skippedExpressions, loadedFiles, skippedFiles })\n      })\n    })\n  }\n\n  private static splitExpressionNameAndText (expr: string): Expression {\n    const firstNewLineIndex: number = expr.indexOf('\\n')\n    if (firstNewLineIndex === -1) {\n      console.log('Expression does not contain first name line.')\n      throw Error()\n    }\n    const firstRow: string = expr.slice(0, firstNewLineIndex).trim()\n    if (!firstRow.endsWith(' ###')) {\n      console.log('Expression does not contain name between hashes.')\n      throw Error()\n    }\n    const name: string = firstRow.slice(0, -4)\n    const text: string = expr.slice(firstNewLineIndex).trim()\n    return { name: name, text: text }\n  }\n\n  /**\n     * Saves given expressions to a textual file. Each expression starts with \"### Expression name ###\\n\" line.\n     *\n     * @param expressions array of expressions to be saved {@type Expression[]}\n     * @param filename name of the downloaded file (without extension) {@type string}\n     * @public\n     */\n  static save (expressions: Expression[], filename: string): void {\n    const textContent: string = expressions.map(e => {\n      return '### ' + e.name + ' ###\\n\\n' + e.text\n    }).join('\\n\\n')\n    const blob = new Blob([textContent], { type: 'text/plain;charset=utf-8' })\n    saveAs(blob, filename + '.txt')\n  }\n}\n","import { Project } from './project'\n\n/**\n * Sample of the application {@link Project} with a name.\n * @category Project\n * @public\n */\nexport interface ProjectSample {\n  /**\n     * name of the sample\n     * @type string\n     * @public\n     */\n  name: string\n  /**\n     * sample project\n     * @type Project\n     * @public\n     */\n  project: Project\n}\n\nconst samples: ProjectSample[] = [\n  // english sample\n  {\n    name: 'Cars and Owners (EN)',\n    project: {\n      relations: [\n        {\n          name: 'Car',\n          columnNames: ['Id', 'Owner', 'Color', 'Electric', 'Weight'],\n          columnTypes: ['number', 'number', 'string', 'boolean', 'number'],\n          rows: [\n            ['1', '1', 'Blue', 'True', '1000'],\n            ['2', '1', 'Green', 'false', '1 200'],\n            ['3', '2', 'Blue', 'F', '850.42'],\n            ['4', '3', 'Black', 't', '1 111.111 111'],\n          ],\n          columnCount: 5,\n          rowCount: 4,\n        },\n        {\n          name: 'Owner',\n          columnNames: ['Id', 'Name'],\n          columnTypes: ['number', 'string'],\n          rows: [\n            ['1', 'George Smith'],\n            ['2', 'Adam \"Driver /\\\\\" Jackson'],\n            ['3', 'Michael Trueman'],\n            ['Fix errors', 'before loading'],\n            ['Or delete', 'invalid rows'],\n          ],\n          columnCount: 2,\n          rowCount: 3,\n        },\n      ],\n      expressions: [\n        {\n          name: 'Relation only',\n          text:\n            \"// You can use comments until the line end after '//'\\n\"\n            + '// You must load relations before using them in expressions\\n'\n            + '\\n'\n            + 'Car\\n'\n            + '\\n'\n            + '// After evaluation, you will see the evaluation tree\\n'\n            + '// and the result relation at the bottom of the page\\n'\n            + '',\n        },\n        {\n          name: 'Unary operator',\n          text:\n            '// Unary operator comes after the source relation\\n'\n            + '// If the relation is still not defined, go check its definition\\n'\n            + '// This expression returns all owners with id 1\\n'\n            + '\\n'\n            + 'Owner(Id = 1)\\n'\n            + '',\n        },\n        {\n          name: 'Binary operator',\n          text:\n            '// Binary operator comes between source relations\\n'\n            + '// This expression returns natural join of cars and owners\\n'\n            + '\\n'\n            + 'Car*Owner\\n'\n            + '',\n        },\n        {\n          name: 'Escapes',\n          text:\n            '// Strings in expressions are enclosed in quotes\\n'\n            + \"// To use quotes inside a string, you must escape them by a backslash '\\\\\\\"'\\n\"\n            + \"// To use backslash inside a string, you must escape it with second one '\\\\\\\\'\\n\"\n            + '\\n'\n            + 'Owner(Name == \"Adam \\\\\"Driver /\\\\\\\\\\\\\" Jackson\")\\n'\n            + '\\n'\n            + '// This does not work: Owner(Name == \"Adam \"Driver /\\\\\" Jackson\")\\n'\n            + '',\n        },\n        {\n          name: 'Example',\n          text:\n            '// Errors are highlighted by red underline - hover mouse over it to see details\\n'\n            + '// While typing, Rachel shows you available relations or columns\\n'\n            + '// (if relations are loaded in the application)\\n'\n            + \"// Try to write a query for: all cars' ids and their owners' names\\n\"\n            + '\\n'\n            + 'TODO...\\n'\n            + '',\n        },\n        {\n          name: 'Example result',\n          text:\n            '// One possible expression is like this...\\n'\n            + '\\n'\n            + '(\\n'\n            + '  Car\\n'\n            + '  *\\n'\n            + '  Owner< Id -> Owner >\\n'\n            + ')[Id, Name]\\n'\n            + '\\n'\n            + \"// For more detailed manual click 'About' button in the page header\\n\"\n            + '',\n        },\n      ],\n      nullValuesSupport: true,\n    },\n  },\n  // czech sample\n  {\n    name: 'Auta a Majitelé (CS)',\n    project: {\n      relations: [\n        {\n          name: 'Auto',\n          columnNames: ['Id', 'Majitel', 'Barva', 'Elektro', 'Váha'],\n          columnTypes: ['number', 'number', 'string', 'boolean', 'number'],\n          rows: [\n            ['1', '1', 'Modrá', 'True', '1000'],\n            ['2', '1', 'Zelená', 'false', '1 200'],\n            ['3', '2', 'Modrá', 'F', '850.42'],\n            ['4', '3', 'Černá', 't', '1 111.111 111'],\n          ],\n          columnCount: 5,\n          rowCount: 4,\n        },\n        {\n          name: 'Majitel',\n          columnNames: ['Id', 'Jméno'],\n          columnTypes: ['number', 'string'],\n          rows: [\n            ['1', 'Pepa Mrázek'],\n            ['2', 'Adam \"Závodník /\\\\\" Horváth'],\n            ['3', 'Michael Dvořák'],\n            ['Před nahráním', 'oprav chyby'],\n            ['Nebo odstraň', 'chybné řádky'],\n          ],\n          columnCount: 2,\n          rowCount: 3,\n        },\n      ],\n      expressions: [\n        {\n          name: 'Pouze relace',\n          text:\n            \"// Můžeš používat komentáře po '//'\\n\"\n            + '// Před použitím relací ve výrazech je musíš nahrát\\n'\n            + '\\n'\n            + 'Auto\\n'\n            + '\\n'\n            + '// Po vyhodnocení uvidíš evaluační strom\\n'\n            + '// a výslednou relaci dole na stránce\\n'\n            + '',\n        },\n        {\n          name: 'Unární operátor',\n          text:\n            '// Unární operátory se píší za vstupní relaci\\n'\n            + '// Pokud je tato relace stále nedefinovaná, zkontroluj její definici\\n'\n            + '// Tento dotaz vrátí všechny majitele s id = 1\\n'\n            + '\\n'\n            + 'Majitel(Id = 1)\\n'\n            + '',\n        },\n        {\n          name: 'Binární operátor',\n          text:\n            '// Binární operátory se píší mezi vstupní relace\\n'\n            + '// Tento výraz vrátí přirozené spojení aut a majitelů\\n'\n            + '\\n'\n            + 'Auto*Majitel\\n'\n            + '',\n        },\n        {\n          name: 'Escapes',\n          text:\n            '// Textové řetězce ve výrazech musí být mezi uvozovkami\\n'\n            + \"// Pro použití uvozovek v řetězci před ně musíš napsat zpětné lomítko '\\\\\\\"'\\n\"\n            + \"// Pro použití zpětného lomítka před něj musíš napsat druhé '\\\\\\\\'\\n\"\n            + '\\n'\n            + 'Majitel(Jméno == \"Adam \\\\\"Závodník /\\\\\\\\\\\\\" Horváth\")\\n'\n            + '\\n'\n            + '// Toto by nefungovalo: Majitel(Jméno == \"Adam \"Závodník /\\\\\" Horváth\")\\n'\n            + '',\n        },\n        {\n          name: 'Příklad',\n          text:\n            '// Chyby jsou zvýrazněni červeným podtržením - přejeď na ně myší pro detaily\\n'\n            + '// Při psaní ti Rachel nabízí dostupné relace nebo sloupce\\n'\n            + '// (pokud jsou relace nahrané v aplikace)\\n'\n            + '// Zkus napsat dotaz pro: id všech aut a jména jejich majitelů\\n'\n            + '\\n'\n            + 'TODO...\\n'\n            + '',\n        },\n        {\n          name: 'Výsledek příkladu',\n          text:\n            '// Jedno možné řešení je toto...\\n'\n            + '\\n'\n            + '(\\n'\n            + '  Auto\\n'\n            + '  *\\n'\n            + '  Majitel< Id -> Majitel >\\n'\n            + ')[Id, Jméno]\\n'\n            + '\\n'\n            + \"// Pro více informací navštiv manuál přes odkaz 'O aplikaci' v horním menu\\n\"\n            + '',\n        },\n      ],\n      nullValuesSupport: true,\n    },\n  },\n]\n\n/**\n * Returns prepared project samples.\n *\n * @return {@type ProjectSample[]}\n * @category Project\n * @public\n */\nexport function getSamples (): ProjectSample[] {\n  return samples\n}\n","import React from 'react'\nimport { CsvValueSeparator } from '../types/csvSupport'\nimport { allSupportedLanguages, LanguageDef, SupportedLanguage } from '../language/language'\nimport './css/managementSection.css'\nimport { getSamples } from '../project/samples'\nimport { Project } from '../project/project'\nimport { TooltipButton } from './tooltipButton'\n\n/**\n * Props of ManagementSection component.\n * @category Components\n * @public\n */\ninterface ManagementSectionProps {\n  /**\n     * handler of loading a config file for batch processing\n     * @type function\n     * @public\n     */\n  onBatchConfig: () => void\n  /**\n     * handler of loading project files for batch processing\n     * @type function\n     * @public\n     */\n  onBatchLoad: () => void\n  /**\n     * information about current batch configuration\n     * @type string\n     * @public\n     */\n  batchConfigurationInfo: string\n  /**\n     * handler of project loading\n     * @type function\n     * @public\n     */\n  onLoadProject: () => void\n  /**\n     * handler of project saving\n     * @type function\n     * @public\n     */\n  onSaveProject: () => void\n  /**\n     * handler of loading the selected sample project\n     * @type function\n     * @public\n     */\n  onLoadSample: (sample: Project) => void\n  /**\n     * current selected value separator in csv files\n     * @type CsvValueSeparator\n     * @public\n     */\n  csvValueSeparator: CsvValueSeparator\n  /**\n     * current selected language of the application\n     * @type LanguageDef\n     * @public\n     */\n  language: LanguageDef\n  /**\n     * current selected null values support\n     * @type boolean\n     * @public\n     */\n  nullValuesSupport: boolean\n  /**\n     * true if dark theme should be applied\n     * @type boolean\n     * @public\n     */\n  darkTheme: boolean\n  /**\n     * handler of change of the current selected value separator in csv files\n     * @type function\n     * @public\n     */\n  onCsvValueSeparatorChange: (csvValueSeparator: CsvValueSeparator) => void\n  /**\n     * handler of change of the current selected language of the application\n     * @type function\n     * @public\n     */\n  onLanguageChange: (language: SupportedLanguage) => void\n  /**\n     * handler of change of the current selected null values support\n     * @type function\n     * @public\n     */\n  onNullValuesSupportChange: (nullValuesSupport: boolean) => void\n  /**\n     * handler of change of the current selected theme\n     * @type function\n     * @public\n     */\n  onDarkThemeChange: (darkTheme: boolean) => void\n}\n\ninterface ManagementSectionState {\n  sectionClicked: boolean\n}\n\n/**\n * Section to manage batch processing, importing/exporting the project, and settings.\n * Accepts {@link ManagementSectionProps} props.\n * @category Components\n * @public\n */\nexport class ManagementSection extends React.Component<ManagementSectionProps, ManagementSectionState> {\n\n  constructor (props: ManagementSectionProps) {\n    super(props)\n    this.state = {\n      sectionClicked: false,\n    }\n  }\n\n  render () {\n    const lang = this.props.language.managementSection\n\n    const createBatchButton = () => {\n      const batchMenu = (\n        <ul className=\"list-menu\">\n          <TooltipButton text={lang.batchConfig} onClick={this.props.onBatchConfig}\n            tooltip={this.props.batchConfigurationInfo}/>\n          <button onClick={this.props.onBatchLoad}>{lang.batchLoad}</button>\n        </ul>\n      )\n      return (<div className={'button-like'}>{lang.batchTitle}{batchMenu}</div>)\n    }\n    const createLoadProjectButton = () => {\n      return (<button onClick={this.props.onLoadProject} >{lang.loadButton}</button>)\n    }\n    const createSaveProjectButton = () => {\n      return (<button onClick={this.props.onSaveProject} >{lang.saveButton}</button>)\n    }\n    const createSettingsButton = () => {\n      const settingsMenu = (\n        <ul className=\"list-menu\">\n          <li>\n            <span>{lang.settingsNullValues}:</span>\n            <input\n              type=\"radio\"\n              name=\"null_values_support\"\n              value=\"allowed\"\n              id=\"null_values_support_allowed\"\n              checked={this.props.nullValuesSupport}\n              onChange={() => this.props.onNullValuesSupportChange(true)} />\n            <label htmlFor=\"null_values_support_allowed\">{lang.settingsNullValuesAllowed}</label>\n            <input\n              type=\"radio\"\n              name=\"null_values_support\"\n              value=\"forbidden\"\n              id=\"null_values_support_forbid\"\n              checked={!this.props.nullValuesSupport}\n              onChange={() => this.props.onNullValuesSupportChange(false)} />\n            <label htmlFor=\"null_values_support_forbid\">{lang.settingsNullValuesForbidden}</label>\n          </li>\n          <li>\n            <span>{lang.settingsCSVSeparator}:</span>\n            <input\n              type=\"radio\"\n              name=\"value_separator\"\n              value=\"semicolon\"\n              id=\"value_separator_semi\"\n              checked={this.props.csvValueSeparator === ';'}\n              onChange={() => this.props.onCsvValueSeparatorChange(';')}/>\n            <label htmlFor=\"value_separator_semi\">{lang.settingsCSVSeparatorSemicolon}</label>\n            <input\n              type=\"radio\"\n              name=\"value_separator\"\n              value=\"comma\"\n              id=\"value_separator_comma\"\n              checked={this.props.csvValueSeparator === ','}\n              onChange={() => this.props.onCsvValueSeparatorChange(',')}/>\n            <label htmlFor=\"value_separator_comma\">{lang.settingsCSVSeparatorComma}</label>\n          </li>\n          <li>\n            <span>{lang.settingsTheme}:</span>\n            <input\n              type=\"radio\"\n              name=\"dark_mode\"\n              value=\"on\"\n              id=\"dark_mode_on\"\n              checked={!this.props.darkTheme}\n              onChange={() => this.props.onDarkThemeChange(false)} />\n            <label htmlFor=\"dark_mode_on\">{lang.settingsThemeLight}</label>\n            <input\n              type=\"radio\"\n              name=\"dark_mode\"\n              value=\"off\"\n              id=\"dark_mode_off\"\n              checked={this.props.darkTheme}\n              onChange={() => this.props.onDarkThemeChange(true)} />\n            <label htmlFor=\"dark_mode_off\">{lang.settingsThemeDark}</label>\n          </li>\n          <li>\n            <span>{lang.settingsLanguage}:</span>\n            {allSupportedLanguages.map(lang => {\n              return (<div key={lang} style={{ display: 'inline' }}>\n                <input\n                  type=\"radio\"\n                  name=\"language\"\n                  value={lang}\n                  id={'language_' + lang}\n                  checked={this.props.language.abbr === lang}\n                  onChange={() => this.props.onLanguageChange(lang)} />\n                <label htmlFor={'language_' + lang}>{lang}</label>\n              </div>)\n            })}\n          </li>\n        </ul>\n      )\n      return (<div className={'button-like'}>{lang.settingsButton}{settingsMenu}</div>)\n    }\n    const createSamplesButton = () => {\n      const samplesMenu = (\n        <ul className=\"list-menu\">\n          {lang.samplesMenuTitle}\n          {getSamples().map((sample, i) => {\n            return (\n              <li key={i}>\n                <button onClick={() => this.props.onLoadSample(sample.project)}>{sample.name}</button>\n              </li>\n            )\n          })}\n        </ul>\n      )\n      return (<div className={'button-like'} >{lang.samplesButton}{samplesMenu}</div>)\n    }\n    const createAboutButton = () => {\n      return (\n        <a href=\"https://github.com/kotliluk/rachel\"\n          target=\"_blank\"\n          rel=\"noreferrer\"\n          className={'button-like'}\n        >{lang.aboutButton}</a>\n      )\n    }\n\n    return (\n      <header className=\"management-section\">\n        <h1>RACHEL</h1>\n        {createLoadProjectButton()}\n        {createSaveProjectButton()}\n        {createSamplesButton()}\n        {createSettingsButton()}\n        {createBatchButton()}\n        {createAboutButton()}\n      </header>\n    )\n  }\n}\n","import { copyExpression, Expression, isExpression } from '../expression/expression'\nimport { copyStoredRelationData, isStoredRelationData, StoredRelationData } from '../relation/storedRelation'\n\n/**\n * Project interface to store information about project relations, expressions, and null values support.\n * Does not store custom settings about saving file types etc.\n *\n * @category Project\n * @public\n */\nexport interface Project {\n  /**\n     * stored relation data in compressed representation\n     * @type StoredRelationData[]\n     * @public\n     */\n  relations: StoredRelationData[]\n  /**\n     * expressions\n     * @type Expression[]\n     * @public\n     */\n  expressions: Expression[]\n  /**\n     * whether the project supports null values\n     * @type boolean\n     * @public\n     */\n  nullValuesSupport: boolean\n}\n\n/**\n * Checks whether the given object is {@link Project} (i.e., has all required fields of required types).\n *\n * @param obj value to be checked {@type any}\n * @return \"OK\" string if the given obj is Project or string description of found error in the structure {@type string}\n *\n * @category Project\n * @public\n */\nexport function isProjectObject (obj: any): string {\n  if (typeof obj !== 'object') {\n    return 'The file cannot be parsed to an object.'\n  }\n  if (!('relations' in obj) || !Array.isArray(obj.relations) || obj.relations.length === 0\n        || obj.relations.some((o: any) => !isStoredRelationData(o))) {\n    return 'The file must contain the field \"relations: StoredRelationData[]\" of length at least one'\n  }\n  if (!('expressions' in obj) || !Array.isArray(obj.expressions) || obj.expressions.length === 0\n        || obj.expressions.some((o: any) => !isExpression(o))) {\n    return 'The file must contain the field \"expressions: Expression[]\" of length at least one'\n  }\n  if (!('nullValuesSupport' in obj) || typeof obj.nullValuesSupport !== 'boolean') {\n    return 'The file must contain the field \"nullValuesSupport: boolean\"'\n  }\n  return 'OK'\n}\n\n/**\n * Creates a copy of the given project.\n *\n * @param proj project to copy {@type Project}\n * @return deep copied project {@type Project}\n * @category Project\n * @public\n */\nexport function copyProject (proj: Project): Project {\n  return {\n    relations: proj.relations.map(rel => copyStoredRelationData(rel)),\n    expressions: proj.expressions.map(expr => copyExpression(expr)),\n    nullValuesSupport: proj.nullValuesSupport,\n  }\n}\n","/**\n * Representation of named relational algebra expression.\n * @category Expression\n * @public\n */\nexport interface Expression {\n  /**\n     * name of the expression\n     * @type string\n     * @public\n     */\n  name: string\n  /**\n     * text of the expression\n     * @type string\n     * @public\n     */\n  text: string\n}\n\n/**\n * Checks whether the given obj is an {@link Expression}.\n *\n * @param obj object to check {@type any}\n * @return whether the given obj is an Expression {@type boolean}\n * @category Expression\n * @public\n */\nexport function isExpression (obj: any): boolean {\n  if (typeof obj !== 'object') {\n    return false\n  }\n  return ('name' in obj) && (typeof obj.name === 'string') && ('text' in obj) && (typeof obj.text === 'string')\n}\n\n/**\n * Creates a copy of the given expression.\n *\n * @param exp Expression to copy {@type Expression}\n * @return deep copied expression {@type Expression}\n * @category Expression\n * @public\n */\nexport function copyExpression (exp: Expression): Expression {\n  return { name: exp.name, text: exp.text }\n}\n","import { isProjectObject, Project } from './project'\nimport { FileDialog } from '../utils/fileDialog'\nimport { saveAs } from 'file-saver'\n\n/**\n * Class for loading and saving all project data as {@link Project} objects.\n * @category Project\n * @public\n */\nexport class ProjectStoreManager {\n\n  /**\n     * Loads asynchronously the project from a .rachel (JSON) file selected by the user.\n     * The file must contain the representation of the project object.\n     * Returned string values always use '\\n' as line separator.\n     *\n     * @return loaded project as a Promise {@type Promise<Project>}\n     * @public\n     */\n  static async load (): Promise<Project> {\n    return await new Promise<Project>((resolve, reject) => {\n      FileDialog.openFile('.rachel').then(file => {\n        if (file.text === null) {\n          reject('Reading of the content of the file ' + file.name + ' failed.')\n        } else if (/\\.rachel$/.exec(file.name)) {\n          // replaces line separators to expected '\\n'\n          file.text = file.text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n')\n            .replace(/\\t/g, '    ')\n          const obj = JSON.parse(file.text)\n          const result: string = isProjectObject(obj)\n          if (result === 'OK') {\n            const project: Project = obj\n            resolve(project)\n          } else {\n            reject('Invalid structure of the JSON file. ' + result)\n          }\n        } else {\n          reject('Please select a JSON file to load a project relation from.')\n        }\n      })\n    })\n  }\n\n  /**\n     * Saves the given Project into the .rachel (JSON) file.\n     *\n     * @param project the Project object with all project data {@type Project}\n     * @param filename name of the downloaded file (without extension, .rachel is added) {@type string}\n     * @public\n     */\n  static save (project: Project, filename: string): void {\n    const blob = new Blob([JSON.stringify(project)], { type: 'text/plain;charset=utf-8' })\n    saveAs(blob, filename + '.rachel')\n  }\n}\n","import { RATreeNode } from '../ratree/raTreeNode'\nimport { UnaryNode } from '../ratree/unaryNode'\nimport { BinaryNode } from '../ratree/binaryNode'\nimport { ProjectionNode } from '../ratree/projectionNode'\nimport { RenameNode } from '../ratree/renameNode'\nimport { SelectionNode } from '../ratree/selectionNode'\nimport { AntijoinNode } from '../ratree/antijoinNode'\nimport { CartesianProductNode } from '../ratree/cartesianProductNode'\nimport { DivisionNode } from '../ratree/divisionNode'\nimport { OuterJoinNode } from '../ratree/outerJoinNode'\nimport { NaturalJoinNode, NaturalJoinType } from '../ratree/naturalJoinNode'\nimport { SetOperationNode, SetOperationType } from '../ratree/setOperationNode'\nimport { ThetaJoinNode, ThetaJoinType } from '../ratree/thetaJoinNode'\n\n\nexport const OperationsTypes: string[] = ['antijoin', 'cartesian', 'division', 'natural', 'outerJoin', 'projection',\n  'rename', 'selection', 'semijoin', 'setOperation', 'thetaJoin', 'thetaSemijoin']\n\n/**\n * Counts of all supported relational algebra operations.\n */\nexport interface OperationsCount {\n  antijoin: number\n  cartesian: number\n  division: number\n  natural: number\n  outerJoin: number\n  projection: number\n  rename: number\n  selection: number\n  semijoin: number\n  union: number\n  intersection: number\n  difference: number\n  thetaJoin: number\n  thetaSemijoin: number\n}\n\n/**\n * Creates zero counts for all operations.\n */\nexport function zeroOperations (): OperationsCount {\n  return addOperations()\n}\n\n/**\n * Adds given OperationsCounts together.\n */\nexport function addOperations (...counts: OperationsCount[]): OperationsCount {\n  return {\n    antijoin: counts.reduce((agg, count) => agg + count.antijoin, 0),\n    cartesian: counts.reduce((agg, count) => agg + count.cartesian, 0),\n    division: counts.reduce((agg, count) => agg + count.division, 0),\n    natural: counts.reduce((agg, count) => agg + count.natural, 0),\n    outerJoin: counts.reduce((agg, count) => agg + count.outerJoin, 0),\n    projection: counts.reduce((agg, count) => agg + count.projection, 0),\n    rename: counts.reduce((agg, count) => agg + count.rename, 0),\n    selection: counts.reduce((agg, count) => agg + count.selection, 0),\n    semijoin: counts.reduce((agg, count) => agg + count.semijoin, 0),\n    union: counts.reduce((agg, count) => agg + count.union, 0),\n    intersection: counts.reduce((agg, count) => agg + count.intersection, 0),\n    difference: counts.reduce((agg, count) => agg + count.difference, 0),\n    thetaJoin: counts.reduce((agg, count) => agg + count.thetaJoin, 0),\n    thetaSemijoin: counts.reduce((agg, count) => agg + count.thetaSemijoin, 0),\n  }\n}\n\n/**\n * Sums all operation counts.\n */\nexport function totalOperations (o: OperationsCount): number {\n  return binaryOperations(o) + unaryOperations(o)\n}\n\n/**\n * Sums all binary operation counts.\n */\nexport function binaryOperations (o: OperationsCount): number {\n  return o.antijoin + o.cartesian + o.division + o.natural + o.outerJoin + o.semijoin + o.union + o.intersection\n    + o.difference + o.thetaJoin + o.thetaSemijoin\n}\n\n/**\n * Sums all unary operation counts.\n */\nexport function unaryOperations (o: OperationsCount): number {\n  return o.projection + o.rename + o.selection\n}\n\n/**\n * Counts all operations used in the given tree.\n */\nexport function operationsOfTree (tree: RATreeNode): OperationsCount {\n  if (tree instanceof UnaryNode) {\n    return addOperations(operationOfUnaryNode(tree), operationsOfTree(tree.getSubtree()))\n  }\n  if (tree instanceof BinaryNode) {\n    return addOperations(operationOfBinaryNode(tree), operationsOfTree(tree.getLeftSubtree()), operationsOfTree(tree.getRightSubtree()))\n  }\n  // no subtree - relation node\n  return zeroOperations()\n}\n\n/**\n * Returns OperationsCount with one given unary operation count set to 1, other operators to 0.\n */\nexport function operationOfUnaryNode (node: UnaryNode): OperationsCount {\n  const ret: OperationsCount = zeroOperations()\n  if (node instanceof ProjectionNode) {\n    ret.projection = 1\n    return ret\n  }\n  if (node instanceof RenameNode) {\n    ret.rename = 1\n    return ret\n  }\n  if (node instanceof SelectionNode) {\n    ret.selection = 1\n    return ret\n  }\n  return ret\n}\n\n/**\n * Returns OperationsCount with one given binary operation count set to 1, other operators to 0.\n */\nexport function operationOfBinaryNode (node: BinaryNode): OperationsCount {\n  const ret: OperationsCount = zeroOperations()\n  if (node instanceof AntijoinNode) {\n    ret.antijoin = 1\n    return ret\n  }\n  if (node instanceof CartesianProductNode) {\n    ret.cartesian = 1\n    return ret\n  }\n  if (node instanceof DivisionNode) {\n    ret.division = 1\n    return ret\n  }\n  if (node instanceof OuterJoinNode) {\n    ret.outerJoin = 1\n    return ret\n  }\n  if (node instanceof NaturalJoinNode) {\n    if (node.getType() === NaturalJoinType.natural) {\n      ret.natural = 1\n    } else {\n      ret.semijoin = 1\n    }\n    return ret\n  }\n  if (node instanceof SetOperationNode) {\n    const type = node.getOperationSymbol()\n    if (type === SetOperationType.union) {\n      ret.union = 1\n    } else if (type === SetOperationType.intersection) {\n      ret.intersection = 1\n    } else {\n      ret.difference = 1\n    }\n    return ret\n  }\n  if (node instanceof ThetaJoinNode) {\n    if (node.getType() === ThetaJoinType.full) {\n      ret.thetaJoin = 1\n    } else {\n      ret.thetaSemijoin = 1\n    }\n    return ret\n  }\n  return ret\n}\n","import { OperationsCount, OperationsTypes } from './operationsCount'\n\n/**\n * Rule for operations count. Should return \"OK\" when it is held, \"ERROR ruleName: ruleDescription\" if not.\n */\nexport type OperationRule = (ops: OperationsCount) => string\n\n/**\n * Rule for tables count. Should return \"OK\" when it is held, \"ERROR ruleName: ruleDescription\" if not.\n */\nexport type TableRule = (tables: number) => string\n\n/**\n * Rule for queries count. Should return \"OK\" when it is held, \"ERROR ruleName: ruleDescription\" if not.\n */\nexport type QueryRule = (tables: number) => string\n\n/**\n * Compares the given number to the predefined value.\n */\nexport type CountComparator = (x: number) => string\n\n/**\n * Creates a CountComparator function with the given count.\n *\n * @param count values to be compared to, expected to be a number or an object with any of the following fields:\n * \"$eq\", \"$gte\", \"$gt\", \"$lte\", \"$lt\".\n * @return created comparator or undefined if count is invalid\n */\nexport const createCountComparator = (count: any): CountComparator | undefined => {\n  // case of \"count\": 5, etc.\n  if (typeof count === 'number') {\n    return (x: number) => {\n      if (x === count) {\n        return ''\n      }\n      return `Expected ${count}, found ${x}`\n    }\n  }\n  // case of \"count\": { \"$eq\": 5 }, etc.\n  if (typeof count === 'object') {\n    const comparators: CountComparator[] = []\n    for (const field in count) {\n      const countValue = count[field]\n      if (typeof countValue !== 'number') {\n        console.warn(field + ' parameter of count field is not a number')\n        return undefined\n      }\n      if (field === '$eq') {\n        comparators.push((x: number) => {\n          if (x === countValue) {\n            return ''\n          }\n          return `Expected ${countValue}, found ${x}`\n        })\n      } else if (field === '$gte') {\n        comparators.push((x: number) => {\n          if (x >= countValue) {\n            return ''\n          }\n          return `Expected greater or equal to ${countValue}, found ${x}`\n        })\n      } else if (field === '$gt') {\n        comparators.push((x: number) => {\n          if (x > countValue) {\n            return ''\n          }\n          return `Expected greater than ${countValue}, found ${x}`\n        })\n      } else if (field === '$lte') {\n        comparators.push((x: number) => {\n          if (x <= countValue) {\n            return ''\n          }\n          return `Expected less or equal to ${countValue}, found ${x}`\n        })\n      } else if (field === '$lt') {\n        comparators.push((x: number) => {\n          if (x < countValue) {\n            return ''\n          }\n          return `Expected less than ${countValue}, found ${x}`\n        })\n      }\n    }\n    if (comparators.length === 0) {\n      console.warn('Count objects has no valid parameters')\n      return undefined\n    }\n    return (x: number) => comparators.map(comparator => comparator(x)).filter(msg => msg !== '').join(' + ')\n  }\n  console.warn('Count field is not a number nor object')\n  return undefined\n}\n\n/**\n * Sums predefined subset of operations.\n */\nexport type OperationsCounter = (x: OperationsCount) => number\n\n/**\n * Creates a OperationsCounter function with the given operations to count.\n *\n * @param ops operations to be counted, expected to be a string or an array of string, each string must be supported\n * operation type\n * @return created counter or undefined if ops is invalid\n */\nexport const createOperationsCounter = (ops: any): OperationsCounter | undefined => {\n  if (typeof ops === 'string') {\n    if (!OperationsTypes.includes(ops)) {\n      console.warn('Invalid value of operations field: ' + ops)\n      return undefined\n    }\n    // @ts-ignore\n    return (x: OperationsCount) => x[ops]\n  } else if (Array.isArray(ops)) {\n    if (ops.some(op => !OperationsTypes.includes(op))) {\n      console.warn('Invalid value of operation in operations field: ' + ops)\n      return undefined\n    }\n    const _ops = [...ops]\n    // @ts-ignore\n    return (x: OperationsCount) => _ops.reduce<number>((prev, cur) => prev + x[cur], 0)\n  }\n  console.warn('Invalid operations field')\n  return undefined\n}\n\n/**\n * Creates a OperationsCounter function with the given operations to indicate (returns +1 for present operations, 0 for\n * absent ones).\n *\n * @param ops operations to be searched for, expected to be a string or an array of string, each string must be supported\n * operation type\n * @return created indicator or undefined if ops is invalid\n */\nexport const createOperationsIndicator = (ops: any): OperationsCounter | undefined => {\n  if (typeof ops === 'string') {\n    if (!OperationsTypes.includes(ops)) {\n      console.warn('Invalid value of operations field: ' + ops)\n      return undefined\n    }\n    // @ts-ignore\n    return (x: OperationsCount) => Math.sign(x[ops])\n  } else if (Array.isArray(ops)) {\n    if (ops.some(op => !OperationsTypes.includes(op))) {\n      console.warn('Invalid value of operation in operations field: ' + ops)\n      return undefined\n    }\n    const _ops = [...ops]\n    // @ts-ignore\n    return (x: OperationsCount) => _ops.reduce<number>((prev, cur) => prev + Math.sign(x[cur]), 0)\n  }\n  console.warn('Invalid operations field')\n  return undefined\n}\n\nexport const getDescription = (ruleDef: any): string => {\n  return ruleDef.description ? ` (${ruleDef.description})` : ''\n}\n\n/**\n * Creates an OperationRule for total count of given operations.\n *\n * @param ruleDef definition of the rule. Expected to contain \"count\" (number/count object) field. If the optional \"unique\" (boolean)\n * field is true, the created rule counts occurrences of operations as 0/1. If the \"description\" (string) is set, it is\n * appended to the returning error description.\n * @param ops operations to count\n */\nexport const createCountOperationRule = (ruleDef: any, ops: string[]): OperationRule | undefined => {\n  const unique = ruleDef.unique === true\n  const comparator = createCountComparator(ruleDef.count)\n  const counter = unique ? createOperationsIndicator(ops) : createOperationsCounter(ops)\n  if (comparator !== undefined && counter !== undefined) {\n    return (x: OperationsCount) => {\n      const result = comparator(counter(x))\n      if (result === '') {\n        return 'OK'\n      }\n      return `${unique ? 'Unique count' : 'Count'} of operations \"${ops.join(', ')}\": ${result}${getDescription(ruleDef)}`\n    }\n  }\n}\n\n/**\n * Creates an OperationRule for counts of each from given operations.\n *\n * @param ruleDef definition of the rule. Expected to contain \"each\" (number/count object) field. If the \"description\" (string) is set, it is\n * appended to the returning error description.\n * @param ops operations to count\n */\nexport const createEachOperationRule = (ruleDef: any, ops: string[]): OperationRule | undefined => {\n  const subRules: OperationRule[] = []\n  // @ts-ignore\n  ops.forEach((op: string) => {\n    const comparator = createCountComparator(ruleDef.each)\n    const counter = createOperationsCounter(op)\n    if (comparator !== undefined && counter !== undefined) {\n      const subRule = (x: OperationsCount) => {\n        const result = comparator(counter(x))\n        if (result === '') {\n          return 'OK'\n        }\n        return `${op}: ${result}`\n      }\n      subRules.push(subRule)\n    }\n  })\n  if (subRules.length > 0) {\n    return (x: OperationsCount) => {\n      const errors = subRules.map(sr => sr(x)).filter(msg => msg !== 'OK').join(',\\n - ')\n      if (errors === '') {\n        return 'OK'\n      }\n      return `Count of each operation \"${ops.join(', ')}\"${getDescription(ruleDef)}:\\n - ${errors}`\n    }\n  }\n}\n\n/**\n * Creates a TableRule.\n *\n * @param ruleDef definition of the rule. Expected to contain \"tables\" (number/count object) field. If the \"description\" (string) is set, it is\n * appended to the returning error description.\n */\nexport const createTableRule = (ruleDef: any): TableRule | undefined => {\n  const comparator = createCountComparator(ruleDef.tables)\n  if (comparator !== undefined) {\n    return (x: number) => {\n      const result = comparator(x)\n      if (result === '') {\n        return 'OK'\n      }\n      return `Count of tables: ${result}${getDescription(ruleDef)}`\n    }\n  }\n}\n\n/**\n * Creates a QueryRule.\n *\n * @param ruleDef definition of the rule. Expected to contain \"queries\" (number/count object) field. If the \"description\" (string) is set, it is\n * appended to the returning error description.\n */\nexport const createQueryRule = (ruleDef: any): QueryRule | undefined => {\n  const comparator = createCountComparator(ruleDef.queries)\n  if (comparator !== undefined) {\n    return (x: number) => {\n      const result = comparator(x)\n      if (result === '') {\n        return 'OK'\n      }\n      return `Count of queries: ${result}${getDescription(ruleDef)}`\n    }\n  }\n}\n\n/**\n * Modifies given name of source project to report name.\n */\nexport type ReportNameModifier = (name: string) => string\n\nconst removeExtension = (name: string) => {\n  const lastDotIndex = name.lastIndexOf('.')\n  return (lastDotIndex > -1 ? name.slice(0, lastDotIndex) : name)\n}\n\nexport const identityReportNameModifier = (name: string) => {\n  return removeExtension(name) + '.txt'\n}\n\n/**\n * Creates ReportNameModifier which given path parts joined with given joiner.\n * The config can specified the following fields:\n * * usePathParts if the array is empty, all path parts are used\n * * joinPathParts if the string is undefined, original path joiners are kept\n * * prefix string to prepend to the name\n * * suffix string to append to the name\n */\nexport const createReportNameModifier = (config: any): ReportNameModifier => {\n  let modifier = removeExtension\n\n  let usePathParts: number[] = []\n  let joinPathParts: string | undefined\n  let prefix = ''\n  let suffix = ''\n\n  for (const fieldName in config) {\n    const field = config[fieldName]\n    if (fieldName === 'usePathParts' && Array.isArray(field) && field.every(n => typeof n === 'number')) {\n      usePathParts = field\n      continue\n    }\n    if (fieldName === 'joinPathParts' && typeof field === 'string') {\n      joinPathParts = field\n      continue\n    }\n    if (fieldName === 'prefix' && typeof field === 'string') {\n      prefix = field\n      continue\n    }\n    if (fieldName === 'suffix' && typeof field === 'string') {\n      suffix = field\n    }\n  }\n\n  if (usePathParts.length > 0) {\n    const previousModifier = modifier\n    modifier = (name) => {\n      const parts = previousModifier(name).split(/[/\\\\]/g)\n      const count = parts.length\n      return parts.filter((part, i) => usePathParts.includes(count - i)).join('/')\n    }\n  }\n\n  if (joinPathParts !== undefined) {\n    const previousModifier = modifier\n    // @ts-ignore\n    modifier = (name) => previousModifier(name).replace(/[/\\\\]/g, joinPathParts)\n  }\n\n  return (name) => prefix + modifier(name) + suffix + '.txt'\n}\n","import { FileDialog } from '../utils/fileDialog'\nimport JSZip from 'jszip'\nimport { saveAs } from 'file-saver'\nimport { Relation } from '../relation/relation'\nimport { isProjectObject, Project } from '../project/project'\nimport { ExprParser } from '../expression/exprParser'\nimport { StoredRelation, StoredRelationData } from '../relation/storedRelation'\nimport { Expression } from '../expression/expression'\nimport { MessageBox } from '../components/messageBox'\nimport {\n  addOperations,\n  binaryOperations,\n  OperationsCount,\n  operationsOfTree,\n  totalOperations,\n  unaryOperations,\n  zeroOperations,\n} from './operationsCount'\nimport {\n  createCountOperationRule,\n  createEachOperationRule,\n  createQueryRule,\n  createReportNameModifier,\n  createTableRule,\n  identityReportNameModifier,\n  OperationRule,\n  QueryRule,\n  ReportNameModifier,\n  TableRule,\n} from './configUtils'\nimport { language } from '../language/language'\n\n/**\n * Class for processing multiple input .rachel project files and generating their reports.\n * @category Batch\n * @public\n */\nexport class BatchProcessor {\n\n  private static loadType: 'files' | 'zip' = 'zip'\n  private static resultFilename = 'rachel-eval-results'\n  private static configurationFileName: string | null = null\n  private static reportNameModifier: ReportNameModifier = identityReportNameModifier\n  private static operationRules: OperationRule[] = []\n  private static tableRules: TableRule[] = []\n  private static queryRules: QueryRule[] = []\n\n  /**\n   * Opens file dialog and loads configuration from a JSON file.\n   *\n   * @return promise with string description of the loaded configuration\n   * @public\n   */\n  static async config (): Promise<string> {\n    return await new Promise<string>((resolve, reject) => {\n      FileDialog.openFile('.json').then(file => {\n        if (file.text === null) {\n          return reject('No content read from the configuration file ' + file.name)\n        } else if (/\\.json$/.exec(file.name)) {\n          BatchProcessor.loadType = 'zip'\n          BatchProcessor.configurationFileName = file.name\n          BatchProcessor.reportNameModifier = identityReportNameModifier\n          BatchProcessor.operationRules = []\n          BatchProcessor.tableRules = []\n          BatchProcessor.queryRules = []\n          try {\n            const config = JSON.parse(file.text)\n            let loaded = 0\n            let skipped = 0\n            for (const ruleName in config) {\n              const rule = config[ruleName]\n              // sets loading type\n              if (ruleName === 'loadType' && typeof rule === 'string' && (rule === 'zip' || rule === 'files')) {\n                BatchProcessor.loadType = rule\n                continue\n              }\n              // sets result zip file name\n              if (ruleName === 'resultFilename' && typeof rule === 'string') {\n                BatchProcessor.resultFilename = rule\n                continue\n              }\n              // sets result zip file name\n              if (ruleName === 'reportName') {\n                BatchProcessor.reportNameModifier = createReportNameModifier(rule)\n                continue\n              }\n              if (BatchProcessor.createRule(ruleName, rule)) {\n                ++loaded\n              } else {\n                ++skipped\n              }\n            }\n            return resolve(loaded + ' rules loaded from the configuration file, ' + skipped + ' skipped')\n          } catch (e) {\n            return reject('Invalid configuration file ' + file.name + ': ' + e)\n          }\n        } else {\n          return reject('Unsupported type of the configuration file ' + file.name)\n        }\n      })\n    })\n  }\n\n  /**\n   * Returns formatted information about current loaded config file and its rules.\n   *\n   * @return string information\n   */\n  static getConfigInfo (): string {\n    if (BatchProcessor.configurationFileName !== null) {\n      const msg = language().managementSection.batchConfigInfo\n      return msg[0] + BatchProcessor.configurationFileName + msg[1]\n        + (BatchProcessor.operationRules.length + BatchProcessor.tableRules.length + BatchProcessor.queryRules.length) + msg[2]\n    }\n    return language().managementSection.batchNoConfig\n  }\n\n  /**\n   * Creates individual rule object and adds it in BatchProcessor rules array.\n   *\n   * @param ruleName name of the rule\n   * @param ruleDef rule definition from the configuration JSON file\n   * @return true if the rule was created successfully\n   */\n  private static createRule (ruleName: string, ruleDef: any): boolean {\n    const fields: string[] = []\n    for (const field in ruleDef) {\n      fields.push(field)\n    }\n    if (fields.length === 0) {\n      console.log('Rule ' + ruleName + ' has no fields specified.')\n      return false\n    }\n    // case of an operation rule\n    if (fields.includes('operations')) {\n      const ops: string[] = Array.isArray(ruleDef.operations) ? ruleDef.operations : [ruleDef.operations]\n      // creates a rule for a total count of all listed operations together\n      if (fields.includes('count')) {\n        const rule = createCountOperationRule(ruleDef, ops)\n        if (rule !== undefined) {\n          BatchProcessor.operationRules.push(rule)\n          return true\n        }\n      }\n      // creates a rule for a count of each listed operation\n      else if (fields.includes('each')) {\n        const rule = createEachOperationRule(ruleDef, ops)\n        if (rule !== undefined) {\n          BatchProcessor.operationRules.push(rule)\n          return true\n        }\n      }\n      return false\n    }\n    // case of a table rule\n    else if (fields.includes('tables')) {\n      const rule = createTableRule(ruleDef)\n      if (rule !== undefined) {\n        BatchProcessor.tableRules.push(rule)\n        return true\n      }\n    }\n    // case of a query rule\n    else if (fields.includes('queries')) {\n      const rule = createQueryRule(ruleDef)\n      if (rule !== undefined) {\n        BatchProcessor.queryRules.push(rule)\n        return true\n      }\n    }\n    return false\n  }\n\n  /**\n   * Opens file dialog and processes project files selected by the user.\n   * If the configuration is set to use multiple files, lets the user select multiple .rachel files.\n   * If the configuration is set to use a zip file, lets the user select one zip file with .rachel files.\n   * For each .rachel file creates a textual evaluation report.\n   *\n   * @public\n   */\n  static process (): void {\n    if (BatchProcessor.loadType === 'files') {\n      FileDialog.openFiles('.rachel').then(files => BatchProcessor.processFiles(files))\n    } else {\n      FileDialog.openZip()\n        .then(async result => await JSZip.loadAsync(result, { createFolders: true }))\n        .then(zip => {\n          // final array of unzipped files\n          const files: { name: string, text: string }[] = []\n          // uses only .rachel files in a ZIP\n          const zippedFiles = Object.values(zip.files).filter(file => !file.dir)\n          const count = zippedFiles.length\n          zippedFiles.forEach(zippedFile => {\n            zippedFile.async('string').then(text => {\n              files.push({ name: zippedFile.name, text })\n              // if all files are unzipped, processes them\n              if (files.length === count) {\n                BatchProcessor.processFiles(files)\n              }\n            })\n          })\n        })\n        .catch(_ => {\n          console.warn('Error in loading a zip file.')\n          MessageBox.error('Error in loading a zip file.')\n        })\n    }\n  }\n\n  /**\n   * For each given file creates a report.\n   *\n   * @param files loaded textual files expected to be .rachel project files\n   */\n  private static readonly processFiles = (files: { name: string, text: string | null }[]) => {\n    console.log(files.length + ' files loaded to BatchProcessor')\n    console.time('Batch duration')\n\n    const reports: { name: string, text: string }[] = []\n    let processed = 0\n    let skipped = 0\n\n    /**\n     * Processes a file on the given index and calls the processing of the next file.\n     * If all files were processed, calls downloadReports().\n     */\n    const processNext = (i: number) => {\n      if (i >= files.length) {\n        return downloadReports()\n      }\n      const file = files[i]\n      const name = BatchProcessor.reportNameModifier(file.name)\n      if (file.text === null) {\n        skipped += 1\n        console.warn('Null read from ' + file.name)\n      } else if (/\\.rachel$/.exec(file.name)) {\n        // @ts-ignore\n        const report = BatchProcessor.processFile(file, name)\n        reports.push(report)\n        processed += 1\n      } else {\n        skipped += 1\n        console.warn('Unsupported filetype: ' + file.name)\n      }\n      MessageBox.message('Batch in progress... ' + (processed + skipped) + '/' + files.length)\n      setTimeout(() => processNext(i + 1), 0)\n    }\n\n    /**\n     * Downloads created reports.\n     */\n    const downloadReports = () => {\n      const zip: JSZip = JSZip()\n      reports.forEach(report => {\n        zip.file(report.name, report.text)\n      })\n      zip.generateAsync({ type: 'blob' }).then(content => {\n        saveAs(content, BatchProcessor.resultFilename + '.zip')\n        console.log('Batch finished: ' + processed + ' files processed, ' + skipped + ' skipped.')\n        MessageBox.message('Batch finished: ' + processed + ' files processed, ' + skipped + ' skipped.')\n      }).catch(err => {\n        MessageBox.error('Batch results saving error: ' + err.message)\n      })\n      console.timeEnd('Batch duration')\n    }\n\n    processNext(0)\n  }\n\n  /**\n   * Tries to parse Project object from given file.text. If successful, parses relations in the project, evaluates\n   * expressions in the project and generates textual report: header (see reportHeader()),\n   * formatted relations (see formatRelations()) and formatted expressions (see processExpression()).\n   *\n   * @param file JSON file to process (its name and text)\n   * @param name name of the generated report\n   * @throws SyntaxError when the given file content is not a valid JSON\n   */\n  private static readonly processFile = (file: { name: string, text: string }, name: string): { name: string, text: string } => {\n    let project: Project\n    try {\n      project = JSON.parse(file.text)\n      const status = isProjectObject(project)\n      if (status !== 'OK') {\n        return { name, text: 'Invalid JSON file: ' + status }\n      }\n    } catch (e) {\n      console.warn('Batch processing error in file ' + file.name + ': ' + e)\n      return { name, text: 'Invalid JSON file: ' + e }\n    }\n\n    const relations: Map<string, Relation> = BatchProcessor.parseRelations(project.relations, project.nullValuesSupport)\n    const exprParser: ExprParser = new ExprParser(relations, project.nullValuesSupport)\n\n    const exprCount: number = project.expressions.length\n    const reports = project.expressions.map(e => BatchProcessor.processExpression(e, exprParser))\n    const ops: OperationsCount = addOperations(...reports.map(r => r.counts))\n    const errors: number = reports.reduce((agg, report) => agg + report.error, 0)\n\n    return {\n      name,\n      text: BatchProcessor.reportHeader(file.name, project.relations.length, exprCount, errors, ops, project.nullValuesSupport)\n        + BatchProcessor.formatRelations(project.relations)\n        + sectionLine + '\\n\\nQUERIES (' + exprCount + ')\\n\\n'\n        + reports.map(r => r.text).join('') + sectionLine + '\\n\\n',\n    }\n  }\n\n  /**\n   * Creates Relation representation for given StoredRelationData array.\n   */\n  private static parseRelations (storedData: StoredRelationData[], nullValuesSupport: boolean): Map<string, Relation> {\n    const map: Map<string, Relation> = new Map()\n    storedData.forEach(data => {\n      try {\n        const storedRelation: StoredRelation = StoredRelation.fromData(data, nullValuesSupport)\n        if (storedRelation.isValid()) {\n          map.set(storedRelation.getName(), storedRelation.createRelation())\n        }\n      } catch (ignored) {\n      }\n    })\n    return map\n  }\n\n  /**\n   * Processes the given expression in the context of the given parser. Returns a formatted expression and its result\n   * (or error), a count of used RA operations and 0/1 error indicator.\n   */\n  private static readonly processExpression = (expr: Expression, parser: ExprParser): { text: string, counts: OperationsCount, error: number } => {\n    try {\n      const evaluationTree = parser.parse(expr.text)\n      const counts: OperationsCount = operationsOfTree(evaluationTree)\n      const relation: Relation = evaluationTree.getResult()\n      return {\n        text: contentLine + '\\n' + expr.name + '\\n\\n' + expr.text + '\\n\\n' + relation.contentString() + '\\n\\n\\n',\n        counts: counts,\n        error: 0,\n      }\n    } catch (err) {\n      return {\n        text: contentLine + '\\n' + expr.name + '\\n\\n' + expr.text + '\\n\\nERROR: ' + err.message + '\\n\\n\\n',\n        counts: zeroOperations(),\n        error: 1,\n      }\n    }\n  }\n\n  /**\n   * Creates the header of the report. The header contains the time of the report, count of expressions and errors,\n   * count of used operations and null values support info.\n   *\n   * @param name name of the processed file\n   * @param rels count of relations\n   * @param exprs count of expressions\n   * @param errs count of errors\n   * @param ops count of operations\n   * @param nvs whether null values are supported\n   */\n  private static readonly reportHeader = (name: string, rels: number, exprs: number, errs: number, ops: OperationsCount, nvs: boolean): string => {\n    const total: number = totalOperations(ops)\n    const binary: number = binaryOperations(ops)\n    const unary: number = unaryOperations(ops)\n    let ruleErrors: string[] = BatchProcessor.operationRules.map(rule => rule(ops))\n    ruleErrors.push(...BatchProcessor.tableRules.map(rule => rule(rels)))\n    ruleErrors.push(...BatchProcessor.queryRules.map(rule => rule(exprs)))\n    const rulesCount = ruleErrors.length\n    ruleErrors = ruleErrors.filter(msg => msg !== 'OK')\n    const errorsCount = ruleErrors.length\n    return sectionLine + '\\n\\nRachel project report from ' + new Date().toLocaleString('cs-CZ') + '\\nSource: '\n      + name + '\\n\\n' + sectionLine + '\\n\\nQueries: ' + exprs + '    Invalid queries: ' + errs + '\\n\\n'\n      + (errorsCount === 0\n        ? 'No errors'\n        : 'Errors (' + errorsCount + ' errors/' + rulesCount + ' rules):\\n'\n        + ruleErrors.map((err, i) => `${i + 1}) ${err}`).join('\\n')) + '\\n\\n'\n      + 'Used operations (' + total + ' in total: ' + binary + ' binary, ' + unary + ' unary):\\n'\n      + '    Selection: ' + ops.selection + '\\n'\n      + '    Projection: ' + ops.projection + '\\n'\n      + '    Rename: ' + ops.rename + '\\n\\n'\n      + '    Union: ' + ops.union + '\\n'\n      + '    Intersection: ' + ops.intersection + '\\n'\n      + '    Difference: ' + ops.difference + '\\n\\n'\n      + '    Natural join: ' + ops.natural + '\\n'\n      + '    Cartesian product: ' + ops.cartesian + '\\n'\n      + '    Semijoin: ' + ops.semijoin + '\\n'\n      + '    Antijoin: ' + ops.antijoin + '\\n'\n      + '    Theta Join: ' + ops.thetaJoin + '\\n'\n      + '    Theta Semijoin: ' + ops.thetaSemijoin + '\\n\\n'\n      + '    Outer Join: ' + ops.outerJoin + '\\n\\n'\n      + '    Division: ' + ops.division + '\\n\\n'\n      + 'Null values ' + (nvs ? 'ALLOWED.\\n\\n' : 'FORBIDDEN.\\n\\n')\n  }\n\n  /**\n   * Returns formatted string for the given StoredRelationsData array.\n   */\n  private static readonly formatRelations = (storedData: StoredRelationData[]): string => {\n    const inlines = storedData.map(data => {\n      return data.name + '(' + data.columnNames.join(', ') + ')\\n'\n    }).join('')\n    return sectionLine + '\\n\\nTABLES (' + storedData.length + ')\\n\\n' + inlines + '\\n'\n      + storedData.map(data => contentLine + '\\n' + data.name + '\\n\\n' + StoredRelation.format(data)).join('')\n  }\n}\n\nconst sectionLine = '################################################################################'\nconst contentLine = '--------------------------------------------------------------------------------'\n","import React from 'react'\nimport './css/editRelationTable.css'\nimport { StoredRelation } from '../relation/storedRelation'\nimport { SupportedColumnType } from '../relation/columnType'\nimport { NNToSMap } from '../types/nnToSMap'\n\n/**\n * Props of EditRelationTable component.\n * @category Components\n * @public\n */\ninterface EditRelationTableProps {\n  /**\n     * stored representation of the relation to be edited\n     * @type StoredRelation\n     * @public\n     */\n  relation: StoredRelation\n  /**\n     * handler of column name change\n     * @type function\n     * @public\n     */\n  onColumnNameChange: (columnName: string, columnIndex: number) => void,\n  /**\n     * handler of column type change\n     * @type function\n     * @public\n     */\n  onColumnTypeChange: (columnType: SupportedColumnType, columnIndex: number) => void,\n  /**\n     * handler of row input change\n     * @type function\n     * @public\n     */\n  onRowInputChange: (input: string, columnIndex: number, rowIndex: number) => void,\n  /**\n     * handler of adding new row\n     * @type function\n     * @public\n     */\n  onNewRow: (onDone: () => void) => void\n  /**\n     * handler of adding new column\n     * @type function\n     * @public\n     */\n  onNewColumn: (onDone: () => void) => void\n  /**\n     * handler of deleting the row of given index\n     * @type function\n     * @public\n     */\n  onDeleteRow: (rowIndex: number) => void\n  /**\n     * handler of deleting the column of given index\n     * @type function\n     * @public\n     */\n  onDeleteColumn: (columnIndex: number) => void\n  /**\n     * handler of input with Ctrl key\n     * @type function\n     * @public\n     */\n  onCtrlInput: (ev: React.KeyboardEvent) => void\n}\n\ninterface EditRelationTableState {\n  selectedColumn: number | undefined\n  selectedRow: 'names' | 'types' | number | undefined\n}\n\n// @ts-ignore\nconst cssConstants: CSSStyleDeclaration = getComputedStyle(document.querySelector(':root'))\nconst cellPaddingSides = Number(cssConstants.getPropertyValue('--cell-padding-sides-num'))\nconst inputMarginSides = Number(cssConstants.getPropertyValue('--input-margin-sides-num'))\n\n/**\n * Table for editing a relation relation. It supports adding new columns and rows and editing all relation (column names,\n * column types and row inputs).\n * Accepts {@link EditRelationTableProps} props.\n * @category Components\n * @public\n */\nexport class EditRelationTable extends React.Component<EditRelationTableProps, EditRelationTableState> {\n  // reference to the table container div\n  private readonly containerRef: React.RefObject<HTMLDivElement>\n  // reference to the head row with columns names\n  private readonly tableHeadRowRef: React.RefObject<HTMLTableRowElement>\n  // width of cells in head (with deducted padding) to set proper inputs width to not resize the table\n  private columnWidths: number[] = []\n\n  constructor (props: EditRelationTableProps) {\n    super(props)\n    this.state = {\n      selectedColumn: undefined,\n      selectedRow: undefined,\n    }\n    this.containerRef = React.createRef<HTMLDivElement>()\n    this.tableHeadRowRef = React.createRef<HTMLTableRowElement>()\n  }\n\n  componentDidMount () {\n    // clicking in the window blurs the selected input (if clicked into a cell, event propagation is stopped to not blur\n    window.addEventListener('click', () => {\n      this.setSelectedInput(undefined, undefined)\n    })\n    this.componentDidUpdate()\n  }\n\n  componentDidUpdate () {\n    const headRow = this.tableHeadRowRef.current\n    if (headRow !== null) {\n      // cells without the first (line number) and last (add column button)\n      const cells = [...headRow.cells].slice(1, -1)\n      this.columnWidths = cells.map(cell => cell.clientWidth - 2 * (cellPaddingSides + inputMarginSides))\n    }\n  }\n\n  /**\n     * Changes column width if the resized input element does not fit in it anymore.\n     */\n  private readonly handleInputResize = (inputElement: EventTarget & HTMLInputElement, column: number) => {\n    // handles larger width\n    if (inputElement.scrollWidth > this.columnWidths[column]) {\n      this.columnWidths[column] = inputElement.scrollWidth\n    }\n  }\n\n  /**\n     * Returns error of the relation to edit.\n     */\n  private readonly getErrors = (): NNToSMap => {\n    return this.props.relation.getErrors()\n  }\n\n  /**\n     * Sets selected input column and row to given values.\n     */\n  private readonly setSelectedInput = (column: number | undefined, row: 'names' | 'types' | number | undefined): void => {\n    this.setState({\n      selectedColumn: column,\n      selectedRow: row,\n    })\n  }\n\n  /**\n     * Moves selected input to right if it is defined and not in the last column.\n     */\n  private readonly moveSelectedInputRight = (): void => {\n    const selectedColumn = this.state.selectedColumn\n    const selectedRow = this.state.selectedRow\n    if (selectedColumn !== undefined && selectedRow !== undefined) {\n      // if not last column was selected\n      if (selectedColumn < this.props.relation.getColumnCount() - 1) {\n        this.setState({ selectedColumn: selectedColumn + 1 })\n      }\n    }\n  }\n\n  /**\n     * Moves selected input to left if it is defined and not in the first column.\n     */\n  private readonly moveSelectedInputLeft = (): void => {\n    const selectedColumn = this.state.selectedColumn\n    const selectedRow = this.state.selectedRow\n    if (selectedColumn !== undefined && selectedRow !== undefined) {\n      // if not first column was selected\n      if (selectedColumn > 0) {\n        this.setState({ selectedColumn: selectedColumn - 1 })\n      }\n    }\n  }\n\n  /**\n     * Moves selected input up if it is defined and not in the first row.\n     */\n  private readonly moveSelectedInputUp = (): void => {\n    const selectedColumn = this.state.selectedColumn\n    const selectedRow = this.state.selectedRow\n    if (selectedColumn !== undefined && selectedRow !== undefined) {\n      // if not first row was selected\n      if (typeof selectedRow === 'number') {\n        if (selectedRow === 0) {\n          this.setState({ selectedRow: 'names' })\n        } else {\n          this.setState({ selectedRow: selectedRow - 1 })\n        }\n      }\n    }\n  }\n\n  /**\n     * Moves selected input down if it is defined and not in the last row.\n     */\n  private readonly moveSelectedInputDown = (): void => {\n    const selectedColumn = this.state.selectedColumn\n    const selectedRow = this.state.selectedRow\n    if (selectedColumn !== undefined && selectedRow !== undefined) {\n      if (selectedRow === 'names' && this.props.relation.getRowCount() > 0) {\n        this.setState({ selectedRow: 0 })\n      }\n      // if not last row was selected\n      if (typeof selectedRow === 'number' && selectedRow < this.props.relation.getRowCount() - 1) {\n        this.setState({ selectedRow: selectedRow + 1 })\n      }\n    }\n  }\n\n  /**\n     * Catches key inputs with special effects in tht table.\n     */\n  private readonly handleKeyDown = (event: React.KeyboardEvent): void => {\n    if (event.key === 'Enter' || event.key === 'Esc' || event.key === 'Escape') {\n      this.setSelectedInput(undefined, undefined)\n    } else if (event.key === 'Tab' || (event.ctrlKey && event.key === 'ArrowRight')) {\n      this.moveSelectedInputRight()\n      event.preventDefault()\n    } else if (event.ctrlKey && event.key === 'ArrowLeft') {\n      this.moveSelectedInputLeft()\n      event.preventDefault()\n    } else if (event.ctrlKey && event.key === 'ArrowUp') {\n      this.moveSelectedInputUp()\n      event.preventDefault()\n    } else if (event.ctrlKey && event.key === 'ArrowDown') {\n      this.moveSelectedInputDown()\n      event.preventDefault()\n    }\n    if (event.ctrlKey) {\n      this.props.onCtrlInput(event)\n    }\n  }\n\n  /**\n     * Passes the change of the column name, column type or row input to the parent element.\n     * When row = \"types\", it is expected that value is of SupportedColumnType type.\n     * Tabulators are replaced by 4 spaces.\n     */\n  private readonly handleChange = (value: string, column: number, row: 'names' | 'types' | number): void => {\n    value = value.replace(/\\t/g, '    ')\n    if (row === 'names') {\n      this.props.onColumnNameChange(value, column)\n    } else if (row === 'types') {\n      // @ts-ignore - should be ensured before method call\n      this.props.onColumnTypeChange(value, column)\n    } else {\n      this.props.onRowInputChange(value, column, row)\n    }\n  }\n\n  /**\n     * Adds a new column to the relation and scrolls to it.\n     */\n  private readonly handleNewColumn = (): void => {\n    this.props.onNewColumn(() => {\n      // @ts-ignore\n      this.containerRef.current.scrollTo(this.containerRef.current.clientWidth, this.containerRef.current.scrollTop)\n    })\n  }\n\n  /**\n     * Adds a new row to the relation and scrolls to it.\n     */\n  private readonly handleNewRow = (): void => {\n    this.props.onNewRow(() => {\n      // @ts-ignore\n      this.containerRef.current.scrollTo(this.containerRef.current.scrollLeft, this.containerRef.current.clientHeight)\n    })\n  }\n\n  /**\n     * Deletes the column at given index.\n     */\n  private readonly handleDeleteColumn = (column: number): void => {\n    this.props.onDeleteColumn(column)\n  }\n\n  /**\n     * Deletes the row at given index.\n     */\n  private readonly handleDeleteRow = (row: number): void => {\n    this.props.onDeleteRow(row)\n  }\n\n  /**\n     * Creates a text input bind to handling change of given column and row.\n     */\n  private readonly createInput = (value: string, column: number, row: 'names' | 'types' | number) => {\n    return (\n      <input\n        type='text'\n        className={'text-input'}\n        spellCheck={false}\n        value={value}\n        onChange={(e) => {\n          this.handleChange(e.target.value, column, row)\n          this.handleInputResize(e.target, column)\n        }}\n        autoFocus={true}\n        style={{ width: this.columnWidths[column] + 'px' }}\n      />\n    )\n  }\n\n  /**\n     * Creates a tooltip with given text.\n     */\n  private createTooltip (text: string, style?: React.CSSProperties) {\n    return (<span className={'tooltip'} style={style}>{text}</span>)\n  }\n\n  /**\n     * Creates a button for deleting rows or columns.\n     */\n  private readonly createDeleteButton = (callback: () => void) => {\n    return (<button className=\"delete-row-or-column-button\" onClick={callback}>&#10006;</button>)\n  }\n\n  /**\n     * Creates content of the first row of the table with column names.\n     * If the table is editable, additional blank column is added for \"add column\" button in next rows.\n     */\n  private createNamesRow () {\n    const rowData = this.props.relation.getColumnNames().map((columnName, columnIndex) => {\n      let content: string | JSX.Element = columnName\n      if (this.state.selectedColumn === columnIndex && this.state.selectedRow === 'names') {\n        content = this.createInput(columnName, columnIndex, 'names')\n      }\n      let span: null | JSX.Element = null\n      let className = 'name-th'\n      const error = this.getErrors().get('name', columnIndex)\n      if (error !== undefined) {\n        span = this.createTooltip(error, { top: '90%', bottom: 'auto' })\n        className += ' error-input'\n      }\n      return (\n        <th key={columnIndex}\n          className={className}\n          onClick={ev => {\n            this.setSelectedInput(columnIndex, 'names')\n            ev.stopPropagation()\n          }}\n        >{content}{span}</th>\n      )\n    })\n    // pushes \"add column\" button in last column\n    rowData.push(\n            <td key='add-column'\n              rowSpan={2}\n              style={{ width: '24px', border: 'none', padding: '1px' }}>\n              <button onClick={this.handleNewColumn}\n                style={{ width: '100%', height: '100%' }}><strong>+</strong></button>\n            </td>)\n    return (\n      <><td className=\"row-number-td\"/>{rowData}</>\n    )\n  }\n\n  /**\n     * Creates content of the second row of the table with column types.\n     * If the table is editable, \"add column\" button is added in the last column with row span to the end of the table.\n     */\n  private createTypesRow () {\n    const rowData = this.props.relation.getColumnTypes().map((columnType, columnIndex) => {\n      const content = (\n        <select value={columnType}\n          onChange={(e) => this.handleChange(e.target.value, columnIndex, 'types')}>\n          <option>number</option>\n          <option>string</option>\n          <option>boolean</option>\n        </select>\n      )\n      return (\n        <th key={columnIndex}\n          className=\"type-th\"\n        >{content}{this.createDeleteButton(() => this.handleDeleteColumn(columnIndex))}</th>\n      )\n    })\n    return (\n      <><td className=\"row-number-td\"/>{rowData}</>\n    )\n  }\n\n  /**\n     * Creates a data rows of the table.\n     */\n  private createRows () {\n    // creates default row if no exists\n    if (this.props.relation.getRows().length === 0) {\n      return null\n    }\n    const rows: string[][] = this.props.relation.getRows()\n    // creates all rows if any\n    return rows.map((row, rowIndex) => (\n      <tr key={rowIndex}>\n        <td className=\"row-number-td\">\n          {rowIndex + 1}\n          {this.createDeleteButton(() => this.handleDeleteRow(rowIndex))}\n        </td>\n        {row.map((value, columnIndex) => {\n          let content: string | JSX.Element = value\n          if (this.state.selectedColumn === columnIndex && this.state.selectedRow === rowIndex) {\n            content = this.createInput(value, columnIndex, rowIndex)\n          }\n          let span: null | JSX.Element = null\n          let className = ''\n          const error = this.getErrors().get(rowIndex, columnIndex)\n          if (error !== undefined) {\n            span = this.createTooltip(error)\n            className = 'error-input'\n          }\n          return (\n            <td key={columnIndex}\n              className={className}\n              onClick={ev => {\n                this.setSelectedInput(columnIndex, rowIndex)\n                ev.stopPropagation()\n              }}\n            >{content}{span}</td>\n          )\n        })}\n      </tr>\n    ))\n  }\n\n  /**\n     * Creates the last row of the table with button for adding rows.\n     */\n  private createAddRow () {\n    return (\n      <tr key='add-row'>\n        <td key='add-row-column'\n          className=\"add-row-td\">\n          <button onClick={this.handleNewRow}><strong>+</strong></button>\n        </td>\n      </tr>\n    )\n  }\n\n  render () {\n    const divClassName = 'edit-table-container scrollbar-container'\n    const tableClassName = 'edit-table'\n\n    return (\n      <div\n        className={divClassName}\n        ref={this.containerRef}\n        onKeyDown={this.handleKeyDown}>\n        <table className={tableClassName}>\n          <thead>\n            <tr ref={this.tableHeadRowRef}>{this.createNamesRow()}</tr>\n            <tr>{this.createTypesRow()}</tr>\n          </thead>\n          <tbody>\n            {this.createRows()}\n            {this.createAddRow()}\n          </tbody>\n        </table>\n      </div>\n    )\n  }\n}\n","import React from 'react'\nimport { Relation } from '../relation/relation'\nimport { TooltipButton } from './tooltipButton'\nimport { SupportedColumnType } from '../relation/columnType'\nimport { EditRelationTable } from './editRelationTable'\nimport { StoredRelation } from '../relation/storedRelation'\nimport { TextInput } from './textInput'\nimport { isForbiddenRelationName } from '../utils/keywords'\nimport { StringUtils } from '../utils/stringUtils'\nimport { MessageBox } from './messageBox'\nimport { LanguageDef } from '../language/language'\n\n/**\n * Props of RelationsSection component.\n * @category Components\n * @public\n */\ninterface RelationsSectionProps {\n  /**\n     * all stored relations\n     * @type StoredRelation[]\n     * @public\n     */\n  storedRelations: StoredRelation[]\n  /**\n     * index of the current selected relation\n     * @type number\n     * @public\n     */\n  storedRelationIndex: number\n  /**\n     * all currently loaded relations in the application\n     * @type Relation[]\n     * @public\n     */\n  loadedRelations: Relation[]\n  /**\n     * handler of change of the name of the current selected relation\n     * @type function\n     * @public\n     */\n  onRelationNameChange: (newName: string) => void\n  /**\n     * handler of change of the name of the column at given index in the current selected relation\n     * @type function\n     * @public\n     */\n  onColumnNameChange: (columnName: string, columnIndex: number) => void,\n  /**\n     * handler of change of the type of the column at given index in the current selected relation\n     * @type function\n     * @public\n     */\n  onColumnTypeChange: (columnType: SupportedColumnType, columnIndex: number) => void,\n  /**\n     * handler of change of the row input at given column/row index in the current selected relation\n     * @type function\n     * @public\n     */\n  onRowInputChange: (input: string, columnIndex: number, rowIndex: number) => void,\n  /**\n     * handler of adding a new row in the current selected relation\n     * @type function\n     * @public\n     */\n  onNewRow: (onDone: () => void) => void\n  /**\n     * handler of adding a new column in the current selected relation\n     * @type function\n     * @public\n     */\n  onNewColumn: (onDone: () => void) => void\n  /**\n     * handler of deleting the row on given index\n     * @type function\n     * @public\n     */\n  onDeleteRow: (rowIndex: number) => void\n  /**\n     * handler of deleting the column on given index\n     * @type function\n     * @public\n     */\n  onDeleteColumn: (columnIndex: number) => void\n  /**\n     * handler of selecting a different relation as current\n     * @type function\n     * @public\n     */\n  onSelectDifferentRelation: (newIndex: number) => void\n  /**\n     * handler of moving a relation on a new position using drag and drop\n     * @type function\n     * @public\n     */\n  onDragRelation: (from: number, to: number) => void,\n  /**\n     * handler of creating a new relation\n     * @type function\n     * @public\n     */\n  onNewRelation: () => void\n  /**\n     * handler of loading the current selected relation into the application\n     * @type function\n     * @public\n     */\n  onLoadRelation: (onDone: (msg: string) => void) => void\n  /**\n     * handler of deleting the current stored relation\n     * @type function\n     * @public\n     */\n  onDeleteStoredRelation: () => void\n  /**\n     * handler of reverting the current relation to its last saved (valid) state\n     * @type function\n     * @public\n     */\n  onRevertRelation: () => void\n  /**\n     * handler of loading all valid relations into the application\n     * @type function\n     * @public\n     */\n  onLoadAllRelations: (onDone: (msg: string) => void) => void\n  /**\n     * handler of deleting the loaded relations\n     * @type function\n     * @public\n     */\n  onRemoveLoadedRelations: (onDone: (msg: string) => void) => void\n  /**\n     * handler of saving the stored relations into the files\n     * @type function\n     * @public\n     */\n  onExportRelations: (onDone: (msg: string) => void) => void\n  /**\n     * handler of loading new relations from files\n     * @type function\n     * @public\n     */\n  onImportRelations: (onDone: (msg: string) => void) => void\n  /**\n     * whether to support null values\n     * @type boolean\n     * @public\n     */\n  nullValuesSupport: boolean\n  /**\n     * current application language\n     * @type LanguageDef\n     * @public\n     */\n  language: LanguageDef\n}\n\ninterface RelationsSectionState {\n  sectionClicked: boolean\n}\n\n/**\n * Identifier of elements drag-and-dropped from the RelationSection.\n */\nconst dndId = 'R'\n\n/**\n * Section to type the RA expression. It contains textarea for relations definition and control buttons.\n * Accepts {@link RelationsSectionProps} props.\n * @category Components\n * @public\n */\nexport class RelationsSection extends React.Component<RelationsSectionProps, RelationsSectionState> {\n\n  constructor (props: RelationsSectionProps) {\n    super(props)\n    this.state = {\n      sectionClicked: false,\n    }\n  }\n\n  /**\n     * Returns selected stored relation.\n     */\n  private readonly getCurRel = (): StoredRelation => {\n    return this.props.storedRelations[this.props.storedRelationIndex]\n  }\n\n  /**\n     * Passes change to the parent element if isShowingStored = true. Otherwise, changes the state.loadedRelationIndex.\n     */\n  private handleSelectDifferentRelation (index: number): void {\n    this.props.onSelectDifferentRelation(index)\n  }\n\n  /**\n     * Passes change of the relation name to the parent element.\n     */\n  private readonly handleRelationNameChange = (name: string) => {\n    this.props.onRelationNameChange(name)\n  }\n\n  /**\n     * Loads the selected relation to the application if there are no errors in it. Otherwise, displays a message to user.\n     */\n  private readonly loadRelation = () => {\n    if (this.getCurRel().isValid()) {\n      this.props.onLoadRelation(MessageBox.message)\n    } else {\n      MessageBox.error('Cannot use the invalid relation. Check errors and try again.')\n    }\n  }\n\n  /**\n     * Passes the load all relations call to the parent.\n     */\n  private readonly loadAllRelations = () => {\n    this.props.onLoadAllRelations(MessageBox.message)\n  }\n\n  /**\n     * Passes the export stored relations call to the parent.\n     */\n  private readonly exportRelations = () => {\n    this.props.onExportRelations(MessageBox.message)\n  }\n\n  /**\n     * Passes the import stored relations call to the parent.\n     */\n  private readonly importRelations = () => {\n    this.props.onImportRelations(MessageBox.message)\n  }\n\n  /**\n     * Passes the call to delete current selected stored relation.\n     */\n  private readonly deleteRelation = () => {\n    this.props.onDeleteStoredRelation()\n  }\n\n  private readonly revertRelation = () => {\n    this.props.onRevertRelation()\n  }\n\n  /**\n     * Passes the create new stored relation call to the parent.\n     */\n  private readonly newRelation = () => {\n    this.props.onNewRelation()\n  }\n\n  /**\n     * Passes the remove loaded relations call to the parent.\n     */\n  private readonly removeLoadedRelations = () => {\n    this.props.onRemoveLoadedRelations(MessageBox.message)\n  }\n\n  /**\n     * Handles input with Ctrl key pressed from relation table.\n     */\n  private readonly handleCtrlInput = (event: React.KeyboardEvent) => {\n    if (event.key === 'Enter') {\n      this.loadRelation()\n    }\n  }\n\n  /**\n     * Creates menu buttons. Buttons for relations with errors are highlighted.\n     */\n  private readonly createRelationMenuButtons = () => {\n    return this.props.storedRelations.map((rel, i) => {\n      const className: string = (this.props.storedRelationIndex === i ? 'button-clicked' : '')\n      const actuality: string = rel.isActual() ? '' : '*'\n      const style = rel.isValid() ? {} : { border: '2px solid #fd3030' }\n      return (\n        <button\n          key={i}\n          onClick={() => this.handleSelectDifferentRelation(i)}\n          className={className}\n          style={style}\n          draggable={true}\n          onDragStart={e => e.dataTransfer.setData('text/plain', dndId + String(i))}\n          onDragOver={e => e.preventDefault()}\n          onDrop={e => this.handleDragDrop(e, i)}\n        >{actuality + rel.getName()}</button>\n      )\n    })\n  }\n\n  /**\n     * Requests relation move when the drag ends.\n     */\n  // @ts-ignore\n  private readonly handleDragDrop = (e: DragEvent<HTMLDivElement>, i: number) => {\n    e.preventDefault()\n    const data = e.dataTransfer.getData('text/plain')\n    const fromIndex = Number(data.slice(1))\n    if (data.charAt(0) === dndId && !isNaN(fromIndex)) {\n      this.props.onDragRelation(fromIndex, i)\n    }\n  }\n\n  render () {\n    const lang = this.props.language.relationSection\n\n    const createButton = (text: string, onClick: () => void, tooltip: string, style?: React.CSSProperties) => {\n      return (<TooltipButton\n        key={text}\n        text={text}\n        onClick={onClick}\n        style={style}\n        tooltip={tooltip}\n      />)\n    }\n\n    // the relation cannot be renamed to forbidden relation names and other currently used relation names\n    const forbiddenRelationNames: string[] = this.props.storedRelations\n      .filter((sr, i) => i !== this.props.storedRelationIndex)\n      .map(sr => sr.getName())\n    const forbiddenNamesFunction = (text: string): boolean => {\n      if (forbiddenRelationNames.includes(text)) {\n        return true\n      }\n      return !StringUtils.isName(text) || isForbiddenRelationName(text)\n    }\n\n    return (\n      <section className=\"page-section\">\n        <header>\n          <h2>{lang.relationSectionHeader}</h2>\n          {createButton(lang.loadAllButton, this.loadAllRelations, lang.loadAllButtonTooltip)}\n          {createButton(lang.removeLoadedButton, this.removeLoadedRelations, lang.removeLoadedButtonTooltip)}\n          {createButton(lang.importButton, this.importRelations, lang.importButtonTooltip)}\n          {createButton(lang.exportButton, this.exportRelations, lang.exportButtonTooltip)}\n        </header>\n\n        <menu className=\"page-section-tab-menu\">\n          {this.createRelationMenuButtons()}\n          <button onClick={this.newRelation}\n            style={{ minWidth: '0', marginLeft: '10px', padding: '2px 6px 1px 6px' }}>\n            <strong>+</strong>\n          </button>\n        </menu>\n\n        <EditRelationTable\n          relation={this.getCurRel()}\n\n          onColumnNameChange={this.props.onColumnNameChange}\n          onColumnTypeChange={this.props.onColumnTypeChange}\n          onRowInputChange={this.props.onRowInputChange}\n          onNewRow={this.props.onNewRow}\n          onNewColumn={this.props.onNewColumn}\n          onDeleteRow={this.props.onDeleteRow}\n          onDeleteColumn={this.props.onDeleteColumn}\n\n          onCtrlInput={this.handleCtrlInput}\n        />\n\n        <menu className=\"page-section-management-menu\">\n          <TooltipButton\n            text={lang.loadButton}\n            onClick={this.loadRelation}\n            className={'action-button'}\n            style={{ marginRight: '40px' }}\n            tooltip={lang.loadButtonTooltip}\n          />\n          <TextInput\n            value={this.getCurRel().getName()}\n            buttonText={lang.renameButton}\n            onSubmit={this.handleRelationNameChange}\n            forbidden={forbiddenNamesFunction}\n            id=\"relation-name-input\"\n          />\n          {createButton(lang.deleteButton, this.deleteRelation, lang.deleteButtonTooltip)}\n          {createButton(lang.revertButton, this.revertRelation,\n                        lang.revertButtonTooltip + ' (' + this.getCurRel().getRevertName() + ')')}\n        </menu>\n      </section>\n    )\n  }\n}\n","interface SendData {\n  access_token: string\n  subject: string\n  text: string\n}\n\n/**\n * Class for sending emails. Powered by https://postmail.invotes.com/.\n * TypeScript version of JavaScript Copy & Paste Example from PostMail webpage.\n */\nexport class Mail {\n\n  /**\n     * Creates a mailer with given Mail access token.\n     *\n     * @param accessToken token which specifies Mail receiver of mails\n     */\n  constructor (readonly accessToken: string) {}\n\n  /**\n     * Sends given subject and body of the email to the Mail receiver.\n     *\n     * @param subject subject of the mail\n     * @param body body of the mail\n     */\n  send (subject: string, body: string): void {\n    const data_js: SendData = {\n      access_token: this.accessToken,\n      subject: subject,\n      text: body,\n    }\n\n    const request = new XMLHttpRequest()\n    request.onreadystatechange = function () {\n      if (request.readyState === 4 && request.status === 200) {\n      } else if (request.readyState === 4) {\n        console.log('failed creating XMLHttpRequest in Mail.send: ' + request.response)\n      }\n    }\n\n    const params = Mail.toParams(data_js)\n    request.open('POST', 'https://postmail.invotes.com/send', true)\n    request.setRequestHeader('Content-type', 'application/x-www-form-urlencoded')\n    request.send(params)\n  }\n\n  private static toParams (data: SendData): string {\n    return encodeURIComponent('access_token') + '=' + encodeURIComponent(data.access_token) + '&'\n            + encodeURIComponent('subject') + '=' + encodeURIComponent(data.subject) + '&'\n                + encodeURIComponent('text') + '=' + encodeURIComponent(data.text)\n  }\n}\n","import React, { Component } from 'react'\nimport { Relation } from '../relation/relation'\nimport { RATreeNode } from '../ratree/raTreeNode'\nimport { ExpressionSection } from './expressionSection'\nimport { ResultSection } from './resultSection'\nimport { ExpressionStoreManager } from '../expression/expressionStoreManager'\nimport { ManagementSection } from './managementSection'\nimport { CsvValueSeparator } from '../types/csvSupport'\nimport { ProjectStoreManager } from '../project/projectStoreManager'\nimport { language, LanguageDef, SupportedLanguage } from '../language/language'\nimport { LocalStorage } from '../utils/localStorage'\nimport { BatchProcessor } from '../batch/batchProcessor'\nimport { Expression } from '../expression/expression'\nimport { RelationsSection } from './relationsSection'\nimport { StoredRelation } from '../relation/storedRelation'\nimport { SupportedColumnType } from '../relation/columnType'\nimport { RelationStoreManager } from '../relation/relationStoreManager'\nimport { Mail } from '../utils/mail'\nimport { POSTMAIL_ACCESS_TOKEN } from '../postMailAccessToken'\nimport { copyProject, Project } from '../project/project'\nimport { getSamples } from '../project/samples'\nimport { MessageBox } from './messageBox'\n\n/**\n * Props of MainScreen component.\n * @category Components\n * @public\n */\ninterface MainScreenProps {}\n\ninterface MainScreenState {\n  samples: { name: string, project: Project }[],\n\n  loadedRelations: Map<string, Relation>,\n  storedRelations: StoredRelation[]\n  selectedRelation: number\n\n  expressions: Expression[]\n  selectedExpression: number\n\n  evaluationTreeRoot: RATreeNode | null\n  evaluatedExpressionName: string\n\n  batchConfigurationInfo: string\n  nullValuesSupport: boolean\n  csvValueSeparator: CsvValueSeparator\n  language: LanguageDef\n  darkTheme: boolean\n}\n\n/**\n * Main component of Rachel web page. It wraps all page sections and passes messages between them.\n * Accepts {@link MainScreenProps} props.\n * @category Components\n * @public\n */\nexport class MainScreen extends Component<MainScreenProps, MainScreenState> {\n\n  private readonly expressionSectionRef: React.RefObject<ExpressionSection>\n\n  constructor (props: MainScreenProps) {\n    super(props)\n\n    // sets body template by settings from local storage\n    document.body.classList.toggle('body-dark', LocalStorage.getDarkTheme())\n    document.body.classList.toggle('body-light', !LocalStorage.getDarkTheme())\n\n    const initRelationData = {\n      name: 'Relation',\n      columnNames: ['Column1', 'Column2', 'Column3'],\n      columnTypes: ['number', 'string', 'boolean'],\n      rows: [\n        ['', '', ''],\n      ],\n      columnCount: 3,\n      rowCount: 1,\n    }\n\n    this.state = {\n      samples: getSamples(),\n\n      loadedRelations: new Map<string, Relation>(),\n      storedRelations: [StoredRelation.fromData(initRelationData, true)],\n      selectedRelation: 0,\n\n      expressions: [{ name: 'Expression 1', text: '' }],\n      selectedExpression: 0,\n\n      evaluationTreeRoot: null,\n      evaluatedExpressionName: '',\n\n      batchConfigurationInfo: BatchProcessor.getConfigInfo(),\n      nullValuesSupport: true,\n      csvValueSeparator: LocalStorage.getCsvValueSeparator(),\n      language: language(),\n      darkTheme: LocalStorage.getDarkTheme(),\n    }\n    this.expressionSectionRef = React.createRef()\n  }\n\n  /**\n     * Reports an error to the author of the application via email.\n     *\n     * @param err unexpected error\n     */\n  private readonly reportUnexpectedError = (err: Error): void => {\n    const postMail: Mail = new Mail(POSTMAIL_ACCESS_TOKEN)\n    const body: string = 'Unexpected error ' + err.name + ' in Rachel application.'\n            + '\\n\\nMessage:\\n' + err.message\n            + '\\n\\nDate:\\n' + new Date().toString()\n            + '\\n\\nStack trace:\\n' + err.stack\n\n            + '\\n\\nLoaded relations: ----------------------------\\n'\n            + [...this.state.loadedRelations.values()].map(relation => {\n              return relation.getName() + '\\n' + relation.contentString()\n            }).join('\\n\\n')\n\n            + '\\n\\nStored relations: ----------------------------'\n            + '\\nSelected relation (1-index): ' + (this.state.selectedRelation + 1) + '\\n\\n'\n            + this.state.storedRelations.map(rel => StoredRelation.format(rel)).join('\\n\\n')\n\n            + '\\n\\nExpressions: ----------------------------'\n            + '\\nSelected expression (1-index): ' + (this.state.selectedExpression + 1) + '\\n\\n'\n            + this.state.expressions.map(expr => expr.text).join('\\n\\n###\\n\\n')\n\n            + '\\n\\nEvaluation tree:\\n' + this.state.evaluationTreeRoot?.printInLine()\n\n            + '\\n\\nOther state: ----------------------------'\n            + '\\ncsvValueSeparator: ' + this.state.csvValueSeparator\n            + '\\nlanguage:          ' + this.state.language\n            + '\\nnullValuesSupport: ' + this.state.nullValuesSupport\n            + '\\ndarkTheme:         ' + this.state.darkTheme\n\n    postMail.send('Rachel application unexpected error', body)\n    console.error('Unexpected error: ' + err.stack)\n  }\n\n  /**\n     * Overwrites the current project data with the given one.\n     *\n     * @param project\n     */\n  private readonly loadProject = (project: Project): void => {\n    this.setState({\n      loadedRelations: new Map<string, Relation>(),\n      storedRelations: project.relations.map(r => StoredRelation.fromData(r, project.nullValuesSupport)),\n      selectedRelation: 0,\n      expressions: project.expressions,\n      nullValuesSupport: project.nullValuesSupport,\n      selectedExpression: 0,\n      evaluationTreeRoot: null,\n      evaluatedExpressionName: '',\n    }, () => {\n      console.log('Project loaded.')\n      this.updateExpressionsErrors()\n    })\n  }\n\n  /**\n     * Adds number after the given name if it already exists in stored relation.\n     */\n  private readonly ensureUniqueRelationName = (name: string): string => {\n    if (this.state.storedRelations.map(sr => sr.getName()).includes(name)) {\n      for (let i = 2; true; ++i) {\n        if (!this.state.storedRelations.map(sr => sr.getName()).includes(name + i)) {\n          name += i\n          break\n        }\n      }\n    }\n    return name\n  }\n\n  /** **************************************** MANAGEMENT SECTION HANDLERS ******************************************/\n\n  /**\n     * Loads a JSON file with batch processing configuration.\n     */\n  private readonly handleBatchConfig = () => {\n    BatchProcessor.config().then(msg => {\n      console.log(msg)\n      MessageBox.message(msg)\n      const configInfo = BatchProcessor.getConfigInfo()\n      this.setState({ batchConfigurationInfo: configInfo })\n    }).catch(err => {\n      console.warn(err)\n      MessageBox.error(err)\n    })\n  }\n\n  /**\n     * Processes multiple selected files with expressions by the user and saves the reports of the evaluation in textual\n     * files.\n     */\n  private readonly handleBatchLoad = () => {\n    BatchProcessor.process()\n  }\n\n  /**\n     * Opens a file dialog and lets the user choose a .rachel (JSON) file with project to load.\n     */\n  private readonly handleLoadProject = (): void => {\n    ProjectStoreManager.load().then(this.loadProject).catch(console.warn)\n  }\n\n  /**\n     * Saves the project relation to the .rachel (JSON) file.\n     */\n  private readonly handleSaveProject = (): void => {\n    try {\n      ProjectStoreManager.save({\n        relations: this.state.storedRelations.map(sr => sr.toDataObject()),\n        expressions: this.state.expressions,\n        nullValuesSupport: this.state.nullValuesSupport,\n      }, 'project')\n      console.log('Project saved.')\n    } catch (err) {\n      console.warn('Project saving failed: ' + err.message)\n    }\n  }\n\n  /**\n     * Handles loading a sample project.\n     */\n  private readonly handleLoadSampleProject = (sample: Project): void => {\n    this.loadProject(copyProject(sample))\n  }\n\n  /**\n     * Changes the support of the null values in relations.\n     *\n     * @param nullValuesSupport new support of the null values in relations\n     */\n  private readonly handleNullValuesSupportChange = (nullValuesSupport: boolean): void => {\n    this.state.storedRelations.forEach(sr => sr.setNullValuesSupport(nullValuesSupport))\n    // null values change can change validity of the relations, therefore set as not actual\n    this.setState({ nullValuesSupport: nullValuesSupport }, this.updateExpressionsErrors)\n  }\n\n  /**\n     * Changes the value separator used in generated CSV files.\n     *\n     * @param csvValueSeparator new value separator used in generated CSV files\n     */\n  private readonly handleCsvValueSeparatorChange = (csvValueSeparator: CsvValueSeparator): void => {\n    LocalStorage.setCsvValueSeparator(csvValueSeparator)\n    this.setState({ csvValueSeparator: csvValueSeparator })\n  }\n\n  /**\n     * Changes the language of the application.\n     *\n     * @param lang new language of the application\n     */\n  private readonly handleLanguageChange = (lang: SupportedLanguage): void => {\n    LocalStorage.setLanguage(lang)\n    // updates language of errors in stored relations\n    this.state.storedRelations.forEach(r => r.recomputeErrors())\n    this.setState({ language: language() })\n  }\n\n  /**\n     * Changes the dark/light mode of the application.\n     *\n     * @param darkTheme true if dark theme is on\n     */\n  private readonly handleDarkThemeChange = (darkTheme: boolean) => {\n    LocalStorage.setDarkTheme(darkTheme)\n    this.setState({ darkTheme: darkTheme })\n    document.body.classList.toggle('body-dark', darkTheme)\n    document.body.classList.toggle('body-light', !darkTheme)\n  }\n\n  /** ***************************************** RELATION SECTION HANDLERS *******************************************/\n\n  private readonly handleRelationNameChange = (name: string): void => {\n    this.setState(state => {\n      const storedRelations = state.storedRelations\n      storedRelations[this.state.selectedRelation].setName(name)\n      return { storedRelations: storedRelations }\n    })\n  }\n\n  private readonly handleRelationColumnNameChange = (columnName: string, columnIndex: number): void => {\n    this.setState(state => {\n      const storedRelations = state.storedRelations\n      storedRelations[this.state.selectedRelation].setColumnName(columnName, columnIndex)\n      return { storedRelations: storedRelations }\n    })\n  }\n\n  private readonly handleRelationColumnTypeChange = (columnType: SupportedColumnType, columnIndex: number): void => {\n    this.setState(state => {\n      const storedRelations = state.storedRelations\n      storedRelations[this.state.selectedRelation].setColumnType(columnType, columnIndex)\n      return { storedRelations: storedRelations }\n    })\n  }\n\n  private readonly handleRelationRowInputChange = (input: string, columnIndex: number, rowIndex: number): void => {\n    this.setState(state => {\n      const storedRelations = state.storedRelations\n      storedRelations[this.state.selectedRelation].setRowInput(input, rowIndex, columnIndex)\n      return { storedRelations: storedRelations }\n    })\n  }\n\n  private readonly handleRelationNewRow = (onDone: () => void): void => {\n    this.state.storedRelations[this.state.selectedRelation].addNewRow()\n    // forces update\n    this.setState({}, onDone)\n  }\n\n  private readonly handleRelationNewColumn = (onDone: () => void): void => {\n    this.state.storedRelations[this.state.selectedRelation].addNewColumn()\n    // forces update\n    this.setState({}, onDone)\n  }\n\n  private readonly handleRelationDeleteRow = (rowIndex: number): void => {\n    this.state.storedRelations[this.state.selectedRelation].deleteRow(rowIndex)\n    // forces update\n    this.setState({})\n  }\n\n  private readonly handleRelationDeleteColumn = (columnIndex: number): void => {\n    this.state.storedRelations[this.state.selectedRelation].deleteColumn(columnIndex)\n    // forces update\n    this.setState({})\n  }\n\n  /**\n     * Selects a new relation from the relations list as the current one.\n     */\n  private readonly handleSelectDifferentRelation = (newIndex: number): void => {\n    this.setState({ selectedRelation: newIndex })\n  }\n\n  /**\n     * Moves a relation from the given \"from\" index to the given \"to\" index.\n     */\n  private readonly handleDragRelation = (from: number, to: number): void => {\n    // dragging left\n    if (from > to) {\n      const before = this.state.storedRelations.slice(0, to)\n      const moved = this.state.storedRelations.slice(to, from)\n      const fromValue = this.state.storedRelations[from]\n      const after = this.state.storedRelations.slice(from + 1)\n      const newArray = [...before, fromValue, ...moved, ...after]\n      this.setState({ storedRelations: newArray, selectedRelation: to })\n    }\n    // dragging right\n    else if (from < to) {\n      const before = this.state.storedRelations.slice(0, from)\n      const fromValue = this.state.storedRelations[from]\n      const moved = this.state.storedRelations.slice(from + 1, to + 1)\n      const after = this.state.storedRelations.slice(to + 1)\n      const newArray = [...before, ...moved, fromValue, ...after]\n      this.setState({ storedRelations: newArray, selectedRelation: to })\n    }\n  }\n\n  /**\n     * Creates a new empty relation and adds it in the relation list.\n     */\n  private readonly handleCreateNewRelation = (): void => {\n    // inserts a new empty relation in the array\n    const newIndex: number = this.state.selectedRelation + 1\n    const name: string = this.ensureUniqueRelationName('NewRelation')\n    this.state.storedRelations.splice(newIndex, 0, StoredRelation.new(name, this.state.nullValuesSupport))\n    this.setState({ selectedRelation: newIndex })\n  }\n\n  /**\n     * Deletes the current relation from the relations list (or clears it if it is the last relation in the list).\n     */\n  private readonly handleDeleteRelation = (): void => {\n    // if there is the last relation, only clears it\n    if (this.state.storedRelations.length === 1) {\n      this.setState({ storedRelations: [StoredRelation.new('Relation', this.state.nullValuesSupport)] })\n      return\n    }\n    const selected: number = this.state.selectedRelation\n    this.state.storedRelations.splice(selected, 1)\n    if (selected === this.state.storedRelations.length) {\n      this.setState({ selectedRelation: selected - 1 }, this.updateExpressionsErrors)\n    } else {\n      // forces update\n      this.setState({}, this.updateExpressionsErrors)\n    }\n  }\n\n  /**\n     * Reverts the current selected stored relation to its last loaded state.\n     */\n  private readonly handleRevertRelation = (): void => {\n    this.setState(state => {\n      const storedRelations = state.storedRelations\n      storedRelations[this.state.selectedRelation].revert()\n      return { storedRelations }\n    })\n  }\n\n  /**\n     * Removes all relations loaded in the application.\n     */\n  private readonly handleRemoveLoadedRelations = (onDone: (msg: string) => void): void => {\n    const lang = this.state.language.userMessages\n    const previous = this.state.loadedRelations.size\n    this.state.loadedRelations.clear()\n    this.state.storedRelations.forEach(sr => sr.setActual(false))\n    onDone(previous + lang.deleteLoadedRelations)\n    // forces update\n    this.setState({}, this.updateExpressionsErrors)\n  }\n\n  /**\n     * Saves the relations list in a textual file.\n     *\n     * @param onDone\n     */\n  private readonly handleExportRelations = (onDone: (msg: string) => void): void => {\n    const lang = this.state.language.userMessages\n    try {\n      RelationStoreManager.save(this.state.storedRelations, 'relations', this.state.csvValueSeparator)\n      onDone(this.state.storedRelations.length + lang.relationsExportOK)\n    } catch (err) {\n      onDone(lang.relationsExportErr + err)\n    }\n  }\n\n  /**\n     * Loads the relations list from the textual file selected by the user.\n     *\n     * @param onDone\n     */\n  private readonly handleImportRelations = (onDone: (msg: string) => void): void => {\n    const lang = this.state.language.userMessages\n    RelationStoreManager.load(this.state.nullValuesSupport).then(info => {\n      const countBefore: number = this.state.storedRelations.length\n      // loads relations to application\n      info.relations.forEach(relation => {\n        const name = this.ensureUniqueRelationName(relation.getName())\n        relation.setName(name)\n        this.state.storedRelations.push(relation)\n      })\n      if (info.relations.length > 0) {\n        // shows first loaded relation\n        this.setState({ selectedRelation: countBefore })\n      }\n      onDone(info.relations.length + lang.relationsImport[0] + info.skipped + lang.relationsImport[1])\n    })\n  }\n\n  private readonly handleLoadRelation = (onDone: (msg: string) => void): void => {\n    const lang = this.state.language.userMessages\n    const currRelation: StoredRelation = this.state.storedRelations[this.state.selectedRelation]\n    currRelation.setActual(true)\n    this.state.loadedRelations.set(currRelation.getName(), currRelation.createRelation())\n    const msgPart2: string = this.state.loadedRelations.size === 0\n      ? lang.loadedRelationsTotalNo\n      : this.state.loadedRelations.size + lang.loadedRelationsTotalSome + [...this.state.loadedRelations.keys()].join(', ') + '.'\n    onDone(lang.loadRelationNew + '\\n' + msgPart2)\n    // forces update\n    this.setState({}, this.updateExpressionsErrors)\n  }\n\n  private readonly handleLoadAllRelations = (onDone: (msg: string) => void): void => {\n    const lang = this.state.language.userMessages\n    let loaded = 0\n    let skipped = 0\n    this.state.storedRelations.forEach(sr => {\n      if (sr.isValid()) {\n        sr.setActual(true)\n        this.state.loadedRelations.set(sr.getName(), sr.createRelation())\n        ++loaded\n      } else {\n        ++skipped\n      }\n    })\n    const msgPart2: string = this.state.loadedRelations.size === 0\n      ? lang.loadedRelationsTotalNo\n      : this.state.loadedRelations.size + lang.loadedRelationsTotalSome + [...this.state.loadedRelations.keys()].join(', ') + '.'\n    onDone(loaded + lang.loadAllRelationsNew[0] + skipped + lang.loadAllRelationsNew[1] + '\\n' + msgPart2)\n    // forces update\n    this.setState({}, this.updateExpressionsErrors)\n  }\n\n  /** **************************************** EXPRESSION SECTION HANDLERS ******************************************/\n\n  private readonly updateExpressionsErrors = (): void => {\n    const expressionSection = this.expressionSectionRef.current\n    if (expressionSection !== null) {\n      expressionSection.updateErrorsAndParentheses()\n    }\n  }\n\n  /**\n     * Saves evaluation tree for the evaluated RA expression.\n     */\n  private readonly handleExprEval = (tree: RATreeNode): void => {\n    this.setState({\n      evaluationTreeRoot: tree,\n      evaluatedExpressionName: this.state.expressions[this.state.selectedExpression].name,\n    })\n  }\n\n  /**\n     * Updates the text of the current expression and sets it as not actual.\n     */\n  private readonly handleExprTextChange = (name: string, text: string): void => {\n    this.setState(state => {\n      const expressions: Expression[] = state.expressions\n      expressions[state.selectedExpression] = { name: name, text: text }\n      return { expressions: expressions }\n    })\n  }\n\n  /**\n     * Selects a new expression from the expression list as the current one.\n     */\n  private readonly handleSelectDifferentExpression = (newIndex: number): void => {\n    this.setState({ selectedExpression: newIndex }, this.updateExpressionsErrors)\n  }\n\n  /**\n     * Moves a expression from the given \"from\" index to the given \"to\" index.\n     */\n  private readonly handleDragExpression = (from: number, to: number): void => {\n    // dragging left\n    if (from > to) {\n      const before = this.state.expressions.slice(0, to)\n      const moved = this.state.expressions.slice(to, from)\n      const fromValue = this.state.expressions[from]\n      const after = this.state.expressions.slice(from + 1)\n      const newArray = [...before, fromValue, ...moved, ...after]\n      this.setState({ expressions: newArray, selectedExpression: to })\n    }\n    // dragging right\n    else if (from < to) {\n      const before = this.state.expressions.slice(0, from)\n      const fromValue = this.state.expressions[from]\n      const moved = this.state.expressions.slice(from + 1, to + 1)\n      const after = this.state.expressions.slice(to + 1)\n      const newArray = [...before, ...moved, fromValue, ...after]\n      this.setState({ expressions: newArray, selectedExpression: to })\n    }\n  }\n\n  /**\n     * Creates a new empty expression and adds it in the expression list.\n     */\n  private readonly handleCreateNewExpression = (): void => {\n    // inserts a new empty expression in the array\n    const newIndex: number = this.state.selectedExpression + 1\n    this.state.expressions.splice(newIndex, 0, { name: 'New expression', text: '' })\n    this.setState({ selectedExpression: newIndex })\n  }\n\n  /**\n     * Deletes the current expression from the expression list (or clears it if it is the last expression in the list).\n     */\n  private readonly handleDeleteExpression = (onDone: () => void): void => {\n    // if there is the last expression, only clears it\n    if (this.state.expressions.length === 1) {\n      return this.handleExprTextChange('Expression 1', '')\n    }\n    const selected: number = this.state.selectedExpression\n    this.state.expressions.splice(selected, 1)\n    if (selected === this.state.expressions.length) {\n      this.setState({ selectedExpression: selected - 1 }, onDone)\n    } else {\n      // forces update\n      this.setState({}, onDone)\n    }\n  }\n\n  /**\n     * Saves the expression list in a textual file.\n     *\n     * @param onDone\n     */\n  private readonly handleExportExpressions = (onDone: (msg: string) => void): void => {\n    const lang = this.state.language.userMessages\n    try {\n      ExpressionStoreManager.save(this.state.expressions, 'expressions')\n      onDone(lang.expressionsExportOK)\n    } catch (err) {\n      onDone(lang.expressionsExportErr + err.message)\n    }\n  }\n\n  /**\n     * Loads the expression list from the textual file selected by the user.\n     *\n     * @param onDone\n     */\n  private readonly handleImportExpressions = (onDone: (msg: string) => void): void => {\n    const lang = this.state.language.userMessages\n    ExpressionStoreManager.load().then(info => {\n      this.state.expressions.push(...info.expressions)\n      this.setState({})\n      onDone(info.expressions.length + lang.expressionsImport[0] + info.loadedFiles + lang.expressionsImport[1]\n                + +info.skippedExpressions + lang.expressionsImport[2] + info.skippedFiles + lang.expressionsImport[3])\n    })\n  }\n\n  /** ****************************************** RESULT SECTION HANDLERS ********************************************/\n\n  /**\n     * Adds the given relation to defined relations.\n     *\n     * @return message and its color (red for errors, black for information)\n     */\n  private readonly addResultRelation = (relation: Relation): void => {\n    const name = this.ensureUniqueRelationName('Evaluated')\n    const storedRelation = StoredRelation.fromRelation(name, relation, this.state.nullValuesSupport)\n    this.state.storedRelations.push(storedRelation)\n    this.setState({ selectedRelation: this.state.storedRelations.length - 1 })\n  }\n\n  /** *************************************************** RENDER *****************************************************/\n\n  render () {\n    let resultSection = null\n    if (this.state.evaluationTreeRoot !== null) {\n      resultSection = (\n        <ResultSection\n          evaluationTreeRoot={this.state.evaluationTreeRoot}\n          expressionName={this.state.evaluatedExpressionName}\n\n          onAddResult={this.addResultRelation}\n          onUnexpectedError={this.reportUnexpectedError}\n\n          csvValueSeparator={this.state.csvValueSeparator}\n          darkTheme={this.state.darkTheme}\n          language={this.state.language}\n        />\n      )\n    }\n\n    return (\n      <main>\n        <ManagementSection\n          onBatchConfig={this.handleBatchConfig}\n          onBatchLoad={this.handleBatchLoad}\n          batchConfigurationInfo={this.state.batchConfigurationInfo}\n          onLoadProject={this.handleLoadProject}\n          onSaveProject={this.handleSaveProject}\n          onLoadSample={this.handleLoadSampleProject}\n\n          csvValueSeparator={this.state.csvValueSeparator}\n          language={this.state.language}\n          nullValuesSupport={this.state.nullValuesSupport}\n          darkTheme={this.state.darkTheme}\n\n          onCsvValueSeparatorChange={this.handleCsvValueSeparatorChange}\n          onLanguageChange={this.handleLanguageChange}\n          onNullValuesSupportChange={this.handleNullValuesSupportChange}\n          onDarkThemeChange={this.handleDarkThemeChange}\n        />\n\n        <RelationsSection\n          storedRelations={this.state.storedRelations}\n          storedRelationIndex={this.state.selectedRelation}\n\n          loadedRelations={[...this.state.loadedRelations.values()]}\n\n          onRelationNameChange={this.handleRelationNameChange}\n          onColumnNameChange={this.handleRelationColumnNameChange}\n          onColumnTypeChange={this.handleRelationColumnTypeChange}\n          onRowInputChange={this.handleRelationRowInputChange}\n          onNewRow={this.handleRelationNewRow}\n          onNewColumn={this.handleRelationNewColumn}\n          onDeleteRow={this.handleRelationDeleteRow}\n          onDeleteColumn={this.handleRelationDeleteColumn}\n\n          onSelectDifferentRelation={this.handleSelectDifferentRelation}\n          onDragRelation={this.handleDragRelation}\n          onNewRelation={this.handleCreateNewRelation}\n          onLoadRelation={this.handleLoadRelation}\n          onDeleteStoredRelation={this.handleDeleteRelation}\n          onRevertRelation={this.handleRevertRelation}\n\n          onLoadAllRelations={this.handleLoadAllRelations}\n          onRemoveLoadedRelations={this.handleRemoveLoadedRelations}\n          onExportRelations={this.handleExportRelations}\n          onImportRelations={this.handleImportRelations}\n\n          nullValuesSupport={this.state.nullValuesSupport}\n          language={this.state.language}\n        />\n\n        <ExpressionSection\n          ref={this.expressionSectionRef}\n\n          expressions={this.state.expressions}\n          currentExpressionIndex={this.state.selectedExpression}\n          relations={this.state.loadedRelations}\n\n          onChange={this.handleExprTextChange}\n          onEval={this.handleExprEval}\n\n          onSelectDifferentExpression={this.handleSelectDifferentExpression}\n          onDragExpression={this.handleDragExpression}\n          onNewExpression={this.handleCreateNewExpression}\n          onDeleteExpression={this.handleDeleteExpression}\n          onExportExpressions={this.handleExportExpressions}\n          onImportExpressions={this.handleImportExpressions}\n\n          onUnexpectedError={this.reportUnexpectedError}\n          nullValuesSupport={this.state.nullValuesSupport}\n          darkTheme={this.state.darkTheme}\n          language={this.state.language}\n        />\n\n        {resultSection}\n      </main>\n    )\n  }\n}\n","/**\n * Access token for PostMail service.\n * Replace it with your own token after registration on https://postmail.invotes.com/ to receive email error logs.\n */\nexport const POSTMAIL_ACCESS_TOKEN = '5uog26ex8q9qu7sqib8ea0qd'\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport * as serviceWorker from './serviceWorker'\nimport { MainScreen } from './components/mainScreen'\n\n/**\n * @license The software is Licensed under the MIT License\n *\n * Copyright (c) Lukáš Kotlík\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n * documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\n * to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions\n * of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO\n * THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n * ********* Used, Licensed third party code: *********\n *\n * JSZIP - Create, read and edit .zip files with Javascript\n * Version: 3.5.0\n * https://github.com/Stuk/jszip\n * MIT License - Copyright (c) 2009-2016 Stuart Knightley, David Duponchel, Franz Buchinger, António Afonso\n *\n * visx - visualization components\n * visx/group - version: 1.0.0\n * visx/hierarchy - version: 1.0.0\n * visx/shape - version: 1.4.0\n * visx/responsive - version: 1.3.0\n * visx/tooltip - version: 1.3.0\n * https://github.com/airbnb/visx\n * MIT License - Copyright (c) 2017-2018 Harrison Shoff\n *\n * export-svg-with-styles - Turn your SVGs to PNGs\n * Version: 0.0.4\n * https://www.npmjs.com/package/export-svg-with-styles\n * MIT License - Copyright (c) 2019 Mathew Leland\n *\n * FileSaver.js - An HTML5 saveAs() FileSaver implementation\n * Version: 2.0.5\n * https://github.com/eligrey/FileSaver.js\n * MIT License - Copyright (c) 2016 Eli Grey\n *\n * Lodash - A modern JavaScript utility library delivering modularity, performance, & extras.\n * Version: 4.17.20\n * https://github.com/lodash/lodash\n * MIT License - Copyright JS Foundation and other contributors <https://js.foundation/>\n * Based on Underscore.js, copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors <http://underscorejs.org/>\n * This software consists of voluntary contributions made by many individuals. For exact contribution history, see the revision history available at https://github.com/lodash/lodash\n *\n * React - A declarative, efficient, and flexible JavaScript library for building user interfaces.\n * Version: 16.13.1\n * https://github.com/facebook/react\n * MIT License - Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Jest - Delightful JavaScript Testing.\n * Version: 26.6.0\n * https://github.com/facebook/jest\n * MIT License - Copyright (c) Facebook, Inc. and its affiliates.\n *\n * create-react-app - Set up a modern web app by running one command.\n * Version: 3.4.1\n * https://github.com/facebook/create-react-app\n * MIT License - Copyright (c) 2013-present, Facebook, Inc.\n *\n * TypeScript - TypeScript is a superset of JavaScript that compiles to clean JavaScript output.\n * Version: 3.7.5\n * https://github.com/microsoft/TypeScript\n * Apache License 2.0\n *\n * JSDoc - An API documentation generator for JavaScript.\n * Version: 3.6.6\n * https://github.com/jsdoc/jsdoc\n * Apache License 2.0\n *\n * better-docs - Beautiful toolbox for jsdoc generated documentation - with 'typescript', `category` and `component` plugins\n * Version: 2.3.2\n * https://github.com/SoftwareBrothers/better-docs\n * MIT License - Copyright 2019 SoftwareBrothers.co\n *\n * ********* Used, not Licensed, free to use code and services: *********\n *\n * PostMail - Send email from JavaScript or static HTML without backend code\n * https://postmail.invotes.com/\n */\nReactDOM.render(\n    <React.StrictMode>\n      <MainScreen/>\n    </React.StrictMode>,\n    document.getElementById('root')\n)\n\nserviceWorker.unregister()\n","export function unregister () {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister()\n      })\n      .catch(error => {\n        console.error(error.message)\n      })\n  }\n}\n"],"sourceRoot":""}
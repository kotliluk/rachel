{"version":3,"sources":["serviceWorker.ts","error/errorWithTextRange.ts","error/errorFactory.ts","error/raSemanticError.ts","error/raSyntaxError.ts","error/codeError.ts","tools/parser.ts","components/tooltipButton.tsx","components/messageLabel.tsx","tools/font.ts","tools/whisper.ts","components/xTextArea.tsx","tools/math.ts","relation/relation.ts","tools/parserIndexed.ts","tools/indexedString.ts","expression/exprTokens.ts","ratree/raTreeNode.ts","ratree/relationNode.ts","ratree/unaryNode.ts","relation/row.ts","tools/keywords.ts","vetree/comparingOperator.ts","ratree/projectionNode.ts","tools/issToISSMap.ts","ratree/renameNode.ts","vetree/veTreeNode.ts","vetree/logicalOperator.ts","vetree/computingOperator.ts","vetree/literalValue.ts","vetree/referenceValue.ts","ratree/antijoinNode.ts","expression/valueTokens.ts","expression/valueParser.ts","ratree/selectionNode.ts","ratree/binaryNode.ts","ratree/outerJoinNode.ts","ratree/cartesianProductNode.ts","ratree/divisionNode.ts","ratree/naturalJoinNode.ts","ratree/setOperationNode.ts","ratree/thetaJoinNode.ts","expression/exprParser.ts","ratree/raTreeFactory.ts","components/textInput.tsx","components/expressionSection.tsx","components/resultRelationTable.tsx","ratree/raTreeTools.ts","components/evaluationTree.tsx","tools/fileDialog.ts","tools/rcToStringMap.ts","relation/storedRelation.ts","relation/columnType.ts","relation/relationStoreManager.ts","tools/csvSupport.ts","components/resultSection.tsx","expression/expressionStoreManager.ts","components/managementSection.tsx","project/project.ts","expression/expression.ts","project/projectStoreManager.ts","tools/localStorage.ts","tools/supportedLanguage.ts","components/footer.tsx","tools/batchProcessor.ts","tools/date.ts","components/editRelationTable.tsx","components/relationsSection.tsx","tools/postMail.ts","components/mainScreen.tsx","index.tsx"],"names":["isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","console","log","onUpdate","onSuccess","catch","error","ErrorWithTextRange","msg","range","Error","insertRangeIfUndefined","err","undefined","CodeErrorCodes","SemanticErrorCodes","SyntaxErrorCodes","RASemanticError","captureStackTrace","name","RASyntaxError","CodeError","codeErrMsgEng","Map","resultSection_getCurrentRelation_nodeIndexNotFound","resultSection_getCurrentRelation_evalError","resultSection_saveResultRelation_nullRelationToSave","resultSection_handleAddRelation_nullRelationToAdd","row_getOrderedValues_absentColumn","valueParser_rpnToVETreeRecursive_unexpectedToken","exprParser_isValidSequence_unexpectedToken","exprParser_rpnToVETreeRecursive_unexpectedToken","exprParser_parseTokensForWhisper_thetaJoinBranchError","exprParser_parseTokensForWhisper_projectionBranchError","semanticErrMsgEng","exprParser_parse_relationNotDefined","binaryNode_eval_commonColumnsInSources","setOperationNode_eval_notEqualColumnsInSources","divisionNode_eval_rightColumnsNotSubsetOfLeft","divisionNode_eval_rightColumnsNotProperSubsetOfLeft","renameNode_eval_absentOriginalColumn","renameNode_eval_changeToDuplicitName","projectionNode_eval_absentColumn","referenceValue_eval_absentColumn","syntaxErrMsgEng","exprParser_parse_emptyStringGiven","exprParser_parseTokens_outerJoinWhenNullNotSupported","exprParser_parseTokens_unexpectedPart","exprParser_parseTokens_bothBranchesError","exprParser_rpnToVETree_invalidExpression","exprParser_assertValidInfixTokens_invalidParentheses","exprParser_assertValidInfixTokens_invalidStart","exprParser_assertValidInfixTokens_invalidEnd","exprParser_assertValidInfixTokens_relationAfterRelation","exprParser_assertValidInfixTokens_relationAfterUnary","exprParser_assertValidInfixTokens_relationAfterClosing","exprParser_assertValidInfixTokens_unaryAfterBinary","exprParser_assertValidInfixTokens_unaryAfterOpening","exprParser_assertValidInfixTokens_binaryAfterBinary","exprParser_assertValidInfixTokens_binaryAfterOpening","exprParser_assertValidInfixTokens_openingAfterRelation","exprParser_assertValidInfixTokens_openingAfterUnary","exprParser_assertValidInfixTokens_openingAfterClosing","exprParser_assertValidInfixTokens_closingAfterBinary","exprParser_assertValidInfixTokens_closingAfterOpening","valueParser_parseTokens_emptyInput","valueParser_parseTokens_unsupportedNull","valueParser_parseTokens_unexpectedPart","valueParser_toRPN_missingOpeningParenthesis","valueParser_toRPN_missingClosingParenthesis","valueParser_rpnToVETree_invalidExpression","valueParser_rpnToVETree_invalidStart","valueParser_rpnToVETree_invalidEnd","valueParser_rpnToVETree_literalAfterLiteral","valueParser_rpnToVETree_literalAfterReference","valueParser_rpnToVETree_literalAfterClosing","valueParser_rpnToVETree_referenceAfterLiteral","valueParser_rpnToVETree_referenceAfterReference","valueParser_rpnToVETree_referenceAfterClosing","valueParser_rpnToVETree_notAfterLiteral","valueParser_rpnToVETree_notAfterReference","valueParser_rpnToVETree_notAfterClosing","valueParser_rpnToVETree_binaryAfterOperator","valueParser_rpnToVETree_binaryAfterOpening","valueParser_rpnToVETree_openingAfterLiteral","valueParser_rpnToVETree_openingAfterReference","valueParser_rpnToVETree_openingAfterClosing","valueParser_rpnToVETree_closingAfterOperator","valueParser_rpnToVETree_closingAfterOpening","parser_nextBorderedPart_missingClosingChar","parser_skipWhitespacesAndChar_charNotFound","projectionNode_constructor_invalidProjectionString","projectionNode_parseProjection_invalidProjectedColumnName","renameNode_parseChanges_invalidRenameString","renameNode_parseChanges_missingArrow","renameNode_parseChanges_invalidNewName","renameNode_parseChanges_keywordNewName","renameNode_parseChanges_multipleRenameOfTheColumn","selectionNode_constructor_invalidString","selectionNode_constructor_emptyString","selectionNode_eval_resultNotBoolean","thetaJoinNode_constructor_invalidString","thetaJoinNode_constructor_emptyString","thetaJoinNode_eval_resultNotBoolean","thetaSemiJoinNode_constructor_invalidString","thetaSemiJoinNode_constructor_emptyString","thetaSemiJoinNode_eval_resultNotBoolean","comparingOperator_eval_differentInputTypes","computingOperator_eval_inputTypesNotNumbers","logicalOperator_eval_leftInputNotBoolean","logicalOperator_eval_rightInputNotBoolean","ErrorFactory","code","get","params","assertParamsCount","length","joinStringArrays","expectedCount","push","a","b","aLen","toConcat","Array","i","concat","Parser","str","split","every","c","isLetter","charAt","isNameChar","res","exec","toLowerCase","toUpperCase","isDigit","test","nextBorderedPart","first","second","substring","char","digitFound","dotFound","start","end","escape","depth","inQuotes","nesting","backslashes","escapeCount","curChar","indexOf","partOne","partTwo","syntaxError","join","charFound","map","line","insideQuotes","slice","TooltipButton","className","this","props","onClick","style","text","tooltipClassName","tooltipStyle","tooltip","React","Component","MessageLabel","message","color","darkTheme","computeFontSizeInPx","fontFamily","fontSize","div","document","createElement","setAttribute","innerText","documentElement","appendChild","divWidth","clientWidth","divHeight","clientHeight","remove","fontWidth","fontHeight","getStartOfWordBeforeIndex","index","prefixText","cssConstants","getComputedStyle","querySelector","getPropertyValue","lineHeight","Number","numsBackgroundLight","numsBackgroundDark","numsColorLight","numsColorDark","XTextArea","reactDiv","createRef","textarea","selectionStart","selectionEnd","setSelectionRange","activeElement","id","focus","getElementById","classList","add","table","tr","td1","td2","ta","mouseIsDown","placeholder","value","canvas","width","canvasWidth","canvasLines","whisperDiv","isShown","selectedIndex","changeSelected","indexDiff","setSelected","newIndex","n","m","childElementCount","children","getSelectedWhisper","paintLineNumbers","height","ctx","getContext","fillStyle","fillRect","scrollHeight","font","startIndex","Math","floor","scrollTop","endIndex","y","fillText","e","showWhisper","whispers","hideWhisper","prevCount","innerHTML","whisper","moveWhisper","cursorLineAndColumn","getPositionLineAndColumn","cursorDistanceFromTATotalTop","cursorDistanceFromTATotalLeft","column","yPos","xPos","scrollLeft","getBoundingClientRect","innerHeight","insertCurrentSelectedWhisper","onChange","currWhisper","beforeAdd","afterAdd","newCursorPos","errorDivs","moveErrors","forEach","highlight","startLine","rangeLength","startColumn","x","innerWidth","messageSpan","updateErrors","ranges","pushHighlight","parentElement","createHighlightDiv","getLineLength","addEventListener","onscroll","onmousedown","onmouseup","onmousemove","oninput","ev","target","onkeydown","ctrlKey","key","preventDefault","cursor","errors","prevProps","updateStyle","current","toggle","ref","position","textBeforeCursor","lastNewLine","lastIndexOf","newLinesFound","lineStart","lineEnd","onclick","newEvent","MouseEvent","type","dispatchEvent","stopPropagation","span","Relation","columns","columnNames","rows","finishedSchema","hasColumn","hasFinishedSchema","set","some","cn","f","row","isEqual","getTypes","finishSchema","finish","r","equals","s","getOrderedValues","other","Set","ParserIndexed","isWord","toString","isName","isWhitespacesOnly","isNumber","strParts","nextWord","nextName","nextNonWhitespacePart","nextNumber","getFirstNonNaNIndex","skippedStr","skipWhitespacesAndChar","getNonNaNRange","toJoin","IndexedString","chars","arr","ic","separator","empty","isSep","new","NaN","ret","isEmpty","isNaN","getLastNonNaNIndex","RangeError","newFromArray","sepLen","strSplit","prefixSum","_start","_end","trimStr","trim","strings","is","searchString","startsWith","endsWith","searchValue","replaceValue","replace","fromIndex","regexp","filter","lastIndex","getLastIndex","getRange","ExprToken","ParenthesisToken","OpeningParentheses","ClosingParentheses","RelationToken","UnaryOperatorToken","selection","projection","rename","BinaryOperatorToken","precedence","precedenceLevelF","precedenceLevelD","precedenceLevelE","precedenceLevelA","precedenceLevelB","precedenceLevelC","RATreeNode","resultRelation","eval","RelationNode","relation","cursorIndex","result","getName","UnaryNode","subtree","Row","types","values","finished","keys","has","orderedColumns","codeError","forbiddenColumnNames","forbiddenRelationNames","isForbiddenColumnName","ComparingOperatorType","ProjectionNode","stringRange","doThrow","indexed","parts","part","isEvaluated","source","getResult","projected","parseProjection","semanticError","forEachColumn","addColumn","getRows","newRow","getColumns","getValues","addValue","addRow","fakeEval","getColumnNames","absent","strName","printInLine","ISSToISSMap","keyValue","delete","clear","size","RenameNode","handleError","words","w","beforeError","afterError","changes","parseChanges","toChange","returned","regexMatch","duplicit","after","before","beforeStr","afterStr","VETreeNode","LogicalOperatorType","ComparingOperator","operator","left","right","equal","nonEqual","less","more","lessOrEqual","moreOrEqual","leftResult","rightResult","ComputingOperatorType","LogicalOperator","and","or","not","LiteralValue","ReferenceValue","columnName","getValue","getType","AntijoinType","ComputingOperator","plus","minus","multiplication","division","ValueToken","OperatorToken","LogicalNotToken","LogicalAndToken","LogicalOrToken","ComputingMultiplicationToken","ComputingDivisionToken","ComputingPlusToken","ComputingMinusToken","ComparingToken","LiteralToken","ReferenceToken","ValueParser","nullValuesSupport","tokens","parseTokens","assertValidInfixTokens","simplify","rpn","toRPN","rpnToVETree","token","rest","i2","token1","token2","notIndexes","indexesToRemove","t","rpnQueue","operatorsStack","pop","curToken","rpnToVETreeRecursive","deduct","multiply","divide","JSON","stringify","SelectionNode","boolExpr","parse","bool","newResult","fakeParse","BinaryNode","leftSubtree","rightSubtree","OuterJoinType","AntijoinNode","rowsToKeep","rowsToHelp","leftSource","rightSource","commonColumns","lc","keptRow","helpRow","fakeEvalBinary","getOperationName","CartesianProductNode","leftRow","rightRow","leftColumn","DivisionNode","leftColumns","rightColumns","getSchemaString","resultColumns","getNamesSchemaString","leftRows","rightRows","testRow","lr","entries","NaturalJoinType","OuterJoinNode","full","SetOperationType","NaturalJoinNode","leftSemi","natural","rightSemi","ThetaJoinType","SetOperationNode","union","intersection","typeStr","getTypeStr","rr","AssertType","ThetaJoinNode","condition","bothSourceColumns","booleanResult","sourceColumns","RATreeFactory","unaryClass","expr","binaryClass","difference","ExprParser","relations","deleteCommentLines","THROW_STRICT","rpnToRATree","indexedExpr","fakeParseTokens","NOT_THROW","innerResult","selectionExpected","rightThetaSemijoin","thetaJoin","errorRange","fullOuterJoin","leftOuterJoin","rightOuterJoin","leftSemijoin","rightSemijoin","naturalJoin","cartesianProduct","leftAntijoin","rightAntijoin","leftThetaSemijoin","whispersFound","restStartIndex","getNextIndexOrNaN","recursiveReturn","operatorEndIndex","relationStartIndex","relationEndIndex","missing","splice","THROW_NOT_STRICT","rpnToRATreeRecursive","createUnary","createBinary","TextInput","inputRef","handleChange","disable","forbidden","setState","buttonDisable","handleKeyDown","event","handleSubmit","blur","onSubmit","htmlFor","label","spellCheck","autoComplete","onKeyDown","disabled","buttonText","ExpressionSection","buttonPropsFirstPart","shift","buttonPropsSecondPart","nullSupportRequiredButtonProps","textAreaRef","lastChange","lastWhisperAndErrorsUpdate","whispersAndErrorsUpdateRate","sectionRef","getCurExpr","evalExpr","showMessage","tree","indexedParse","expressions","currentExpressionIndex","onEval","errorRanges","er","showError","newExpression","onNewExpression","deleteExpression","onDeleteExpression","saveExpressions","onExportExpressions","loadExpressions","onImportExpressions","addSpecialString","getSelection","firstPart","secondPart","newPosition","newStr","handleExprChange","setSelection","onDone","Date","now","updateWhispersAndErrors","textArea","isFocused","wordBeforeCursor","getLikelihood","sort","sortWhispers","handleExprNameChange","isError","messageText","isMessageError","onUnexpectedError","sectionClicked","setInterval","section","shiftKey","onSelectDifferentExpression","createButton","createOpButtons","buttonProps","prop","sectionClassName","handleSelectDifferentExpression","marginRight","ResultRelationTable","getOrderByText","orderDir","orderBy","prevState","snapshot","updateOrderBy","getRowsCount","colSpan","sortCol","aValue","bValue","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","String","localeCompare","headerRow","createHeaderRow","createRows","divClassName","tableClassName","depthSearch","root","findIndexInTree","node","getSubtree","leftSearch","getLeftSubtree","getRightSubtree","getTreeDepth","max","EvaluationTree","TreeComponent","raTree","selected","nodeHeight","backgroundColorLight","backgroundColorDark","textColorLight","textColorDark","selectedNodeColorLight","unselectedNodeColorLight","selectedNodeColorDark","unselectedNodeColorDark","TreeNodeComponent","useTooltip","tooltipLeft","tooltipTop","tooltipOpen","showTooltip","hideTooltip","useTooltipInPortal","detectBounds","scroll","containerRef","TooltipInPortal","nodeWidth","data","title","Group","top","rx","fill","onMouseOver","onMouseOut","random","dy","textAnchor","pointerEvents","margin","bottom","yMax","xMax","indexes","parseTreeForDisplayHelper","param","getParameter","getColumnsCount","parseTreeForDisplay","hierarchy","Cluster","cluster","links","link","LinkVertical","stroke","strokeWidth","strokeOpacity","descendants","FileDialog","accept","Promise","resolve","element","fileInput","firstChild","file","files","reader","FileReader","onload","readAsText","click","openFilesHelper","fileInfo","readFile","RCToStringMap","entry","parseKey","StoredRelation","columnTypes","columnCount","rowCount","actual","recomputeErrors","isStoredRelationData","d","checkColumnNames","checkRowInput","columnIndex","reduce","agg","rowIndex","input","lower","isStringLiteral","_","rowInput","addNewColumn","columnType","checkColumnTypes","obj","isArray","o","isSupportedColumnType","RelationStoreManager","openFiles","skipped","csvToRelation","createValidName","filename","valueSeparator","zip","JSZip","relationToCsv","generateAsync","content","saveAs","blob","Blob","lines","findValueSeparatorChar","nextRowInput","inString","names","getColumnTypes","ResultSection","getCurrentRelation","currentNode","evaluationTreeRoot","handleSelectedNodeChange","saveResultRelation","relationName","save","fromRelation","csvValueSeparator","handleRelationNameChange","handleAddRelation","onAddResult","selectedNode","tableTitle","expressionName","ExpressionStoreManager","skippedExpressions","loadedFiles","skippedFiles","splitExpressionNameAndText","firstNewLineIndex","firstRow","textContent","ManagementSection","handleStateChange","toState","batchMessage","projectMessage","createBatch","onBatch","createProject","onImportProject","onExportProject","createSettings","listStyleType","checked","onNullValuesSupportChange","onCsvValueSeparatorChange","onDarkModeChange","createButtonChangeState","changeTo","openState","paddingTop","paddingBottom","marginTop","isProjectObject","isExpression","ProjectStoreManager","reject","openFile","project","defaultLanguage","defaultDarkMode","LocalStorage","storageSupported","storedSeparator","localStorage","getItem","setItem","language","warn","isInit","init","Storage","Footer","modeStr","href","rel","BatchProcessor","processFile","status","parseRelations","exprParser","exprCount","reports","processExpression","ops","addOperations","counts","report","reportHeader","formatRelations","parser","evaluationTree","operationsOfTree","contentString","zeroOperations","operations","date","total","binaryOperations","unaryOperations","binary","unary","getDate","padStart","getMonth","getFullYear","getHours","getMinutes","antijoin","cartesian","outerJoin","semijoin","setOperation","thetaSemijoin","storedData","time","processed","timeEnd","storedRelation","fromData","isValid","createRelation","count","operationOfUnaryNode","operationOfBinaryNode","EditRelationTable","deleteButtonRef","getErrors","setSelectedInput","editable","selectedColumn","selectedRow","moveSelectedInputRight","getColumnCount","moveSelectedInputLeft","moveSelectedInputUp","moveSelectedInputDown","getRowCount","handleRightClick","button","handleDeleteRow","clientY","clientX","visibility","handleDeleteColumn","onColumnNameChange","onColumnTypeChange","onRowInputChange","handleNewColumn","onNewColumn","scrollTo","handleNewRow","onNewRow","really","onDeleteColumn","onDeleteRow","autoFocus","rowData","createInput","createTooltip","onContextMenu","border","rowSpan","padding","namesRow","createNamesRow","typesRow","createTypesRow","createAddRow","contextButtonClassName","onBlur","RelationsSection","isShowingStored","contentToShow","getCurRel","storedRelations","storedRelationIndex","loadedRelation","loadedRelations","loadedRelationIndex","changeContentToShow","onRelationNameChange","loadRelation","onLoadRelation","loadAllRelations","onLoadAllRelations","exportRelations","onExportRelations","importRelations","onImportRelations","deleteRelation","onDeleteStoredRelation","nameToDelete","upgrade","onDeleteLoadedRelation","newRelation","onNewRelation","deleteAllLoadedRelations","createRelationMenuButtons","actuality","isActual","actualityTooltip","handleSelectDifferentRelation","onSelectDifferentRelation","sr","PostMail","accessToken","subject","body","data_js","access_token","request","XMLHttpRequest","onreadystatechange","readyState","response","toParams","open","setRequestHeader","send","encodeURIComponent","MainScreen","expressionSectionRef","reportUnexpectedError","postMail","stack","selectedRelation","selectedExpression","handleBatch","process","handleImportProject","load","evaluatedExpressionName","updateExpressionsErrors","handleExportProject","toDataObject","handleNullValuesSupportChange","setNullValuesSupport","handleCsvValueSeparatorChange","setCsvValueSeparator","handleLanguageChange","setLanguage","handleDarkModeChange","setDarkMode","setName","handleRelationColumnNameChange","setColumnName","handleRelationColumnTypeChange","setColumnType","handleRelationRowInputChange","setRowInput","handleRelationNewRow","addNewRow","handleRelationNewColumn","handleRelationDeleteRow","deleteRow","handleRelationDeleteColumn","deleteColumn","handleCreateNewRelation","handleDeleteRelation","handleDeleteLoadedRelation","specific","setActual","handleExportRelations","handleImportRelations","info","countBefore","handleLoadRelation","currRelation","handleLoadAllRelations","loaded","expressionSection","handleExprEval","handleExprTextChange","handleCreateNewExpression","handleDeleteExpression","handleExportExpressions","handleImportExpressions","addResultRelation","onError","sR1","sR2","getCsvValueSeparator","getLanguage","getDarkMode","resultSection","onLanguageChange","ReactDOM","render","StrictMode","URL","origin","fetch","headers","contentType","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.a72bde0f.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","/**\r\n * Error with optional text range of the error.\r\n */\r\nexport default class ErrorWithTextRange extends Error {\r\n    constructor(msg: string, public range?: {start: number, end: number} | undefined) {\r\n        super(msg);\r\n    }\r\n}\r\n\r\n/**\r\n * If the given error is ErrorWithTextRange instance and has undefined range, sets its range to given value.\r\n * Returns (possibly modified) input error.\r\n *\r\n * @param err\r\n * @param range\r\n */\r\nexport function insertRangeIfUndefined<T>(err: T, range: {start: number, end: number} | undefined): T {\r\n    if (err instanceof ErrorWithTextRange && err.range === undefined) {\r\n        err.range = range;\r\n    }\r\n    return err;\r\n}","import RASemanticError from \"./raSemanticError\";\r\nimport RASyntaxError from \"./raSyntaxError\";\r\nimport CodeError from \"./codeError\";\r\n\r\n/**\r\n * Codes for CodeErrors.\r\n */\r\nexport enum CodeErrorCodes {\r\n    resultSection_getCurrentRelation_nodeIndexNotFound = 1,\r\n    resultSection_getCurrentRelation_evalError,\r\n    resultSection_saveResultRelation_nullRelationToSave,\r\n    resultSection_handleAddRelation_nullRelationToAdd,\r\n\r\n    row_getOrderedValues_absentColumn,\r\n\r\n    valueParser_rpnToVETreeRecursive_unexpectedToken,\r\n\r\n    exprParser_isValidSequence_unexpectedToken,\r\n    exprParser_rpnToVETreeRecursive_unexpectedToken,\r\n    exprParser_parseTokensForWhisper_thetaJoinBranchError,\r\n    exprParser_parseTokensForWhisper_projectionBranchError\r\n}\r\n\r\n/**\r\n * Codes for RASemanticErrors.\r\n */\r\nexport enum SemanticErrorCodes {\r\n    exprParser_parse_relationNotDefined = 1001,\r\n\r\n    binaryNode_eval_commonColumnsInSources,\r\n    setOperationNode_eval_notEqualColumnsInSources,\r\n    divisionNode_eval_rightColumnsNotSubsetOfLeft,\r\n    divisionNode_eval_rightColumnsNotProperSubsetOfLeft,\r\n    renameNode_eval_absentOriginalColumn,\r\n    renameNode_eval_changeToDuplicitName,\r\n    projectionNode_eval_absentColumn,\r\n\r\n    referenceValue_eval_absentColumn\r\n}\r\n\r\n/**\r\n * Codes for RASyntaxErrors.\r\n */\r\nexport enum SyntaxErrorCodes {\r\n    exprParser_parse_emptyStringGiven = 2001,\r\n    exprParser_parseTokens_outerJoinWhenNullNotSupported,\r\n    exprParser_parseTokens_unexpectedPart,\r\n    exprParser_parseTokens_bothBranchesError,\r\n    exprParser_rpnToVETree_invalidExpression,\r\n    exprParser_assertValidInfixTokens_invalidParentheses,\r\n    exprParser_assertValidInfixTokens_invalidStart,\r\n    exprParser_assertValidInfixTokens_invalidEnd,\r\n    exprParser_assertValidInfixTokens_relationAfterRelation,\r\n    exprParser_assertValidInfixTokens_relationAfterUnary,\r\n    exprParser_assertValidInfixTokens_relationAfterClosing,\r\n    exprParser_assertValidInfixTokens_unaryAfterBinary,\r\n    exprParser_assertValidInfixTokens_unaryAfterOpening,\r\n    exprParser_assertValidInfixTokens_binaryAfterBinary,\r\n    exprParser_assertValidInfixTokens_binaryAfterOpening,\r\n    exprParser_assertValidInfixTokens_openingAfterRelation,\r\n    exprParser_assertValidInfixTokens_openingAfterUnary,\r\n    exprParser_assertValidInfixTokens_openingAfterClosing,\r\n    exprParser_assertValidInfixTokens_closingAfterBinary,\r\n    exprParser_assertValidInfixTokens_closingAfterOpening,\r\n\r\n    valueParser_parseTokens_emptyInput,\r\n    valueParser_parseTokens_unsupportedNull,\r\n    valueParser_parseTokens_unexpectedPart,\r\n    valueParser_toRPN_missingOpeningParenthesis,\r\n    valueParser_toRPN_missingClosingParenthesis,\r\n    valueParser_rpnToVETree_invalidExpression,\r\n    valueParser_rpnToVETree_invalidStart,\r\n    valueParser_rpnToVETree_invalidEnd,\r\n    valueParser_rpnToVETree_literalAfterLiteral,\r\n    valueParser_rpnToVETree_literalAfterReference,\r\n    valueParser_rpnToVETree_literalAfterClosing,\r\n    valueParser_rpnToVETree_referenceAfterLiteral,\r\n    valueParser_rpnToVETree_referenceAfterReference,\r\n    valueParser_rpnToVETree_referenceAfterClosing,\r\n    valueParser_rpnToVETree_notAfterLiteral,\r\n    valueParser_rpnToVETree_notAfterReference,\r\n    valueParser_rpnToVETree_notAfterClosing,\r\n    valueParser_rpnToVETree_binaryAfterOperator,\r\n    valueParser_rpnToVETree_binaryAfterOpening,\r\n    valueParser_rpnToVETree_openingAfterLiteral,\r\n    valueParser_rpnToVETree_openingAfterReference,\r\n    valueParser_rpnToVETree_openingAfterClosing,\r\n    valueParser_rpnToVETree_closingAfterOperator,\r\n    valueParser_rpnToVETree_closingAfterOpening,\r\n\r\n    parser_nextBorderedPart_missingClosingChar,\r\n    parser_skipWhitespacesAndChar_charNotFound,\r\n\r\n    projectionNode_constructor_invalidProjectionString,\r\n    projectionNode_parseProjection_invalidProjectedColumnName,\r\n\r\n    renameNode_parseChanges_invalidRenameString,\r\n    renameNode_parseChanges_missingArrow,\r\n    renameNode_parseChanges_invalidNewName,\r\n    renameNode_parseChanges_keywordNewName,\r\n    renameNode_parseChanges_multipleRenameOfTheColumn,\r\n\r\n    selectionNode_constructor_invalidString,\r\n    selectionNode_constructor_emptyString,\r\n    selectionNode_eval_resultNotBoolean,\r\n\r\n    thetaJoinNode_constructor_invalidString,\r\n    thetaJoinNode_constructor_emptyString,\r\n    thetaJoinNode_eval_resultNotBoolean,\r\n\r\n    thetaSemiJoinNode_constructor_invalidString,\r\n    thetaSemiJoinNode_constructor_emptyString,\r\n    thetaSemiJoinNode_eval_resultNotBoolean,\r\n\r\n    comparingOperator_eval_differentInputTypes,\r\n\r\n    computingOperator_eval_inputTypesNotNumbers,\r\n\r\n    logicalOperator_eval_leftInputNotBoolean,\r\n    logicalOperator_eval_rightInputNotBoolean\r\n}\r\n\r\n/**\r\n * English messages for CodeErrors mapped by their error codes.\r\n */\r\nconst codeErrMsgEng: Map<CodeErrorCodes, string[]> = new Map<CodeErrorCodes, string[]>([\r\n    [CodeErrorCodes.resultSection_getCurrentRelation_nodeIndexNotFound,\r\n        [\"ResultSection.getCurrentRelation: Selected node index in evaluation tree not found.\"]],\r\n    [CodeErrorCodes.resultSection_getCurrentRelation_evalError,\r\n        [\"ResultSection.getCurrentRelation: Evaluation error in result section: \", \"\"]],\r\n    [CodeErrorCodes.resultSection_saveResultRelation_nullRelationToSave,\r\n        [\"ResultSection.saveResultRelation: Result relation is null when tried to save it.\"]],\r\n    [CodeErrorCodes.resultSection_handleAddRelation_nullRelationToAdd,\r\n        [\"ResultSection.handleAddRelation: Result relation is null when tried to add it.\"]],\r\n\r\n    [CodeErrorCodes.row_getOrderedValues_absentColumn,\r\n        [\"Row.getOrderedValues: Column \", \" is absent in row with columns: \", \"\"]],\r\n\r\n    [CodeErrorCodes.valueParser_rpnToVETreeRecursive_unexpectedToken,\r\n        [\"ValueParser.rpnToVETreeRecursive: Unexpected token: \", \".\"]],\r\n\r\n    [CodeErrorCodes.exprParser_isValidSequence_unexpectedToken,\r\n        [\"ExprParser.isValidSequence: Unexpected token: \", \".\"]],\r\n    [CodeErrorCodes.exprParser_rpnToVETreeRecursive_unexpectedToken,\r\n        [\"ExprParser.rpnToVETreeRecursive: Unexpected token: \", \".\"]],\r\n    [CodeErrorCodes.exprParser_parseTokensForWhisper_thetaJoinBranchError,\r\n        [\"ExprParser.parseTokensForWhisper: Error in theta join branch: \", \".\"]],\r\n    [CodeErrorCodes.exprParser_parseTokensForWhisper_projectionBranchError,\r\n        [\"ExprParser.parseTokensForWhisper: Error in projection branch: \", \".\"]]\r\n]);\r\n\r\n/**\r\n * English messages for RASemanticErrors mapped by their error codes.\r\n */\r\nconst semanticErrMsgEng: Map<SemanticErrorCodes, string[]> = new Map<SemanticErrorCodes, string[]>([\r\n    [SemanticErrorCodes.exprParser_parse_relationNotDefined,\r\n        [\"Relation \\\"\", \"\\\" is not defined. Please check relations definitions.\"]],\r\n\r\n    [SemanticErrorCodes.binaryNode_eval_commonColumnsInSources,\r\n        [\"Source relations for \", \" have common columns \\\"\", \"\\\".\"]],\r\n    [SemanticErrorCodes.setOperationNode_eval_notEqualColumnsInSources,\r\n        [\"Source relations \\\"\", \"\\\" and \\\"\", \"\\\" for set \", \" do not have the same column sets.\"]],\r\n    [SemanticErrorCodes.divisionNode_eval_rightColumnsNotSubsetOfLeft,\r\n        [\"Right source relation \\\"\", \"\\\" is not a subset of the left source relation \\\"\", \"\\\".\"]],\r\n    [SemanticErrorCodes.divisionNode_eval_rightColumnsNotProperSubsetOfLeft,\r\n        [\"Right source relation \\\"\", \"\\\" is not a proper subset of the left source relation \\\"\",\r\n            \". There must exist a column in the left relation which is not present in the right relation.\"]],\r\n    [SemanticErrorCodes.renameNode_eval_absentOriginalColumn,\r\n        [\"Invalid rename, column \\\"\", \"\\\" does not exist in the source relation.\"]],\r\n    [SemanticErrorCodes.renameNode_eval_changeToDuplicitName,\r\n        [\"Invalid rename, new column name \\\"\", \"\\\" is duplicit in the changed relation.\"]],\r\n    [SemanticErrorCodes.projectionNode_eval_absentColumn,\r\n        [\"Invalid projection of the column \\\"\", \"\\\". It does not exist in the source relation.\"]],\r\n\r\n    [SemanticErrorCodes.referenceValue_eval_absentColumn,\r\n        [\"Column \\\"\", \"\\\" is absent in a schema with columns: \", \".\"]],\r\n]);\r\n\r\n/**\r\n * English messages for RASyntaxErrors mapped by their error codes.\r\n */\r\nconst syntaxErrMsgEng: Map<SyntaxErrorCodes, string[]> = new Map<SyntaxErrorCodes, string[]>([\r\n    [SyntaxErrorCodes.exprParser_parse_emptyStringGiven,\r\n        [\"Cannot parse an expression from an empty string.\"]],\r\n    [SyntaxErrorCodes.exprParser_parseTokens_outerJoinWhenNullNotSupported,\r\n        [\"Found \", \" when null values are not supported.\"]],\r\n    [SyntaxErrorCodes.exprParser_parseTokens_unexpectedPart,\r\n        [\"Unexpected part \\\"\", \"\\\" in RA expression.\"]],\r\n    [SyntaxErrorCodes.exprParser_parseTokens_bothBranchesError,\r\n        [\"All combinations throw error in \\\"\", \"\\\". When treated as projection:\\n\", \"\\nWhen treated as theta join:\\n\", \"\"]],\r\n    [SyntaxErrorCodes.exprParser_rpnToVETree_invalidExpression,\r\n        [\"Given string is not a valid expression.\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_invalidParentheses,\r\n        [\"Invalid structure of parentheses in the expression.\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_invalidStart,\r\n        [\"RA expression cannot start with \", \".\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_invalidEnd,\r\n        [\"RA expression cannot end with \", \".\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_relationAfterRelation,\r\n        [\"Relation \\\"\", \"\\\" after relation \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_relationAfterUnary,\r\n        [\"Relation \\\"\", \"\\\" after unary operator \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_relationAfterClosing,\r\n        [\"Relation \\\"\", \"\\\" after closing parenthesis.\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_unaryAfterBinary,\r\n        [\"Unary operator \\\"\", \"\\\" after binary operator \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_unaryAfterOpening,\r\n        [\"Unary operator \\\"\", \"\\\" after opening parenthesis.\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_binaryAfterBinary,\r\n        [\"Binary operator \\\"\", \"\\\" after binary operator \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_binaryAfterOpening,\r\n        [\"Binary operator \\\"\", \"\\\" after opening parenthesis.\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_openingAfterRelation,\r\n        [\"Opening parentheses after relation \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_openingAfterUnary,\r\n        [\"Opening parentheses after unary operator \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_openingAfterClosing,\r\n        [\"Opening parentheses after closing parentheses.\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_closingAfterBinary,\r\n        [\"Closing parentheses after binary operator \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_closingAfterOpening,\r\n        [\"Closing parentheses after opening parentheses.\"]],\r\n\r\n    [SyntaxErrorCodes.valueParser_parseTokens_emptyInput,\r\n        [\"An empty string given as a condition.\"]],\r\n    [SyntaxErrorCodes.valueParser_parseTokens_unsupportedNull,\r\n        [\"Null constant used when null values are not supported.\"]],\r\n    [SyntaxErrorCodes.valueParser_parseTokens_unexpectedPart,\r\n        [\"Unexpected part \\\"\", \"\\\" in expression.\"]],\r\n    [SyntaxErrorCodes.valueParser_toRPN_missingOpeningParenthesis,\r\n        [\"Missing opening parenthesis '(' in an expression.\"]],\r\n    [SyntaxErrorCodes.valueParser_toRPN_missingClosingParenthesis,\r\n        [\"Missing closing parenthesis ')' in an expression.\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_invalidExpression,\r\n        [\"Given string is not a valid expression.\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_invalidStart,\r\n        [\"Expression cannot start with \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_invalidEnd,\r\n        [\"Expression cannot end with \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_literalAfterLiteral,\r\n        [\"Literal \\\"\", \"\\\" after literal \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_literalAfterReference,\r\n        [\"Literal \\\"\", \"\\\" after reference to column \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_literalAfterClosing,\r\n        [\"Literal \\\"\", \"\\\" after closing parentheses.\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_referenceAfterLiteral,\r\n        [\"Reference to column \\\"\", \"\\\" after literal \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_referenceAfterReference,\r\n        [\"Reference to column \\\"\", \"\\\" after reference to column \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_referenceAfterClosing,\r\n        [\"Reference to column \\\"\", \"\\\" after closing parentheses.\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_notAfterLiteral,\r\n        [\"Logical not operator \\\"\", \"\\\" after literal \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_notAfterReference,\r\n        [\"Logical not operator \\\"\", \"\\\" after reference to column \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_notAfterClosing,\r\n        [\"Logical not operator \\\"\", \"\\\" after closing parentheses.\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_binaryAfterOperator,\r\n        [\"Binary operator \\\"\", \"\\\" after binary operator \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_binaryAfterOpening,\r\n        [\"Binary operator \\\"\", \"\\\" after opening parentheses.\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_openingAfterLiteral,\r\n        [\"Opening parentheses after literal \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_openingAfterReference,\r\n        [\"Opening parentheses after reference to column \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_openingAfterClosing,\r\n        [\"Opening parentheses after closing parentheses.\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_closingAfterOperator,\r\n        [\"Closing parentheses after binary operator \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_closingAfterOpening,\r\n        [\"Closing parentheses after opening parentheses.\"]],\r\n\r\n    [SyntaxErrorCodes.parser_nextBorderedPart_missingClosingChar,\r\n        [\"Missing '\", \"' after opening '\", \"'.\"]],\r\n    [SyntaxErrorCodes.parser_skipWhitespacesAndChar_charNotFound,\r\n        [\"Expected \\\"\", \"\\\" not found.\"]],\r\n\r\n    [SyntaxErrorCodes.projectionNode_constructor_invalidProjectionString,\r\n        ['\"', \"\\\" is not a projection string. It must be bordered with '[' and ']'.\"]],\r\n    [SyntaxErrorCodes.projectionNode_parseProjection_invalidProjectedColumnName,\r\n        [\"Invalid projection of column \\\"\", \"\\\". Column name must contain letters, number and underscores only and start with a letter.\"]],\r\n\r\n    [SyntaxErrorCodes.renameNode_parseChanges_invalidRenameString,\r\n        ['\"', \"\\\" is not a rename string. It must be bordered with '<' and '>'.\"]],\r\n    [SyntaxErrorCodes.renameNode_parseChanges_missingArrow,\r\n        [\"Invalid rename, please use \\\"OldName -> NewName\\\" for each column renaming separated by commas ','.\"]],\r\n    [SyntaxErrorCodes.renameNode_parseChanges_invalidNewName,\r\n        [\"Invalid rename to \\\"\", \"\\\". New column name must contain letters, number and underscores only and start with a letter.\"]],\r\n    [SyntaxErrorCodes.renameNode_parseChanges_keywordNewName,\r\n        [\"Invalid rename to \\\"\", \"\\\". New column name cannot be a keyword.\"]],\r\n    [SyntaxErrorCodes.renameNode_parseChanges_multipleRenameOfTheColumn,\r\n        [\"Multiple rename of column \\\"\", \"\\\".\"]],\r\n\r\n    [SyntaxErrorCodes.selectionNode_constructor_invalidString,\r\n        [\"Invalid selection, it must be bordered with '(' and ')'.\"]],\r\n    [SyntaxErrorCodes.selectionNode_constructor_emptyString,\r\n        [\"The selection cannot be empty.\"]],\r\n    [SyntaxErrorCodes.selectionNode_eval_resultNotBoolean,\r\n        [\"Result of the selection condition \", \" is not a boolean value, but \", \".\"]],\r\n\r\n    [SyntaxErrorCodes.thetaJoinNode_constructor_invalidString,\r\n        [\"Invalid theta join, it must be bordered with '[' and ']'.\"]],\r\n    [SyntaxErrorCodes.thetaJoinNode_constructor_emptyString,\r\n        [\"The theta join condition cannot be empty.\"]],\r\n    [SyntaxErrorCodes.thetaJoinNode_eval_resultNotBoolean,\r\n        [\"Result of the theta join condition \", \" is not a boolean value, but \", \".\"]],\r\n\r\n    [SyntaxErrorCodes.thetaSemiJoinNode_constructor_invalidString,\r\n        [\"Invalid theta semijoin, it must be bordered with '<' and ']' or '[' and '>'.\"]],\r\n    [SyntaxErrorCodes.thetaSemiJoinNode_constructor_emptyString,\r\n        [\"The theta semijoin condition cannot be empty.\"]],\r\n    [SyntaxErrorCodes.thetaSemiJoinNode_eval_resultNotBoolean,\r\n        [\"Result of the theta semijoin condition \", \" is not a boolean value, but \", \".\"]],\r\n\r\n    [SyntaxErrorCodes.comparingOperator_eval_differentInputTypes,\r\n        [\"Inputs for \\\"\", \"\\\"  have different types \", \" and \", \".\"]],\r\n\r\n    [SyntaxErrorCodes.computingOperator_eval_inputTypesNotNumbers,\r\n        [\"Inputs for \\\"\", \"\\\" are not both numbers, they are \", \" and \", \".\"]],\r\n\r\n    [SyntaxErrorCodes.logicalOperator_eval_leftInputNotBoolean,\r\n        [\"Left input value for \\\"\",  \"\\\" is not a boolean, but \", \".\"]],\r\n    [SyntaxErrorCodes.logicalOperator_eval_rightInputNotBoolean,\r\n        [\"Right input value for \\\"\", \"\\\" is not a boolean, but \", \".\"]]\r\n]);\r\n\r\n/**\r\n * Factory for creating custom application errors: CodeError, RASemanticError, RASyntaxError.\r\n * It creates an error message by given error code and string parameters.\r\n */\r\nexport class ErrorFactory {\r\n\r\n    /**\r\n     * Creates a new CodeError with given code. Params are used to join error messages expecting textual specification.\r\n     *\r\n     * @param code code of the code error\r\n     * @param params textual specification\r\n     */\r\n    public static codeError(code: CodeErrorCodes, ...params: string[]): CodeError {\r\n        let msg: string[] | undefined = codeErrMsgEng.get(code);\r\n        if (msg === undefined) {\r\n            console.log(\"Unknown code of code error given: \" + code);\r\n            msg = [\"Code error\"];\r\n        }\r\n        assertParamsCount(msg.length - 1, params, code);\r\n        return new CodeError(joinStringArrays(msg, params));\r\n    }\r\n\r\n    /**\r\n     * Creates a new RASemanticError with given code and range. Params are used to join error messages expecting textual\r\n     * specification.\r\n     *\r\n     * @param code code of the semantic error\r\n     * @param range text range of the error in the input when defined\r\n     * @param params textual specification\r\n     */\r\n    public static semanticError(code: SemanticErrorCodes, range: {start: number, end: number} | undefined, ...params: string[]): RASemanticError {\r\n        let msg: string[] | undefined = semanticErrMsgEng.get(code);\r\n        if (msg === undefined) {\r\n            console.log(\"Unknown code of semantic error given: \" + code);\r\n            msg = [\"Semantic error\"];\r\n        }\r\n        assertParamsCount(msg.length - 1, params, code);\r\n        return new RASemanticError(joinStringArrays(msg, params), range);\r\n    }\r\n\r\n    /**\r\n     * Creates a new RASyntaxError with given code and range. Params are used to join error messages expecting textual\r\n     * specification.\r\n     *\r\n     * @param code code of the syntax error\r\n     * @param range text range of the error in the input when defined\r\n     * @param params textual specification\r\n     */\r\n    public static syntaxError(code: SyntaxErrorCodes, range: {start: number, end: number} | undefined, ...params: string[]): RASyntaxError {\r\n        let msg: string[] | undefined = syntaxErrMsgEng.get(code);\r\n        if (msg === undefined) {\r\n            console.log(\"Unknown code of syntax error given: \" + code);\r\n            msg = [\"Syntax error\"];\r\n        }\r\n        assertParamsCount(msg.length - 1, params, code);\r\n        return new RASyntaxError(joinStringArrays(msg, params), range);\r\n    }\r\n}\r\n\r\n/**\r\n * Extends the given params array with empty strings to have the length of expectedCount. When the intial length of the\r\n * given params array is same or greater, the array is unchanged.\r\n *\r\n * @param expectedCount\r\n * @param params\r\n * @param code code of the error\r\n */\r\nexport function assertParamsCount(expectedCount: number, params: string[], code: number): void {\r\n    if (params.length !== expectedCount) {\r\n        console.log(\"Unexpected params count for error \" + code + \", expected \" + expectedCount + \", given \" + params.length);\r\n        while (params.length < expectedCount) {\r\n            params.push(\"\");\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Joins given string arrays [a1, a2, ..., an] and [b1, b2, ..., bn-1] to one string \"a1b1a2b2...an-1bn-1an\".\r\n * WARNING: a.length is expected to be at least 1. b.length is expected to be at least \"a.length - 1\".\r\n *\r\n * @param a array of length at least 1\r\n * @param b array of length at least \"a.length - 1\"\r\n */\r\nexport function joinStringArrays(a: string[], b: string[]): string {\r\n    const aLen: number = a.length;\r\n    const toConcat: string[] = Array<string>(2 * aLen - 2);\r\n    for (let i = 1; i < aLen; i++) {\r\n        toConcat[2 * i - 2] = b[i - 1];\r\n        toConcat[2 * i - 1] = a[i];\r\n    }\r\n    return a[0].concat(...toConcat);\r\n}","import ErrorWithTextRange from \"./errorWithTextRange\";\r\n\r\n/**\r\n * Semantic error in an expression structure.\r\n */\r\nexport default class RASemanticError extends ErrorWithTextRange {\r\n    /**\r\n     * @param msg Adds \"Semantic error: \" before given message\r\n     * @param range optional text range of the error\r\n     */\r\n    constructor(msg: string, range: {start: number, end: number} | undefined) {\r\n        super(\"Semantic error: \" + msg, range);\r\n        if (Error.captureStackTrace) {\r\n            Error.captureStackTrace(this, RASemanticError);\r\n        }\r\n        this.name = 'RASemanticError';\r\n    }\r\n}","import ErrorWithTextRange from \"./errorWithTextRange\";\r\n\r\n/**\r\n * Syntax error in an expression structure.\r\n */\r\nexport default class RASyntaxError extends ErrorWithTextRange {\r\n    /**\r\n     * @param msg Adds \"Syntax error: \" before given message\r\n     * @param range optional text range of the error\r\n     */\r\n    constructor(msg: string, range: {start: number, end: number} | undefined) {\r\n        super(\"Syntax error: \" + msg, range);\r\n        if (Error.captureStackTrace) {\r\n            Error.captureStackTrace(this, RASyntaxError);\r\n        }\r\n        this.name = 'RASyntaxError';\r\n    }\r\n}","/**\r\n * Error caused by fatal error in code of the application.\r\n */\r\nexport default class CodeError extends Error {\r\n    constructor(msg: string) {\r\n        super(msg);\r\n        if (Error.captureStackTrace) {\r\n            Error.captureStackTrace(this, CodeError);\r\n        }\r\n        this.name = 'CodeError';\r\n    }\r\n}","import {ErrorFactory, SyntaxErrorCodes} from \"../error/errorFactory\";\r\n\r\n/**\r\n * Parser providing general parsing helper functions.\r\n */\r\nexport default class Parser {\r\n\r\n    /**\r\n     * @param str Checked string\r\n     * @return true if the string contains letters only and has length at least 1\r\n     */\r\n    public static isWord(str: string): boolean {\r\n        return str.length > 0 && str.split(\"\").every(c => Parser.isLetter(c));\r\n    }\r\n\r\n    /**\r\n     * @param str Checked string\r\n     * @return true if the string contains letters, numbers and underscores only, has length at least 1 and starts with\r\n     * a letter or an underscore\r\n     */\r\n    public static isName(str: string): boolean {\r\n        if (str.length === 0) {\r\n            return false;\r\n        }\r\n        if (!Parser.isLetter(str.charAt(0)) && str.charAt(0) !== '_') {\r\n            return false;\r\n        }\r\n        return str.split(\"\").every(c => Parser.isNameChar(c));\r\n    }\r\n\r\n    /**\r\n     * @param str Checked string\r\n     * @return true if the string contains whitespaces only\r\n     */\r\n    public static isWhitespacesOnly(str: string): boolean {\r\n        const regex = /\\s*/;\r\n        const res = regex.exec(str);\r\n        return res === null ? false : res[0] === str;\r\n    }\r\n\r\n    /**\r\n     * @param c Checked character\r\n     * @return true if the given string has length one and the character is a letter\r\n     */\r\n    public static isLetter(c: string): boolean {\r\n        return c.length === 1 && c.toLowerCase() !== c.toUpperCase();\r\n    }\r\n\r\n    /**\r\n     * @param c Checked character\r\n     * @return true if the given string has length one and the character is a letter, a number or an underscore\r\n     */\r\n    public static isNameChar(c: string): boolean {\r\n        return Parser.isLetter(c) || Parser.isDigit(c) || c === '_';\r\n    }\r\n\r\n    /**\r\n     * @param c Checked character\r\n     * @return true if the given string has length one and the character is a digit\r\n     */\r\n    public static isDigit(c: string): boolean {\r\n        return c.length === 1 && c.match(/\\d/) !== null;\r\n    }\r\n\r\n    /**\r\n     * @param str Checked string\r\n     * @return true if the string represents a decimal number\r\n     */\r\n    public static isNumber(str: string): boolean {\r\n        return /^[-]?[\\d]+([.][\\d]+)?$/.test(str);\r\n    }\r\n\r\n    /**\r\n     * Checks whether the given string starts and ends with double quotes and all double quotes used inside it are\r\n     * escaped by '\\'.\r\n     */\r\n    public static isStringLiteral(str: string): boolean {\r\n        if (str.length < 2 || str[0] !== '\"') {\r\n            return false;\r\n        }\r\n        try {\r\n            const split = Parser.nextBorderedPart(str, '\"', '\"', '\\\\');\r\n            return split.first.length === str.length;\r\n        }\r\n        catch (err) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Splits given string to a starting sequence of letters and its rest and returns these parts in a pair.\r\n     * NOTE: if the string does not start with a letter, as a word is returned an empty string.\r\n     *\r\n     * @param str string to be split\r\n     * @return split string in a pair { word, rest }\r\n     */\r\n    public static nextWord(str: string): { first: string, second: string } {\r\n        if (str === \"\") {\r\n            return { first: \"\", second: \"\" };\r\n        }\r\n        let i: number = 0;\r\n        while (i < str.length) {\r\n            if (!Parser.isLetter(str.charAt(i))) {\r\n                return { first: str.substring(0, i), second: str.substring(i)};\r\n            }\r\n            ++i;\r\n        }\r\n        return { first: str, second: \"\"};\r\n    }\r\n\r\n    /**\r\n     * Splits given string to a starting sequence of letters, numbers and underscores, which starts with a letter or\r\n     * an underscore and its rest and returns these parts in a pair.\r\n     * NOTE: if the string does not start with a letter, or an underscore, as a name is returned an empty string.\r\n     *\r\n     * @param str string to be split\r\n     * @return split string in a pair { name, rest }\r\n     */\r\n    public static nextName(str: string): { first: string, second: string } {\r\n        if (str === \"\") {\r\n            return { first: \"\", second: \"\" };\r\n        }\r\n        if (!Parser.isLetter(str.charAt(0)) && str.charAt(0) !== '_') {\r\n            return { first: \"\", second: str };\r\n        }\r\n        let i: number = 0;\r\n        while (i < str.length) {\r\n            const char: string = str.charAt(i);\r\n            if (!Parser.isLetter(char) && !Parser.isDigit(char) && char !== '_') {\r\n                return { first: str.substring(0, i), second: str.substring(i)};\r\n            }\r\n            ++i;\r\n        }\r\n        return { first: str, second: \"\"};\r\n    }\r\n\r\n    /**\r\n     * Splits given string to a starting sequence of non-whitespace characters and its rest and returns these parts in a pair.\r\n     *\r\n     * @param str string to be split\r\n     * @return split string in a pair { word, rest }\r\n     */\r\n    public static nextNonWhitespacePart(str: string): { first: string, second: string } {\r\n        if (str === \"\") {\r\n            return { first: \"\", second: \"\" };\r\n        }\r\n        let i: number = 0;\r\n        while (i < str.length) {\r\n            if (str.charAt(i).match(/\\s/)) {\r\n                return { first: str.substring(0, i), second: str.substring(i)};\r\n            }\r\n            ++i;\r\n        }\r\n        return { first: str, second: \"\"};\r\n    }\r\n\r\n    /**\r\n     * Splits given string to a starting number and its rest and returns these parts in a pair.\r\n     * NOTE: if the string does not start with a digit, as a number is returned an empty string.\r\n     *\r\n     * @param str string to be split\r\n     * @return split string in a pair (word, rest)\r\n     */\r\n    static nextNumber(str: string): { first: string, second: string } {\r\n        if (str === \"\") {\r\n            return { first: \"\", second: \"\" };\r\n        }\r\n        let i: number = 0;\r\n        // string starts with '-' sign\r\n        if (str.charAt(0) === '-') {\r\n            // if there is a digit after '-', shifts the start\r\n            if (str.length > 1 && Parser.isDigit(str.charAt(1))) {\r\n                i = 1;\r\n            }\r\n            // there is no digit\r\n            else {\r\n                return { first: \"\", second: str };\r\n            }\r\n        }\r\n        let digitFound: boolean = false;\r\n        let dotFound: boolean = false;\r\n        while (i < str.length) {\r\n            if (Parser.isDigit(str.charAt(i))) {\r\n                digitFound = true;\r\n                ++i;\r\n            }\r\n            else if (str.charAt(i) === '.') {\r\n                // second dot or a dot without previous digits\r\n                if (dotFound || !digitFound) {\r\n                    break;\r\n                }\r\n                else {\r\n                    dotFound = true;\r\n                    ++i;\r\n                }\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        const numStr = str.substring(0, i);\r\n        const rest = str.substring(i);\r\n        return { first: numStr, second: rest };\r\n    }\r\n\r\n    /**\r\n     * Splits the string to the starting bordered part and the rest and returns these parts in a pair.\r\n     * If there is only one ending character and it differs from the starting one, nested bordering is supported.\r\n     * Characters after an odd count of escape characters are ignored and cannot start or end a bordered part.\r\n     * Starting and ending characters in quoted part are ignored, quotes can be escaped by an odd count of backslashes.\r\n     * NOTE: First character of the string is expected to be 'start'.\r\n     *\r\n     * @param str string to be split\r\n     * @param start starting character of the string and also starting character of the bordered part (one character)\r\n     * @param end ending characters of the bordered part (one or more characters)\r\n     * @param escape character which makes next character being ignored (default '\\0')\r\n     * @return pair of the starting bordered part and the rest\r\n     */\r\n    static nextBorderedPart(str: string, start: string, end: string, escape: string = '\\0'): { first: string, second: string } {\r\n        let depth: number = 1;\r\n        let i: number = 1;\r\n        // to ignore special characters in quoted part\r\n        let inQuotes: boolean = false;\r\n        // nested bordering is supported if there is only one ending character\r\n        const nesting: boolean = end.length === 1;\r\n        // backslashes escape the quote character only in odd count\r\n        let backslashes: number = 0;\r\n        // escape characters escape the end character only in odd count\r\n        let escapeCount: number = 0;\r\n        while (i < str.length) {\r\n            const curChar = str.charAt(i);\r\n            // checks end of the part (before checking start for a case when start == end)\r\n            if (end.indexOf(curChar) > -1 && (escapeCount % 2) === 0 && !inQuotes) {\r\n                --depth;\r\n            }\r\n            // checks start of the bordered part (if only one ending character was given)\r\n            else if (curChar === start && (escapeCount % 2) === 0 && nesting && !inQuotes) {\r\n                ++depth;\r\n            }\r\n            // found quote - changes ignoring of special chars\r\n            else if (curChar === '\"' && (backslashes % 2) === 0) {\r\n                inQuotes = !inQuotes;\r\n            }\r\n            // updates escape chars count\r\n            if (curChar === escape) {\r\n                ++escapeCount;\r\n            }\r\n            else {\r\n                escapeCount = 0;\r\n            }\r\n            // updates backslash count\r\n            if (curChar === '\\\\') {\r\n                ++backslashes;\r\n            }\r\n            else {\r\n                backslashes = 0;\r\n            }\r\n            ++i;\r\n            if (depth === 0) {\r\n                const partOne: string = str.substring(0, i);\r\n                let partTwo: string = (i < str.length) ? str.substring(i) : \"\";\r\n                return { first: partOne, second: partTwo };\r\n            }\r\n        }\r\n        throw ErrorFactory.syntaxError(SyntaxErrorCodes.parser_nextBorderedPart_missingClosingChar, undefined,\r\n            end.split('').join(\"' or '\"), start);\r\n    }\r\n\r\n    /**\r\n     * Skips all whitespaces and exactly one given character and returns rest of the string.\r\n     * If the string does not match this pattern, throws error.\r\n     *\r\n     * @param str string to be skipped in\r\n     * @param char char to be skipped exactly one time (expected to be string of length 1)\r\n     * @return given string without starting sequence of whitespaces and exactly one char\r\n     */\r\n    public static skipWhitespacesAndChar(str: string, char: string): string {\r\n        let charFound: boolean = false;\r\n        let i: number = 0;\r\n        while (i < str.length) {\r\n            if (str.charAt(i).match(/\\s/)) {\r\n                ++i;\r\n            }\r\n            else if (str.charAt(i) === char && !charFound) {\r\n                charFound = true;\r\n                ++i;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        if (!charFound) {\r\n            throw ErrorFactory.syntaxError(SyntaxErrorCodes.parser_skipWhitespacesAndChar_charNotFound, undefined, char);\r\n        }\r\n        return str.substring(i);\r\n    }\r\n\r\n    /**\r\n     * Deletes all lines, where two first non-whitespace characters are '//'.\r\n     *\r\n     * @param str string to be deleted comments in\r\n     */\r\n    public static deleteCommentLines(str: string) {\r\n        return str.split('\\n').map(line => {\r\n            let insideQuotes: boolean = false;\r\n            for (let i = 0; i < line.length; ++i) {\r\n                // quotes found\r\n                if (line.charAt(i) === '\"') {\r\n                    if (insideQuotes && line.charAt(i - 1) !== '\\\\') {\r\n                        insideQuotes = false;\r\n                    }\r\n                    else if (!insideQuotes) {\r\n                        insideQuotes = true;\r\n                    }\r\n                }\r\n                // double-backslash found outside quotes\r\n                if (!insideQuotes && line.charAt(i) === '/' && i > 0 && line.charAt(i - 1) === '/') {\r\n                    return line.slice(0, i - 1);\r\n                }\r\n            }\r\n            return line;\r\n        }).join('\\n');\r\n    }\r\n}","import React from \"react\";\r\n\r\ninterface TooltipButtonProps {\r\n    // text on the button\r\n    text: string,\r\n    // handler of the button click\r\n    onClick: () => void,\r\n    // css class of the button\r\n    className: string,\r\n    // inline styling for button\r\n    style?: React.CSSProperties,\r\n\r\n    // text of the tooltip\r\n    tooltip: string,\r\n    // css class of the tooltip\r\n    tooltipClassName: string,\r\n    // inline styling for tooltip\r\n    tooltipStyle?: React.CSSProperties,\r\n}\r\n\r\ninterface TooltipButtonState {\r\n}\r\n\r\n/**\r\n * Button with a tooltip text.\r\n */\r\nexport class TooltipButton extends React.Component<TooltipButtonProps, TooltipButtonState> {\r\n\r\n    render() {\r\n        return (\r\n            <button\r\n                className={this.props.className}\r\n                onClick={this.props.onClick}\r\n                style={this.props.style}\r\n                >{this.props.text}\r\n                <span\r\n                    className={this.props.tooltipClassName}\r\n                    style={this.props.tooltipStyle}\r\n                >{this.props.tooltip}</span>\r\n            </button>\r\n        );\r\n    }\r\n}","import React from \"react\";\r\n\r\ninterface MessageLabelProps {\r\n    // message to be shown\r\n    message: string,\r\n    // when true, the message is highlighted as error\r\n    error: boolean,\r\n    // true if dark theme should be applied\r\n    darkTheme: boolean\r\n}\r\n\r\ninterface MessageLabelState {}\r\n\r\n/**\r\n * Label to show a message in a paragraph.\r\n */\r\nexport class MessageLabel extends React.Component<MessageLabelProps, MessageLabelState> {\r\n\r\n    render() {\r\n        // does not render for an empty message\r\n        if (this.props.message === '') {\r\n            return null;\r\n        }\r\n        let color: string;\r\n        if (this.props.darkTheme) {\r\n            color = this.props.error ? \"red\" : \"white\";\r\n        }\r\n        else {\r\n            color = this.props.error ? \"red\" : \"black\";\r\n        }\r\n        return (\r\n            <p style={{color: color}}>\r\n                {this.props.message}\r\n            </p>\r\n        );\r\n    }\r\n}","/**\r\n * Computes width (average on sample of characters) and its height of the given font with given size in pixels.\r\n *\r\n * @param fontFamily\r\n * @param fontSize\r\n */\r\nexport function computeFontSizeInPx(fontFamily: string, fontSize: string): {fontWidth: number, fontHeight: number} {\r\n    const text: string = \"0123456789qwertyuiopasdfghjkllzxcvbnmQWERTYUIOOPASDFGHJKLLZXCVBNM!@#$%^&*()_+[];',./\";\r\n    const div = document.createElement(\"div\");\r\n    div.setAttribute('style', `font-family: ${fontFamily}; font-size: ${fontSize}; position: absolute;`);\r\n    div.innerText = text;\r\n    document.documentElement.appendChild(div);\r\n    const divWidth: number = div.clientWidth;\r\n    const divHeight: number = div.clientHeight;\r\n    div.remove();\r\n    return { fontWidth: divWidth / text.length, fontHeight: divHeight };\r\n}","/**\r\n * Returns start index of the word before given index in the given string.\r\n *\r\n * @param str\r\n * @param index\r\n */\r\nexport function getStartOfWordBeforeIndex(str: string, index: number): number {\r\n    const prefixText: string = str.slice(0, index);\r\n    let i: number = prefixText.length - 1;\r\n    while (true) {\r\n        // if non-name-character is reached\r\n        if (!prefixText.charAt(i).match(/\\w/)) {\r\n            ++i;\r\n            break;\r\n        }\r\n        if (i === 0) {\r\n            break;\r\n        }\r\n        --i;\r\n    }\r\n    return i;\r\n}\r\n\r\n/**\r\n * Sorts given array of whispers according to given last word before cursor.\r\n *\r\n * @param whispers\r\n * @param wordBeforeCursor\r\n */\r\nexport function sortWhispers(whispers: string[], wordBeforeCursor: string): void {\r\n    const firstCharHit: number = 64;\r\n    const containsWord: number = 128;\r\n    const getLikelihood = (whisper: string): number => {\r\n        const a = (whisper.charAt(0).toLowerCase() === wordBeforeCursor.charAt(0).toLowerCase()) ? firstCharHit : 0;\r\n        const b = (whisper.toLowerCase().indexOf(wordBeforeCursor.toLowerCase()) > -1) ? containsWord : 0;\r\n        return a + b;\r\n    }\r\n    if (wordBeforeCursor !== \"\") {\r\n        whispers.sort((x, y) => getLikelihood(y) - getLikelihood(x));\r\n    }\r\n}","import React from \"react\";\r\nimport './css/xTextArea.css';\r\nimport {mod} from \"../tools/math\";\r\nimport {computeFontSizeInPx} from \"../tools/font\";\r\nimport {getStartOfWordBeforeIndex} from \"../tools/whisper\";\r\n\r\ninterface XTextAreaProps {\r\n    // id of the component\r\n    id: string;\r\n    // current text content of the textarea\r\n    text: string;\r\n    // text to be shown as textarea placeholder\r\n    placeholder: string;\r\n    // error messages and ranges to be highlighted in text area\r\n    errors: {start: number, end: number, msg: string}[];\r\n    // strings whispered to the user to be added at the current position\r\n    whispers: string[];\r\n    // handler of text change\r\n    onChange: (text: string, cursorIndex: number) => void;\r\n    // true if dark theme should be applied\r\n    darkTheme: boolean;\r\n}\r\n\r\ninterface XTextAreaState {}\r\n\r\n/**\r\n * HTMLTextAreaElement extended for painting number lines, inserting strings given from parent and whispering.\r\n */\r\ntype ExtendedHTMLTextArea = HTMLTextAreaElement & {\r\n    /**\r\n     * (Re)paints line numbers next to textarea.\r\n     *\r\n     * @param darkTheme style to be applied to numbers\r\n     */\r\n    paintLineNumbers: (darkTheme: boolean) => void,\r\n    // reference to canvas element used to paint line numbers\r\n    canvasLines: HTMLCanvasElement,\r\n    // true when the mouse button is clicked down\r\n    mouseIsDown: boolean,\r\n\r\n    /**\r\n     * Whispers given array of strings to the user at the current cursor position.\r\n     *\r\n     * @param toWhisper\r\n     */\r\n    showWhisper: (whispers: string[]) => void,\r\n    /**\r\n     * Moves the WhisperDiv to be located next to the current cursor position.\r\n     * The WhisperDiv is moved only if the whisperDiv.isShown is true.\r\n     */\r\n    moveWhisper: () => void,\r\n    /**\r\n     * Hides the WhisperDiv (whisperDiv.isShown is set to false).\r\n     */\r\n    hideWhisper: () => void,\r\n    /**\r\n     * Inserts current selected whisper.\r\n     *\r\n     * @param onChange callback to the parent after text change\r\n     */\r\n    insertCurrentSelectedWhisper: (onChange: (text: string, cursorIndex: number) => void) => void,\r\n    // reference to whisper div\r\n    whisperDiv: WhisperDiv,\r\n\r\n    /**\r\n     * Creates error div elements for given ranges.\r\n     */\r\n    updateErrors: (ranges: {start: number, end: number, msg: string}[]) => void,\r\n    /**\r\n     * Moves error div elements to current position.\r\n     */\r\n    moveErrors: () => void,\r\n    // div elements for highlighting errors\r\n    errorDivs: ErrorDiv[]\r\n};\r\n\r\n/**\r\n * HTMLDivElement extended by functions for easy whispering.\r\n */\r\ntype WhisperDiv = HTMLDivElement & {\r\n    // true when the whisper should be shown\r\n    isShown: boolean,\r\n    // index of the selected whisper\r\n    selectedIndex: number,\r\n    /**\r\n     * Updates selected whisper by given difference. Removes highlights from previous highlighted whisper and\r\n     * highlights the new selected. The new index is modulo actual whisper count. The function does nothing, when\r\n     * there no whispers at the moment.\r\n     *\r\n     * @param indexDiff\r\n     */\r\n    changeSelected: (indexDiff: number) => void,\r\n    /**\r\n     * Updates selected whisper to given index. Removes highlights from previous highlighted whisper and\r\n     * highlights the new selected. The new index is modulo actual whisper count. The function does nothing, when\r\n     * there no whispers at the moment.\r\n     *\r\n     * @param newIndex\r\n     */\r\n    setSelected: (newIndex: number) => void,\r\n    /**\r\n     * Returns current selected whisper or undefined, when no whisper is selected.\r\n     */\r\n    getSelectedWhisper: () => string | undefined\r\n};\r\n\r\ntype ErrorDiv = HTMLDivElement & {\r\n    startLine: number,\r\n    startColumn: number,\r\n    rangeLength: number,\r\n    messageSpan: HTMLSpanElement\r\n}\r\n\r\n// @ts-ignore\r\nconst cssConstants: CSSStyleDeclaration = getComputedStyle(document.querySelector(':root'));\r\n\r\nconst fontSize: string = cssConstants.getPropertyValue('--x-textarea-font-size');\r\nconst fontFamily: string = cssConstants.getPropertyValue('--x-textarea-font-family');\r\nconst {fontWidth} = computeFontSizeInPx(fontFamily, fontSize);\r\nconst lineHeight: number = Number(cssConstants.getPropertyValue('--x-textarea-line-height'));\r\nconst numsBackgroundLight: string = cssConstants.getPropertyValue('--light-section');\r\nconst numsBackgroundDark: string = cssConstants.getPropertyValue('--dark-section');\r\nconst numsColorLight: string = cssConstants.getPropertyValue('--text-color-light');\r\nconst numsColorDark: string = cssConstants.getPropertyValue('--text-color-dark');\r\nconst canvasWidth: number = 24;\r\n\r\n/**\r\n * TextArea extended by line numbers and text highlighting. The component is maintained by JavaScript HTML functions,\r\n * not by React.\r\n */\r\nexport class XTextArea extends React.Component<XTextAreaProps, XTextAreaState> {\r\n    // reference to XTextArea root React div element\r\n    private reactDiv: React.RefObject<HTMLDivElement> = React.createRef<HTMLDivElement>();\r\n    // @ts-ignore - always set before usage in componentDidMount\r\n    private textarea: ExtendedHTMLTextArea;\r\n\r\n    /**\r\n     * Returns current text area selection start and end.\r\n     */\r\n    public getSelection(): {start: number, end: number} {\r\n        return {start: this.textarea.selectionStart, end: this.textarea.selectionEnd};\r\n    }\r\n\r\n    /**\r\n     * Sets text area selection start and end. If end is not given, start value is used as end value as well.\r\n     *\r\n     * @param start\r\n     * @param end\r\n     */\r\n    public setSelection(start: number, end?: number): void {\r\n        this.textarea.setSelectionRange(start, end ? end : start);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the textarea has focus.\r\n     */\r\n    public isFocused(): boolean {\r\n        return document.activeElement !== null && document.activeElement.id === this.props.id + '-ta';\r\n    }\r\n\r\n    /**\r\n     * The text area gains focus in the window.\r\n     */\r\n    public focus(): void {\r\n        this.textarea.focus();\r\n    }\r\n\r\n    /**\r\n     * The component is build by JavaScript HTML functions after mount of the empty div in render function.\r\n     */\r\n    componentDidMount() {\r\n        // @ts-ignore - gets parent div\r\n        const div: HTMLDivElement = document.getElementById(this.props.id);\r\n        div.classList.add(this.props.darkTheme ? \"x-textarea-div-dark\" : \"x-textarea-div-light\");\r\n\r\n        // LAYOUT (table with 1 row and 2 columns)\r\n        const table = document.createElement('table');\r\n        table.setAttribute('cellspacing','0');\r\n        table.setAttribute('cellpadding','0');\r\n        table.classList.add('x-textarea-table');\r\n        const tr = document.createElement('tr');\r\n        const td1 = document.createElement('td');\r\n        td1.setAttribute('id', this.props.id + '-td1');\r\n        td1.classList.add(this.props.darkTheme ? 'x-textarea-table-td1-dark' : 'x-textarea-table-td1-light');\r\n        const td2 = document.createElement('td');\r\n        td2.classList.add('x-textarea-table-td2');\r\n        tr.appendChild(td1);\r\n        tr.appendChild(td2);\r\n        table.appendChild(tr);\r\n\r\n        // TEXTAREA\r\n        // @ts-ignore - extended later in componentDidMount\r\n        const ta: ExtendedHTMLTextArea = document.createElement('textarea');\r\n        ta.setAttribute('id', this.props.id + '-ta');\r\n        ta.setAttribute('rows', '2');\r\n        ta.setAttribute('spellcheck', 'false');\r\n        ta.mouseIsDown = false;\r\n        ta.setAttribute('placeholder', this.props.placeholder);\r\n        ta.classList.add('x-textarea');\r\n        this.props.darkTheme ? ta.classList.add('x-textarea-dark', 'cursor-container-dark') :\r\n                              ta.classList.add('x-textarea-light', 'cursor-container-light');\r\n        ta.value = this.props.text;\r\n\r\n        // TEXTAREA NUMBERS (Canvas)\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = canvasWidth + 4;    // must not set width & height in css !!!\r\n        canvas.classList.add(this.props.darkTheme ? 'canvas-dark' : 'canvas-light');\r\n        ta.canvasLines = canvas;\r\n        td1.appendChild(canvas);\r\n        td2.appendChild(ta);\r\n        div.appendChild(table);\r\n\r\n        // TEXTAREA WHISPER DIV\r\n        // @ts-ignore - extended later in componentDidMount\r\n        const whisperDiv: WhisperDiv = document.createElement('div');\r\n        whisperDiv.classList.add('whisper-div', this.props.darkTheme ? 'whisper-div-dark' : 'whisper-div-light');\r\n        whisperDiv.isShown = false;\r\n        whisperDiv.selectedIndex = -1;\r\n        whisperDiv.changeSelected = function (indexDiff: number) {\r\n            this.setSelected(this.selectedIndex + indexDiff);\r\n        }\r\n        whisperDiv.setSelected = function (newIndex: number) {\r\n            if (this.childElementCount > 0) {\r\n                // removes selected highlight from previous selected whisper (if it is valid)\r\n                if (this.selectedIndex > -1 && this.selectedIndex < this.childElementCount) {\r\n                    this.children[this.selectedIndex].classList.remove(\"selected-whisper\");\r\n                }\r\n                // updates the index modulo child count\r\n                this.selectedIndex = mod(newIndex, this.childElementCount);\r\n                // adds selected highlight\r\n                this.children[this.selectedIndex].classList.add(\"selected-whisper\");\r\n            }\r\n        }\r\n        whisperDiv.getSelectedWhisper = function (): string | undefined {\r\n            if (this.selectedIndex > -1 && this.childElementCount > 0) {\r\n                // @ts-ignore\r\n                return this.children[this.selectedIndex].innerText;\r\n            }\r\n            return undefined;\r\n        }\r\n        ta.whisperDiv = whisperDiv;\r\n        td2.appendChild(whisperDiv);\r\n\r\n        // Line numbers rendering inspired by: https://www.w3schools.com/code/tryit.asp?filename=G68VMFWS12UH,\r\n        // Nikola Bozovic, nigerija@gmail.com\r\n        ta.paintLineNumbers = function(darkTheme: boolean): void {\r\n            try {\r\n                const canvas = this.canvasLines;\r\n                if (canvas.height !== this.clientHeight) {\r\n                    canvas.height = this.clientHeight; // on resize\r\n                }\r\n                // @ts-ignore\r\n                const ctx: CanvasRenderingContext2D = canvas.getContext(\"2d\");\r\n                ctx.fillStyle = darkTheme ? numsBackgroundDark : numsBackgroundLight;\r\n                ctx.fillRect(0, 0, canvasWidth + 2, this.scrollHeight + 1);\r\n                ctx.fillStyle = darkTheme ? numsColorDark : numsColorLight;\r\n                ctx.font = fontSize + \" \" + fontFamily;\r\n                const startIndex = Math.floor(this.scrollTop / lineHeight);\r\n                const endIndex = startIndex + Math.floor(this.clientHeight / lineHeight);\r\n                for (let i = startIndex; i <= endIndex; i++) {\r\n                    const y = 16 - this.scrollTop + (i * lineHeight);\r\n                    const text = '' + (i + 1);  // line number\r\n                    ctx.fillText(text,canvasWidth - (text.length * 6), y);\r\n                }\r\n            }\r\n            catch(e) {\r\n                console.log('XTextArea paintLineNumbers error: ' + e);\r\n            }\r\n        };\r\n\r\n        ta.showWhisper = function (whispers: string[]): void {\r\n            if (whispers.length === 0) {\r\n                this.hideWhisper();\r\n            }\r\n            else {\r\n                const prevCount: number = this.whisperDiv.childElementCount;\r\n                // inserts given whispers (rewrites innerHTML)\r\n                this.whisperDiv.innerHTML = whispers.map(whisper => `<div>${whisper}</div>`).join('');\r\n                if (this.whisperDiv.childElementCount !== prevCount) {\r\n                    // sets selected index to 0 when whispers count has changed\r\n                    this.whisperDiv.setSelected(0);\r\n                }\r\n                else {\r\n                    // forces highlight of current selection\r\n                    this.whisperDiv.changeSelected(0);\r\n                }\r\n                // needs to be set to true before moveWhisper call\r\n                this.whisperDiv.isShown = true;\r\n                // sets the div position\r\n                this.moveWhisper();\r\n            }\r\n        }\r\n\r\n        ta.moveWhisper = function () {\r\n            // updates only if the whisper is shown\r\n            if (this.whisperDiv.isShown) {\r\n                // finds cursor position in the whole string\r\n                const cursorLineAndColumn = getPositionLineAndColumn(this.value, this.selectionEnd);\r\n                // computes position of the bottom end of the cursor relative to the text\r\n                const cursorDistanceFromTATotalTop: number = (cursorLineAndColumn.line + 1) * lineHeight;\r\n                const cursorDistanceFromTATotalLeft: number = cursorLineAndColumn.column * fontWidth;\r\n                const yPos: number = cursorDistanceFromTATotalTop - this.scrollTop;\r\n                const xPos: number = cursorDistanceFromTATotalLeft - this.scrollLeft;\r\n                // shows the div at computed position if the cursor is visible\r\n                if (0 <= yPos && yPos < this.clientHeight && 0 <= xPos && xPos < this.clientWidth) {\r\n                    // if the div is in the upper part of the screen, shows it under the cursor\r\n                    if (this.getBoundingClientRect().y + yPos <= window.innerHeight / 2) {\r\n                        this.whisperDiv.setAttribute('style', `display: block; top: ${yPos + 4}px; left: ${xPos}px;`);\r\n                    }\r\n                    // if the div is in the lower part of the screen, shows it above the cursor\r\n                    else {\r\n                        this.whisperDiv.setAttribute('style',\r\n                            `display: block; bottom: ${this.getBoundingClientRect().height - yPos + lineHeight}px; left: ${xPos}px;`);\r\n                    }\r\n                }\r\n                // hides the div if the cursor is not visible (but DOES NOT SET whisperDiv.isShown to false to re-appear it again)\r\n                else {\r\n                    this.whisperDiv.setAttribute('style', `display: none;`);\r\n                }\r\n            }\r\n        }\r\n\r\n        ta.hideWhisper = function () {\r\n            whisperDiv.innerHTML = '';\r\n            this.whisperDiv.setAttribute('style', 'display: none;');\r\n            this.whisperDiv.isShown = false;\r\n        }\r\n\r\n        ta.insertCurrentSelectedWhisper = function (onChange: (text: string, cursorIndex: number) => void) {\r\n            const currWhisper: string | undefined = this.whisperDiv.getSelectedWhisper();\r\n            if (currWhisper !== undefined) {\r\n                const i: number = getStartOfWordBeforeIndex(this.value, this.selectionEnd);\r\n                const beforeAdd: string = this.value.slice(0, i);\r\n                const afterAdd: string = this.value.slice(this.selectionEnd);\r\n                const newCursorPos: number = i + currWhisper.length;\r\n                onChange(beforeAdd + currWhisper + afterAdd, newCursorPos);\r\n                this.setSelectionRange(newCursorPos, newCursorPos);\r\n                this.hideWhisper();\r\n            }\r\n        }\r\n\r\n        // TEXTAREA ERROR RANGE HIGHLIGHTS\r\n        ta.errorDivs = [];\r\n\r\n        ta.moveErrors = function () {\r\n            this.errorDivs.forEach(highlight => {\r\n                // computes position of the highlight relative to the text\r\n                const yPos: number = (highlight.startLine + 1) * lineHeight + 1 - this.scrollTop;\r\n                // shows the div at computed position if the line is visible\r\n                if (1 < yPos && yPos < this.clientHeight) {\r\n                    let width: number = highlight.rangeLength * fontWidth;\r\n                    let xPos: number = highlight.startColumn * fontWidth + 7 - this.scrollLeft;\r\n                    // if the whole highlight is out of the width, does not display it\r\n                    if (xPos > this.clientWidth || xPos + width < 3) {\r\n                        highlight.setAttribute('style', `display: none;`);\r\n                    }\r\n                    else {\r\n                        // updates position of highlights starting before first visible column\r\n                        if (xPos < 3) {\r\n                            width += xPos - 3;\r\n                            xPos = 3;\r\n                        }\r\n                        // updates width of highlights ending after last visible column\r\n                        if (xPos + width > this.clientWidth) {\r\n                            width = this.clientWidth - xPos;\r\n                        }\r\n                        // updates the position of message span when the highlight is on the right side of the screen\r\n                        if (this.getBoundingClientRect().x + xPos >= window.innerWidth / 2) {\r\n                            highlight.messageSpan.setAttribute('style', `right: 50%; left: unset;`);\r\n                        }\r\n                        highlight.setAttribute('style', `display: block; top: ${yPos}px; left: ${xPos}px; width: ${width}px`);\r\n                    }\r\n                }\r\n                // hides the div if the line is not visible\r\n                else {\r\n                    highlight.setAttribute('style', `display: none;`);\r\n                }\r\n            });\r\n        }\r\n\r\n        ta.updateErrors = function (ranges: {start: number, end: number, msg: string}[]) {\r\n            // removes old highlight divs\r\n            this.errorDivs.forEach(highlight => {\r\n                highlight.remove();\r\n            });\r\n            this.errorDivs = [];\r\n\r\n            // appends the highlight div as textarea child and adds it to highlights array\r\n            const pushHighlight = (highlight: ErrorDiv) => {\r\n                // @ts-ignore - adds it to the parent element\r\n                this.parentElement.appendChild(highlight);\r\n                this.errorDivs.push(highlight);\r\n            }\r\n\r\n            ranges.forEach(range => {\r\n                // finds highlight start and end lines and columns\r\n                const start = getPositionLineAndColumn(this.value, range.start);\r\n                const end = getPositionLineAndColumn(this.value, range.end);\r\n                // error on one line only\r\n                if (start.line === end.line) {\r\n                    pushHighlight(createHighlightDiv(start.line, start.column, end.column - start.column,\r\n                        range.msg, this));\r\n                }\r\n                // error on multiple lines\r\n                else {\r\n                    // pushes first line part - from error start to line end\r\n                    pushHighlight(createHighlightDiv(start.line, start.column,\r\n                        getLineLength(this.value, start.line) - start.column, range.msg, this));\r\n                    // pushes middle lines\r\n                    for (let line = start.line + 1; line < end.line; ++line) {\r\n                        pushHighlight(createHighlightDiv(line, 0, getLineLength(this.value, line),\r\n                            range.msg, this));\r\n                    }\r\n                    // pushes last line part - from line start to error end\r\n                    pushHighlight(createHighlightDiv(end.line, 0, end.column, range.msg, this));\r\n                }\r\n            });\r\n\r\n            // moves highlight to current positions\r\n            this.moveErrors();\r\n        }\r\n\r\n        // handles whisper div position when scrolling on page\r\n        window.addEventListener('scroll', () => ta.moveWhisper());\r\n        window.addEventListener('resize', () => {\r\n            ta.moveWhisper();\r\n            ta.moveErrors();\r\n        });\r\n        ta.onscroll     = () => {\r\n            ta.paintLineNumbers(this.props.darkTheme);\r\n            ta.moveWhisper();\r\n            ta.moveErrors();\r\n        };\r\n        ta.addEventListener(\"focusout\", () => ta.hideWhisper());\r\n        ta.onmousedown  = () => {\r\n            ta.mouseIsDown = true;\r\n            ta.hideWhisper();\r\n        }\r\n        ta.onmouseup    = () => {\r\n            ta.mouseIsDown = false;\r\n            ta.paintLineNumbers(this.props.darkTheme);\r\n        };\r\n        ta.onmousemove  = () => {\r\n            if (ta.mouseIsDown) ta.paintLineNumbers(this.props.darkTheme);\r\n        };\r\n        ta.oninput      = (ev) => {\r\n            // @ts-ignore\r\n            this.props.onChange(ev.target.value, ev.target.selectionStart);\r\n        }\r\n        // prevents default behavior of special keys input when whisperDiv is shown, passes key event to the parent\r\n        ta.onkeydown    = (ev) => {\r\n            // if the ctrl key is pressed, hides whisperDiv and keeps default behaviour\r\n            if (ta.whisperDiv.isShown && ev.ctrlKey) {\r\n                ta.hideWhisper();\r\n            }\r\n            // if the ctrl key is not pressed, changes whisper and key default behaviour\r\n            else if (ta.whisperDiv.isShown) {\r\n                if (ev.key === \"ArrowDown\") {\r\n                    ta.whisperDiv.changeSelected(1);\r\n                    ev.preventDefault();\r\n                }\r\n                if (ev.key === \"ArrowUp\") {\r\n                    ta.whisperDiv.changeSelected(-1);\r\n                    ev.preventDefault();\r\n                }\r\n                if (ev.key === \"PageDown\") {\r\n                    // moves selected whisper to bottom\r\n                    ta.whisperDiv.setSelected(-1);\r\n                    ev.preventDefault();\r\n                }\r\n\r\n                if (ev.key === \"PageUp\") {\r\n                    // moves selected whisper to top\r\n                    ta.whisperDiv.setSelected(0);\r\n                    ev.preventDefault();\r\n                }\r\n                if (ev.key === \"End\" || ev.key === \"Home\") {\r\n                    ta.hideWhisper();\r\n                    // keeps default behaviour\r\n                }\r\n                if (ev.key === \"Escape\" || ev.key === \"Esc\") {\r\n                    ta.hideWhisper();\r\n                    ev.preventDefault();\r\n                }\r\n                if (ev.key === \"Enter\" || ev.key === \"Tab\") {\r\n                    ta.insertCurrentSelectedWhisper(this.props.onChange);\r\n                    ev.preventDefault();\r\n                }\r\n                if (ev.key === \"ArrowLeft\") {\r\n                    const cursor = (ta.selectionStart === 0) ? 0 : (ta.selectionStart - 1);\r\n                    // forces update to recompute whispers if needed\r\n                    this.props.onChange(ta.value, cursor);\r\n                    // keeps default behaviour\r\n                }\r\n                if (ev.key === \"ArrowRight\") {\r\n                    const cursor = (ta.selectionStart === ta.value.length) ? ta.selectionStart : ta.selectionStart + 1;\r\n                    // forces update to recompute whispers if needed\r\n                    this.props.onChange(ta.value, cursor);\r\n                    // keeps default behaviour\r\n                }\r\n            }\r\n        }\r\n\r\n        // make sure numbers are painted\r\n        ta.paintLineNumbers(this.props.darkTheme);\r\n        // shows highlights\r\n        ta.updateErrors(this.props.errors);\r\n        this.textarea = ta;\r\n    }\r\n\r\n    /**\r\n     * Updates text content and component style.\r\n     */\r\n    componentDidUpdate(prevProps: Readonly<XTextAreaProps>) {\r\n        this.textarea.value = this.props.text;\r\n        if (prevProps.darkTheme !== this.props.darkTheme) {\r\n            this.updateStyle();\r\n        }\r\n        // whispers\r\n        if (this.props.whispers !== prevProps.whispers) {\r\n            this.textarea.showWhisper(this.props.whispers);\r\n        }\r\n        // highlights error\r\n        if (this.props.errors !== undefined) {\r\n            this.textarea.updateErrors(this.props.errors);\r\n        }\r\n        // first undefined highlight removes 'x-textarea-err' from textarea.className to show selection with blue color\r\n        else if (this.props.errors !== prevProps.errors) {\r\n            this.textarea.classList.remove('x-textarea-err');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates style of the XTextArea elements to fit current darkTheme settings.\r\n     */\r\n    private updateStyle(): void {\r\n        // @ts-ignore\r\n        this.reactDiv.current.classList.toggle('x-textarea-div-dark', this.props.darkTheme);\r\n        // @ts-ignore\r\n        this.reactDiv.current.classList.toggle('x-textarea-div-light', !this.props.darkTheme);\r\n        this.textarea.classList.toggle('x-textarea-dark', this.props.darkTheme);\r\n        this.textarea.classList.toggle('cursor-container-dark', this.props.darkTheme);\r\n        this.textarea.classList.toggle('x-textarea-light', !this.props.darkTheme);\r\n        this.textarea.classList.toggle('cursor-container-light', !this.props.darkTheme);\r\n        this.textarea.paintLineNumbers(this.props.darkTheme);\r\n        this.textarea.canvasLines.classList.toggle('canvas-dark', this.props.darkTheme);\r\n        this.textarea.canvasLines.classList.toggle('canvas-light', !this.props.darkTheme);\r\n        this.textarea.whisperDiv.classList.toggle('whisper-div-dark', this.props.darkTheme);\r\n        this.textarea.whisperDiv.classList.toggle('whisper-div-light', !this.props.darkTheme);\r\n        // @ts-ignore\r\n        document.getElementById(this.props.id + '-td1').classList.toggle('x-textarea-table-td1-dark', this.props.darkTheme);\r\n        // @ts-ignore\r\n        document.getElementById(this.props.id + '-td1').classList.toggle('x-textarea-table-td1-light', !this.props.darkTheme);\r\n    }\r\n\r\n    /**\r\n     * Renders only an empty div. Other maintaining is not provided by React.\r\n     */\r\n    public render() {\r\n        return (\r\n            <div\r\n                ref={this.reactDiv}\r\n                id={this.props.id}\r\n                className=\"x-textarea-div\"\r\n            />\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Computes line and column number for given position in text.\r\n */\r\nfunction getPositionLineAndColumn(text: string, position: number): {line: number, column: number} {\r\n    const textBeforeCursor: string = text.slice(0, position);\r\n    const line: number = (textBeforeCursor.match(/\\n/g) || []).length;\r\n    const lastNewLine: number = textBeforeCursor.lastIndexOf('\\n');\r\n    const column: number = textBeforeCursor.length - lastNewLine - 1;\r\n    return {line, column};\r\n}\r\n\r\n/**\r\n *\r\n */\r\nfunction getLineLength(text: string, line: number): number {\r\n    let newLinesFound = 0;\r\n    let lineStart = 0;  // index of line-th newline\r\n    let lineEnd = 0;    // index of (line+1)-th newline\r\n    for (let i = 0; i < text.length; ++i) {\r\n        if (text.charAt(i) === '\\n') {\r\n            ++newLinesFound;\r\n            if (newLinesFound === line) {\r\n                lineStart = i;\r\n            }\r\n            else if (newLinesFound === line + 1) {\r\n                lineEnd = i;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (lineEnd === 0) {\r\n        lineEnd = text.length; // handles case of last line in text\r\n    }\r\n    return lineEnd - lineStart;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nfunction createHighlightDiv(startLine: number, startColumn: number, rangeLength: number, msg: string,\r\n                            textarea: ExtendedHTMLTextArea): ErrorDiv {\r\n    // @ts-ignore\r\n    const highlight: ErrorDiv = document.createElement('div');\r\n    highlight.classList.add(\"x-textarea-highlight\");\r\n    highlight.startLine = startLine;\r\n    highlight.startColumn = startColumn;\r\n    highlight.rangeLength = rangeLength;\r\n    // dispatches click event to not block textarea underneath highlights\r\n    highlight.onclick = (ev: MouseEvent) => {\r\n        const newEvent: MouseEvent = new MouseEvent(ev.type, {...ev});\r\n        textarea.dispatchEvent(newEvent);\r\n        ev.stopPropagation();\r\n    }\r\n    const span: HTMLSpanElement = document.createElement('span');\r\n    span.classList.add(\"highlight-tooltip\");\r\n    span.innerText = msg;\r\n    highlight.messageSpan = span;\r\n    highlight.appendChild(span);\r\n    return highlight;\r\n}","/**\r\n * Modulo operation with positive result for negative numbers (as % in JavaScript can give negative results).\r\n *\r\n * @param n base number\r\n * @param m dividing number\r\n */\r\nexport function mod(n: number, m: number) {\r\n    return ((n % m) + m) % m;\r\n}","import Row from \"./row\";\r\nimport {SupportedColumnType} from \"./columnType\";\r\nimport { isEqual } from \"lodash\";\r\n\r\n/**\r\n * Relation from relational algebra. It contains relational schema (set of columns' names and types)\r\n * and relation's relation (set of rows).\r\n */\r\nexport default class Relation {\r\n\r\n    public readonly name: string;\r\n    private columns = new Map<string, SupportedColumnType>();\r\n    private columnNames: string[] = []; // array to have an ordered printing of columns\r\n    private rows: Row[] = [];\r\n    private finishedSchema = false;\r\n\r\n    /**\r\n     * Creates an empty relation of the given name.\r\n     *\r\n     * @param name name of the relation\r\n     */\r\n    constructor(name: string) {\r\n        this.name = name;\r\n    }\r\n\r\n    /**\r\n     * Returns name of the relation.\r\n     */\r\n    public getName(): string {\r\n        return this.name;\r\n    }\r\n\r\n    /**\r\n     * @return true if the relational schema is finished (no more columns can be added)\r\n     */\r\n    public hasFinishedSchema(): boolean {\r\n        return this.finishedSchema;\r\n    }\r\n\r\n    /**\r\n     * Sets the relational schema finished (no more columns can be added).\r\n     */\r\n    public finishSchema(): void {\r\n        this.finishedSchema = true;\r\n    }\r\n\r\n    /**\r\n     * Adds a column to a relational schema if the relational schema is not finished yet.\r\n     *\r\n     * @param name name of the column\r\n     * @param type type of the column\r\n     * @return true if the column was added (relation did not contain a column with the same name before)\r\n     */\r\n    public addColumn(name: string, type: SupportedColumnType): boolean {\r\n        if (!this.hasColumn(name) && !this.hasFinishedSchema()) {\r\n            this.columns.set(name, type);\r\n            this.columnNames.push(name);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks whether the relation has a column with the same name\r\n     * (NOTE: type of the column does not matter).\r\n     *\r\n     * @param name Column name to be checked\r\n     * @return true if the relation has a column with the same name\r\n     */\r\n    public hasColumn(name: string): boolean {\r\n        return this.columnNames.some(cn => cn === name);\r\n    }\r\n\r\n    /**\r\n     * @return map (name -> value) of columns' values in a relation.\r\n     */\r\n    public getColumns(): Map<string, SupportedColumnType> {\r\n        return this.columns;\r\n    }\r\n\r\n    /**\r\n     * @param f function to be applied for each column in the relation\r\n     */\r\n    public forEachColumn(f: (type: SupportedColumnType, name: string) => void): void {\r\n        return this.columns.forEach(f);\r\n    }\r\n\r\n    /**\r\n     * @return array of column names in a relation.\r\n     */\r\n    public getColumnNames(): string[] {\r\n        return this.columnNames;\r\n    }\r\n\r\n    /**\r\n     * @return Number of columns in a relation.\r\n     */\r\n    public getColumnsCount(): number {\r\n        return this.columnNames.length;\r\n    }\r\n\r\n    /**\r\n     * Adds a row to a relation. The row must have the same column set as the relation. If the row was added,\r\n     * sets the row finished and returns true. Also the relational schema of this relation\r\n     * is set finished (no more columns can be added). If the row was not added, returns false.\r\n     * NOTE: Rows in a relation cannot be duplicit, adding a duplicit row returns true, but only one is kept.\r\n     *\r\n     * @param row row to be added\r\n     * @return true if the row was added, false otherwise\r\n     */\r\n    public addRow(row: Row): boolean {\r\n        if (isEqual(row.getTypes(), this.columns)) {\r\n            this.finishSchema();\r\n            row.finish();\r\n            if (!this.rows.some(r => r.equals(row))) {\r\n                this.rows.push(row);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @return array of rows in a relation.\r\n     */\r\n    public getRows(): Row[] {\r\n        return this.rows;\r\n    }\r\n\r\n    /**\r\n     * @return Number of rows in a relation.\r\n     */\r\n    public getRowsCount(): number {\r\n        return this.rows.length;\r\n    }\r\n\r\n    /**\r\n     * Returns a relational schema in a format: RelationName(ColumnOneName: ColumnOneType, ...) - both column names\r\n     * and column types are used.\r\n     *\r\n     * @return relational schema as a string\r\n     */\r\n    public getSchemaString(): string {\r\n        return this.name + \"(\" + [...this.columns].map(s => s[0] + \": \" + s[1]).join(\", \") + \")\";\r\n    }\r\n\r\n    /**\r\n     * Returns a relational schema in a format: RelationName(ColumnOneName, ...) - only column names are used.\r\n     *\r\n     * @return relational schema as a string\r\n     */\r\n    public getNamesSchemaString(): string {\r\n        return this.name + \"(\" + this.columnNames.join(\", \") + \")\";\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of the relation content (column names, column types and rows).\r\n     *\r\n     * @return string representation of the relation\r\n     */\r\n    public contentString(): string {\r\n        const names = this.columnNames.join(', ') + '\\n';\r\n        const types = this.columnNames.map((name) => this.columns.get(name)).join(', ') + '\\n';\r\n        const rows = [...this.rows].map(row => row.getOrderedValues(this.columnNames).join(', ')).join('\\n');\r\n        return names + types + rows;\r\n    }\r\n\r\n    /**\r\n     * Custom equals function for testing purposes.\r\n     *\r\n     * @param other\r\n     */\r\n    public equals(other: any): boolean {\r\n        if (other instanceof Relation) {\r\n            return this.name === other.name &&\r\n                isEqual(this.columns, other.columns) &&\r\n                isEqual(new Set(this.rows), new Set(other.rows));\r\n        }\r\n        return false;\r\n    }\r\n}","import {IndexedString} from \"./indexedString\";\r\nimport Parser from \"./parser\";\r\nimport {insertRangeIfUndefined} from \"../error/errorWithTextRange\";\r\n\r\n/**\r\n * IndexedParser providing general parsing helper functions for IndexedString. It wraps Parser methods for IndexedStrings.\r\n */\r\nexport default class ParserIndexed {\r\n\r\n    /**\r\n     * @param str Checked indexed string\r\n     * @return true if the string contains letters only and has length at least 1\r\n     */\r\n    public static isWord(str: IndexedString): boolean {\r\n        return Parser.isWord(str.toString());\r\n    }\r\n\r\n    /**\r\n     * @param str Checked string\r\n     * @return true if the string contains letters, numbers and underscores only, has length at least 1 and starts with\r\n     * a letter or an underscore\r\n     */\r\n    public static isName(str: IndexedString): boolean {\r\n        return Parser.isName(str.toString());\r\n    }\r\n\r\n    /**\r\n     * @param str Checked string\r\n     * @return true if the string contains whitespaces only\r\n     */\r\n    public static isWhitespacesOnly(str: IndexedString): boolean {\r\n        return Parser.isWhitespacesOnly(str.toString());\r\n    }\r\n\r\n    /**\r\n     * @param c Checked character\r\n     * @return true if the given string has length one and the character is a letter\r\n     */\r\n    public static isLetter(c: IndexedString): boolean {\r\n        return Parser.isLetter(c.toString());\r\n    }\r\n\r\n    /**\r\n     * @param c Checked character\r\n     * @return true if the given string has length one and the character is a letter, a number or an underscore\r\n     */\r\n    public static isNameChar(c: IndexedString): boolean {\r\n        return Parser.isNameChar(c.toString());\r\n    }\r\n\r\n    /**\r\n     * @param c Checked character\r\n     * @return true if the given string has length one and the character is a digit\r\n     */\r\n    public static isDigit(c: IndexedString): boolean {\r\n        return Parser.isDigit(c.toString());\r\n    }\r\n\r\n    /**\r\n     * @param str Checked string\r\n     * @return true if the string represents a decimal number\r\n     */\r\n    public static isNumber(str: IndexedString): boolean {\r\n        return Parser.isNumber(str.toString());\r\n    }\r\n\r\n    /**\r\n     * Splits given indexed string to a starting sequence of letters and its rest and returns these parts in a pair.\r\n     * NOTE: if the string does not start with a letter, as a word is returned an empty string.\r\n     *\r\n     * @param str indexed string to be split\r\n     * @return split indexed string in a pair { word, rest }\r\n     */\r\n    public static nextWord(str: IndexedString): { first: IndexedString, second: IndexedString } {\r\n        const strParts: { first: string, second: string } = Parser.nextWord(str.toString());\r\n        return { first: str.slice(0, strParts.first.length), second: str.slice(strParts.first.length)};\r\n    }\r\n\r\n    /**\r\n     * Splits given indexed string to a starting sequence of letters, numbers and underscores, which starts with a letter or\r\n     * an underscore and its rest and returns these parts in a pair.\r\n     * NOTE: if the string does not start with a letter, or an underscore, as a name is returned an empty string.\r\n     *\r\n     * @param str string to be split\r\n     * @return split indexed string in a pair { name, rest }\r\n     */\r\n    public static nextName(str: IndexedString): { first: IndexedString, second: IndexedString } {\r\n        const strParts: { first: string, second: string } = Parser.nextName(str.toString());\r\n        return { first: str.slice(0, strParts.first.length), second: str.slice(strParts.first.length)};\r\n    }\r\n\r\n    /**\r\n     * Splits given indexed string to a starting sequence of non-whitespace characters and its rest and returns these\r\n     * parts in a pair.\r\n     *\r\n     * @param str string to be split\r\n     * @return split indexed string in a pair { name, rest }\r\n     */\r\n    public static nextNonWhitespacePart(str: IndexedString): { first: IndexedString, second: IndexedString } {\r\n        const strParts: { first: string, second: string } = Parser.nextNonWhitespacePart(str.toString());\r\n        return { first: str.slice(0, strParts.first.length), second: str.slice(strParts.first.length)};\r\n    }\r\n\r\n    /**\r\n     * Splits given indexed string to a starting number and its rest and returns these parts in a pair.\r\n     * NOTE: if the string does not start with a digit, as a number is returned an empty string.\r\n     *\r\n     * @param str indexed string to be split\r\n     * @return split indexed string in a pair (word, rest)\r\n     */\r\n    static nextNumber(str: IndexedString): { first: IndexedString, second: IndexedString } {\r\n        const strParts: { first: string, second: string } = Parser.nextNumber(str.toString());\r\n        return { first: str.slice(0, strParts.first.length), second: str.slice(strParts.first.length)};\r\n    }\r\n\r\n    /**\r\n     * Splits the indexed string to the starting bordered part and the rest and returns these parts in a pair.\r\n     * If there is only one ending character and it differs from the starting one, nested bordering is supported.\r\n     * Characters after escape character are ignored and cannot start or end a bordered part.\r\n     * Starting and ending characters in quoted part are ignored.\r\n     * NOTE: First character of the string is expected to be 'start'.\r\n     *\r\n     * @param str indexed string to be split\r\n     * @param start starting character of the string and also starting character of the bordered part (one character)\r\n     * @param end ending characters of the bordered part (one or more characters)\r\n     * @param escape character which makes next character being ignored (default '\\0')\r\n     * @return pair of the starting bordered part and the rest as indexed strings\r\n     */\r\n    static nextBorderedPart(str: IndexedString, start: string, end: string, escape: string = '\\0'):\r\n        { first: IndexedString, second: IndexedString } {\r\n        try {\r\n            const strParts: { first: string, second: string } = Parser.nextBorderedPart(str.toString(), start, end, escape);\r\n            return { first: str.slice(0, strParts.first.length), second: str.slice(strParts.first.length)};\r\n        }\r\n        catch (err) {\r\n            const startIndex = str.getFirstNonNaNIndex();\r\n            if (startIndex !== undefined) {\r\n                throw insertRangeIfUndefined(err, {start: startIndex, end: startIndex});\r\n            }\r\n            throw err;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Skips all whitespaces and exactly one given character and returns rest of the string.\r\n     * If the string does not match this pattern, throws error.\r\n     *\r\n     * @param str string to be skipped in\r\n     * @param char char to be skipped exactly one time (expected to be string of length 1)\r\n     * @return given string without starting sequence of whitespaces and exactly one char\r\n     */\r\n    public static skipWhitespacesAndChar(str: IndexedString, char: string): IndexedString {\r\n        try {\r\n            const skippedStr: string = Parser.skipWhitespacesAndChar(str.toString(), char);\r\n            return str.slice(str.length() - skippedStr.length);\r\n        }\r\n        catch (err) {\r\n            throw insertRangeIfUndefined(err, str.getNonNaNRange());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes all lines, where two first non-whitespace characters are '//'.\r\n     *\r\n     * @param str indexed string to be deleted comments in\r\n     */\r\n    public static deleteCommentLines(str: IndexedString) {\r\n        const toJoin: IndexedString[] = str.split('\\n').map(line => {\r\n            let insideQuotes: boolean = false;\r\n            for (let i = 0; i < line.length(); ++i) {\r\n                // quotes found\r\n                if (line.charAt(i) === '\"') {\r\n                    if (insideQuotes && line.charAt(i - 1) !== '\\\\') {\r\n                        insideQuotes = false;\r\n                    }\r\n                    else if (!insideQuotes) {\r\n                        insideQuotes = true;\r\n                    }\r\n                }\r\n                // double-backslash found outside quotes\r\n                if (!insideQuotes && line.charAt(i) === '/' && i > 0 && line.charAt(i - 1) === '/') {\r\n                    return line.slice(0, i - 1);\r\n                }\r\n            }\r\n            return line;\r\n        });\r\n        return IndexedString.join(toJoin, '\\n');\r\n    }\r\n}","import ParserIndexed from \"./parserIndexed\";\r\nimport Parser from \"./parser\";\r\n\r\n/**\r\n * Immutable string representation with index of each character. Provides some usual string functions.\r\n */\r\nexport class IndexedString {\r\n\r\n    /**\r\n     * Creates a new IndexedString instance representing the given string. StartIndex is used as the offset for indexes.\r\n     * When the startIndex is omitted, 0 is used. When NaN is given, all indexes are NaN.\r\n     * Indexes of the characters are (0 + startIndex, ..., str.length - 1 + startIndex).\r\n     * NOTE: Each character has its own index. That means '\\r\\n' line separator has two indexes. For expected behavior, use\r\n     * '\\n' separator instead.\r\n     *\r\n     * @param str string\r\n     * @param startIndex\r\n     */\r\n    public static new(str: string, startIndex: number = 0): IndexedString {\r\n        return new IndexedString(str, str.split('').map((char, index) => {return {char: char, index: index + startIndex}}));\r\n    }\r\n\r\n    /**\r\n     * Creates a new IndexedString instance representing an empty string \"\".\r\n     */\r\n    public static empty(): IndexedString {\r\n        return new IndexedString('', []);\r\n    }\r\n\r\n    /**\r\n     * Creates a new IndexedString instance representing the given array of IndexedChars.\r\n     * The array is deep copied for immutability.\r\n     *\r\n     * @param arr IndexedChar array\r\n     */\r\n    public static newFromArray(arr: IndexedChar[]): IndexedString {\r\n        return new IndexedString(arr.map(ic => ic.char).join(''), arr.map(ic => {return {char: ic.char, index: ic.index}}));\r\n    }\r\n\r\n    /**\r\n     * Joins given array of IndexedStrings with given separator. When the separator is omitted, empty string \"\" is used.\r\n     * All characters of all inserted separators will have NaN indexes.\r\n     *\r\n     * @param arr array to join\r\n     * @param separator separator string\r\n     */\r\n    public static join(arr: IndexedString[], separator?: string): IndexedString {\r\n        if (arr.length === 0) {\r\n            return IndexedString.empty();\r\n        }\r\n        if (arr.length === 1) {\r\n            return arr[0];\r\n        }\r\n        if (separator === undefined) {\r\n            separator = '';\r\n        }\r\n        const isSep: IndexedString = IndexedString.new(separator, NaN);\r\n        const toConcat: IndexedString[] = Array<IndexedString>(2 * arr.length - 2);\r\n        for (let i = 1; i < arr.length; i++) {\r\n            toConcat[2 * i - 2] = isSep;\r\n            toConcat[2 * i - 1] = arr[i];\r\n        }\r\n        return arr[0].concat(...toConcat);\r\n    }\r\n\r\n    /**\r\n     * Private constructor to ensure compatible string and IndexCharArray.\r\n     *\r\n     * @param str string representation\r\n     * @param chars IndexedChar representation\r\n     */\r\n    private constructor(private readonly str: string, private readonly chars: IndexedChar[]) { }\r\n\r\n    /**\r\n     * Returns string representation of the IndexedString.\r\n     */\r\n    public toString(): string {\r\n        return this.str;\r\n    }\r\n\r\n    /**\r\n     * Returns length of the string.\r\n     */\r\n    public length(): number {\r\n        return this.str.length;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the IndexedString represents an empty string \"\".\r\n     */\r\n    public isEmpty(): boolean {\r\n        return this.length() === 0;\r\n    }\r\n\r\n    /**\r\n     * Returns IndexedChar array representing the IndexedString.\r\n     * The array is deep copied.\r\n     */\r\n    public getChars(): IndexedChar[] {\r\n        const ret: IndexedChar[] = Array<IndexedChar>(this.length());\r\n        this.chars.forEach((char, i) => {ret[i] = {char: char.char, index: char.index}})\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the first character of the IndexedString. Returns undefined if empty.\r\n     */\r\n    public getFirstIndex(): number | undefined {\r\n        if (this.isEmpty()) {\r\n            return undefined;\r\n        }\r\n        return this.chars[0].index;\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the last character of the IndexedString. Returns undefined if empty.\r\n     */\r\n    public getLastIndex(): number | undefined {\r\n        if (this.isEmpty()) {\r\n            return undefined;\r\n        }\r\n        return this.chars[this.length() - 1].index;\r\n    }\r\n\r\n    /**\r\n     * Returns the first non-NaN index of a character of the IndexedString. Returns undefined if empty.\r\n     * If all indexes are NaN, NaN is returned.\r\n     */\r\n    public getFirstNonNaNIndex(): number | undefined {\r\n        if (this.isEmpty()) {\r\n            return undefined;\r\n        }\r\n        for (let i = 0; i < this.length(); i++) {\r\n            if (!isNaN(this.chars[i].index)) {\r\n                return this.chars[i].index;\r\n            }\r\n        }\r\n        return NaN;\r\n    }\r\n\r\n    /**\r\n     * Returns the last non-NaN index of a character of the IndexedString. Returns undefined if empty.\r\n     * If all indexes are NaN, NaN is returned.\r\n     */\r\n    public getLastNonNaNIndex(): number | undefined {\r\n        if (this.isEmpty()) {\r\n            return undefined;\r\n        }\r\n        for (let i = this.length() - 1; i >= 0; i--) {\r\n            if (!isNaN(this.chars[i].index)) {\r\n                return this.chars[i].index;\r\n            }\r\n        }\r\n        return NaN;\r\n    }\r\n\r\n    /**\r\n     * Returns indexes of the first and the last character of the IndexedString. Returns undefined if empty.\r\n     */\r\n    public getRange(): {start: number, end: number} | undefined {\r\n        if (this.isEmpty()) {\r\n            return undefined;\r\n        }\r\n        return { start: this.chars[0].index, end: this.chars[this.length() - 1].index };\r\n    }\r\n\r\n    /**\r\n     * Returns the first and the last non-NaN indexes of characters of the IndexedString. Returns undefined if empty or\r\n     * if all indexes are NaN.\r\n     */\r\n    public getNonNaNRange(): {start: number, end: number} | undefined {\r\n        if (this.isEmpty()) {\r\n            return undefined;\r\n        }\r\n        // @ts-ignore\r\n        const start: number = this.getFirstNonNaNIndex();\r\n        // returns undefined when all indexes are NaN\r\n        if (isNaN(start)) {\r\n            return undefined;\r\n        }\r\n        // @ts-ignore\r\n        const end: number = this.getLastNonNaNIndex();\r\n        return { start: start, end: end };\r\n    }\r\n\r\n    /**\r\n     * Returns an IndexedString representation of the character at the given index. Throws RangeError if the index is\r\n     * out of string bounds.\r\n     *\r\n     * @param index number\r\n     */\r\n    public indexedCharAt(index: number): IndexedString {\r\n        if (index < 0 || index >= this.length()) {\r\n            throw new RangeError();\r\n        }\r\n        return IndexedString.newFromArray([this.chars[index]]);\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of the character at the given index. Throws RangeError if the index is\r\n     * out of IndexedString bounds.\r\n     *\r\n     * @param index\r\n     */\r\n    public charAt(index: number): string {\r\n        if (index < 0 || index >= this.length()) {\r\n            throw new RangeError();\r\n        }\r\n        return this.chars[index].char;\r\n    }\r\n\r\n    /**\r\n     * Returns an original position index of the character at the given current index. Throws RangeError if the given index is\r\n     * out of IndexedString bounds.\r\n     *\r\n     * @param index\r\n     */\r\n    public indexAt(index: number): number {\r\n        if (index < 0 || index >= this.length()) {\r\n            throw new RangeError();\r\n        }\r\n        return this.chars[index].index;\r\n    }\r\n\r\n    /**\r\n     * Split a string into substrings using the specified separator and return them as an array.\r\n     * It does not accept RegEx separators and array limit as built-in string.\r\n     *\r\n     * @param separator string separator\r\n     */\r\n    public split(separator: string): IndexedString[] {\r\n        if (this.isEmpty()) {\r\n            if (separator === '') {\r\n                return [];\r\n            }\r\n            return [IndexedString.empty()];\r\n        }\r\n        const sepLen: number = separator.length;\r\n        const strSplit: string[] = this.str.split(separator);\r\n        const prefixSum: number[] = Array<number>(strSplit.length);\r\n        prefixSum[0] = 0;\r\n        for (let i = 1; i < strSplit.length; i++) {\r\n            prefixSum[i] = prefixSum[i - 1] + strSplit[i - 1].length + sepLen;\r\n        }\r\n\r\n        return strSplit.map((strSplit, index) => {\r\n            return new IndexedString(strSplit, this.chars.slice(prefixSum[index], prefixSum[index] + strSplit.length));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns a section of a IndexedString.\r\n     *\r\n     * @param start The index of the beginning of the specified portion of stringObj.\r\n     * @param end The index of the end of the specified portion of IndexedString. The substring includes the characters\r\n     * up to, but not including, the character indicated by end. If this value is not specified, the substring\r\n     * continues to the end of IndexedString.\r\n     */\r\n    public slice(start: number, end?: number): IndexedString {\r\n        const _start = start < 0 ? this.length() + start : start;\r\n        const _end = end !== undefined ? (end < 0 ? this.length() + end : end) : this.length();\r\n        if (_start > _end || _start < 0 || _end > this.length()) {\r\n            throw new RangeError();\r\n        }\r\n        return IndexedString.newFromArray(this.chars.slice(_start, _end));\r\n    }\r\n\r\n    /**\r\n     * Removes the leading and trailing white space and line terminator characters from a string.\r\n     */\r\n    public trim(): IndexedString {\r\n        const trimStr: string = this.str.trim();\r\n        if (trimStr === '') {\r\n            return new IndexedString('', []);\r\n        }\r\n        const start: number = this.str.indexOf(trimStr.charAt(0));\r\n        return IndexedString.newFromArray(this.chars.slice(start, start + trimStr.length));\r\n    }\r\n\r\n    /**\r\n     * Returns a string that contains the concatenation of this IndexedString with multiple other.\r\n     *\r\n     * @param strings The IndexedStrings to append to the end of the string.\r\n     */\r\n    public concat(...strings: IndexedString[]) {\r\n        return IndexedString.newFromArray(this.chars.concat(...strings.map(is => is.chars)));\r\n    }\r\n\r\n    /**\r\n     * Returns true if the searchString sequence is the same as the corresponding\r\n     * elements of this object starting at position. Otherwise returns false.\r\n     *\r\n     * @param searchString\r\n     * @param position\r\n     */\r\n    public startsWith(searchString: string, position?: number | undefined): boolean {\r\n        return this.str.startsWith(searchString, position);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the searchString sequence is the same as the corresponding\r\n     * elements of this object starting at endPosition  searchString.length. Otherwise returns false.\r\n     *\r\n     * @param searchString\r\n     * @param position\r\n     */\r\n    public endsWith(searchString: string, position?: number | undefined): boolean {\r\n        return this.str.endsWith(searchString, position);\r\n    }\r\n\r\n    /**\r\n     * Replaces text in a string, using a regular expression or search string.\r\n     * NOTE: Returns built-in string.\r\n     *\r\n     * @param searchValue A string or RegEx to search for.\r\n     * @param replaceValue A string containing the text to replace for every successful match of searchValue in this string.\r\n     */\r\n    public replace(searchValue: string | RegExp, replaceValue: string): string {\r\n        return this.str.replace(searchValue, replaceValue);\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first occurrence of a substring.\r\n     *\r\n     * @param searchValue The substring to search for in the string\r\n     * @param fromIndex The index at which to begin searching the String object. If omitted, search starts at the beginning of the string.\r\n     */\r\n    public indexOf(searchValue: string, fromIndex?: number): number {\r\n        return this.str.indexOf(searchValue, fromIndex);\r\n    }\r\n\r\n    /**\r\n     * Matches a string with a regular expression, and returns an array containing the results of that search.\r\n     *\r\n     * @param regexp A variable name or string literal containing the regular expression pattern and flags.\r\n     */\r\n    public match(regexp: string | RegExp): RegExpMatchArray | null {\r\n        return this.str.match(regexp);\r\n    }\r\n\r\n    /**\r\n     * Creates a deep copy of the IndexedString.\r\n     */\r\n    public copy(): IndexedString {\r\n        return new IndexedString(this.str, this.chars.map(ic => {return {char: ic.char, index: ic.index}}));\r\n    }\r\n\r\n    /**\r\n     * Returns deep copy of the string with all whitespaces removed.\r\n     */\r\n    public removeWhitespaces(): IndexedString {\r\n        return new IndexedString(this.str.replace(/\\s/g, ''), this.chars\r\n            .filter(ic => {return !/\\s/.test(ic.char)})\r\n            .map(ic => {return {char: ic.char, index: ic.index}})\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns next index of the string (this.getLastIndex() + 1), if last index of the string is a number.\r\n     * Otherwise, returns NaN.\r\n     */\r\n    public getNextIndexOrNaN(): number {\r\n        const lastIndex = this.getLastIndex();\r\n        return lastIndex === undefined ? NaN : lastIndex + 1;\r\n    }\r\n}\r\n\r\n/**\r\n * Indexed representation of one character.\r\n * WARNING: It is always assumed that IndexedChar.char is a string of length 1.\r\n */\r\nexport interface IndexedChar {\r\n    char: string,\r\n    index: number\r\n}\r\n\r\n/**\r\n * Gets string range: when IndexedString given, returns str.getNonNaNRange(), when string given, returns undefined.\r\n *\r\n * @param str string to get the range of\r\n */\r\nexport function getRange(str: string | IndexedString): {start: number, end: number} | undefined {\r\n    return (str instanceof IndexedString) ? str.getNonNaNRange() : undefined;\r\n}\r\n\r\n/**\r\n * Gets strings length.\r\n *\r\n * @param str string to get the length of\r\n */\r\nexport function length(str: string | IndexedString): number {\r\n    return (str instanceof IndexedString) ? str.length() : str.length;\r\n}\r\n\r\n/**\r\n * Returns true if the given string is empty.\r\n *\r\n * @param str\r\n */\r\nexport function isEmpty(str: string | IndexedString): boolean {\r\n    if (str instanceof IndexedString) {\r\n        return str.isEmpty();\r\n    }\r\n    return str === \"\";\r\n}\r\n\r\n/**\r\n * Returns next bordered part of the given string. Returned parts are of the same type as the argument.\r\n *\r\n * @param str\r\n * @param start\r\n * @param end\r\n * @param escape\r\n */\r\nexport function nextBorderedPart(str: string | IndexedString, start: string, end: string, escape?: string):\r\n    {first: IndexedString, second: IndexedString} | {first: string, second: string} {\r\n    if (str instanceof IndexedString) {\r\n        return ParserIndexed.nextBorderedPart(str, start, end, escape);\r\n    }\r\n    return Parser.nextBorderedPart(str, start, end, escape);\r\n}\r\n\r\n/**\r\n * Returns true if the string str contains any of the characters from string chars. Otherwise, returns false.\r\n *\r\n * @param str\r\n * @param chars\r\n */\r\nexport function containsAny(str: string | IndexedString, chars: string): boolean {\r\n    for (let char in chars.split('')) {\r\n        if (str.indexOf(char) > -1) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}","import {BinaryNodeClass} from \"../ratree/binaryNode\";\r\nimport {getRange, IndexedString} from \"../tools/indexedString\";\r\nimport {UnaryNodeClass} from \"../ratree/unaryNode\";\r\n\r\n/**\r\n * Abstract parent class for all RATokens.\r\n */\r\nexport abstract class ExprToken {\r\n    protected constructor(public readonly str: string | IndexedString) {\r\n    }\r\n\r\n    /**\r\n     * Gets token start and end index in the text (if the token has IndexedString representation) or undefined.\r\n     */\r\n    public getRange(): {start: number, end: number} | undefined {\r\n        return getRange(this.str);\r\n    }\r\n}\r\n\r\n/**\r\n * Parentheses.\r\n */\r\nexport abstract class ParenthesisToken extends ExprToken {}\r\n\r\nexport class OpeningParentheses extends ParenthesisToken {\r\n    public constructor(str: string | IndexedString) {\r\n        super(str);\r\n    }\r\n}\r\n\r\nexport class ClosingParentheses extends ParenthesisToken {\r\n    public constructor(str: string | IndexedString) {\r\n        super(str);\r\n    }\r\n}\r\n\r\n/**\r\n * Relation reference.\r\n */\r\nexport class RelationToken extends ExprToken {\r\n    public constructor(name: string | IndexedString) {\r\n        super(name);\r\n    }\r\n}\r\n\r\n/**\r\n * Unary operators.\r\n */\r\nexport class UnaryOperatorToken extends ExprToken {\r\n\r\n    public static selection(selection: string | IndexedString) {\r\n        return new UnaryOperatorToken(selection, \"selection\");\r\n    }\r\n\r\n    public static projection(projection: string | IndexedString) {\r\n        return new UnaryOperatorToken(projection, \"projection\");\r\n    }\r\n\r\n    public static rename(rename: string | IndexedString) {\r\n        return new UnaryOperatorToken(rename, \"rename\");\r\n    }\r\n\r\n    private constructor(str: string | IndexedString, public readonly type: UnaryNodeClass) {\r\n        super(str);\r\n    }\r\n}\r\n\r\n/**\r\n * Precedence values for binary operators (highest to lowest). As there is no fixed precedence order for RA and set\r\n * operation, we chose the following.\r\n */\r\nconst precedenceLevelA: number = 10;\r\nconst cartesianPrecedence: number = precedenceLevelA;\r\nconst naturalPrecedence: number = precedenceLevelA;\r\nconst thetaPrecedence: number = precedenceLevelA;\r\n\r\nconst precedenceLevelB: number = precedenceLevelA - 1;\r\nconst semiPrecedence: number = precedenceLevelB;\r\nconst antiPrecedence: number = precedenceLevelB;\r\nconst thetaSemiPrecedence: number = precedenceLevelB;\r\n\r\nconst precedenceLevelC: number = precedenceLevelB - 1;\r\nconst outerPrecedence: number = precedenceLevelC;\r\n\r\nconst precedenceLevelD: number = precedenceLevelC - 1;\r\nconst divisionPrecedence: number = precedenceLevelD;\r\n\r\nconst precedenceLevelE: number = precedenceLevelD - 1;\r\nconst intersectionPrecedence: number = precedenceLevelE;\r\n\r\nconst precedenceLevelF: number = precedenceLevelE - 1;\r\nconst differencePrecedence: number = precedenceLevelF;\r\n\r\nconst precedenceLevelG: number = precedenceLevelF - 1;\r\nconst unionPrecedence: number = precedenceLevelG;\r\n\r\n/**\r\n * Binary operators.\r\n */\r\nexport class BinaryOperatorToken extends ExprToken {\r\n\r\n    static naturalJoin(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, naturalPrecedence, \"natural join\");\r\n    }\r\n\r\n    static cartesianProduct(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, cartesianPrecedence, \"cartesian product\");\r\n    }\r\n\r\n    static union(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, unionPrecedence, \"union\");\r\n    }\r\n\r\n    static intersection(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, intersectionPrecedence, \"intersection\");\r\n    }\r\n\r\n    static difference(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, differencePrecedence, \"difference\");\r\n    }\r\n\r\n    static leftSemijoin(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, semiPrecedence, \"left semijoin\");\r\n    }\r\n\r\n    static rightSemijoin(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, semiPrecedence, \"right semijoin\");\r\n    }\r\n\r\n    static leftAntijoin(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, antiPrecedence, \"left antijoin\");\r\n    }\r\n\r\n    static rightAntijoin(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, antiPrecedence, \"right antijoin\");\r\n    }\r\n\r\n    static thetaJoin(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, thetaPrecedence, \"theta join\");\r\n    }\r\n\r\n    static leftThetaSemijoin(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, thetaSemiPrecedence, \"left theta semijoin\");\r\n    }\r\n\r\n    static rightThetaSemijoin(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, thetaSemiPrecedence, \"right theta semijoin\");\r\n    }\r\n\r\n    static fullOuterJoin(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, outerPrecedence, \"full outer join\");\r\n    }\r\n\r\n    static leftOuterJoin(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, outerPrecedence, \"left outer join\");\r\n    }\r\n\r\n    static rightOuterJoin(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, outerPrecedence, \"right outer join\");\r\n    }\r\n\r\n    static division(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, divisionPrecedence, \"division\");\r\n    }\r\n\r\n    private constructor(str: string | IndexedString, public readonly precedence: number, public readonly type: BinaryNodeClass) {\r\n        super(str);\r\n    }\r\n}","import Relation from \"../relation/relation\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\n\r\n/**\r\n * Abstract general node of the relational algebra syntactic tree.\r\n */\r\nexport default abstract class RATreeNode {\r\n\r\n    protected resultRelation: Relation | undefined;\r\n\r\n    protected constructor() {\r\n    }\r\n\r\n    /**\r\n     * Evaluates the RA query in this node and its subtree.\r\n     * After successful call, this.resultRelation must be set to valid Relation.\r\n     */\r\n    public abstract eval(): void;\r\n\r\n    /**\r\n     * Evaluates the RA query in this node and its subtree.\r\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\r\n     * Otherwise returns the result relation schema (only column names, no rows).\r\n     * When an error occurs, it is faked to work, and adds it to the errors array.\r\n     *\r\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper\r\n     */\r\n    public abstract fakeEval(cursorIndex: number): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]};\r\n\r\n    /**\r\n     * @return true if this node and its subtree was already evaluated\r\n     */\r\n    public isEvaluated(): boolean {\r\n        return this.resultRelation !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Returns the resulting relation. The node and its subtree is evaluated if it was not evaluated before.\r\n     *\r\n     * @return resulting relation gained by evaluating this node and its subtree\r\n     */\r\n    public getResult(): Relation {\r\n        if (this.resultRelation === undefined) {\r\n            this.eval();\r\n        }\r\n        // @ts-ignore\r\n        return this.resultRelation;\r\n    }\r\n\r\n    /**\r\n     * Creates a string with a structure of the RA tree in one line.\r\n     *\r\n     * @return string with a structure of the RA tree in one line\r\n     */\r\n    public abstract printInLine(): string;\r\n\r\n    /**\r\n     * Return the word name of the RA operation of the node.\r\n     * Example: returns \"Selection\" for SelectionNode.\r\n     *\r\n     * @return name of the RA operation of the node\r\n     */\r\n    public abstract getOperationName(): string;\r\n}","import Relation from \"../relation/relation\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\n\r\n/**\r\n * Leave node of the relational algebra syntactic tree with reference to a source relation.\r\n */\r\nexport default class RelationNode extends RATreeNode {\r\n\r\n    public constructor(relation: Relation) {\r\n        super();\r\n        this.resultRelation = relation;\r\n    }\r\n\r\n    public eval(): void {\r\n        // nothing to evaluate\r\n    }\r\n\r\n    public fakeEval(cursorIndex: number): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} {\r\n        // @ts-ignore\r\n        return {result: this.resultRelation, whispers: [], errors: []};\r\n    }\r\n\r\n    public printInLine(): string {\r\n        // @ts-ignore\r\n        return this.resultRelation.getName();\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        // @ts-ignore\r\n        return this.resultRelation.getName();\r\n    }\r\n}","import RATreeNode from \"./raTreeNode\";\r\n\r\n/**\r\n * Classes extending unary node.\r\n */\r\nexport type UnaryNodeClass = \"rename\" | \"projection\" | \"selection\";\r\n\r\n/**\r\n * Abstract node of the relational algebra syntactic tree with one subtree.\r\n */\r\nexport default abstract class UnaryNode extends RATreeNode {\r\n\r\n    protected subtree: RATreeNode;\r\n\r\n    protected constructor(subtree: RATreeNode) {\r\n        super();\r\n        this.subtree = subtree;\r\n    }\r\n\r\n    public getSubtree(): RATreeNode {\r\n        return this.subtree;\r\n    }\r\n}","import {ColumnContent, SupportedColumnType} from \"./columnType\";\r\nimport {isEqual} from \"lodash\";\r\nimport {CodeErrorCodes, ErrorFactory} from \"../error/errorFactory\";\r\n\r\n/**\r\n * Row stores a set of columns' values in a relation.\r\n */\r\nexport default class Row {\r\n\r\n    private readonly types = new Map<string, SupportedColumnType>();\r\n    private values = new Map<string, ColumnContent>();\r\n    private finished: boolean;\r\n\r\n    /**\r\n     * Creates a new row with given columns. Given column set is final, no more column can be added.\r\n     * Given columns' values are set to null. They can be set to a new value by addColumn function, as long as the row\r\n     * is not set finished.\r\n     *\r\n     * @param columns set of columns in a row\r\n     */\r\n    public constructor(columns: Map<string, SupportedColumnType>) {\r\n        // adds empty columns\r\n        columns.forEach((value, name) => {\r\n            this.values.set(name, null);\r\n        });\r\n        this.types = columns;\r\n        this.finished = false;\r\n    }\r\n\r\n    /**\r\n     * Returns whether the row is finished and no more column change is possible.\r\n     *\r\n     * @return true if the row is finished\r\n     */\r\n    public isFinished(): boolean {\r\n        return this.finished;\r\n    }\r\n\r\n    /**\r\n     * Sets the row as finished, no more changes in column values are possible.\r\n     */\r\n    public finish(): void {\r\n        this.finished = true;\r\n    }\r\n\r\n    /**\r\n     * Gets name of all columns in a row.\r\n     *\r\n     * @return set of all columns' names\r\n     */\r\n    public getColumnNames(): IterableIterator<string> {\r\n        return this.types.keys();\r\n    }\r\n\r\n    /**\r\n     * Adds a value to the row. If the addition succeeded, returns true. It can fail, if the row is finished,\r\n     * if there is no column of the given name or if there is a column with the name, but different type.\r\n     *\r\n     * @param name name of the column\r\n     * @param value new value of the column\r\n     * @return true if addition succeeded\r\n     */\r\n    public addValue(name: string, value: ColumnContent): boolean {\r\n        // finished row or not present column\r\n        if (this.finished || !this.types.has(name)) {\r\n            return false;\r\n        }\r\n        let givenType = typeof value;\r\n        // null can be set to both string and number columns\r\n        if (value !== null && givenType !== this.types.get(name)) {\r\n            return false;\r\n        }\r\n        this.values.set(name, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets the value (possibly null) of the column with the given name. If there is no column with this name, undefined is returned.\r\n     *\r\n     * @param name name of the column\r\n     * @return value of the column or undefined if there is no such column\r\n     */\r\n    public getValue(name: string): ColumnContent | undefined {\r\n        return this.values.get(name);\r\n    }\r\n\r\n    /**\r\n     * Returns the type of the given column or undefined if the column is absent.\r\n     *\r\n     * @param name name of the column\r\n     * @return the type of the column\r\n     */\r\n    public getType(name: string): SupportedColumnType | undefined {\r\n        return this.types.get(name);\r\n    }\r\n\r\n    /**\r\n     * Gets types of all columns.\r\n     *\r\n     * @return map of columns (name -> type)\r\n     */\r\n    public getTypes(): Map<string, SupportedColumnType> {\r\n        return this.types;\r\n    }\r\n\r\n    /**\r\n     * Gets values of all columns.\r\n     *\r\n     * @return map of columns (name -> value)\r\n     */\r\n    public getValues(): Map<string, ColumnContent> {\r\n        return this.values;\r\n    }\r\n\r\n    /**\r\n     * Gets values of all columns ordered by given array of column names. OrderedColumns are expected to be from the\r\n     * relation that contains the row.\r\n     *\r\n     * @param orderedColumns order of columns to be returned\r\n     * @return ordered array of values\r\n     */\r\n    public getOrderedValues(orderedColumns: string[]): Array<ColumnContent> {\r\n        let ret = new Array<ColumnContent>();\r\n        orderedColumns.forEach(column => {\r\n            const value = this.values.get(column);\r\n            // should be handled before call\r\n            if (value === undefined) {\r\n                throw ErrorFactory.codeError(CodeErrorCodes.row_getOrderedValues_absentColumn, column, [...this.types.values()].join(', '));\r\n            }\r\n            ret.push(value);\r\n        });\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Custom equals function.\r\n     *\r\n     * @param other\r\n     */\r\n    public equals(other: Object): boolean {\r\n        if (other instanceof Row) {\r\n            return isEqual(this.types, other.types) && isEqual(this.values, other.values);\r\n        }\r\n        return false;\r\n    }\r\n}\r\n","import {IndexedString} from \"./indexedString\";\r\n\r\n/**\r\n * Lowercase reserved keywords which cannot be used for column names. They are:\r\n * - Null value: null\r\n * - Boolean values: true, false\r\n * - Empty string: \"\"\r\n */\r\nconst forbiddenColumnNames: string[] = [\"null\", \"true\", \"false\", \"\"];\r\n\r\n/**\r\n * Reserved keywords which cannot be used for relation names. They are:\r\n * - First characters of outer joins: F, L, R, f, l, r\r\n * - Empty string: \"\"\r\n */\r\nconst forbiddenRelationNames: string[] = [\"F\", \"L\", \"R\", \"\"];\r\n\r\n/**\r\n * Returns lowercase reserved keywords which cannot be used for column names. They are:\r\n * - Null value: null\r\n * - Boolean values: true, false\r\n * - Empty string: \"\"\r\n */\r\nexport function getForbiddenColumnNames(): string[] {\r\n    return forbiddenColumnNames;\r\n}\r\n\r\n/**\r\n * Returns reserved keywords which cannot be used for relation names. They are:\r\n * - First characters of outer joins: F, L, R, f, l, r\r\n * - Empty string: \"\"\r\n */\r\nexport function getForbiddenRelationNames(): string[] {\r\n    return forbiddenRelationNames;\r\n}\r\n\r\n/**\r\n * Returns true if the given string is forbidden as a column name.\r\n */\r\nexport function isForbiddenColumnName(str: string | IndexedString): boolean {\r\n    return forbiddenColumnNames.indexOf(str.toString().toLowerCase()) > -1;\r\n}\r\n\r\n/**\r\n * Returns true if the given string is forbidden as a relation name.\r\n */\r\nexport function isForbiddenRelationName(str: string | IndexedString): boolean {\r\n    // does not use to lower because forbidden names are upper\r\n    return forbiddenRelationNames.indexOf(str.toString()) > -1;\r\n}","import Row from \"../relation/row\";\r\nimport {VETreeNode} from \"./veTreeNode\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\nimport {ErrorFactory, SyntaxErrorCodes} from \"../error/errorFactory\";\r\nimport {getRange, IndexedString} from \"../tools/indexedString\";\r\n\r\n/**\r\n * Types of ComparingOperator class.\r\n */\r\nexport enum ComparingOperatorType {\r\n    equal,\r\n    nonEqual,\r\n    less,\r\n    more,\r\n    lessOrEqual,\r\n    moreOrEqual\r\n}\r\n\r\n/**\r\n * Comparing operator compares two values and returns boolean.\r\n */\r\nexport class ComparingOperator extends VETreeNode {\r\n\r\n    /**\r\n     * Creates new ComparingOperator instance of equality type (type = ComparingOperatorType.equal).\r\n     *\r\n     * @param operator used string representation of equality operator\r\n     * @param left left subtree producing a value\r\n     * @param right right subtree producing a value\r\n     * @return new ComparingOperator instance of equality type\r\n     */\r\n    public static equal(operator: string | IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\r\n        return new ComparingOperator(ComparingOperatorType.equal, operator, left, right);\r\n    }\r\n\r\n    /**\r\n     * Creates new ComparingOperator instance of non-equality type (type = ComparingOperatorType.nonEqual).\r\n     *\r\n     * @param operator used string representation of non-equality operator\r\n     * @param left left subtree producing a value\r\n     * @param right right subtree producing a value\r\n     * @return new ComparingOperator instance of non-equality type\r\n     */\r\n    public static nonEqual(operator: string | IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\r\n        return new ComparingOperator(ComparingOperatorType.nonEqual, operator, left, right);\r\n    }\r\n\r\n    /**\r\n     * Creates new ComparingOperator instance of less type (type = ComparingOperatorType.less).\r\n     *\r\n     * @param operator used string representation of less operator\r\n     * @param left left subtree producing a value\r\n     * @param right right subtree producing a value\r\n     * @return new ComparingOperator instance of less type\r\n     */\r\n    public static less(operator: string | IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\r\n        return new ComparingOperator(ComparingOperatorType.less, operator, left, right);\r\n    }\r\n\r\n    /**\r\n     * Creates new ComparingOperator instance of more type (type = ComparingOperatorType.more).\r\n     *\r\n     * @param operator used string representation of more operator\r\n     * @param left left subtree producing a value\r\n     * @param right right subtree producing a value\r\n     * @return new ComparingOperator instance of more type\r\n     */\r\n    public static more(operator: string | IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\r\n        return new ComparingOperator(ComparingOperatorType.more, operator, left, right);\r\n    }\r\n\r\n    /**\r\n     * Creates new ComparingOperator instance of less-or-equal type (type = ComparingOperatorType.lessOrEqual).\r\n     *\r\n     * @param operator used string representation of less-or-equal operator\r\n     * @param left left subtree producing a value\r\n     * @param right right subtree producing a value\r\n     * @return new ComparingOperator instance of less-or-equal type\r\n     */\r\n    public static lessOrEqual(operator: string | IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\r\n        return new ComparingOperator(ComparingOperatorType.lessOrEqual, operator, left, right);\r\n    }\r\n\r\n    /**\r\n     * Creates new ComparingOperator instance of more-or-equal type (type = ComparingOperatorType.moreOrEqual).\r\n     *\r\n     * @param operator used string representation of more-or-equal operator\r\n     * @param left left subtree producing a value\r\n     * @param right right subtree producing a value\r\n     * @return new ComparingOperator instance of more-or-equal type\r\n     */\r\n    public static moreOrEqual(operator: string | IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\r\n        return new ComparingOperator(ComparingOperatorType.moreOrEqual, operator, left, right);\r\n    }\r\n\r\n    /**\r\n     * Creates new ComparingOperator of the given type.\r\n     *\r\n     * @param type ComparingOperator type\r\n     * @param operator used string representation of the operator\r\n     * @param left left subtree producing a value\r\n     * @param right right subtree producing a value\r\n     */\r\n    public constructor(private readonly type: ComparingOperatorType, private readonly operator: string | IndexedString,\r\n                       private readonly left: VETreeNode, private readonly right: VETreeNode) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Evaluate the node and its subtrees and compares their value results to produce a boolean value. It needs to\r\n     * receive results of the same type from its subtrees.\r\n     * NOTE: If one of the subtrees' results is null, only equality and non-equality are valid. Other comparing\r\n     * operations returns always false.\r\n     *\r\n     * @param source row with actual values of columns recursively passed to leaf reference nodes\r\n     * @return boolean comparing left and right subtrees' values\r\n     */\r\n    public eval(source: Row): { value: boolean, type: \"boolean\" } {\r\n        const leftResult: { value: ColumnContent, type: SupportedColumnType | \"null\" } = this.left.eval(source);\r\n        const rightResult: { value: ColumnContent, type: SupportedColumnType | \"null\" } = this.right.eval(source);\r\n\r\n        if (leftResult.type !== \"null\" && rightResult.type !== \"null\" && leftResult.type !== rightResult.type) {\r\n            throw ErrorFactory.syntaxError(SyntaxErrorCodes.comparingOperator_eval_differentInputTypes,\r\n                getRange(this.operator), this.operator.toString(), leftResult.type, rightResult.type);\r\n        }\r\n\r\n        // if both values are null but both types are not null, returns false\r\n        if (leftResult.value === null && rightResult.value === null && leftResult.type !== \"null\" && rightResult.type !== \"null\") {\r\n            return {value: false, type: \"boolean\"};\r\n        }\r\n        if (this.type === ComparingOperatorType.equal) {\r\n            return {value: leftResult.value === rightResult.value, type: \"boolean\"};\r\n        }\r\n        if (this.type === ComparingOperatorType.nonEqual) {\r\n            // if any value of non-null type is null, returns false\r\n            if ((leftResult.value === null && leftResult.type !== \"null\") || (rightResult.value === null && rightResult.type !== \"null\")) {\r\n                return {value: false, type: \"boolean\"};\r\n            }\r\n            return {value: leftResult.value !== rightResult.value, type: \"boolean\"};\r\n        }\r\n        if (this.type === ComparingOperatorType.less) {\r\n            if (leftResult.value === null || rightResult.value === null) {\r\n                return {value: false, type: \"boolean\"};\r\n            }\r\n            return {value: leftResult.value < rightResult.value, type: \"boolean\"};\r\n        }\r\n        if (this.type === ComparingOperatorType.more) {\r\n            if (leftResult.value === null || rightResult.value === null) {\r\n                return {value: false, type: \"boolean\"};\r\n            }\r\n            return {value: leftResult.value > rightResult.value, type: \"boolean\"};\r\n        }\r\n        if (this.type === ComparingOperatorType.lessOrEqual) {\r\n            if (leftResult.value === null || rightResult.value === null) {\r\n                return {value: false, type: \"boolean\"};\r\n            }\r\n            return {value: leftResult.value <= rightResult.value, type: \"boolean\"};\r\n        }\r\n        // if (this.type === ComparingOperatorType.moreOrEqual)\r\n            if (leftResult.value === null || rightResult.value === null) {\r\n                return {value: false, type: \"boolean\"};\r\n            }\r\n            return {value: leftResult.value >= rightResult.value, type: \"boolean\"};\r\n    }\r\n\r\n    public toString(): string {\r\n        return \"(\" + this.left.toString() + \" \" + this.operator + \" \" + this.right.toString() + \")\";\r\n    }\r\n}","import UnaryNode from \"./unaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Parser from \"../tools/parser\";\r\nimport Relation from \"../relation/relation\";\r\nimport Row from \"../relation/row\";\r\nimport {ParameterizedNode} from \"./parameterizedNode\";\r\nimport {getRange, IndexedString, isEmpty} from \"../tools/indexedString\";\r\nimport {ErrorFactory, SemanticErrorCodes, SyntaxErrorCodes} from \"../error/errorFactory\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\nimport {isForbiddenColumnName} from \"../tools/keywords\";\r\nimport ParserIndexed from \"../tools/parserIndexed\";\r\n\r\n/**\r\n * Projection node of the relational algebra syntactic tree.\r\n */\r\nexport default class ProjectionNode extends UnaryNode implements ParameterizedNode {\r\n\r\n    private readonly projection: string | IndexedString;\r\n    private readonly stringRange: { start: number, end: number } | undefined;\r\n\r\n    /**\r\n     * Expects the projection string to start with '[' and end with ']'.\r\n     *\r\n     * @param projection\r\n     * @param subtree\r\n     */\r\n    constructor(projection: string | IndexedString, subtree: RATreeNode) {\r\n        super(subtree);\r\n        this.projection = projection;\r\n        this.stringRange = getRange(projection);\r\n    }\r\n\r\n    /**\r\n     * Parses projection string to set of projected columns.\r\n     * If doThrow is true, throws found errors. Otherwise, adds found errors to given errors array.\r\n     */\r\n    private parseProjection(doThrow: boolean, errors: ErrorWithTextRange[] = []): Set<string | IndexedString> {\r\n        const ret: Set<string | IndexedString> = new Set<string>();\r\n        const indexed: boolean = this.projection instanceof IndexedString\r\n        // @ts-ignore\r\n        let str: string | IndexedString = this.projection.slice(1, -1);\r\n        let parts: (string | IndexedString)[] = str.split(\",\");\r\n        parts.forEach(part => {\r\n            part = part.trim();\r\n            // @ts-ignore\r\n            const isName = indexed ? ParserIndexed.isName(part) : Parser.isName(part);\r\n            if (isName && !isForbiddenColumnName(part)) {\r\n                ret.add(part);\r\n            }\r\n            else {\r\n                let range = getRange(part);\r\n                if (isEmpty(part) && this.stringRange !== undefined) {\r\n                    range = {start: this.stringRange.start, end: this.stringRange.start};\r\n                }\r\n                const error = ErrorFactory.syntaxError(SyntaxErrorCodes.projectionNode_parseProjection_invalidProjectedColumnName,\r\n                    range, part.toString());\r\n                if (doThrow) {\r\n                    throw error;\r\n                }\r\n                else {\r\n                    errors.push(error);\r\n                }\r\n            }\r\n        });\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Expectations: projected names are subset of source schema\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n        const source: Relation = this.subtree.getResult();\r\n        const projected: string[] = [...this.parseProjection(true)].map(value => value.toString());\r\n        // checks if projected columns really exist in source relation\r\n        projected.forEach(name => {\r\n            if (!source.hasColumn(name.toString())) {\r\n                throw ErrorFactory.semanticError(SemanticErrorCodes.projectionNode_eval_absentColumn,\r\n                    getRange(name), name.toString());\r\n            }\r\n        });\r\n\r\n        const result: Relation = new Relation(source.getName() + \"[...]\");\r\n        // projection of relational schema\r\n        source.forEachColumn((type, name) => {\r\n            if (projected.indexOf(name) > -1) {\r\n                result.addColumn(name, type);\r\n            }\r\n        });\r\n        // projection of relation rows\r\n        source.getRows().forEach(row => {\r\n             let newRow: Row = new Row(result.getColumns());\r\n             row.getValues().forEach((value, name) => {\r\n                 if (projected.indexOf(name) > -1) {\r\n                     newRow.addValue(name, value);\r\n                 }\r\n             });\r\n             result.addRow(newRow);\r\n        });\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: projected names are subset of source schema\r\n     * Returned schema: intersection of projected names and source schema\r\n     * Second possible approach would be to return all projected names - less strict.\r\n     */\r\n    public fakeEval(cursorIndex: number): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} {\r\n        let source: {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} = this.subtree.fakeEval(cursorIndex);\r\n        // checks whether the cursor is in this projection block - saves current available columns\r\n        let whispers = source.whispers;\r\n        if (this.stringRange !== undefined && this.stringRange.start < cursorIndex && cursorIndex <= this.stringRange.end) {\r\n            whispers = source.result.getColumnNames();\r\n        }\r\n        // adds errors from current expression\r\n        const errors = source.errors;\r\n        const projected: Set<string | IndexedString> = this.parseProjection(false, errors);\r\n        // creates relational schema - \"projected columns\"\r\n        const result: Relation = new Relation(source.result.name + \"[...]\");\r\n        // adds only projected, which exist in source\r\n        const absent: (string | IndexedString)[] = [];\r\n        projected.forEach(name => {\r\n            const strName = name.toString();\r\n            if (source.result.hasColumn(strName)) {\r\n                // @ts-ignore - strName must be in the source now\r\n                result.addColumn(strName, source.result.getColumns().get(strName));\r\n            }\r\n            else {\r\n                absent.push(name);\r\n            }\r\n        });\r\n        absent.forEach(column => {\r\n            errors.push(ErrorFactory.semanticError(SemanticErrorCodes.projectionNode_eval_absentColumn,\r\n                getRange(column), column.toString()));\r\n        });\r\n        return {result, whispers, errors};\r\n    }\r\n\r\n    printInLine(): string {\r\n        return \"Projection of \" + this.projection.replace(/\\s/g, '') + \" from {\" + this.subtree.printInLine() + \"}\";\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        return \"Projection\";\r\n    }\r\n\r\n    public getParameter(): string {\r\n        return this.projection.replace(/\\s/g, '');\r\n    }\r\n}","import {IndexedString} from \"./indexedString\";\r\n\r\ninterface KeyValue {\r\n    key: string | IndexedString,\r\n    value: string | IndexedString\r\n}\r\n\r\n/**\r\n * Wrapper of JavaScript Map object to provide usage of object (string | IndexedString) as a key.\r\n * Keys \"IndexedString: something\" and \"string: something\" are equal for this map.\r\n */\r\nexport class ISSToISSMap {\r\n    private map: Map<string, KeyValue> = new Map<string, KeyValue>();\r\n\r\n    public get(key: string | IndexedString): string | IndexedString | undefined {\r\n        const keyValue = this.map.get(key.toString());\r\n        return keyValue === undefined ? undefined : keyValue.value;\r\n    }\r\n\r\n    public set(key: string | IndexedString, value: string | IndexedString): void {\r\n        this.map.set(key.toString(), {key, value});\r\n    }\r\n\r\n    public delete(key: string | IndexedString): boolean {\r\n        return this.map.delete(key.toString());\r\n    }\r\n\r\n    public has(key: string | IndexedString): boolean {\r\n        return this.map.has(key.toString());\r\n    }\r\n\r\n    public clear(): void {\r\n        this.map.clear();\r\n    }\r\n\r\n    public size(): number {\r\n        return this.map.size;\r\n    }\r\n\r\n    public forEach(f: (value: string | IndexedString, row: string | IndexedString, index?: number) => void): void {\r\n        [...this.map.values()].forEach((keyValue, index) => f(keyValue.value, keyValue.key, index));\r\n    }\r\n}","import UnaryNode from \"./unaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Parser from \"../tools/parser\";\r\nimport Relation from \"../relation/relation\";\r\nimport {SupportedColumnType} from \"../relation/columnType\";\r\nimport Row from \"../relation/row\";\r\nimport {ParameterizedNode} from \"./parameterizedNode\";\r\nimport {getRange, IndexedString, isEmpty} from \"../tools/indexedString\";\r\nimport {ErrorFactory, SemanticErrorCodes, SyntaxErrorCodes} from \"../error/errorFactory\";\r\nimport {isForbiddenColumnName} from \"../tools/keywords\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\nimport {ISSToISSMap} from \"../tools/issToISSMap\";\r\n\r\n/**\r\n * Renaming node of the relational algebra syntactic tree.\r\n */\r\nexport default class RenameNode extends UnaryNode implements ParameterizedNode {\r\n\r\n    private readonly rename: string | IndexedString;\r\n    private readonly stringRange: { start: number, end: number } | undefined;\r\n\r\n    /**\r\n     * Creates a new renaming node with given subtree.\r\n     * The rename string is expected to start with '<' and end with '>'.\r\n     *\r\n     * @param rename string describing each renaming\r\n     * @param subtree source subtree for renaming\r\n     */\r\n    public constructor(rename: string | IndexedString, subtree: RATreeNode) {\r\n        super(subtree);\r\n        this.rename = rename;\r\n        this.stringRange = getRange(rename);\r\n    }\r\n\r\n    private parseChanges(doThrow: boolean, errors: ErrorWithTextRange[] = []): ISSToISSMap {\r\n        const handleError = (error: SyntaxError) => {\r\n            if (doThrow) {\r\n                throw error;\r\n            } else {\r\n                errors.push(error);\r\n            }\r\n        }\r\n        const parts: (string | IndexedString)[] = this.rename.slice(1, -1).split(\",\");\r\n        const ret: ISSToISSMap = new ISSToISSMap();\r\n        for (let part of parts) {\r\n            // @ts-ignore\r\n            let words: (string | IndexedString)[] = part.split(\"->\").map(w => w.trim());\r\n            let beforeError = false; // true when there was an error in before in \"before -> after\"\r\n            let afterError = false;  // true when there was an error in after in \"before -> after\"\r\n            if (words.length !== 2) {\r\n                let range = getRange(part);\r\n                if (isEmpty(part) && this.stringRange !== undefined) {\r\n                    range = {start: this.stringRange.start, end: this.stringRange.start};\r\n                }\r\n                handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.renameNode_parseChanges_missingArrow, range));\r\n                beforeError = true;\r\n                afterError = true;\r\n            }\r\n            if (!beforeError && ret.has(words[0].toString())) {\r\n                handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.renameNode_parseChanges_multipleRenameOfTheColumn,\r\n                    getRange(words[0]), words[0].toString()));\r\n                beforeError = true;\r\n            }\r\n            if (!afterError && !Parser.isName(words[1].toString())) {\r\n                handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.renameNode_parseChanges_invalidNewName,\r\n                    getRange(words[1]), words[1].toString()));\r\n                afterError = true;\r\n            }\r\n            if (!afterError && isForbiddenColumnName(words[1])) {\r\n                handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.renameNode_parseChanges_keywordNewName,\r\n                    getRange(words[1]), words[1].toString()));\r\n                afterError = true;\r\n            }\r\n            // if no error found, adds original rename pair\r\n            if (!beforeError && !afterError) {\r\n                ret.set(words[0], words[1]);\r\n            }\r\n            // if no before error, fakes rename \"before -> before\"\r\n            else if (!beforeError) {\r\n                ret.set(words[0], words[0]);\r\n            }\r\n            // if no after error, fakes rename \"\"\" -> before\", where empty string has undefined range\r\n            else if (!afterError) {\r\n                ret.set(\"\", words[0]);\r\n            }\r\n            // if both errors, adds nothing\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Expectations: original names in projection pair (original -> new) are subset of the source schema,\r\n     * new names with rest of the source schema contain no duplicity\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n        const changes: ISSToISSMap = this.parseChanges(true);\r\n        const source: Relation = this.subtree.getResult();\r\n        // check whether all columns to rename are in source relation\r\n        changes.forEach((value, key) => {\r\n             if (source.getColumnNames().indexOf(key.toString()) === -1) {\r\n                 throw ErrorFactory.semanticError(SemanticErrorCodes.renameNode_eval_absentOriginalColumn,\r\n                     getRange(key), key.toString());\r\n             }\r\n        });\r\n        // rename of relational schema\r\n        const result: Relation = new Relation(source.getName() + \"<...>\");\r\n        const toChange: Map<string, SupportedColumnType> = new Map<string, SupportedColumnType>();\r\n        // in first loop adds unchanged columns only\r\n        source.forEachColumn((type, name) => {\r\n            if (changes.has(name)) {\r\n                toChange.set(name, type);\r\n            }\r\n            else {\r\n                result.addColumn(name, type);\r\n            }\r\n        });\r\n        // in second loop adds changed columns\r\n        toChange.forEach((type, name) => {\r\n            // @ts-ignore (changes must contain 'name' key now)\r\n            if (!result.addColumn(changes.get(name).toString(), type)) {\r\n                throw ErrorFactory.semanticError(SemanticErrorCodes.renameNode_eval_changeToDuplicitName,\r\n                    getRange(this.rename), changes.get(name) as string);\r\n            }\r\n        });\r\n        // rename of relation rows\r\n        source.getRows().forEach(row => {\r\n            const newRow: Row = new Row(result.getColumns());\r\n            row.getValues().forEach((value, name) => {\r\n                const returned = changes.get(name);\r\n                if (typeof returned === \"undefined\") {\r\n                    newRow.addValue(name, value);\r\n                }\r\n                else {\r\n                    newRow.addValue(returned.toString(), value);\r\n                }\r\n            });\r\n            result.addRow(newRow);\r\n        });\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: original names in projection pair (original -> new) are subset of the source schema,\r\n     * new names with rest of the source schema contain no duplicity\r\n     * Returned schema: if the cursor is not after the arrow '->' returns\r\n     * (source schema minus originals) union (news whose originals were in source schema),\r\n     * otherwise returns empty array (does not whisper to what the user should rename)\r\n     * Second possible approach would be to return (source schema minus originals) union (news) - less strict.\r\n     */\r\n    public fakeEval(cursorIndex: number): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} {\r\n        const source: {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} = this.subtree.fakeEval(cursorIndex);\r\n        // checks whether the cursor is in this rename block\r\n        let whispers = source.whispers;\r\n        if (this.stringRange !== undefined && this.stringRange.start < cursorIndex && cursorIndex <= this.stringRange.end) {\r\n            // if the last special character before cursor is '<' or ',' returns current available columns (subtree schema)\r\n            const beforeCursor: string | IndexedString = this.rename.slice(0, cursorIndex - this.stringRange.start).trim();\r\n            const regexMatch = beforeCursor.match(/.*[^\\w\\s]/);\r\n            if (regexMatch !== null && (regexMatch[0].endsWith('<') || regexMatch[0].endsWith(','))) {\r\n                whispers = source.result.getColumnNames();\r\n            }\r\n        }\r\n        // adds errors from current expression\r\n        const errors = source.errors;\r\n        const changes: ISSToISSMap = this.parseChanges(false, errors);\r\n        // creates relational schema - \"(source minus to-rename) union (renamed existing in source)\"\r\n        const result: Relation = new Relation(source.result.getName() + \"<...>\");\r\n        // in first loop adds source columns which are not in changes.keys\r\n        source.result.forEachColumn((type, name) => {\r\n            if (!changes.has(name)) {\r\n                result.addColumn(name, type);\r\n            }\r\n        });\r\n        // in second loop adds changes.values whose changes.keys are in source\r\n        const absent: (string | IndexedString)[] = [];\r\n        const duplicit: (string | IndexedString)[] = [];\r\n        changes.forEach((after, before) => {\r\n            const beforeStr = before.toString();\r\n            const afterStr = after.toString();\r\n            if (!source.result.hasColumn(beforeStr) && before !== \"\") {\r\n                absent.push(before);\r\n            }\r\n            // @ts-ignore source must have beforeStr now\r\n            else if(!result.addColumn(afterStr, source.result.getColumns().get(beforeStr))) {\r\n                duplicit.push(after);\r\n            }\r\n        });\r\n        absent.forEach(column => {\r\n            errors.push(ErrorFactory.semanticError(SemanticErrorCodes.renameNode_eval_absentOriginalColumn,\r\n                getRange(column), column.toString()));\r\n        });\r\n        duplicit.forEach(column => {\r\n            errors.push(ErrorFactory.semanticError(SemanticErrorCodes.renameNode_eval_changeToDuplicitName,\r\n                getRange(column), column.toString()));\r\n        });\r\n        return {result, whispers, errors};\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return \"Projection of \" + this.rename.replace(/\\s+/g, \"\") + \" from {\" + this.subtree.printInLine() + \"}\";\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        return \"Rename\";\r\n    }\r\n\r\n    public getParameter(): string {\r\n        return this.rename.replace(/\\s+/g, \" \");\r\n    }\r\n}","import Row from \"../relation/row\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\n\r\n/**\r\n * Abstract class for value-evaluating nodes producing new values.\r\n */\r\nexport abstract class VETreeNode {\r\n\r\n    /**\r\n     * Evaluates this value-evaluating tree.\r\n     *\r\n     * @param source row with values to be used to reference to\r\n     * @return evaluated value and its type\r\n     */\r\n    public abstract eval(source: Row): { value: ColumnContent, type: SupportedColumnType | \"null\" };\r\n\r\n    /**\r\n     * @return string representation of the value-evaluating tree\r\n     */\r\n    public abstract toString(): string;\r\n}","import Row from \"../relation/row\";\r\nimport {VETreeNode} from \"./veTreeNode\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\nimport {ErrorFactory, SyntaxErrorCodes} from \"../error/errorFactory\";\r\nimport {getRange, IndexedString} from \"../tools/indexedString\";\r\n\r\n/**\r\n * Types of LogicalOperator class.\r\n */\r\nenum LogicalOperatorType {\r\n    and,\r\n    or,\r\n    not\r\n}\r\n\r\n/**\r\n * Logical operator chains boolean values and produces new ones.\r\n */\r\nexport class LogicalOperator extends VETreeNode {\r\n\r\n    /**\r\n     * Creates an 'and' logical operator.\r\n     *\r\n     * @param operator String representing an 'and' in input (used to printing)\r\n     * @param left Left subtree evaluating to a boolean value\r\n     * @param right Right subtree evaluating to a boolean value\r\n     */\r\n    public static and(operator: string | IndexedString, left: VETreeNode, right: VETreeNode): LogicalOperator {\r\n        return new LogicalOperator(LogicalOperatorType.and, operator, left, right);\r\n    }\r\n\r\n    /**\r\n     * Creates an 'or' logical operator.\r\n     *\r\n     * @param operator String representing an 'or' in input (used to printing)\r\n     * @param left Left subtree evaluating to a boolean value\r\n     * @param right Right subtree evaluating to a boolean value\r\n     */\r\n    public static or(operator: string | IndexedString, left: VETreeNode, right: VETreeNode): LogicalOperator {\r\n        return new LogicalOperator(LogicalOperatorType.or, operator, left, right);\r\n    }\r\n\r\n    /**\r\n     * Creates a 'not' logical operator.\r\n     *\r\n     * @param operator String representing a 'not' in input (used to printing)\r\n     * @param subtree Subtree evaluating to a boolean value\r\n     */\r\n    public static not(operator: string | IndexedString, subtree: VETreeNode): LogicalOperator {\r\n        return new LogicalOperator(LogicalOperatorType.not, operator, subtree);\r\n    }\r\n\r\n    private constructor(private readonly type: LogicalOperatorType, private readonly operator: string | IndexedString,\r\n                        private readonly left: VETreeNode, private readonly right?: VETreeNode) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Evaluates recursively subtrees and transforms their boolean results into a new boolean.\r\n     * If any subtree evaluates to string or number, throws error.\r\n     *\r\n     * @param source row with actual values of columns recursively passed to leaf reference nodes\r\n     * @return boolean comparing left and right subtrees' values\r\n     */\r\n    public eval(source: Row): { value: boolean, type: \"boolean\" } {\r\n\r\n        const leftResult: { value: ColumnContent, type: SupportedColumnType | \"null\" } = this.left.eval(source);\r\n        if (leftResult.type !== \"boolean\") {\r\n            throw ErrorFactory.syntaxError(SyntaxErrorCodes.logicalOperator_eval_leftInputNotBoolean,\r\n                getRange(this.operator), this.operator.toString(), leftResult.type);\r\n        }\r\n\r\n        if (this.type === LogicalOperatorType.not) {\r\n            if (leftResult.value === null) {\r\n                return { value: false, type: \"boolean\" };\r\n            }\r\n            return { value: !leftResult.value, type: \"boolean\" };\r\n        }\r\n        else {\r\n            // @ts-ignore (in and/or operations right subtree must exist)\r\n            const rightResult: { value: ColumnContent, type: SupportedColumnType | \"null\" } = this.right.eval(source);\r\n            if (rightResult.type !== \"boolean\") {\r\n                throw ErrorFactory.syntaxError(SyntaxErrorCodes.logicalOperator_eval_rightInputNotBoolean,\r\n                    getRange(this.operator), this.operator.toString(), rightResult.type);\r\n            }\r\n\r\n            if (this.type === LogicalOperatorType.and) {\r\n                if (leftResult.value === null || rightResult.value === null) {\r\n                    return { value: false, type: \"boolean\" };\r\n                }\r\n                // @ts-ignore (they must be both booleans now)\r\n                return { value: leftResult.value && rightResult.value, type: \"boolean\" };\r\n            }\r\n            else /* if (this.type === LogicalOperatorType.or)*/ {\r\n                if (leftResult.value === null && rightResult.value === null) {\r\n                    return { value: false, type: \"boolean\" };\r\n                }\r\n                if (leftResult.value === null) {\r\n                    // @ts-ignore (it must be boolean now)\r\n                    return { value: rightResult.value, type: \"boolean\" };\r\n                }\r\n                if (rightResult.value === null) {\r\n                    // @ts-ignore (it must be boolean now)\r\n                    return { value: leftResult.value, type: \"boolean\" };\r\n                }\r\n                // @ts-ignore (they must be both booleans now)\r\n                return { value: leftResult.value || rightResult.value, type: \"boolean\" };\r\n            }\r\n        }\r\n    }\r\n\r\n    public toString(): string {\r\n        if (this.type === LogicalOperatorType.not) {\r\n            return this.operator + \"(\" + this.left.toString() + \")\";\r\n        }\r\n        // @ts-ignore (in and, or operations right subtree must exist)\r\n        return \"(\" + this.left.toString() + \" \" + this.operator.toString() + \" \" + this.right.toString() + \")\";\r\n    }\r\n}","import Row from \"../relation/row\";\r\nimport {VETreeNode} from \"./veTreeNode\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\nimport {ErrorFactory, SyntaxErrorCodes} from \"../error/errorFactory\";\r\n\r\n/**\r\n * Types of ComputingOperator class.\r\n */\r\nenum ComputingOperatorType {\r\n    plus = \"+\",\r\n    minus = \"-\",\r\n    multiplication = \"*\",\r\n    division = \"/\"\r\n}\r\n\r\n/**\r\n * Comparing operator takes two number values and returns a new computed number.\r\n */\r\nexport class ComputingOperator extends VETreeNode {\r\n\r\n    /**\r\n     * Creates an addition (+) computing operator.\r\n     *\r\n     * @param left Left subtree evaluating to a number value\r\n     * @param right Right subtree evaluating to a number value\r\n     * @param range Range of the operator in the input string to highlight errors\r\n     */\r\n    public static add(left: VETreeNode, right: VETreeNode, range: {start: number, end: number} | undefined): ComputingOperator {\r\n        return new ComputingOperator(ComputingOperatorType.plus, left, right, range);\r\n    }\r\n\r\n    /**\r\n     * Creates a deduction (-) computing operator.\r\n     *\r\n     * @param left Left subtree evaluating to a number value\r\n     * @param right Right subtree evaluating to a number value\r\n     * @param range Range of the operator in the input string to highlight errors\r\n     */\r\n    public static deduct(left: VETreeNode, right: VETreeNode, range: {start: number, end: number} | undefined): ComputingOperator {\r\n        return new ComputingOperator(ComputingOperatorType.minus, left, right, range);\r\n    }\r\n\r\n    /**\r\n     * Creates a multiplication (*) computing operator.\r\n     *\r\n     * @param left Left subtree evaluating to a number value\r\n     * @param right Right subtree evaluating to a number value\r\n     * @param range Range of the operator in the input string to highlight errors\r\n     */\r\n    public static multiply(left: VETreeNode, right: VETreeNode, range: {start: number, end: number} | undefined): ComputingOperator {\r\n        return new ComputingOperator(ComputingOperatorType.multiplication, left, right, range);\r\n    }\r\n\r\n    /**\r\n     * Creates a division (/) computing operator.\r\n     *\r\n     * @param left Left subtree evaluating to a number value\r\n     * @param right Right subtree evaluating to a number value\r\n     * @param range Range of the operator in the input string to highlight errors\r\n     */\r\n    public static divide(left: VETreeNode, right: VETreeNode, range: {start: number, end: number} | undefined): ComputingOperator {\r\n        return new ComputingOperator(ComputingOperatorType.division, left, right, range);\r\n    }\r\n\r\n    private constructor(private readonly type: ComputingOperatorType, private readonly left: VETreeNode,\r\n                        private readonly right: VETreeNode, private readonly range: {start: number, end: number} | undefined) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Evaluates recursively subtrees and transforms their number results into a new number.\r\n     * If any subtree evaluates to string or boolean, throws error.\r\n     * If any subtree evaluates to null, returns null.\r\n     *\r\n     * @param source row with actual values of columns recursively passed to leaf reference nodes\r\n     * @return number produced from subtrees with given operation, or null if any subtree returned null\r\n     */\r\n    public eval(source: Row): { value: number | null, type: \"number\" } {\r\n        const leftResult: { value: ColumnContent, type: SupportedColumnType | \"null\" } = this.left.eval(source);\r\n        const rightResult: { value: ColumnContent, type: SupportedColumnType | \"null\" } = this.right.eval(source);\r\n\r\n        if (leftResult.type !== \"number\" || rightResult.type !== \"number\") {\r\n            throw ErrorFactory.syntaxError(SyntaxErrorCodes.computingOperator_eval_inputTypesNotNumbers, this.range,\r\n                this.type, leftResult.type, rightResult.type);\r\n        }\r\n\r\n        if (leftResult.value === null || rightResult.value === null) {\r\n            return { value: null, type: \"number\" };\r\n        }\r\n\r\n        switch (this.type) {\r\n            case ComputingOperatorType.plus:\r\n                // @ts-ignore (ensured by first if)\r\n                return { value: leftResult.value + rightResult.value, type: \"number\" };\r\n            case ComputingOperatorType.minus:\r\n                // @ts-ignore (ensured by first if)\r\n                return { value: leftResult.value - rightResult.value, type: \"number\" };\r\n            case ComputingOperatorType.multiplication:\r\n                // @ts-ignore (ensured by first if)\r\n                return { value: leftResult.value * rightResult.value, type: \"number\" };\r\n            case ComputingOperatorType.division:\r\n                // @ts-ignore (ensured by first if)\r\n                return { value: leftResult.value / rightResult.value, type: \"number\" };\r\n        }\r\n    }\r\n\r\n    public toString(): string {\r\n        return \"(\" + this.left.toString() + \" \" + this.type + \" \" + this.right.toString() + \")\";\r\n    }\r\n}","import Row from \"../relation/row\";\r\nimport {VETreeNode} from \"./veTreeNode\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\n\r\n/**\r\n * Class storing literal value of number, string or null type.\r\n */\r\nexport class LiteralValue extends VETreeNode {\r\n\r\n    /**\r\n     * Creates a literal storing given value.\r\n     *\r\n     * @param value value to be returned by eval(...) function\r\n     * @param type type of the literal value\r\n     */\r\n    public constructor(private readonly value: ColumnContent, private readonly type: SupportedColumnType | \"null\") {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Returns stored value.\r\n     *\r\n     * @param source row with actual values of columns (note: not used in literals)\r\n     * @return stored value and its type\r\n     */\r\n    public eval(source: Row): { value: ColumnContent, type: SupportedColumnType | \"null\" } {\r\n        return { value: this.value, type: this.type };\r\n    }\r\n\r\n    public toString(): string {\r\n        if (this.value === null) {\r\n            return \"null\";\r\n        }\r\n        return this.value.toString();\r\n    }\r\n}","import Row from \"../relation/row\";\r\nimport {VETreeNode} from \"./veTreeNode\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\nimport {ErrorFactory, SemanticErrorCodes} from \"../error/errorFactory\";\r\nimport {getRange, IndexedString} from \"../tools/indexedString\";\r\n\r\n/**\r\n * Class storing reference to a column.\r\n */\r\nexport class ReferenceValue extends VETreeNode {\r\n\r\n    /**\r\n     * Creates a reference to the given column.\r\n     *\r\n     * @param columnName name of the column whose value is returned by eval(...) function\r\n     */\r\n    public constructor(private readonly columnName: string | IndexedString) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Returns value (expected to be string, number, or boolean) of the referenced column from given source row.\r\n     *\r\n     * @param source row with actual values of columns\r\n     * @return referenced value and its type\r\n     */\r\n    public eval(source: Row): { value: ColumnContent, type: SupportedColumnType } {\r\n        const value: ColumnContent | undefined = source.getValue(this.columnName.toString());\r\n        const type: SupportedColumnType | undefined = source.getType(this.columnName.toString());\r\n        if (value === undefined || type === undefined) {\r\n            throw ErrorFactory.semanticError(SemanticErrorCodes.referenceValue_eval_absentColumn,\r\n                getRange(this.columnName), this.columnName.toString(), [...source.getColumnNames()].join(', '));\r\n        }\r\n        return { value: value, type: type };\r\n    }\r\n\r\n    public toString(): string {\r\n        return this.columnName.toString();\r\n    }\r\n}","import BinaryNode from \"./binaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport Row from \"../relation/row\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\n\r\n/**\r\n * Types of antijoin node.\r\n */\r\nexport enum AntijoinType {\r\n    left = \"\\u22b3\",\r\n    right = \"\\u22b2\"\r\n}\r\n\r\n/**\r\n * Antijoin node of the relational algebra syntactic tree.\r\n */\r\nexport default class AntijoinNode extends BinaryNode {\r\n\r\n    private readonly type: AntijoinType;\r\n\r\n    public constructor(operator: AntijoinType, leftSubtree: RATreeNode, rightSubtree: RATreeNode) {\r\n        super(leftSubtree, rightSubtree);\r\n        this.type = operator;\r\n    }\r\n\r\n    /**\r\n     * Expectations on source schemas: none\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n        const leftSource: Relation = this.leftSubtree.getResult();\r\n        const rightSource: Relation = this.rightSubtree.getResult();\r\n        // intersection of columns in left and right subtree\r\n        const commonColumns: string[] = leftSource.getColumnNames().filter(lc => rightSource.hasColumn(lc));\r\n        let rowsToKeep: Row[];   // rows from the subtree, which have to be kept in result\r\n        let rowsToHelp: Row[];\r\n        // change of relational schema\r\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + this.type + rightSource.getName() + \")\");\r\n        if (this.type === AntijoinType.left) {\r\n            leftSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n            rowsToKeep = leftSource.getRows();\r\n            rowsToHelp = rightSource.getRows();\r\n        }\r\n        else {\r\n            rightSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n            rowsToKeep = rightSource.getRows();\r\n            rowsToHelp = leftSource.getRows();\r\n        }\r\n        // join of relation rows\r\n        rowsToKeep.forEach(keptRow => {\r\n            let someMatch: boolean = rowsToHelp.some(helpRow => {\r\n                // if all common columns match, the row should not be added\r\n                return commonColumns.every(c => keptRow.getValue(c) === helpRow.getValue(c));\r\n            });\r\n            if (!someMatch) {\r\n                let newRow: Row = new Row(result.getColumns());\r\n                keptRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                result.addRow(newRow);\r\n            }\r\n        });\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: none\r\n     * Returned schema: left/right source schema (for left/right antijoin)\r\n     */\r\n    public fakeEval(cursorIndex: number): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} {\r\n        const type = this.type === AntijoinType.left ? \"left\" : \"right\";\r\n        return this.fakeEvalBinary(cursorIndex, type);\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return this.getOperationName() + \" of {\" + this.leftSubtree.printInLine() + \"} and {\" + this.rightSubtree.printInLine() + \"}\";\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        return this.type === AntijoinType.left ? \"Left antijoin\" : \"Right antijoin\";\r\n    }\r\n}","import {ComparingOperatorType} from \"../vetree/comparingOperator\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\nimport {IndexedString} from \"../tools/indexedString\";\r\n\r\n/**\r\n * Precedence value for all token types.\r\n */\r\nconst precedenceNot: number = 50;\r\nconst precedenceMulDiv: number = 30;\r\nconst precedencePlusMinus: number = 25;\r\nconst precedenceComparison: number = 20;\r\nconst precedenceAnd: number = 10;\r\nconst precedenceOr: number = 5;\r\n\r\n/**\r\n * Tokens used for parsing of string expression to BooleanEvaluating tree.\r\n */\r\nexport abstract class ValueToken {\r\n    protected constructor(public readonly str: string | IndexedString) {}\r\n\r\n    /**\r\n     * Gets token start and end index in the text (if the token has IndexedString representation) or undefined.\r\n     */\r\n    public getRange(): {start: number, end: number} | undefined {\r\n        return this.str instanceof IndexedString ? this.str.getNonNaNRange() : undefined;\r\n    }\r\n}\r\n\r\nexport abstract class OperatorToken extends ValueToken {\r\n    protected constructor(str: string | IndexedString, readonly precedence: number) {\r\n        super(str);\r\n    }\r\n}\r\n\r\nexport class LogicalNotToken extends OperatorToken {\r\n    constructor(operator: string | IndexedString) {\r\n        super(operator, precedenceNot);\r\n    }\r\n}\r\n\r\nexport class LogicalAndToken extends OperatorToken {\r\n    constructor(operator: string | IndexedString) {\r\n        super(operator, precedenceAnd);\r\n    }\r\n}\r\n\r\nexport class LogicalOrToken extends OperatorToken {\r\n    constructor(operator: string | IndexedString) {\r\n        super(operator, precedenceOr);\r\n    }\r\n}\r\n\r\nexport class ComputingMultiplicationToken extends OperatorToken {\r\n    constructor(operator: string | IndexedString) {\r\n        super(operator, precedenceMulDiv);\r\n    }\r\n}\r\n\r\nexport class ComputingDivisionToken extends OperatorToken {\r\n    constructor(operator: string | IndexedString) {\r\n        super(operator, precedenceMulDiv);\r\n    }\r\n}\r\n\r\nexport class ComputingPlusToken extends OperatorToken {\r\n    constructor(operator: string | IndexedString) {\r\n        super(operator, precedencePlusMinus);\r\n    }\r\n}\r\n\r\nexport class ComputingMinusToken extends OperatorToken {\r\n    constructor(operator: string | IndexedString) {\r\n        super(operator, precedencePlusMinus);\r\n    }\r\n}\r\n\r\nexport class ComparingToken extends OperatorToken {\r\n    constructor(readonly type: ComparingOperatorType, operator: string | IndexedString) {\r\n        super(operator, precedenceComparison);\r\n    }\r\n}\r\n\r\nexport abstract class ParenthesisToken extends ValueToken {\r\n    protected constructor(operator: string | IndexedString) {\r\n        super(operator);\r\n    }\r\n}\r\n\r\nexport class OpeningParentheses extends ParenthesisToken {\r\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\r\n    constructor(operator: string | IndexedString) {\r\n        super(operator);\r\n    }\r\n}\r\n\r\nexport class ClosingParentheses extends ParenthesisToken {\r\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\r\n    constructor(operator: string | IndexedString) {\r\n        super(operator);\r\n    }\r\n}\r\n\r\nexport class LiteralToken extends ValueToken {\r\n    constructor(str: string | IndexedString, readonly value: ColumnContent, readonly type: SupportedColumnType | \"null\") {\r\n        super(str);\r\n    }\r\n}\r\n\r\nexport class ReferenceToken extends ValueToken {\r\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\r\n    constructor(columnName: string | IndexedString) {\r\n        super(columnName);\r\n    }\r\n}","import Parser from \"../tools/parser\";\r\nimport {ComparingOperator, ComparingOperatorType} from \"../vetree/comparingOperator\";\r\nimport {LogicalOperator} from \"../vetree/logicalOperator\";\r\nimport {LiteralValue} from \"../vetree/literalValue\";\r\nimport {ReferenceValue} from \"../vetree/referenceValue\";\r\nimport {ComputingOperator} from \"../vetree/computingOperator\";\r\nimport {\r\n    ClosingParentheses,\r\n    ComparingToken,\r\n    ComputingDivisionToken,\r\n    ComputingMinusToken,\r\n    ComputingMultiplicationToken,\r\n    ComputingPlusToken,\r\n    LiteralToken,\r\n    LogicalAndToken,\r\n    LogicalNotToken,\r\n    LogicalOrToken,\r\n    OpeningParentheses,\r\n    OperatorToken,\r\n    ParenthesisToken,\r\n    ReferenceToken,\r\n    ValueToken\r\n} from \"./valueTokens\"\r\nimport {VETreeNode} from \"../vetree/veTreeNode\";\r\nimport {getRange, IndexedString, isEmpty, length, nextBorderedPart} from \"../tools/indexedString\";\r\nimport ParserIndexed from \"../tools/parserIndexed\";\r\nimport ErrorWithTextRange, {insertRangeIfUndefined} from \"../error/errorWithTextRange\";\r\nimport {CodeErrorCodes, ErrorFactory, SemanticErrorCodes, SyntaxErrorCodes} from \"../error/errorFactory\";\r\nimport RASyntaxError from \"../error/raSyntaxError\";\r\n\r\n/**\r\n * Parser of string infix boolean and algebraic expression to value-evaluating tree.\r\n */\r\nexport default class ValueParser {\r\n\r\n    /**\r\n     * Parses given string infix boolean and algebraic expression into an value-evaluating tree and returns the tree.\r\n     * Uses Shunting-yard algorithm (first, it transforms the string into reverse polish notation).\r\n     * Supported expressions:\r\n     * - logical: and (&&, &), or (||, |), not (!, ~)\r\n     * - computing: addition (+), deduction (-), multiplication (*), division (/)\r\n     * - comparing: equal (==, =), non-equal (!=, <>), less (<), more (>), less-or-equal (<=), more-or-equal (>=)\r\n     * - literals: numbers (1, 5.02, etc.), strings (\"String\", \"With inner \\\" symbol\", etc.), nulls (null),\r\n     * booleans (true, false)\r\n     * - column references (ColumnNameAsStringWithoutQuotes, Id, etc.)\r\n     * If the given string is IndexedString, thrown errors contain error range information.\r\n     *\r\n     * @param str infix boolean and algebraic expression to be parsed\r\n     * @param nullValuesSupport whether null values are supported\r\n     * @return VETreeNode tree (its root)\r\n     */\r\n    public static parse(str: string | IndexedString, nullValuesSupport: boolean): VETreeNode {\r\n        let tokens: ValueToken[] = ValueParser.parseTokens(str, nullValuesSupport, true);\r\n        this.assertValidInfixTokens(tokens, true);\r\n        tokens = this.simplify(tokens);\r\n        try {\r\n            const rpn: ValueToken[] = ValueParser.toRPN(tokens);\r\n            return ValueParser.rpnToVETree(rpn);\r\n        }\r\n        catch (err) {\r\n            throw insertRangeIfUndefined(err, getRange(str));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses given string infix boolean and algebraic expression and returns errors in it.\r\n     * For supported operations see ValueParser.parse().\r\n     *\r\n     * @param str infix boolean and algebraic expression to be parsed\r\n     * @param nullValuesSupport whether null values are supported\r\n     * @param columns\r\n     */\r\n    public static fakeParse(str: IndexedString, nullValuesSupport: boolean, columns: string[]): ErrorWithTextRange[] {\r\n        const errors: ErrorWithTextRange[] = [];\r\n        let tokens: ValueToken[] = ValueParser.parseTokens(str, nullValuesSupport, false, errors);\r\n        tokens.forEach(token => {\r\n            if (token instanceof ReferenceToken && columns.indexOf(token.str.toString()) === -1) {\r\n                errors.push(ErrorFactory.semanticError(SemanticErrorCodes.referenceValue_eval_absentColumn,\r\n                    getRange(token.str), token.str.toString(), columns.join(', ')));\r\n            }\r\n        })\r\n        this.assertValidInfixTokens(tokens, false, errors);\r\n        return errors;\r\n    }\r\n\r\n    /**\r\n     * Parses given string infix boolean and algebraic expression into an array of Tokens.\r\n     * Tokens are returned infix (in order parsed from string).\r\n     * If doThrow is true, found errors are thrown. Otherwise, they are added in errors array and ignored.\r\n     *\r\n     * @param str infix boolean and algebraic expression to be parsed\r\n     * @param nullValuesSupport whether null values are supported\r\n     * @param doThrow true if errors should be thrown\r\n     * @param errors array for storing not thrown errors\r\n     * @return infix array of parsed Tokens\r\n     */\r\n    public static parseTokens(str: string | IndexedString, nullValuesSupport: boolean, doThrow: boolean,\r\n                              errors: ErrorWithTextRange[] = []): ValueToken[] {\r\n        const handleError = (error: RASyntaxError) => {\r\n            if (doThrow) {\r\n                throw error;\r\n            }\r\n            else {\r\n                errors.push(error);\r\n            }\r\n        }\r\n        let rest: string | IndexedString = str.trim();\r\n        if (isEmpty(rest)) {\r\n            handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_parseTokens_emptyInput, undefined));\r\n        }\r\n        const tokens: ValueToken[] = [];\r\n        while (!isEmpty(rest)) {\r\n            rest = rest.trim();\r\n            // PARENTHESES\r\n            if (rest.startsWith('(')) {\r\n                tokens.push(new OpeningParentheses(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            else if (rest.startsWith(')')) {\r\n                tokens.push(new ClosingParentheses(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            // COMPUTING OPERATORS\r\n            else if (rest.startsWith('+')) {\r\n                tokens.push(new ComputingPlusToken(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            else if (rest.startsWith('-')) {\r\n                tokens.push(new ComputingMinusToken(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            else if (rest.startsWith('*')) {\r\n                tokens.push(new ComputingMultiplicationToken(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            else if (rest.startsWith('/')) {\r\n                tokens.push(new ComputingDivisionToken(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            // COMPARING OPERATORS\r\n            else if (rest.startsWith('==')) {\r\n                tokens.push(new ComparingToken(ComparingOperatorType.equal, rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n            }\r\n            else if (rest.startsWith('=')) {     // NOTE: needs to be after '==' check\r\n                tokens.push(new ComparingToken(ComparingOperatorType.equal, rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            else if (rest.startsWith('!=')) {\r\n                tokens.push(new ComparingToken(ComparingOperatorType.nonEqual, rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n            }\r\n            else if (rest.startsWith('<>')) {\r\n                tokens.push(new ComparingToken(ComparingOperatorType.nonEqual, rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n            }\r\n            else if (rest.startsWith('<=')) {\r\n                tokens.push(new ComparingToken(ComparingOperatorType.lessOrEqual, rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n            }\r\n            else if (rest.startsWith('>=')) {\r\n                tokens.push(new ComparingToken(ComparingOperatorType.moreOrEqual, rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n            }\r\n            else if (rest.startsWith('<')) {\r\n                tokens.push(new ComparingToken(ComparingOperatorType.less, rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            else if (rest.startsWith('>')) {\r\n                tokens.push(new ComparingToken(ComparingOperatorType.more, rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            // LOGICAL OPERATORS\r\n            else if (rest.startsWith('!')) {     // NOTE: needs to be after '!=' check\r\n                tokens.push(new LogicalNotToken(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            else if (rest.startsWith('~')) {\r\n                tokens.push(new LogicalNotToken(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            else if (rest.startsWith('&&')) {\r\n                tokens.push(new LogicalAndToken(rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n            }\r\n            else if (rest.startsWith('&')) {     // NOTE: needs to be after '&&' check\r\n                tokens.push(new LogicalAndToken(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            else if (rest.startsWith('||')) {\r\n                tokens.push(new LogicalOrToken(rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n            }\r\n            else if (rest.startsWith('|')) {     // NOTE: needs to be after '||' check\r\n                tokens.push(new LogicalOrToken(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            // LITERALS\r\n            else if (rest.startsWith('\"')) {\r\n                try {\r\n                    let split = nextBorderedPart(rest, '\"', '\"', '\\\\');\r\n                    tokens.push(new LiteralToken(split.first, split.first.toString(), \"string\"));\r\n                    rest = split.second;\r\n                }\r\n                catch (err) {\r\n                    handleError(err);\r\n                    break;\r\n                }\r\n            }\r\n            else if (Parser.isDigit(rest.charAt(0))) {\r\n                let split = (rest instanceof IndexedString) ? ParserIndexed.nextNumber(rest) : Parser.nextNumber(rest);\r\n                tokens.push(new LiteralToken(split.first, Number(split.first.toString()), \"number\"));\r\n                rest = split.second;\r\n            }\r\n            else if (rest.startsWith('null')) {\r\n                if (!nullValuesSupport) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_parseTokens_unsupportedNull,\r\n                        getRange(rest.slice(0, 4))));\r\n                }\r\n                tokens.push(new LiteralToken(rest.slice(0, 4), null, \"null\"));\r\n                rest = rest.slice(4);\r\n            }\r\n            else if (rest.startsWith('true') || rest.startsWith('True') || rest.startsWith('TRUE')) {\r\n                tokens.push(new LiteralToken(rest.slice(0, 4), true, \"boolean\"));\r\n                rest = rest.slice(4);\r\n            }\r\n            else if (rest.startsWith('false') || rest.startsWith('False') || rest.startsWith('FALSE')) {\r\n                tokens.push(new LiteralToken(rest.slice(0, 5), false, \"boolean\"));\r\n                rest = rest.slice(5);\r\n            }\r\n            // COLUMN REFERENCE\r\n            else if (Parser.isLetter(rest.charAt(0)) || rest.charAt(0) === '_') {\r\n                let split = (rest instanceof IndexedString) ? ParserIndexed.nextName(rest) : Parser.nextName(rest);\r\n                tokens.push(new ReferenceToken(split.first));\r\n                rest = split.second;\r\n            }\r\n            // UNEXPECTED PART\r\n            else {\r\n                const split = (rest instanceof IndexedString) ? ParserIndexed.nextNonWhitespacePart(rest) : Parser.nextNonWhitespacePart(rest);\r\n                handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_parseTokens_unexpectedPart,\r\n                    getRange(split.first), split.first.toString()));\r\n                rest = rest.slice(length(split.first));\r\n            }\r\n        }\r\n        return tokens;\r\n    }\r\n\r\n    /**\r\n     * It checks whether all adjacent pairs of tokens are possible and if the array start and end are valid\r\n     * (e.i., it starts with '(', literal, column reference or '!' and it ends with ')', literal or column reference).\r\n     * If doThrow is true, found errors are thrown. Otherwise, they are added in errors array and ignored.\r\n     */\r\n    public static assertValidInfixTokens(tokens: ValueToken[], doThrow: boolean, errors: ErrorWithTextRange[] = []) {\r\n        if (tokens.length === 0) {\r\n            return;\r\n        }\r\n        \r\n        const handleError = (error: RASyntaxError) => {\r\n            if (doThrow) {\r\n                throw error;\r\n            }\r\n            else {\r\n                errors.push(error);\r\n            }\r\n        }\r\n        \r\n        // checks start of an array: it must start with '(', literal, reference or '!'\r\n        // it cannot start with binary operator or ')'\r\n        if ((tokens[0] instanceof ClosingParentheses) || ((tokens[0] instanceof OperatorToken) && !(tokens[0] instanceof LogicalNotToken))) {\r\n            handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_invalidStart,\r\n                tokens[0].getRange(), tokens[0].str.toString()));\r\n        }\r\n        // checks end of an array: it must end with ')', literal or reference\r\n        // it cannot end with operator or '('\r\n        if ((tokens[tokens.length - 1] instanceof OpeningParentheses) || (tokens[tokens.length - 1] instanceof OperatorToken)) {\r\n            handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_invalidEnd,\r\n                tokens[tokens.length - 1].getRange(), tokens[tokens.length - 1].str.toString()));\r\n        }\r\n        // checks adjacent pairs of tokens\r\n        let i2: number = 1;\r\n        while (i2 < tokens.length) {\r\n            const token1: ValueToken = tokens[i2 - 1];\r\n            const token2: ValueToken = tokens[i2];\r\n            ++i2;\r\n\r\n            // valid predecessors: operator or '('\r\n            // invalid predecessors: literal, reference or ')'\r\n            if (token2 instanceof LiteralToken) {\r\n                if (token1 instanceof LiteralToken) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_literalAfterLiteral,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof ReferenceToken) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_literalAfterReference,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof ClosingParentheses) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_literalAfterClosing,\r\n                        token2.getRange(), token2.str.toString()));\r\n                }\r\n            }\r\n            // valid predecessors: operator or '('\r\n            // invalid predecessors: literal, reference or ')'\r\n            else if (token2 instanceof ReferenceToken) {\r\n                if (token1 instanceof LiteralToken) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_referenceAfterLiteral,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof ReferenceToken) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_referenceAfterReference,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof ClosingParentheses) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_referenceAfterClosing,\r\n                        token2.getRange(), token2.str.toString()));\r\n                }\r\n            }\r\n            // valid predecessors: operator or '('\r\n            // invalid predecessors: literal, reference or ')'\r\n            else if (token2 instanceof LogicalNotToken) {\r\n                if (token1 instanceof LiteralToken) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_notAfterLiteral,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof ReferenceToken) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_notAfterReference,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof ClosingParentheses) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_notAfterClosing,\r\n                        token2.getRange(), token2.str.toString()));\r\n                }\r\n            }\r\n            // valid predecessors: literal, reference or ')'\r\n            // invalid predecessors: operator or '('\r\n            else if (token2 instanceof OperatorToken /* only binary (without LogicalNotToken) */ ) {\r\n                if (token1 instanceof OperatorToken) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_binaryAfterOperator,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof OpeningParentheses) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_binaryAfterOpening,\r\n                        token2.getRange(), token2.str.toString()));\r\n                }\r\n            }\r\n            // valid predecessors: operator or '('\r\n            // invalid predecessors: literal, reference or ')'\r\n            else if (token2 instanceof OpeningParentheses) {\r\n                if (token1 instanceof LiteralToken) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_openingAfterLiteral,\r\n                        token2.getRange(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof ReferenceToken) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_openingAfterReference,\r\n                        token2.getRange(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof ClosingParentheses) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_openingAfterClosing,\r\n                        token2.getRange()));\r\n                }\r\n            }\r\n            // valid predecessors: literal or reference\r\n            // invalid predecessors: operator, '(' or ')'\r\n            else if (token2 instanceof ClosingParentheses) {\r\n                if (token1 instanceof OperatorToken) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_closingAfterOperator,\r\n                        token2.getRange(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof OpeningParentheses) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_closingAfterOpening,\r\n                        token2.getRange()));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Simplifies given token array in infix form. That means all groups of LogicalNotTokens ('!') are reduced to 1 or 0\r\n     * tokens (\"!\" => \"!\", \"!!\" => \"\", \"!!!\" => \"!\", \"!!!!\" => \"\", ...).\r\n     *\r\n     * @param tokens tokens to simplify\r\n     */\r\n    public static simplify(tokens: ValueToken[]): ValueToken[] {\r\n        const notIndexes: number[] = [];\r\n        const indexesToRemove: Set<number> = new Set<number>();\r\n        // finds indexes in tokens where '!'s are\r\n        tokens.forEach((token, i) => {\r\n            if (token instanceof LogicalNotToken) {\r\n                notIndexes.push(i);\r\n            }\r\n        });\r\n        for (let i = 1; i < notIndexes.length; ++i) {\r\n            // if there is \"x - 1\" and \"x\" next to each other, adds them to remove\r\n            if (notIndexes[i - 1] + 1 === notIndexes[i]) {\r\n                indexesToRemove.add(notIndexes[i - 1]);\r\n                indexesToRemove.add(notIndexes[i]);\r\n                notIndexes[i] = NaN; // sets to NaN to not remove possible third '!' in a row\r\n            }\r\n        }\r\n        if (indexesToRemove.size === 0) {\r\n            return tokens;\r\n        }\r\n        return tokens.filter((t, i) => !indexesToRemove.has(i));\r\n    }\r\n\r\n    /**\r\n     * Transforms given infix boolean and algebraic expression into postfix (reverse polish) form.\r\n     *\r\n     * @param tokens infix boolean and algebraic expression as Token array\r\n     * @return postfix (reverse polish) form of given array\r\n     */\r\n    public static toRPN(tokens: ValueToken[]): ValueToken[] {\r\n        const rpnQueue: ValueToken[] = [];\r\n        const operatorsStack: Array<OperatorToken | ParenthesisToken> = [];\r\n        tokens.forEach(token => {\r\n            if (token instanceof LiteralToken || token instanceof ReferenceToken) {\r\n                rpnQueue.push(token);\r\n            }\r\n            else if (token instanceof OperatorToken) {\r\n                while (operatorsStack.length > 0 && operatorsStack[operatorsStack.length - 1] instanceof OperatorToken) {\r\n                    // @ts-ignore (token must be of OperatorToken class)\r\n                    let other: OperatorToken = operatorsStack[operatorsStack.length - 1];\r\n                    // all used operators have left associativity\r\n                    if (token.precedence <= other.precedence) {\r\n                        // @ts-ignore (token must be present)\r\n                        rpnQueue.push(operatorsStack.pop());\r\n                    }\r\n                    else {\r\n                        break;\r\n                    }\r\n                }\r\n                operatorsStack.push(token);\r\n            }\r\n            else if (token instanceof OpeningParentheses) {\r\n                operatorsStack.push(token);\r\n            }\r\n            else if (token instanceof ClosingParentheses) {\r\n                while (true) {\r\n                    if (operatorsStack.length === 0) {\r\n                        throw ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_toRPN_missingOpeningParenthesis,\r\n                            undefined);\r\n                    }\r\n                    if (operatorsStack[operatorsStack.length - 1] instanceof OpeningParentheses) {\r\n                        operatorsStack.pop();\r\n                        break;\r\n                    }\r\n                    // @ts-ignore (token must be present)\r\n                    rpnQueue.push(operatorsStack.pop());\r\n                }\r\n            }\r\n        });\r\n        while (operatorsStack.length > 0) {\r\n            // @ts-ignore (token must be present)\r\n            const curToken: ValueToken = operatorsStack.pop();\r\n            if (curToken instanceof OpeningParentheses) {\r\n                throw ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_toRPN_missingClosingParenthesis,\r\n                    undefined);\r\n            }\r\n            else {\r\n                rpnQueue.push(curToken);\r\n            }\r\n        }\r\n        return rpnQueue;\r\n    }\r\n\r\n    /**\r\n     * Creates a value-evaluating tree from the given array of tokens in reverse polish form.\r\n     * Wraps recursive function rpnToVETreeRecursive(tokens), when not all tokens are used, throws error.\r\n     *\r\n     * @param tokens value-evaluating expression in reverse polish form\r\n     * @return VETreeNode tree (its root)\r\n     */\r\n    public static rpnToVETree(tokens: ValueToken[]): VETreeNode {\r\n        const ret: VETreeNode = this.rpnToVETreeRecursive(tokens);\r\n        // not all tokens were used\r\n        if (tokens.length > 0) {\r\n            throw ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_invalidExpression, undefined);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Creates a value-evaluating tree from the given array of tokens in reverse polish form.\r\n     *\r\n     * @param tokens value-evaluating expression in reverse polish form\r\n     * @return VETreeNode tree (its root)\r\n     */\r\n    public static rpnToVETreeRecursive(tokens: ValueToken[]): VETreeNode {\r\n        if (tokens.length === 0) {\r\n            throw ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_invalidExpression, undefined);\r\n        }\r\n        // @ts-ignore (there must be a token)\r\n        const token: ValueToken = tokens.pop();\r\n        if (token instanceof LogicalNotToken) {\r\n            const subtree: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            return LogicalOperator.not(token.str, subtree);\r\n        }\r\n        if (token instanceof LogicalAndToken) {\r\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            return LogicalOperator.and(token.str, left, right);\r\n        }\r\n        if (token instanceof LogicalOrToken) {\r\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            return LogicalOperator.or(token.str, left, right);\r\n        }\r\n        if (token instanceof ComparingToken) {\r\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            return new ComparingOperator(token.type, token.str.toString(), left, right);\r\n        }\r\n        if (token instanceof LiteralToken) {\r\n            return new LiteralValue(token.value, token.type);\r\n        }\r\n        if (token instanceof ReferenceToken) {\r\n            return new ReferenceValue(token.str);\r\n        }\r\n        if (token instanceof ComputingPlusToken) {\r\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            return ComputingOperator.add(left, right, token.getRange());\r\n        }\r\n        if (token instanceof ComputingMinusToken) {\r\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            return ComputingOperator.deduct(left, right, token.getRange());\r\n        }\r\n        if (token instanceof ComputingMultiplicationToken) {\r\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            return ComputingOperator.multiply(left, right, token.getRange());\r\n        }\r\n        if (token instanceof ComputingDivisionToken) {\r\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            return ComputingOperator.divide(left, right, token.getRange());\r\n        }\r\n        // should never happen\r\n        throw ErrorFactory.codeError(CodeErrorCodes.valueParser_rpnToVETreeRecursive_unexpectedToken, JSON.stringify(token));\r\n    }\r\n}","import UnaryNode from \"./unaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport {VETreeNode} from \"../vetree/veTreeNode\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\nimport {ParameterizedNode} from \"./parameterizedNode\";\r\nimport {getRange, IndexedString} from \"../tools/indexedString\";\r\nimport ValueParser from \"../expression/valueParser\";\r\nimport {ErrorFactory, SyntaxErrorCodes} from \"../error/errorFactory\";\r\nimport ErrorWithTextRange, {insertRangeIfUndefined} from \"../error/errorWithTextRange\";\r\n\r\n/**\r\n * Selection node of the relational algebra syntactic tree.\r\n */\r\nexport default class SelectionNode extends UnaryNode implements ParameterizedNode {\r\n\r\n    private readonly selection: string | IndexedString;\r\n    private readonly stringRange: { start: number, end: number } | undefined;\r\n    private readonly nullValuesSupport: boolean;\r\n\r\n    /**\r\n     * Expects the selection string to start with '(' and end with ')'.\r\n     *\r\n     * @param selection\r\n     * @param subtree\r\n     * @param nullValuesSupport\r\n     */\r\n    public constructor(selection: string | IndexedString, subtree: RATreeNode, nullValuesSupport: boolean) {\r\n        super(subtree);\r\n        this.selection = selection;\r\n        this.stringRange = getRange(selection);\r\n        this.nullValuesSupport = nullValuesSupport;\r\n    }\r\n\r\n    /**\r\n     * Expectations: condition is valid expression which evaluates to boolean\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n\r\n        let boolExpr: VETreeNode;\r\n        try {\r\n            boolExpr = ValueParser.parse(this.selection.slice(1, -1), this.nullValuesSupport);\r\n        }\r\n        catch (e) {\r\n            throw insertRangeIfUndefined(e, this.stringRange);\r\n        }\r\n\r\n        const source: Relation = this.subtree.getResult();\r\n        const result: Relation = new Relation(source.name + \"(...)\");\r\n        source.forEachColumn((type, name) => result.addColumn(name, type));\r\n\r\n        source.getRows().forEach(row => {\r\n            let bool: { value: ColumnContent, type: SupportedColumnType | \"null\" } = boolExpr.eval(row);\r\n            if (bool.type !== \"boolean\") {\r\n                throw ErrorFactory.syntaxError(SyntaxErrorCodes.selectionNode_eval_resultNotBoolean,\r\n                    this.stringRange, this.selection.replace(/\\s+/g, \" \"), bool.type);\r\n            }\r\n            if (bool.value) {\r\n                result.addRow(row);\r\n            }\r\n        });\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: columns names used in the condition exists in source schema\r\n     * Returned schema: source schema\r\n     * Usage of absent column names does not affect returned schema.\r\n     */\r\n    public fakeEval(cursorIndex: number): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} {\r\n        let {result, whispers, errors} = this.subtree.fakeEval(cursorIndex);\r\n        const newResult = new Relation(result.getName() + \"(...)\");\r\n        result.forEachColumn((type, name) => {\r\n            newResult.addColumn(name, type);\r\n        });\r\n        result = newResult;\r\n        // checks whether the cursor is in this selection block - saves current available columns\r\n        if (this.stringRange !== undefined && this.stringRange.start < cursorIndex && cursorIndex <= this.stringRange.end) {\r\n            whispers = result.getColumnNames();\r\n        }\r\n        // checks empty selection input\r\n        if (this.selection.toString().slice(1, -1).trim().length  === 0) {\r\n            errors.push(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_parseTokens_emptyInput, this.stringRange));\r\n        }\r\n        // adds errors from current expression\r\n        else if (this.selection instanceof IndexedString) {\r\n            errors.push(...ValueParser.fakeParse(this.selection.slice(1, -1), this.nullValuesSupport, result.getColumnNames()));\r\n        }\r\n        // result schema is the same as the source\r\n        return {result, whispers, errors};\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return \"Selection of \" + this.selection.replace(/\\s+/g, \" \") + \" from {\" + this.subtree.printInLine() + \"}\";\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        return \"Selection\";\r\n    }\r\n\r\n    public getParameter(): string {\r\n        return this.selection.replace(/\\s+/g, \" \");\r\n    }\r\n}","import RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\n\r\n/**\r\n * Classes extending binary node.\r\n */\r\nexport type BinaryNodeClass = \"left antijoin\" | \"right antijoin\" | \"cartesian product\" | \"division\" | \"natural join\"\r\n    | \"left outer join\" | \"right outer join\" | \"full outer join\" | \"left semijoin\" | \"right semijoin\" | \"union\"\r\n    | \"intersection\" | \"difference\" | \"theta join\" | \"left theta semijoin\" | \"right theta semijoin\";\r\n\r\n/**\r\n * Abstract node of the relational algebra syntactic tree with two subtrees.\r\n */\r\nexport default abstract class BinaryNode extends RATreeNode {\r\n\r\n    protected leftSubtree: RATreeNode;\r\n    protected rightSubtree: RATreeNode;\r\n\r\n    protected constructor(left: RATreeNode, right: RATreeNode) {\r\n        super();\r\n        this.leftSubtree = left;\r\n        this.rightSubtree = right;\r\n    }\r\n\r\n    public getLeftSubtree(): RATreeNode {\r\n        return this.leftSubtree;\r\n    }\r\n\r\n    public getRightSubtree(): RATreeNode {\r\n        return this.rightSubtree;\r\n    }\r\n\r\n    /**\r\n     * Fake evaluates left and right subtrees of the current not-parametrized binary node.\r\n     * If not, returns new simple faked schema with empty \"\" name:\r\n     * - type = union: returns union of source schemas\r\n     * - type = left: returns left source schema\r\n     * - type = right: returns right source schema\r\n     */\r\n    protected fakeEvalBinary(cursorIndex: number, type: \"union\" | \"left\" | \"right\"): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} {\r\n        // evaluates the subtrees\r\n        const left: {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} = this.leftSubtree.fakeEval(cursorIndex);\r\n        const right: {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} = this.rightSubtree.fakeEval(cursorIndex);\r\n        // creates return relation\r\n        const result: Relation = new Relation(\"\");\r\n        if (type === \"left\" || type === \"union\") {\r\n            left.result.forEachColumn((type, name) => result.addColumn(name, type));\r\n        }\r\n        if (type === \"right\" || type === \"union\") {\r\n            right.result.forEachColumn((type, name) => result.addColumn(name, type));\r\n        }\r\n        left.errors.push(...right.errors);\r\n        return {result, whispers: left.whispers.length !== 0 ? left.whispers : right.whispers, errors: left.errors};\r\n    }\r\n}","import BinaryNode from \"./binaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport Row from \"../relation/row\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\n\r\n/**\r\n * Types of outer join node.\r\n */\r\nexport enum OuterJoinType {\r\n    left = \"*L*\",\r\n    right = \"*R*\",\r\n    full = \"*F*\"\r\n}\r\n\r\n/**\r\n * Outer join node of the relational algebra syntactic tree.\r\n */\r\nexport default class OuterJoinNode extends BinaryNode {\r\n\r\n    private readonly type: OuterJoinType;\r\n\r\n    public constructor(operator: OuterJoinType, leftSubtree: RATreeNode, rightSubtree: RATreeNode) {\r\n        super(leftSubtree, rightSubtree);\r\n        this.type = operator;\r\n    }\r\n\r\n    /**\r\n     * Expectations on source schemas: none\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n        const leftSource: Relation = this.leftSubtree.getResult();\r\n        const rightSource: Relation = this.rightSubtree.getResult();\r\n        // change of relational schema\r\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + this.type + rightSource.getName() + \")\");\r\n        leftSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n        rightSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n        // join of relation rows\r\n        const leftRows: Row[] = leftSource.getRows();\r\n        const rightRows: Row[] = rightSource.getRows();\r\n        // intersection of columns in left and right subtree\r\n        const commonColumns: string[] = leftSource.getColumnNames().filter(lc => rightSource.hasColumn(lc));\r\n        // adds naturally joined rows\r\n        leftRows.forEach(leftRow => {\r\n            rightRows.forEach(rightRow => {\r\n                // if all common columns have the same value\r\n                if (commonColumns.every(c => leftRow.getValue(c) === rightRow.getValue(c))) {\r\n                    let newRow: Row = new Row(result.getColumns());\r\n                    leftRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                    rightRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                    result.addRow(newRow);\r\n                }\r\n            });\r\n        });\r\n        // adds left source rows with right null values\r\n        if (this.type === OuterJoinType.left || this.type === OuterJoinType.full) {\r\n            leftRows.forEach(leftRow => {\r\n                let someMatch: boolean = rightRows.some(rightRow => {\r\n                    // if all common columns match, the row should not be added\r\n                    return commonColumns.every(c => leftRow.getValue(c) === rightRow.getValue(c));\r\n                });\r\n                if (!someMatch) {\r\n                    let newRow: Row = new Row(result.getColumns());\r\n                    leftRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                    result.addRow(newRow);\r\n                }\r\n            });\r\n        }\r\n        // adds right source rows with left null values\r\n        if (this.type === OuterJoinType.right || this.type === OuterJoinType.full) {\r\n            rightRows.forEach(rightRow => {\r\n                let someMatch: boolean = leftRows.some(leftRow => {\r\n                    // if all common columns match, the row should not be added\r\n                    return commonColumns.every(c => leftRow.getValue(c) === rightRow.getValue(c));\r\n                });\r\n                if (!someMatch) {\r\n                    let newRow: Row = new Row(result.getColumns());\r\n                    rightRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                    result.addRow(newRow);\r\n                }\r\n            });\r\n        }\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: none\r\n     * Returned schema: union of source schemas (in all cases - full/left/right)\r\n     */\r\n    public fakeEval(cursorIndex: number): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} {\r\n        return this.fakeEvalBinary(cursorIndex, \"union\");\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return this.getOperationName() + \" of {\" + this.leftSubtree.printInLine() + \"} and {\" + this.rightSubtree.printInLine() + \"}\";\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        let typeStr: string;\r\n        if (this.type === OuterJoinType.left) {\r\n            typeStr = \"Left\";\r\n        }\r\n        else if (this.type === OuterJoinType.right) {\r\n            typeStr = \"Right\";\r\n        }\r\n        else {\r\n            typeStr = \"Full\";\r\n        }\r\n        return typeStr + \" outer join\";\r\n    }\r\n}","import BinaryNode from \"./binaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport Row from \"../relation/row\";\r\nimport {ErrorFactory, SemanticErrorCodes} from \"../error/errorFactory\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\n\r\n/**\r\n * Cartesian product node of the relational algebra syntactic tree.\r\n */\r\nexport default class CartesianProductNode extends BinaryNode {\r\n\r\n    public constructor(leftSubtree: RATreeNode, rightSubtree: RATreeNode, private stringRange?: { start: number, end: number }) {\r\n        super(leftSubtree, rightSubtree);\r\n    }\r\n\r\n    /**\r\n     * Expectations on source schemas: disjointness\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n        const leftSource: Relation = this.leftSubtree.getResult();\r\n        const rightSource: Relation = this.rightSubtree.getResult();\r\n        // join of relational schema\r\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + \"\\u2a2f\" + rightSource.getName() + \")\");\r\n        leftSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n        rightSource.forEachColumn((type, name) => {\r\n            if (!result.addColumn(name, type)) {\r\n                throw ErrorFactory.semanticError(SemanticErrorCodes.binaryNode_eval_commonColumnsInSources,\r\n                    this.stringRange, \"cartesian product\", name);\r\n            }\r\n        });\r\n        // join of relation rows\r\n        leftSource.getRows().forEach(leftRow => {\r\n            rightSource.getRows().forEach(rightRow => {\r\n                let newRow: Row = new Row(result.getColumns());\r\n                leftRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                rightRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                result.addRow(newRow);\r\n            });\r\n        });\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: disjointness\r\n     * Returned schema: union of source schemas\r\n     * Returned fake schema is not affected when disjointness is not held\r\n     */\r\n    public fakeEval(cursorIndex: number): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]}{\r\n        // evaluates the subtrees\r\n        const left: {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} = this.leftSubtree.fakeEval(cursorIndex);\r\n        const right: {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} = this.rightSubtree.fakeEval(cursorIndex);\r\n        // creates return relation\r\n        const result: Relation = new Relation(\"\");\r\n        left.result.forEachColumn((type, name) => result.addColumn(name, type));\r\n        right.result.forEachColumn((type, name) => result.addColumn(name, type));\r\n        // checks errors\r\n        left.errors.push(...right.errors);\r\n        const commonColumns: string[] = [];\r\n        left.result.getColumnNames().forEach(leftColumn => {\r\n            if (right.result.hasColumn(leftColumn)) {\r\n                commonColumns.push(leftColumn);\r\n            }\r\n        });\r\n        if (commonColumns.length > 0) {\r\n            left.errors.push(ErrorFactory.semanticError(SemanticErrorCodes.binaryNode_eval_commonColumnsInSources,\r\n                this.stringRange, \"cartesian product\", commonColumns.join('\", \"')));\r\n        }\r\n        return {result, whispers: left.whispers.length !== 0 ? left.whispers : right.whispers, errors: left.errors};\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return \"Cartesian product of {\" + this.leftSubtree.printInLine() + \"} and {\" + this.rightSubtree.printInLine() + \"}\";\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        return \"Cartesian product\";\r\n    }\r\n}","import BinaryNode from \"./binaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport Row from \"../relation/row\";\r\nimport {SupportedColumnType} from \"../relation/columnType\";\r\nimport {ErrorFactory, SemanticErrorCodes} from \"../error/errorFactory\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\n\r\n/**\r\n * Division node of the relational algebra syntactic tree.\r\n */\r\nexport default class DivisionNode extends BinaryNode {\r\n\r\n    public constructor(leftSubtree: RATreeNode, rightSubtree: RATreeNode, private stringRange?: { start: number, end: number }) {\r\n        super(leftSubtree, rightSubtree);\r\n    }\r\n\r\n    /**\r\n     * Expectations on source schemas: right source schema is a proper subset of left source schema\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n        const leftSource: Relation = this.leftSubtree.getResult();\r\n        const rightSource: Relation = this.rightSubtree.getResult();\r\n        const leftColumns: Map<string, SupportedColumnType> = leftSource.getColumns();\r\n        const rightColumns: Map<string, SupportedColumnType> = rightSource.getColumns();\r\n\r\n        if (![...rightColumns].every(value => leftColumns.has(value[0]) && leftColumns.get(value[0]) === value[1])) {\r\n            throw ErrorFactory.semanticError(SemanticErrorCodes.divisionNode_eval_rightColumnsNotSubsetOfLeft,\r\n                this.stringRange, rightSource.getSchemaString(), leftSource.getSchemaString());\r\n        }\r\n\r\n        // difference of columns in left and right subtree\r\n        const resultColumns: Map<string, SupportedColumnType> = new Map<string, SupportedColumnType>();\r\n        leftColumns.forEach((type, name) => {\r\n           if (!rightColumns.has(name)) {\r\n               resultColumns.set(name, type);\r\n           }\r\n        });\r\n\r\n        if (resultColumns.size === 0) {\r\n            throw ErrorFactory.semanticError(SemanticErrorCodes.divisionNode_eval_rightColumnsNotProperSubsetOfLeft,\r\n                this.stringRange, rightSource.getNamesSchemaString(), leftSource.getNamesSchemaString());\r\n        }\r\n\r\n        // join of relational schema\r\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + \"\\u00f7\" + rightSource.getName() + \")\");\r\n        resultColumns.forEach((type, name) => result.addColumn(name, type));\r\n        // filter relation rows\r\n        const leftRows: Row[] = leftSource.getRows();\r\n        const rightRows: Row[] = rightSource.getRows();\r\n        leftRows.forEach(leftRow => {\r\n           if (rightRows.every(rightRow => {\r\n               // creates a row with left row's extra columns and right row's common columns\r\n               let testRow: Row = new Row(leftColumns);\r\n               // left row's extra columns\r\n               // @ts-ignore ('name' must be present in left row)\r\n               resultColumns.forEach((type, name) => testRow.addValue(name, leftRow.getValue(name)));\r\n               // right row's common columns\r\n               rightRow.getValues().forEach((type, name) => testRow.addValue(name, type));\r\n               // tests if the created row exists in left relation\r\n               return [...leftRows].some(lr => lr.equals(testRow));\r\n           })) {\r\n               let newRow: Row = new Row(result.getColumns());\r\n               // @ts-ignore ('name' must be present in left row)\r\n               resultColumns.forEach((value, name) => newRow.addValue(name, leftRow.getValue(name)));\r\n               result.addRow(newRow);\r\n           }\r\n        });\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: right source schema is a proper subset of left source schema\r\n     * Returned schema: left source schema minus right source schema\r\n     * Returned fake schema may be empty (right source schema may contain all left source columns).\r\n     */\r\n    public fakeEval(cursorIndex: number): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} {\r\n        const left: {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} = this.leftSubtree.fakeEval(cursorIndex);\r\n        const right: {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} = this.rightSubtree.fakeEval(cursorIndex);\r\n        const leftColumns = left.result.getColumns();\r\n        const rightColumns = right.result.getColumns();\r\n        // creates relation schema - \"left columns minus right columns\"\r\n        const resultColumns = new Map([...leftColumns.entries()].filter(([key, _]) => !rightColumns.has(key)));\r\n        const result = new Relation(\"(\" + left.result.getName() + \"\\u00f7\" + right.result.getName() + \")\");\r\n        resultColumns.forEach((type, name) => result.addColumn(name, type));\r\n        // checks errors in schema\r\n        const errors = left.errors;\r\n        errors.push(...right.errors);\r\n        if (![...rightColumns].every(value => leftColumns.has(value[0]) && leftColumns.get(value[0]) === value[1])\r\n            && left.result.getName() !== \"\") {\r\n            errors.push(ErrorFactory.semanticError(SemanticErrorCodes.divisionNode_eval_rightColumnsNotSubsetOfLeft,\r\n                this.stringRange, right.result.getSchemaString(), left.result.getSchemaString()));\r\n        }\r\n        else if (resultColumns.size === 0 && left.result.getName() !== \"\") {\r\n            errors.push(ErrorFactory.semanticError(SemanticErrorCodes.divisionNode_eval_rightColumnsNotProperSubsetOfLeft,\r\n                this.stringRange, right.result.getNamesSchemaString(), left.result.getNamesSchemaString()));\r\n        }\r\n        return {result, whispers: left.whispers.length !== 0 ? left.whispers : right.whispers, errors};\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return \"Division of {\" + this.leftSubtree.printInLine() + \"} and {\" + this.rightSubtree.printInLine() + \"}\";\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        return \"Division\";\r\n    }\r\n}","import BinaryNode from \"./binaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport Row from \"../relation/row\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\n\r\n/**\r\n * Types of natural join node.\r\n */\r\nexport enum NaturalJoinType {\r\n    natural = \"*\",\r\n    leftSemi = \"<*\",\r\n    rightSemi = \"*>\"\r\n}\r\n\r\n/**\r\n * Natural join or semi join node of the relational algebra syntactic tree.\r\n */\r\nexport default class NaturalJoinNode extends BinaryNode {\r\n\r\n    private readonly type: NaturalJoinType;\r\n\r\n    public constructor(operator: NaturalJoinType, leftSubtree: RATreeNode, rightSubtree: RATreeNode) {\r\n        super(leftSubtree, rightSubtree);\r\n        this.type = operator;\r\n    }\r\n\r\n    /**\r\n     * Expectations on source schemas: none\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n        const leftSource: Relation = this.leftSubtree.getResult();\r\n        const rightSource: Relation = this.rightSubtree.getResult();\r\n        // intersection of columns in left and right subtree\r\n        const commonColumns: string[] = leftSource.getColumnNames().filter(lc => rightSource.hasColumn(lc));\r\n        // change of relational schema\r\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + this.type + rightSource.getName() + \")\");\r\n        if (this.type === NaturalJoinType.leftSemi || this.type === NaturalJoinType.natural) {\r\n            leftSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n        }\r\n        if (this.type === NaturalJoinType.rightSemi || this.type === NaturalJoinType.natural) {\r\n            rightSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n        }\r\n        // join of relation rows\r\n        leftSource.getRows().forEach(leftRow => {\r\n            rightSource.getRows().forEach(rightRow => {\r\n                // if all common columns have the same value\r\n                if ([...commonColumns].every(c => leftRow.getValue(c) === rightRow.getValue(c))) {\r\n                    let newRow: Row = new Row(result.getColumns());\r\n                    if (this.type === NaturalJoinType.leftSemi || this.type === NaturalJoinType.natural) {\r\n                        leftRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                    }\r\n                    if (this.type === NaturalJoinType.rightSemi || this.type === NaturalJoinType.natural) {\r\n                        rightRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                    }\r\n                    result.addRow(newRow);\r\n                }\r\n            });\r\n        });\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: none\r\n     * Returned schema: left/right/both source schema (for left-semijoin/right-semijoin/natural join)\r\n     */\r\n    public fakeEval(cursorIndex: number): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} {\r\n        let type: \"union\" | \"left\" | \"right\" = \"union\";\r\n        if (this.type === NaturalJoinType.leftSemi) {\r\n            type = \"left\";\r\n        }\r\n        else if (this.type === NaturalJoinType.rightSemi) {\r\n            type = \"right\";\r\n        }\r\n        return this.fakeEvalBinary(cursorIndex, type);\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return this.getOperationName() + \" of {\" + this.leftSubtree.printInLine() + \"} and {\" + this.rightSubtree.printInLine() + \"}\";\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        if (this.type === NaturalJoinType.leftSemi) {\r\n            return \"Left semijoin\";\r\n        }\r\n        else if (this.type === NaturalJoinType.rightSemi) {\r\n            return \"Right semijoin\";\r\n        }\r\n        else {\r\n            return \"Natural join\";\r\n        }\r\n    }\r\n\r\n    public getType(): NaturalJoinType {\r\n        return this.type;\r\n    }\r\n}","import BinaryNode from \"./binaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport Row from \"../relation/row\";\r\nimport { isEqual } from \"lodash\";\r\nimport {ErrorFactory, SemanticErrorCodes} from \"../error/errorFactory\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\n\r\n/**\r\n * Types of set operation node.\r\n */\r\nexport enum SetOperationType {\r\n    union = \"\\u222a\",\r\n    intersection = \"\\u2229\",\r\n    difference = \"\\\\\"\r\n}\r\n\r\n/**\r\n * Set operation node of the relational algebra syntactic tree.\r\n */\r\nexport default class SetOperationNode extends BinaryNode {\r\n\r\n    private readonly type: SetOperationType;\r\n\r\n    public constructor(operator: SetOperationType, leftSubtree: RATreeNode, rightSubtree: RATreeNode,\r\n                       private stringRange?: { start: number, end: number }) {\r\n        super(leftSubtree, rightSubtree);\r\n        this.type = operator;\r\n    }\r\n\r\n    private getTypeStr(): string {\r\n        if (this.type === SetOperationType.union) {\r\n            return \"Union\";\r\n        }\r\n        else if (this.type === SetOperationType.intersection) {\r\n            return \"Intersection\";\r\n        }\r\n        else {\r\n            return \"Difference\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Expectations on source schemas: equality\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n        const leftSource: Relation = this.leftSubtree.getResult();\r\n        const rightSource: Relation = this.rightSubtree.getResult();\r\n\r\n        if (!isEqual(leftSource.getColumns(), rightSource.getColumns())) {\r\n            let typeStr: string = this.getTypeStr().toLowerCase();\r\n            throw ErrorFactory.semanticError(SemanticErrorCodes.setOperationNode_eval_notEqualColumnsInSources,\r\n                this.stringRange, leftSource.getSchemaString(), rightSource.getSchemaString(), typeStr);\r\n        }\r\n        // copy of relational schema\r\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + this.type + rightSource.getName() + \")\");\r\n        leftSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n        // change of relation rows\r\n        let resultRows: Row[];\r\n        const leftRows: Row[] = leftSource.getRows();\r\n        const rightRows: Row[] = rightSource.getRows();\r\n        if (this.type === SetOperationType.union) {\r\n            resultRows = [...leftRows, ...rightRows];\r\n        }\r\n        else if (this.type === SetOperationType.intersection) {\r\n            resultRows = [...leftRows].filter(lr => [...rightRows].some(rr => lr.equals(rr)));\r\n        }\r\n        else /* this.type === SetOperationType.difference */ {\r\n            resultRows = [...leftRows].filter(lr => ![...rightRows].some(rr => lr.equals(rr)));\r\n        }\r\n        resultRows.forEach(row => result.addRow(row));\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: equality\r\n     * Returned schema: intersection of source schemas\r\n     * Returned schema may be empty (when there is no common column in sources).\r\n     * Second possible approach would be to return union of source schemas (less strict).\r\n     */\r\n    public fakeEval(cursorIndex: number): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} {\r\n        const left: {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} = this.leftSubtree.fakeEval(cursorIndex);\r\n        const right: {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} = this.rightSubtree.fakeEval(cursorIndex);\r\n        // join of relational schema - \"left intersection right\"\r\n        const result: Relation = new Relation(\"(\" + left.result.getName() + this.type + right.result.getName() + \")\");\r\n        left.result.forEachColumn((type, name) => {\r\n            if (right.result.hasColumn(name)) {\r\n                result.addColumn(name, type);\r\n            }\r\n        });\r\n        // checks errors in schema\r\n        const errors = left.errors;\r\n        errors.push(...right.errors);\r\n        if (!isEqual(left.result.getColumns(), right.result.getColumns()) && left.result.getName() !== \"\" && right.result.getName() !== \"\") {\r\n            let typeStr: string = this.getTypeStr().toLowerCase();\r\n            errors.push(ErrorFactory.semanticError(SemanticErrorCodes.setOperationNode_eval_notEqualColumnsInSources,\r\n                this.stringRange, left.result.getSchemaString(), right.result.getSchemaString(), typeStr));\r\n        }\r\n        return {result, whispers: left.whispers.length !== 0 ? left.whispers : right.whispers, errors};\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return this.getOperationName() + \" of {\" + this.leftSubtree.printInLine() + \"} and {\" + this.rightSubtree.printInLine() + \"}\";\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        return this.getTypeStr();\r\n    }\r\n}","import BinaryNode from \"./binaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport Row from \"../relation/row\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\nimport {VETreeNode} from \"../vetree/veTreeNode\";\r\nimport {ParameterizedNode} from \"./parameterizedNode\";\r\nimport {getRange, IndexedString} from \"../tools/indexedString\";\r\nimport ValueParser from \"../expression/valueParser\";\r\nimport {ErrorFactory, SemanticErrorCodes, SyntaxErrorCodes} from \"../error/errorFactory\";\r\nimport ErrorWithTextRange, {insertRangeIfUndefined} from \"../error/errorWithTextRange\";\r\n\r\n/**\r\n * Types of theta join node.\r\n */\r\nexport enum ThetaJoinType {\r\n    full = \"[]\",\r\n    left = \"<]\",\r\n    right = \"[>\"\r\n}\r\n\r\n/**\r\n * Theta join or theta semijoin node of the relational algebra syntactic tree.\r\n */\r\nexport default class ThetaJoinNode extends BinaryNode implements ParameterizedNode {\r\n\r\n    private readonly type: ThetaJoinType;\r\n    private readonly condition: string | IndexedString;\r\n    private readonly stringRange: { start: number, end: number } | undefined;\r\n    private readonly nullValuesSupport: boolean;\r\n\r\n    /**\r\n     * Expects the condition string to start with '<' and end with ']' or start with '[' and end with '>'.\r\n     */\r\n    public constructor(type: ThetaJoinType, condition: string | IndexedString,\r\n                       leftSubtree: RATreeNode, rightSubtree: RATreeNode, nullValuesSupport: boolean) {\r\n        super(leftSubtree, rightSubtree);\r\n        this.condition = condition;\r\n        this.stringRange = getRange(condition);\r\n        this.nullValuesSupport = nullValuesSupport;\r\n        this.type = type;\r\n    }\r\n\r\n    /**\r\n     * Expectations on source schemas: disjointness\r\n     * Other expectations: condition is valid expression which evaluates to boolean\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n\r\n        let boolExpr: VETreeNode;\r\n        try {\r\n            boolExpr = ValueParser.parse(this.condition.slice(1, -1), this.nullValuesSupport);   // slices brackets out\r\n        }\r\n        catch (e) {\r\n            throw insertRangeIfUndefined(e, this.stringRange);\r\n        }\r\n\r\n        const leftSource: Relation = this.leftSubtree.getResult();\r\n        const rightSource: Relation = this.rightSubtree.getResult();\r\n\r\n        leftSource.getColumnNames().forEach(leftColumn => {\r\n            if (rightSource.hasColumn(leftColumn)) {\r\n                throw ErrorFactory.semanticError(SemanticErrorCodes.binaryNode_eval_commonColumnsInSources, this.stringRange,\r\n                    this.getOperationName().toLowerCase(), leftColumn);\r\n            }\r\n        });\r\n        // change of relational schema\r\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + this.type.charAt(0) + \"...\" + this.type.charAt(1) + rightSource.getName() + \")\");\r\n        if (this.type === ThetaJoinType.left || this.type === ThetaJoinType.full) {\r\n            leftSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n        }\r\n        if (this.type === ThetaJoinType.right || this.type === ThetaJoinType.full) {\r\n            rightSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n        }\r\n        // combine columns of both source relations to use it in testing row\r\n        const bothSourceColumns: Map<string, SupportedColumnType> = new Map<string, SupportedColumnType>(leftSource.getColumns());\r\n        rightSource.forEachColumn((type, name) => bothSourceColumns.set(name, type));\r\n\r\n        leftSource.getRows().forEach(leftRow => {\r\n            rightSource.getRows().forEach(rightRow => {\r\n                const testRow: Row = new Row(bothSourceColumns);\r\n                leftRow.getValues().forEach((value, name) => testRow.addValue(name, value));\r\n                rightRow.getValues().forEach((value, name) => testRow.addValue(name, value));\r\n                // checks whether the combined row from both relations' columns satisfies the condition\r\n                let booleanResult: { value: ColumnContent, type: SupportedColumnType | \"null\" } = boolExpr.eval(testRow);\r\n                if (booleanResult.type !== \"boolean\") {\r\n                    throw ErrorFactory.syntaxError(SyntaxErrorCodes.thetaSemiJoinNode_eval_resultNotBoolean,\r\n                        this.stringRange, this.condition.replace(/\\s+/g, \" \"), booleanResult.type);\r\n                }\r\n                if (booleanResult.value) {\r\n                    const newRow: Row = new Row(result.getColumns());\r\n                    if (this.type === ThetaJoinType.left || this.type === ThetaJoinType.full) {\r\n                        leftRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                    }\r\n                    if (this.type === ThetaJoinType.right || this.type === ThetaJoinType.full) {\r\n                        rightRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                    }\r\n                    result.addRow(newRow);\r\n                }\r\n            });\r\n        });\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: disjointness\r\n     * Returned schema: left/right/both source schema (for left/right/full semijoin)\r\n     * Returned fake schema is not affected when disjointness is not held\r\n     */\r\n    public fakeEval(cursorIndex: number): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} {\r\n        const left: {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} = this.leftSubtree.fakeEval(cursorIndex);\r\n        const right: {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} = this.rightSubtree.fakeEval(cursorIndex);\r\n        const sourceColumns: string[] = [];\r\n        sourceColumns.push(...left.result.getColumnNames());\r\n        sourceColumns.push(...right.result.getColumnNames());\r\n        // creates return relation\r\n        const result: Relation = new Relation(\"\");\r\n        if (this.type === ThetaJoinType.left || this.type === ThetaJoinType.full) {\r\n            left.result.forEachColumn((type, name) => result.addColumn(name, type));\r\n        }\r\n        if (this.type === ThetaJoinType.right || this.type === ThetaJoinType.full) {\r\n            right.result.forEachColumn((type, name) => result.addColumn(name, type));\r\n        }\r\n        // checks whether the cursor is in this condition block - saves current available columns\r\n        let whispers = left.whispers.length !== 0 ? left.whispers : right.whispers;\r\n        if (this.stringRange !== undefined && this.stringRange.start < cursorIndex && cursorIndex <= this.stringRange.end) {\r\n            whispers = sourceColumns;\r\n        }\r\n        // adds errors from current expression\r\n        const errors = left.errors;\r\n        errors.push(...right.errors);\r\n        const commonColumns: string[] = [];\r\n        left.result.getColumnNames().forEach(leftColumn => {\r\n            if (right.result.hasColumn(leftColumn)) {\r\n                commonColumns.push(leftColumn);\r\n            }\r\n        });\r\n        if (commonColumns.length > 0 && this.stringRange !== undefined) {\r\n            errors.push(ErrorFactory.semanticError(SemanticErrorCodes.binaryNode_eval_commonColumnsInSources,\r\n                {start: this.stringRange.start, end: this.stringRange.start},   // highlight only opening bracket\r\n                this.getOperationName().toLowerCase(), commonColumns.join('\", \"')));\r\n        }\r\n        // checks empty condition input\r\n        if (this.condition.toString().slice(1, -1).trim().length  === 0) {\r\n            errors.push(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_parseTokens_emptyInput, this.stringRange));\r\n        }\r\n        else if (this.condition instanceof IndexedString) {\r\n            errors.push(...ValueParser.fakeParse(this.condition.slice(1, -1), this.nullValuesSupport, sourceColumns));\r\n        }\r\n        return {result, whispers, errors};\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return this.getOperationName() + \" of {\" + this.leftSubtree.printInLine() + \"} and {\" + this.rightSubtree.printInLine() + \"}\";\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        if (this.type === ThetaJoinType.left) {\r\n            return \"Left theta semijoin\";\r\n        }\r\n        else if (this.type === ThetaJoinType.right) {\r\n            return \"Right theta semijoin\";\r\n        }\r\n        else {\r\n            return \"Theta join\";\r\n        }\r\n    }\r\n\r\n    public getParameter(): string {\r\n        return this.condition.replace(/\\s+/g, \" \");\r\n    }\r\n\r\n    public getType(): ThetaJoinType {\r\n        return this.type;\r\n    }\r\n}","import Relation from \"../relation/relation\";\r\nimport {CodeErrorCodes, ErrorFactory, SemanticErrorCodes, SyntaxErrorCodes} from \"../error/errorFactory\";\r\nimport {\r\n    BinaryOperatorToken,\r\n    ClosingParentheses,\r\n    ExprToken,\r\n    OpeningParentheses,\r\n    ParenthesisToken,\r\n    RelationToken,\r\n    UnaryOperatorToken\r\n} from \"./exprTokens\";\r\nimport Parser from \"../tools/parser\";\r\nimport RATreeNode from \"../ratree/raTreeNode\";\r\nimport RelationNode from \"../ratree/relationNode\";\r\nimport {\r\n    getRange,\r\n    IndexedString,\r\n    isEmpty,\r\n    nextBorderedPart\r\n} from \"../tools/indexedString\";\r\nimport ParserIndexed from \"../tools/parserIndexed\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\nimport RATreeFactory from \"../ratree/raTreeFactory\";\r\n\r\n/**\r\n * Assertion types for assertValidInfixTokens function.\r\n */\r\nenum AssertType {\r\n    NOT_THROW,\r\n    THROW_STRICT,\r\n    THROW_NOT_STRICT\r\n}\r\n\r\n/**\r\n * Parser of relational algebra expressions. Provides parsing function parse(String expr) and additional\r\n * helping functions and predicates. Uses IndexedString to describe error ranges in thrown errors.\r\n */\r\nexport class ExprParser {\r\n\r\n    /**\r\n     * Creates a parser with given source relations.\r\n     *\r\n     * @param relations Map with relations' names as keys and relation themselves as values used as source for leave nodes\r\n     * @param nullValuesSupport whether to support null values\r\n     */\r\n    public constructor(readonly relations: Map<string, Relation>, readonly nullValuesSupport: boolean) {}\r\n\r\n    /**\r\n     * Parses given relational algebra expression 'expr' and returns tree of RA operations.\r\n     * Expression is expected to respect following constraints:\r\n     * - all relation's and column's names contain letters, numbers and underscores only\r\n     * - all relation's and column's names start with a letter\r\n     * - used operations must be in a practical notation and be well-structured\r\n     * - comment begins with '//' and ends with newline\r\n     *\r\n     * Supported operations are:\r\n     * - projection of columns: Relation[projectedColumn1, ...]\r\n     * - selection of rows: Relation(condition)\r\n     * - rename of columns: Relation<oldName -> newName, ...>\r\n     * - cartesian product: A \\u2a2f B\r\n     * - natural join: A * B\r\n     * - theta join: A [condition] B\r\n     * - left and right semijoin: A <* B and A *> B\r\n     * - left and right antijoin: A \\u22b3 B and A \\u22b2 B\r\n     * - left and right theta semijoin: A <condition] B and A [condition> B\r\n     * - division: A \\u00f7 B\r\n     * - left, right and full outer join: A *L* B, A *R* B and A *F* B\r\n     * - union, intersection and difference: A \\u222a B, A \\u2229 B and A \\ B\r\n     *\r\n     * See ValueParser for condition constraints.\r\n     *\r\n     * @param expr relational algebra expression in expected format\r\n     * @return tree structure of 'expr'\r\n     */\r\n    public parse(expr: string): RATreeNode {\r\n        expr = Parser.deleteCommentLines(expr);\r\n        if (expr.trim() === \"\") {\r\n            throw ErrorFactory.syntaxError(SyntaxErrorCodes.exprParser_parse_emptyStringGiven, undefined);\r\n        }\r\n        const tokens: ExprToken[] = this.parseTokens(expr);\r\n        this.assertValidInfixTokens(tokens, AssertType.THROW_STRICT);\r\n        const rpn: ExprToken[] = this.toRPN(tokens);\r\n        return this.rpnToRATree(rpn, true);\r\n    }\r\n\r\n    /**\r\n     * Indexed version of ExprParser.parse() function. Uses IndexedString to describe error ranges.\r\n     * See ExprParser.parse for detailed description.\r\n     *\r\n     * @param expr relational algebra expression in expected format\r\n     * @return tree structure of 'expr'\r\n     */\r\n    public indexedParse(expr: string): RATreeNode {\r\n        const indexedExpr = ParserIndexed.deleteCommentLines(IndexedString.new(expr));\r\n        if (indexedExpr.trim().isEmpty()) {\r\n            throw ErrorFactory.syntaxError(SyntaxErrorCodes.exprParser_parse_emptyStringGiven, undefined);\r\n        }\r\n        const tokens: ExprToken[] = this.parseTokens(indexedExpr);\r\n        this.assertValidInfixTokens(tokens, AssertType.THROW_STRICT);\r\n        const rpn: ExprToken[] = this.toRPN(tokens);\r\n        return this.rpnToRATree(rpn, true);\r\n    }\r\n\r\n    /**\r\n     * Parses given expression and finds words to whisper for the given cursorIndex.\r\n     * If the cursor is located next to any RA operator, returns list of all defined relation names.\r\n     * If the cursor is located inside any RA operator, which uses relation columns, returns list of available column\r\n     * names at given place.\r\n     * If a parsing error occurs, it is faked to work or ignored and reported in returning errors array.\r\n     */\r\n    public fakeParse(expr: string, cursorIndex: number): {whispers: string[], errors: ErrorWithTextRange[]} {\r\n        const indexedExpr = ParserIndexed.deleteCommentLines(IndexedString.new(expr));\r\n        if (indexedExpr.trim().isEmpty()) {\r\n            return {whispers: [], errors: []};\r\n        }\r\n        const {whispers, tokens, errors} = this.fakeParseTokens(indexedExpr, cursorIndex);\r\n        // prevent errors in creation of RPN\r\n        if (tokens.length === 0) {\r\n            return {whispers: [], errors: errors};\r\n        }\r\n        // fakes found errors to valid parse\r\n        this.assertValidInfixTokens(tokens, AssertType.NOT_THROW, errors);\r\n        const rpn: ExprToken[] = this.toRPN(tokens);\r\n        const raTree: RATreeNode = this.rpnToRATree(rpn, false, errors);\r\n        // tries to find whispers inside RA operations with parameters\r\n        const innerResult: {whispers: string[], errors: ErrorWithTextRange[]} = raTree.fakeEval(cursorIndex);\r\n        errors.push(...innerResult.errors);\r\n        // if there are whispers from inner operators, returns them\r\n        if (innerResult.whispers.length > 0) {\r\n            return {whispers: innerResult.whispers, errors: errors};\r\n        }\r\n        // otherwise returns outer whispers (or empty array if no were found)\r\n        return {whispers: whispers, errors: errors};\r\n    }\r\n\r\n    /**\r\n     * Given expression string is expected to be without comment lines and not empty.\r\n     *\r\n     * @param expr IndexedString to parse the expression from\r\n     * @param selectionExpected true if next part \"(...)\" should be treated as a selection = last part\r\n     * was a relation or an unary operator (default false)\r\n     */\r\n    public parseTokens(expr: string | IndexedString, selectionExpected: boolean = false): ExprToken[] {\r\n        let tokens: ExprToken[] = [];\r\n        let rest: string | IndexedString = expr;\r\n\r\n        while (!isEmpty(rest)) {\r\n            rest = rest.trim();\r\n            // '(' can be a selection or a parentheses\r\n            if (rest.startsWith(\"(\")) {\r\n                const split = nextBorderedPart(rest, '(', ')');\r\n                // whole \"(...)\" part pushed as selection\r\n                if (selectionExpected) {\r\n                    //tokens.push(new SelectionToken(split.first));\r\n                    tokens.push(UnaryOperatorToken.selection(split.first));\r\n                }\r\n                // inner of \"(...)\" part parsed as parentheses structure\r\n                else {\r\n                    tokens.push(new OpeningParentheses(split.first.slice(0, 1)));\r\n                    tokens.push(...this.parseTokens(split.first.slice(1, -1)));\r\n                    tokens.push(new ClosingParentheses(split.first.slice(-1)));\r\n                    selectionExpected = true;\r\n                }\r\n                rest = split.second;\r\n            }\r\n            else if (rest.startsWith(\"[\")) {\r\n                const split = nextBorderedPart(rest, '[', ']');\r\n                //tokens.push(new ProjectionToken(split.first));\r\n                tokens.push(UnaryOperatorToken.projection(split.first));\r\n                selectionExpected = true;\r\n                rest = split.second;\r\n            }\r\n            else if (rest.startsWith(\"{\")) {\r\n                const split = nextBorderedPart(rest, '{', '}>');\r\n                // right theta semijoin found\r\n                if (split.first.endsWith('>')) {\r\n                    tokens.push(BinaryOperatorToken.rightThetaSemijoin(split.first));\r\n                }\r\n                else {\r\n                    tokens.push(BinaryOperatorToken.thetaJoin(split.first));\r\n                }\r\n                selectionExpected = false;\r\n                rest = split.second;\r\n            }\r\n            // BINARY OPERATORS\r\n            else if (rest.startsWith(\"*F*\") || rest.startsWith(\"*L*\") || rest.startsWith(\"*R*\")) {\r\n                if (!this.nullValuesSupport) {\r\n                    let errorRange: {start: number, end: number} | undefined = undefined;\r\n                    if (rest instanceof IndexedString && rest.getFirstNonNaNIndex() !== undefined) {\r\n                        // @ts-ignore\r\n                        errorRange = {start: rest.getFirstNonNaNIndex(), end: rest.getFirstNonNaNIndex() + 2};\r\n                    }\r\n                    throw ErrorFactory.syntaxError(SyntaxErrorCodes.exprParser_parseTokens_outerJoinWhenNullNotSupported,\r\n                        errorRange, \"*F*\");\r\n                }\r\n                if (rest.startsWith(\"*F\")) {\r\n                    tokens.push(BinaryOperatorToken.fullOuterJoin(rest.slice(0, 3)));\r\n                }\r\n                else if (rest.startsWith(\"*L\")) {\r\n                    tokens.push(BinaryOperatorToken.leftOuterJoin(rest.slice(0, 3)));\r\n                }\r\n                else {\r\n                    tokens.push(BinaryOperatorToken.rightOuterJoin(rest.slice(0, 3)));\r\n                }\r\n                rest = rest.slice(3);\r\n                selectionExpected = false;\r\n            }\r\n            else if (rest.startsWith(\"<*\")) {\r\n                tokens.push(BinaryOperatorToken.leftSemijoin(rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n                selectionExpected = false;\r\n            }\r\n            else if (rest.startsWith(\"*>\")) {\r\n                tokens.push(BinaryOperatorToken.rightSemijoin(rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n                selectionExpected = false;\r\n            }\r\n            // operators of 1 character\r\n            else if (\"*\\u2a2f\\u222a\\u2229\\\\\\u22b3\\u22b2\\u00f7\".indexOf(rest.charAt(0)) > -1) {\r\n                const operator: string | IndexedString = rest.slice(0, 1);\r\n                if (rest.startsWith(\"*\")) {\r\n                    tokens.push(BinaryOperatorToken.naturalJoin(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\u2a2f\")) {\r\n                    tokens.push(BinaryOperatorToken.cartesianProduct(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\u222a\")) {\r\n                    tokens.push(BinaryOperatorToken.union(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\u2229\")) {\r\n                    tokens.push(BinaryOperatorToken.intersection(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\\\\")) {\r\n                    tokens.push(BinaryOperatorToken.difference(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\u22b3\")) {\r\n                    tokens.push(BinaryOperatorToken.leftAntijoin(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\u22b2\")) {\r\n                    tokens.push(BinaryOperatorToken.rightAntijoin(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\u00f7\")) {\r\n                    tokens.push(BinaryOperatorToken.division(operator));\r\n                }\r\n                rest = rest.slice(1);\r\n                selectionExpected = false;\r\n            }\r\n            // '<' can be a rename or left theta semi join - this \"if\" must be after <* and *>\r\n            else if (rest.startsWith('<')) {\r\n                const split = nextBorderedPart(rest, '<', '>}', '-');\r\n                if (split.first.endsWith('>')) {\r\n                    //tokens.push(new RenameToken(split.first));\r\n                    tokens.push(UnaryOperatorToken.rename(split.first));\r\n                    selectionExpected = true;\r\n                }\r\n                else {\r\n                    tokens.push(BinaryOperatorToken.leftThetaSemijoin(split.first));\r\n                    selectionExpected = false;\r\n                }\r\n                rest = split.second;\r\n            }\r\n            // RELATION REFERENCE\r\n            else if (Parser.isLetter(rest.charAt(0)) || rest.charAt(0) === '_') {\r\n                const split = (rest instanceof IndexedString) ? ParserIndexed.nextName(rest) : Parser.nextName(rest);\r\n                tokens.push(new RelationToken(split.first));\r\n                rest = split.second;\r\n                selectionExpected = true;\r\n            }\r\n            // UNEXPECTED PART\r\n            else {\r\n                const split = (rest instanceof IndexedString) ? ParserIndexed.nextNonWhitespacePart(rest) : Parser.nextNonWhitespacePart(rest);\r\n                throw ErrorFactory.syntaxError(SyntaxErrorCodes.exprParser_parseTokens_unexpectedPart,\r\n                    getRange(split.first), split.first.toString());\r\n            }\r\n        }\r\n        return tokens;\r\n    }\r\n\r\n    /**\r\n     * Parses given expression to ExprToken array. While parsing, it tries to find cursor index and returns whispers.\r\n     * Parsing errors are not thrown but stored in errors array.\r\n     *\r\n     * @param expr IndexedString to parse the expression from\r\n     * @param cursorIndex\r\n     * @param selectionExpected true if next part \"(...)\" should be treated as a selection = last part\r\n     * was a relation or an unary operator (default false)\r\n     */\r\n    public fakeParseTokens(expr: IndexedString, cursorIndex: number, selectionExpected: boolean = false):\r\n            { whispersFound: boolean, tokens: ExprToken[], whispers: string[], errors: ErrorWithTextRange[] } {\r\n        // found whispers\r\n        let whispersFound: boolean = false;\r\n        let whispers: string[] = [];\r\n        let tokens: ExprToken[] = [];\r\n        let errors: ErrorWithTextRange[] = [];\r\n        let rest: IndexedString = expr;\r\n\r\n        while (!rest.isEmpty()) {\r\n            // checks whether the cursor was reached\r\n            const restStartIndex: number | undefined = rest.getFirstNonNaNIndex();\r\n            if (restStartIndex === cursorIndex) {\r\n                whispersFound = true;\r\n                whispers = [...this.relations.keys()];\r\n            }\r\n\r\n            rest = rest.trim();\r\n            // '(' can be a selection or a parentheses\r\n            if (rest.startsWith(\"(\")) {\r\n                let split: {first: IndexedString, second: IndexedString};\r\n                try {\r\n                    split = ParserIndexed.nextBorderedPart(rest, '(', ')');\r\n                }\r\n                // catches error from nextBorderedPart\r\n                catch (err) {\r\n                    // saves error\r\n                    if (err instanceof ErrorWithTextRange) {\r\n                        errors.push(err);\r\n                    }\r\n\r\n                    if (selectionExpected) {\r\n                        // it fakes the unclosed expression part as a selection operator\r\n                        // pushes space with valid index and parentheses with NaN index for expected behavior (error\r\n                        // indexing) in fakeEval in selection/theta join nodes and fakeEval in ValueParser\r\n                        //tokens.push(new SelectionToken(rest.concat(IndexedString.newFromArray([\r\n                        //    {char: ' ', index: rest.getNextIndexOrNaN()}, {char: ')', index: NaN}]))));\r\n                        tokens.push(UnaryOperatorToken.selection(rest.concat(IndexedString.newFromArray([\r\n                            {char: ' ', index: rest.getNextIndexOrNaN()}, {char: ')', index: NaN}]))));\r\n                    }\r\n                    else {\r\n                        // checks whether the cursor was reached after the opening parentheses\r\n                        if (restStartIndex === cursorIndex - 1) {\r\n                            whispersFound = true;\r\n                            whispers = [...this.relations.keys()];\r\n                        }\r\n\r\n                        // it fakes the unclosed expression as nested expression in parentheses\r\n                        tokens.push(new OpeningParentheses(rest.slice(0, 1)));\r\n                        // parses inner part between parentheses\r\n                        const recursiveReturn = this.fakeParseTokens(rest.slice(1), cursorIndex);\r\n                        errors.push(...recursiveReturn.errors);\r\n                        if (recursiveReturn.whispersFound) {\r\n                            whispersFound = true;\r\n                            whispers = recursiveReturn.whispers;\r\n                        }\r\n                        tokens.push(...recursiveReturn.tokens);\r\n                        // gives invalid index (NaN for not reporting errors with this imaginary parentheses\r\n                        tokens.push(new ClosingParentheses(IndexedString.new(')', NaN)));\r\n                    }\r\n                    // breaks the while cycle because rest was parsed recursively\r\n                    break;\r\n                }\r\n\r\n                // whole \"(...)\" part pushed as selection\r\n                if (selectionExpected) {\r\n                    //tokens.push(new SelectionToken(split.first));\r\n                    tokens.push(UnaryOperatorToken.selection(split.first));\r\n                }\r\n                // inner of \"(...)\" part parsed as parentheses structure\r\n                else {\r\n                    tokens.push(new OpeningParentheses(split.first.slice(0, 1)));\r\n                    const recursiveReturn = this.fakeParseTokens(split.first.slice(1, -1), cursorIndex);\r\n                    errors.push(...recursiveReturn.errors);\r\n                    if (recursiveReturn.whispersFound) {\r\n                        whispersFound = true;\r\n                        whispers = recursiveReturn.whispers;\r\n                    }\r\n                    tokens.push(...recursiveReturn.tokens);\r\n                    tokens.push(new ClosingParentheses(split.first.slice(-1)));\r\n                    selectionExpected = true;\r\n                }\r\n                rest = split.second;\r\n            }\r\n            // projection found\r\n            else if (rest.startsWith(\"[\")) {\r\n                let split: {first: IndexedString, second: IndexedString};\r\n                try {\r\n                    split = ParserIndexed.nextBorderedPart(rest, '[', ']');\r\n                    //tokens.push(new ProjectionToken(split.first));\r\n                    tokens.push(UnaryOperatorToken.projection(split.first));\r\n                    rest = split.second;\r\n                    // checks whether the cursor was reached\r\n                    const operatorEndIndex: number | undefined = split.first.getLastNonNaNIndex();\r\n                    if (operatorEndIndex === cursorIndex - 1) {\r\n                        whispersFound = true;\r\n                        whispers = [...this.relations.keys()];\r\n                    }\r\n                }\r\n                // catches error from nextBorderedPart\r\n                catch (err) {\r\n                    // saves error\r\n                    if (err instanceof ErrorWithTextRange) {\r\n                        errors.push(err);\r\n                    }\r\n                    // it fakes the unclosed expression part as a projection operator\r\n                    //tokens.push(new ProjectionToken(rest.concat(IndexedString.new(']', rest.getNextIndexOrNaN()))));\r\n                    tokens.push(UnaryOperatorToken.projection(rest.concat(IndexedString.new(']', rest.getNextIndexOrNaN()))));\r\n                    // breaks the while cycle because the whole rest was used\r\n                    break;\r\n                }\r\n            }\r\n            // theta join or right theta join found\r\n            else if (rest.startsWith(\"{\")) {\r\n                let split: {first: IndexedString, second: IndexedString};\r\n                try {\r\n                    split = ParserIndexed.nextBorderedPart(rest, '{', '}>');\r\n                    if (split.first.endsWith('>')) {\r\n                        tokens.push(BinaryOperatorToken.rightThetaSemijoin(split.first));\r\n                    }\r\n                    else {\r\n                        tokens.push(BinaryOperatorToken.thetaJoin(split.first));\r\n                    }\r\n                    rest = split.second;\r\n                    // checks whether the cursor was reached\r\n                    const operatorEndIndex: number | undefined = split.first.getLastNonNaNIndex();\r\n                    if (operatorEndIndex === cursorIndex - 1) {\r\n                        whispersFound = true;\r\n                        whispers = [...this.relations.keys()];\r\n                    }\r\n                }\r\n                // catches error from nextBorderedPart\r\n                catch (err) {\r\n                    // saves error\r\n                    if (err instanceof ErrorWithTextRange) {\r\n                        errors.push(err);\r\n                    }\r\n                    // it fakes the unclosed expression part as a theta join operator\r\n                    tokens.push(BinaryOperatorToken.thetaJoin(rest.concat(IndexedString.new('}', rest.getNextIndexOrNaN()))));\r\n                    // breaks the while cycle because the whole rest was used\r\n                    break;\r\n                }\r\n            }\r\n            // BINARY OPERATORS\r\n            else if (rest.startsWith(\"*F*\") || rest.startsWith(\"*L*\") || rest.startsWith(\"*R*\")) {\r\n                const operator: IndexedString = rest.slice(0, 3);\r\n                // checks whether the cursor was reached\r\n                const operatorEndIndex: number | undefined = operator.getLastNonNaNIndex();\r\n                if (operatorEndIndex === cursorIndex - 1) {\r\n                    whispersFound = true;\r\n                    whispers = [...this.relations.keys()];\r\n                }\r\n\r\n                if (rest.startsWith(\"*F\")) {\r\n                    tokens.push(BinaryOperatorToken.fullOuterJoin(operator));\r\n                }\r\n                else if (rest.startsWith(\"*L\")) {\r\n                    tokens.push(BinaryOperatorToken.leftOuterJoin(operator));\r\n                }\r\n                else {\r\n                    tokens.push(BinaryOperatorToken.rightOuterJoin(operator));\r\n                }\r\n                rest = rest.slice(3);\r\n                selectionExpected = false;\r\n            }\r\n            // operators of 2 characters\r\n            else if (rest.startsWith(\"<*\") || rest.startsWith(\"*>\")) {\r\n                const operator: IndexedString = rest.slice(0, 2);\r\n                // checks whether the cursor was reached\r\n                const operatorEndIndex: number | undefined = operator.getLastNonNaNIndex();\r\n                if (operatorEndIndex === cursorIndex - 1) {\r\n                    whispersFound = true;\r\n                    whispers = [...this.relations.keys()];\r\n                }\r\n\r\n                if (rest.startsWith(\"<*\")) {\r\n                    tokens.push(BinaryOperatorToken.leftSemijoin(operator));\r\n                }\r\n                else {\r\n                    tokens.push(BinaryOperatorToken.rightSemijoin(operator));\r\n                }\r\n                rest = rest.slice(2);\r\n                selectionExpected = false;\r\n            }\r\n            // operators of 1 character\r\n            else if (\"*\\u2a2f\\u222a\\u2229\\\\\\u22b3\\u22b2\\u00f7\".indexOf(rest.charAt(0)) > -1) {\r\n                const operator: IndexedString = rest.slice(0, 1);\r\n                // checks whether the cursor was reached\r\n                const operatorEndIndex: number | undefined = operator.getLastNonNaNIndex();\r\n                if (operatorEndIndex === cursorIndex - 1) {\r\n                    whispersFound = true;\r\n                    whispers = [...this.relations.keys()];\r\n                }\r\n\r\n                if (rest.startsWith(\"*\")) {\r\n                    tokens.push(BinaryOperatorToken.naturalJoin(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\u2a2f\")) {\r\n                    tokens.push(BinaryOperatorToken.cartesianProduct(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\u222a\")) {\r\n                    tokens.push(BinaryOperatorToken.union(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\u2229\")) {\r\n                    tokens.push(BinaryOperatorToken.intersection(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\\\\")) {\r\n                    tokens.push(BinaryOperatorToken.difference(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\u22b3\")) {\r\n                    tokens.push(BinaryOperatorToken.leftAntijoin(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\u22b2\")) {\r\n                    tokens.push(BinaryOperatorToken.rightAntijoin(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\u00f7\")) {\r\n                    tokens.push(BinaryOperatorToken.division(operator));\r\n                }\r\n                rest = rest.slice(1);\r\n                selectionExpected = false;\r\n            }\r\n            // '<' can be a rename or left theta semi join - this \"if\" must be after <*\r\n            else if (rest.startsWith('<')) {\r\n                try {\r\n                    const split = ParserIndexed.nextBorderedPart(rest, '<', '>}', '-');\r\n                    // found rename\r\n                    if (split.first.endsWith('>')) {\r\n                        // checks whether the cursor was reached - after unary rename operator it does not whisper\r\n                        const operatorEndIndex: number | undefined = split.first.getLastNonNaNIndex();\r\n                        if (operatorEndIndex === cursorIndex - 1) {\r\n                            whispersFound = true;\r\n                            whispers = [];\r\n                        }\r\n\r\n                        //tokens.push(new RenameToken(split.first));\r\n                        tokens.push(UnaryOperatorToken.rename(split.first));\r\n                        selectionExpected = true;\r\n                    }\r\n                    // found left theta semi join\r\n                    else {\r\n                        // checks whether the cursor was reached\r\n                        const operatorEndIndex: number | undefined = split.first.getLastNonNaNIndex();\r\n                        if (operatorEndIndex === cursorIndex - 1) {\r\n                            whispersFound = true;\r\n                            whispers = [...this.relations.keys()];\r\n                        }\r\n\r\n                        tokens.push(BinaryOperatorToken.leftThetaSemijoin(split.first));\r\n                        selectionExpected = false;\r\n                    }\r\n                    rest = split.second;\r\n                }\r\n                // catches error from nextBorderedPart\r\n                catch (e) {\r\n                    // it fakes the unclosed expression part as a rename operator\r\n                    //tokens.push(new RenameToken(rest.concat(IndexedString.new('>', rest.getNextIndexOrNaN()))));\r\n                    tokens.push(UnaryOperatorToken.rename(rest.concat(IndexedString.new('>', rest.getNextIndexOrNaN()))));\r\n                    // breaks the while cycle as all was used\r\n                    break;\r\n                }\r\n            }\r\n            // RELATION REFERENCE\r\n            else if (Parser.isLetter(rest.charAt(0)) || rest.charAt(0) === '_') {\r\n                const split = ParserIndexed.nextName(rest);\r\n\r\n                // checks whether the cursor was reached in the relation reference string\r\n                const relationStartIndex: number | undefined = split.first.getFirstNonNaNIndex();\r\n                const relationEndIndex: number | undefined = split.first.getLastNonNaNIndex();\r\n                if (typeof relationStartIndex === \"number\" && typeof relationEndIndex === \"number\" &&\r\n                    relationStartIndex <= cursorIndex - 1 && cursorIndex - 1 <= relationEndIndex) {\r\n                    whispersFound = true;\r\n                    whispers = [...this.relations.keys()];\r\n                }\r\n\r\n                tokens.push(new RelationToken(split.first));\r\n                rest = split.second;\r\n                selectionExpected = true;\r\n            }\r\n            // UNEXPECTED PART\r\n            else {\r\n                const split = ParserIndexed.nextNonWhitespacePart(rest);\r\n                errors.push(ErrorFactory.syntaxError(SyntaxErrorCodes.exprParser_parseTokens_unexpectedPart,\r\n                    getRange(split.first), split.first.toString()));\r\n                // tries to skip first unexpected character\r\n                rest = rest.slice(split.first.length());\r\n            }\r\n        }\r\n        // when whispers were found, returns them\r\n        if (whispersFound) {\r\n            return { whispersFound, tokens, whispers, errors };\r\n        }\r\n        return { whispersFound, tokens: tokens, whispers: [], errors: errors };\r\n    }\r\n\r\n    /**\r\n     * Checks the validity of the given infix token array.\r\n     * If the type is THROW_STRICT or THROW_NOT_STRICT, it throws found errors. Strict version checks the first\r\n     * token in the array, not strict version does not. In both throw version is the errors parameter ignored.\r\n     * If the type is NOT_THROW, it adds fake tokens if the array is not valid.\r\n     * Fake tokens are relations with empty name \"\", or natural joins \"*\", their error ranges are undefined.\r\n     * All faked errors are reported pushed in given errors array.\r\n     * Expects validly nested parentheses: yes \"(()())\", no \")()\", \")(\". Expects not empty array.\r\n     *\r\n     * @param tokens token array to check\r\n     * @param type type of the assertion\r\n     * @param errors array for pushing faked errors for NOT_THROW type\r\n     */\r\n    public assertValidInfixTokens(tokens: ExprToken[], type: AssertType, errors: ErrorWithTextRange[] = []): void {\r\n        /**\r\n         * Handles the error described by given error code, params and range. If doThrow is true, throws the described\r\n         * error. Otherwise, fakes it by inserting a new token at given index. The token is binary (natural join) if\r\n         * missing is \"binary\", otherwise, it is a relation with empty name.\r\n         */\r\n        const handleError = (index: number, missing: \"binary\" | \"relation\",\r\n                             code: SyntaxErrorCodes, range: {start: number, end: number} | undefined, ...params: string[]) => {\r\n            const error = ErrorFactory.syntaxError(code, range, ...params);\r\n            if (type !== AssertType.NOT_THROW) {\r\n                throw error;\r\n            }\r\n            else if (missing === \"binary\") {\r\n                errors.push(error);\r\n                tokens.splice(index, 0, BinaryOperatorToken.naturalJoin(\"*\"));\r\n            }\r\n            else {\r\n                errors.push(error);\r\n                tokens.splice(index, 0, new RelationToken(\"\"));\r\n            }\r\n        }\r\n\r\n        if (type !== AssertType.THROW_NOT_STRICT) {\r\n            // checks start of an array: it must start with '(' or relation\r\n            if (tokens[0] instanceof UnaryOperatorToken || tokens[0] instanceof BinaryOperatorToken || tokens[0] instanceof ClosingParentheses) {\r\n                handleError(0, \"relation\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_invalidStart,\r\n                    tokens[0].getRange(), tokens[0].str.toString());\r\n            }\r\n        }\r\n\r\n        // checks end of an array: it must end with ')', relation or an unary operator\r\n        if (tokens[tokens.length - 1] instanceof OpeningParentheses || tokens[tokens.length - 1] instanceof BinaryOperatorToken) {\r\n            handleError(tokens.length, \"relation\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_invalidEnd,\r\n                tokens[tokens.length - 1].getRange(), tokens[tokens.length - 1].str.toString());\r\n        }\r\n\r\n        // checks adjacent pairs of tokens\r\n        let i2: number = 1;\r\n        while (i2 < tokens.length) {\r\n            const token1: ExprToken = tokens[i2 - 1];\r\n            const token2: ExprToken = tokens[i2];\r\n\r\n            // valid predecessors: binary operator or '('\r\n            if (token2 instanceof RelationToken) {\r\n                if (token1 instanceof RelationToken) {\r\n                    handleError(i2, \"binary\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_relationAfterRelation,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString());\r\n                }\r\n                if (token1 instanceof UnaryOperatorToken) {\r\n                    handleError(i2, \"binary\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_relationAfterUnary,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString());\r\n                }\r\n                if (token1 instanceof ClosingParentheses) {\r\n                    handleError(i2, \"binary\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_relationAfterClosing,\r\n                        token2.getRange(), token2.str.toString());\r\n                }\r\n            }\r\n            // valid predecessors: relation, unary operator or ')'\r\n            else if (token2 instanceof UnaryOperatorToken) {\r\n                if (token1 instanceof BinaryOperatorToken) {\r\n                    handleError(i2, \"relation\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_unaryAfterBinary,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString());\r\n                }\r\n                if (token1 instanceof OpeningParentheses) {\r\n                    handleError(i2, \"relation\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_unaryAfterOpening,\r\n                        token2.getRange(), token2.str.toString());\r\n                }\r\n            }\r\n            // valid predecessors: relation, unary operator or ')'\r\n            else if (token2 instanceof BinaryOperatorToken) {\r\n                if (token1 instanceof BinaryOperatorToken) {\r\n                    handleError(i2, \"relation\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_binaryAfterBinary,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString());\r\n                }\r\n                if (token1 instanceof OpeningParentheses) {\r\n                    handleError(i2, \"relation\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_binaryAfterOpening,\r\n                        token2.getRange(), token2.str.toString());\r\n                }\r\n            }\r\n            // valid predecessors: binary operator or '('\r\n            else if (token2 instanceof OpeningParentheses) {\r\n                if (token1 instanceof RelationToken) {\r\n                    handleError(i2, \"binary\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_openingAfterRelation,\r\n                        token2.getRange(), token1.str.toString());\r\n                }\r\n                if (token1 instanceof UnaryOperatorToken) {\r\n                    handleError(i2, \"binary\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_openingAfterUnary,\r\n                        token2.getRange(), token1.str.toString());\r\n                }\r\n                if (token1 instanceof ClosingParentheses) {\r\n                    handleError(i2, \"binary\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_openingAfterClosing,\r\n                        token2.getRange());\r\n                }\r\n            }\r\n            // valid predecessors: relation, unary operator or ')'\r\n            else if (token2 instanceof ClosingParentheses) {\r\n                if (token1 instanceof BinaryOperatorToken) {\r\n                    handleError(i2, \"relation\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_closingAfterBinary,\r\n                        token2.getRange(), token1.str.toString());\r\n                }\r\n                if (token1 instanceof OpeningParentheses) {\r\n                    handleError(i2, \"relation\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_closingAfterOpening,\r\n                        token2.getRange());\r\n                }\r\n            }\r\n            else {\r\n                throw ErrorFactory.codeError(CodeErrorCodes.exprParser_isValidSequence_unexpectedToken, JSON.stringify(token2));\r\n            }\r\n            ++i2;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transforms given infix relation algebra expression into postfix (reverse polish) form.\r\n     * Throws error when invalid parentheses structure is given.\r\n     *\r\n     * @param tokens infix relational algebra expression as Token array\r\n     * @return postfix (reverse polish) form of given array\r\n     */\r\n    public toRPN(tokens: ExprToken[]): ExprToken[] {\r\n        const rpnQueue: ExprToken[] = [];\r\n        const operatorsStack: Array<BinaryOperatorToken | ParenthesisToken> = [];\r\n        tokens.forEach(token => {\r\n            if (token instanceof RelationToken || token instanceof UnaryOperatorToken) {\r\n                rpnQueue.push(token);\r\n            }\r\n            else if (token instanceof BinaryOperatorToken) {\r\n                while (operatorsStack.length > 0 && operatorsStack[operatorsStack.length - 1] instanceof BinaryOperatorToken) {\r\n                    // @ts-ignore (token must be of BinaryOperatorToken class)\r\n                    let other: BinaryOperatorToken = operatorsStack[operatorsStack.length - 1];\r\n                    // all used operators have left associativity\r\n                    if (token.precedence <= other.precedence) {\r\n                        // @ts-ignore (token must be present)\r\n                        rpnQueue.push(operatorsStack.pop());\r\n                    }\r\n                    else {\r\n                        break;\r\n                    }\r\n                }\r\n                operatorsStack.push(token);\r\n            }\r\n            else if (token instanceof OpeningParentheses) {\r\n                operatorsStack.push(token);\r\n            }\r\n            else if (token instanceof ClosingParentheses) {\r\n                while (true) {\r\n                    if (operatorsStack.length === 0) {\r\n                        throw ErrorFactory.syntaxError(SyntaxErrorCodes.exprParser_assertValidInfixTokens_invalidParentheses,\r\n                            undefined);\r\n                    }\r\n                    if (operatorsStack[operatorsStack.length - 1] instanceof OpeningParentheses) {\r\n                        operatorsStack.pop();\r\n                        break;\r\n                    }\r\n                    // @ts-ignore (token must be present)\r\n                    rpnQueue.push(operatorsStack.pop());\r\n                }\r\n            }\r\n        });\r\n        while (operatorsStack.length > 0) {\r\n            // @ts-ignore (token must be present)\r\n            const curToken: ExprToken = operatorsStack.pop();\r\n            if (curToken instanceof OpeningParentheses) {\r\n                throw ErrorFactory.syntaxError(SyntaxErrorCodes.exprParser_assertValidInfixTokens_invalidParentheses,\r\n                    undefined);\r\n            }\r\n            else {\r\n                rpnQueue.push(curToken);\r\n            }\r\n        }\r\n        return rpnQueue;\r\n    }\r\n\r\n    /**\r\n     * Creates a RA expression evaluating tree from the given array of tokens in reverse polish form.\r\n     * Wraps recursive function rpnToRATreeRecursive(tokens).\r\n     * Possible errors:\r\n     * - not all tokens were used (invalid RPN structure was given, should not happen if the previous infix structure\r\n     * was asserted/faked) - if doThrow = false, returns a RelationNode with an empty relation\r\n     * - reference to a relation which does not exist found - if doThrow = false, replaces it with an empty relation\r\n     *\r\n     * @param tokens value-evaluating expression in reverse polish form\r\n     * @param doThrow if true and an error occurs, throws an error, if false and an error occurs, fakes it and does\r\n     * not throw\r\n     * @param errors\r\n     * @return RATreeNode tree (its root)\r\n     */\r\n    public rpnToRATree(tokens: ExprToken[], doThrow: boolean, errors: ErrorWithTextRange[] = []): RATreeNode {\r\n        const ret: RATreeNode = this.rpnToRATreeRecursive(tokens, doThrow, errors);\r\n        // not all tokens were used\r\n        if (tokens.length > 0) {\r\n            if (doThrow) {\r\n                throw ErrorFactory.syntaxError(SyntaxErrorCodes.exprParser_rpnToVETree_invalidExpression, undefined);\r\n            }\r\n            else {\r\n                return new RelationNode(new Relation(\"\"));\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    public rpnToRATreeRecursive(tokens: ExprToken[], doThrow: boolean, errors: ErrorWithTextRange[]): RATreeNode {\r\n        if (tokens.length === 0) {\r\n            throw ErrorFactory.syntaxError(SyntaxErrorCodes.exprParser_rpnToVETree_invalidExpression, undefined);\r\n        }\r\n        // @ts-ignore (there must be a token)\r\n        const token: ExprToken = tokens.pop();\r\n        // RELATION REFERENCE\r\n        if (token instanceof RelationToken) {\r\n            const relation: Relation | undefined = this.relations.get(token.str.toString());\r\n            // when the relation does not exist, throws or fakes it with an empty relation\r\n            if (relation === undefined) {\r\n                const error = ErrorFactory.semanticError(SemanticErrorCodes.exprParser_parse_relationNotDefined,\r\n                    token.getRange(), token.str.toString());\r\n                if (doThrow) {\r\n                    throw error;\r\n                }\r\n                else {\r\n                    errors.push(error);\r\n                    return new RelationNode(new Relation(\"\"));\r\n                }\r\n            }\r\n            return new RelationNode(relation);\r\n        }\r\n        // UNARY OPERATORS\r\n        if (token instanceof UnaryOperatorToken) {\r\n            const subtree: RATreeNode = this.rpnToRATreeRecursive(tokens, doThrow, errors);\r\n            return RATreeFactory.createUnary(token.type, subtree, this.nullValuesSupport, token.str);\r\n        }\r\n        // BINARY OPERATORS\r\n        if (token instanceof BinaryOperatorToken) {\r\n            const right: RATreeNode = this.rpnToRATreeRecursive(tokens, doThrow, errors);\r\n            const left: RATreeNode = this.rpnToRATreeRecursive(tokens, doThrow, errors);\r\n            return RATreeFactory.createBinary(token.type, left, right, this.nullValuesSupport, token.str);\r\n        }\r\n        // should never happen\r\n        throw ErrorFactory.codeError(CodeErrorCodes.exprParser_rpnToVETreeRecursive_unexpectedToken, JSON.stringify(token));\r\n    }\r\n}","import RATreeNode from \"./raTreeNode\";\r\nimport ProjectionNode from \"./projectionNode\";\r\nimport RenameNode from \"./renameNode\";\r\nimport SelectionNode from \"./selectionNode\";\r\nimport UnaryNode, {UnaryNodeClass} from \"./unaryNode\";\r\nimport AntijoinNode, {AntijoinType} from \"./antijoinNode\";\r\nimport CartesianProductNode from \"./cartesianProductNode\";\r\nimport DivisionNode from \"./divisionNode\";\r\nimport OuterJoinNode, {OuterJoinType} from \"./outerJoinNode\";\r\nimport NaturalJoinNode, {NaturalJoinType} from \"./naturalJoinNode\";\r\nimport SetOperationNode, {SetOperationType} from \"./setOperationNode\";\r\nimport BinaryNode, {BinaryNodeClass} from \"./binaryNode\";\r\nimport {getRange, IndexedString} from \"../tools/indexedString\";\r\nimport ThetaJoinNode, {ThetaJoinType} from \"./thetaJoinNode\";\r\n\r\n/**\r\n * Factory for creating unary and binary nodes of given class.\r\n */\r\nexport default class RATreeFactory {\r\n\r\n    /**\r\n     * Creates new unary node of given class.\r\n     *\r\n     * @param unaryClass wanted class\r\n     * @param subtree source subtree for a node\r\n     * @param nullValuesSupport whether null values are supported\r\n     * @param expr expression used to specify node's behavior\r\n     */\r\n    public static createUnary(unaryClass: UnaryNodeClass, subtree: RATreeNode,\r\n                              nullValuesSupport: boolean, expr: string | IndexedString): UnaryNode {\r\n        switch (unaryClass) {\r\n            case \"projection\":\r\n                return new ProjectionNode(expr, subtree);\r\n            case \"rename\":\r\n                return new RenameNode(expr, subtree);\r\n            case \"selection\":\r\n                return new SelectionNode(expr, subtree, nullValuesSupport);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates new binary node of given class.\r\n     *\r\n     * @param binaryClass wanted class\r\n     * @param left left source subtree for a node\r\n     * @param right right source subtree for a node\r\n     * @param nullValuesSupport whether null values are supported\r\n     * @param expr expression used to specify node's behavior\r\n     */\r\n    public static createBinary(binaryClass: BinaryNodeClass, left: RATreeNode, right: RATreeNode,\r\n                               nullValuesSupport: boolean, expr: string | IndexedString): BinaryNode {\r\n        switch (binaryClass) {\r\n            case \"left antijoin\":\r\n                return new AntijoinNode(AntijoinType.left, left, right);\r\n            case \"right antijoin\":\r\n                return new AntijoinNode(AntijoinType.right, left, right);\r\n            case \"cartesian product\":\r\n                return new CartesianProductNode(left, right, getRange(expr));\r\n            case \"division\":\r\n                return new DivisionNode(left, right, getRange(expr));\r\n            case \"natural join\":\r\n                return new NaturalJoinNode(NaturalJoinType.natural, left, right);\r\n            case \"left outer join\":\r\n                return new OuterJoinNode(OuterJoinType.left, left, right);\r\n            case \"right outer join\":\r\n                return new OuterJoinNode(OuterJoinType.right, left, right);\r\n            case \"full outer join\":\r\n                return new OuterJoinNode(OuterJoinType.full, left, right);\r\n            case \"left semijoin\":\r\n                return new NaturalJoinNode(NaturalJoinType.leftSemi, left, right);\r\n            case \"right semijoin\":\r\n                return new NaturalJoinNode(NaturalJoinType.rightSemi, left, right);\r\n            case \"union\":\r\n                return new SetOperationNode(SetOperationType.union, left, right, getRange(expr));\r\n            case \"intersection\":\r\n                return new SetOperationNode(SetOperationType.intersection, left, right, getRange(expr));\r\n            case \"difference\":\r\n                return new SetOperationNode(SetOperationType.difference, left, right, getRange(expr));\r\n            case \"theta join\":\r\n                return new ThetaJoinNode(ThetaJoinType.full, expr, left, right, nullValuesSupport);\r\n            case \"left theta semijoin\":\r\n                return new ThetaJoinNode(ThetaJoinType.left, expr, left, right, nullValuesSupport);\r\n            case \"right theta semijoin\":\r\n                return new ThetaJoinNode(ThetaJoinType.right, expr, left, right, nullValuesSupport);\r\n        }\r\n    }\r\n}","import React from \"react\";\r\n\r\ninterface TextInputProps {\r\n    // label before the input\r\n    label: string,\r\n    // initial value for the input\r\n    value: string,\r\n    // text on the submit button\r\n    buttonText: string,\r\n    // handler of input submit\r\n    onSubmit: (text: string) => void,\r\n    // function which returns true for forbidden inputs which cannot be submitted\r\n    forbidden: (text: string) => boolean,\r\n\r\n    // id of the input\r\n    id: string,\r\n    // true if dark theme should be applied\r\n    darkTheme: boolean,\r\n    // additional styling properties applied on root div container\r\n    style?: React.CSSProperties\r\n}\r\n\r\ninterface TextInputState {\r\n    value: string,\r\n    buttonDisable: boolean\r\n}\r\n\r\n/**\r\n * Basic text input with submit button. The input cannot be submit if the current value is forbidden.\r\n */\r\nexport class TextInput extends React.Component<TextInputProps, TextInputState> {\r\n\r\n    private readonly inputRef: React.RefObject<HTMLInputElement>;\r\n\r\n    constructor(props: TextInputProps) {\r\n        super(props);\r\n        this.state = {\r\n            value: this.props.value,\r\n            buttonDisable: this.props.forbidden(this.props.value)\r\n        }\r\n        this.inputRef = React.createRef();\r\n    }\r\n\r\n    componentDidUpdate(prevProps: Readonly<TextInputProps>) {\r\n        if (prevProps.value !== this.props.value) {\r\n            this.setState({value: this.props.value});\r\n        }\r\n    }\r\n\r\n    private handleChange = (value: string): void => {\r\n        const disable: boolean = this.props.forbidden(value);\r\n        this.setState({\r\n            value: value,\r\n            buttonDisable: disable\r\n        });\r\n    }\r\n\r\n    private handleKeyDown = (event: React.KeyboardEvent<HTMLInputElement>): void => {\r\n        if (event.key === \"Enter\") {\r\n            if (!this.state.buttonDisable) {\r\n                this.handleSubmit();\r\n            }\r\n        }\r\n        else if (event.key === \"Escape\" || event.key === \"Esc\") {\r\n            if (this.inputRef.current !== null) {\r\n                this.inputRef.current.blur();\r\n            }\r\n        }\r\n    }\r\n\r\n    private handleSubmit = (): void => {\r\n        this.props.onSubmit(this.state.value);\r\n    }\r\n\r\n    public render() {\r\n        return (\r\n            <div style={this.props.style}>\r\n                <label htmlFor={this.props.id}>{this.props.label}</label>\r\n                <input\r\n                    ref={this.inputRef}\r\n                    type='text'\r\n                    id={this.props.id}\r\n                    spellCheck={false}\r\n                    autoComplete={\"off\"}\r\n                    value={this.state.value}\r\n                    onChange={event => this.handleChange(event.target.value)}\r\n                    onKeyDown={this.handleKeyDown}\r\n                    className={this.props.darkTheme ? 'text-input-dark' : 'text-input-light'}\r\n                />\r\n                <button\r\n                    onClick={this.handleSubmit}\r\n                    disabled={this.state.buttonDisable}\r\n                    className={this.props.darkTheme ? \"button-dark\" : \"button-light\"}\r\n                >{this.props.buttonText}</button>\r\n            </div>\r\n        );\r\n    }\r\n}","import React from \"react\";\r\nimport \"./css/expressionSection.css\"\r\nimport Relation from \"../relation/relation\";\r\nimport {TooltipButton} from \"./tooltipButton\";\r\nimport {MessageLabel} from \"./messageLabel\";\r\nimport RASyntaxError from \"../error/raSyntaxError\";\r\nimport RASemanticError from \"../error/raSemanticError\";\r\nimport {XTextArea} from \"./xTextArea\";\r\nimport {ExprParser} from \"../expression/exprParser\";\r\nimport {getStartOfWordBeforeIndex, sortWhispers} from \"../tools/whisper\";\r\nimport {Expression} from \"../expression/expression\";\r\nimport {TextInput} from \"./textInput\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\nimport RATreeNode from \"../ratree/raTreeNode\";\r\n\r\ninterface ExpressionSectionProps {\r\n    // available expressions\r\n    expressions: Expression[],\r\n    // index of the current selected expression in the expression list\r\n    currentExpressionIndex: number,\r\n\r\n    // loaded relations user as sources for expression evaluation\r\n    relations: Map<string, Relation>,\r\n\r\n    // handler of selecting different expression as current\r\n    onSelectDifferentExpression: (newIndex: number) => void,\r\n    // handler of creating the new expression\r\n    onNewExpression: () => void,\r\n    // handler of deleting the current expression\r\n    onDeleteExpression: (onDone: () => void) => void,\r\n    // handler of saving the expressions\r\n    onExportExpressions: (onDone: (msg: string) => void) => void,\r\n    // handler of loading the expressions\r\n    onImportExpressions: (onDone: (msg: string) => void) => void,\r\n\r\n    // handler of change in the current selected expression\r\n    onChange: (name: string, text: string) => void,\r\n    // handler of evaluation, it accepts the parsed tree from the expression text\r\n    onEval: (tree: RATreeNode) => void,\r\n    // handler of unexpected errors\r\n    onUnexpectedError: (e: Error) => void,\r\n\r\n    // whether to support null values\r\n    nullValuesSupport: boolean,\r\n    // true if dark theme should be applied\r\n    darkTheme: boolean\r\n}\r\n\r\ninterface ExpressionSectionState {\r\n    sectionClicked: boolean,\r\n    whispers: string[],\r\n    errors: {start: number, end: number, msg: string}[],\r\n    cursorIndex: number,\r\n    messageText: string,\r\n    isMessageError: boolean\r\n}\r\n\r\ninterface OpButtonProps {\r\n    // key for React DOM\r\n    key: string,\r\n    // characters to be added on click\r\n    char: string,\r\n    // text to display on the button\r\n    text: string,\r\n    // tooltip ti show on mouse move\r\n    tooltip: string,\r\n    // shift to left of the cursor after adding the characters\r\n    shift: number\r\n}\r\n\r\n/**\r\n * Section to edit, manage, and eval relational algebra expressions.\r\n */\r\nexport class ExpressionSection extends React.Component<ExpressionSectionProps, ExpressionSectionState> {\r\n\r\n    // buttons for inserting RA operations supported without null values\r\n    private readonly buttonPropsFirstPart: Array<OpButtonProps> = [\r\n        // unary\r\n        {key: 'unary_a', char: '()',        text: '()', tooltip: 'Selection (P1)',   shift: 1},\r\n        {key: 'unary_b', char: '[]',        text: '[]', tooltip: 'Projection (P1)',  shift: 1},\r\n        {key: 'unary_c', char: '< -> >',    text: '<>', tooltip: 'Rename (P1)',      shift: 5},\r\n        // binary (precedence A)\r\n        {key: 'a', char: '*',       text: '*',      tooltip: 'Natural join (P2)',            shift: 0},\r\n        {key: 'b', char: '\\u2a2f',  text: '\\u2a2f', tooltip: 'Cartesian product (P2)',       shift: 0},\r\n        {key: 'c', char: '{}',      text: '{}',     tooltip: 'Theta join (P2)',              shift: 1},\r\n        // binary (precedence B)\r\n        {key: 'd', char: '<*',      text: '<*',     tooltip: 'Left semijoin (P3)',           shift: 0},\r\n        {key: 'e', char: '*>',      text: '*>',     tooltip: 'Right semijoin (P3)',          shift: 0},\r\n        {key: 'f', char: '\\u22b3',  text: '\\u22b3', tooltip: 'Left antijoin (P3)',           shift: 0},\r\n        {key: 'g', char: '\\u22b2',  text: '\\u22b2', tooltip: 'Right antijoin (P3)',          shift: 0},\r\n        {key: 'h', char: '<}',      text: '<}',     tooltip: 'Left theta semijoin (P3)',     shift: 1},\r\n        {key: 'i', char: '{>',      text: '{>',     tooltip: 'Right theta semijoin (P3)',    shift: 1},\r\n    ];\r\n    // buttons for inserting RA operations supported without null values\r\n    private readonly buttonPropsSecondPart: Array<OpButtonProps> = [\r\n        // binary (precedence D)\r\n        {key: 'j', char: '\\u00f7',  text: '\\u00f7', tooltip: 'Division (P5)',                shift: 0},\r\n        // binary (precedence E)\r\n        {key: 'k', char: '\\u2229',  text: '\\u2229', tooltip: 'Intersection (P6)',            shift: 0},\r\n        // binary (precedence F)\r\n        {key: 'l', char: '\\\\',      text: '\\\\',     tooltip: 'Difference (P7)',              shift: 0},\r\n        // binary (precedence G)\r\n        {key: 'm', char: '\\u222a',  text: '\\u222a', tooltip: 'Union (P8)',                   shift: 0},\r\n    ];\r\n    // buttons for inserting RA operations supported with null values only\r\n    private readonly nullSupportRequiredButtonProps: Array<OpButtonProps> = [\r\n        // binary (precedence C)\r\n        {key: 'null_a', char: '*F*', text: '*F*', tooltip: 'Full outer join (P4)',  shift: 0},\r\n        {key: 'null_b', char: '*L*', text: '*L*', tooltip: 'Left outer join (P4)',  shift: 0},\r\n        {key: 'null_c', char: '*R*', text: '*R*', tooltip: 'Right outer join (P4)', shift: 0}\r\n    ];\r\n\r\n    // reference to child textarea element\r\n    private readonly textAreaRef: React.RefObject<XTextArea>;\r\n    // timestamp of last expression text change\r\n    private lastChange: number = 0;\r\n    // timestamp of last display of whispers and errors\r\n    private lastWhisperAndErrorsUpdate: number = 0;\r\n    // update rate of whispers and errors (in ms)\r\n    private readonly whispersAndErrorsUpdateRate: number = 200;\r\n    // reference to this section element\r\n    private readonly sectionRef: React.RefObject<HTMLDivElement>;\r\n\r\n    constructor(props: ExpressionSectionProps) {\r\n        super(props);\r\n        this.state = {\r\n            sectionClicked: false,\r\n            whispers: [],\r\n            errors: [],\r\n            cursorIndex: 0,\r\n            messageText: \"\",\r\n            isMessageError: false\r\n        }\r\n        this.textAreaRef = React.createRef<XTextArea>();\r\n        this.sectionRef = React.createRef<HTMLDivElement>();\r\n        setInterval(() => this.updateWhispersAndErrors(), this.whispersAndErrorsUpdateRate);\r\n    }\r\n\r\n    componentDidMount() {\r\n        // adds listeners for evaluating on Ctrl+Enter\r\n        const section = this.sectionRef.current;\r\n        if (section !== null) {\r\n            section.addEventListener(\"click\", () => {\r\n                this.setState({sectionClicked: true});\r\n            }, true); // useCapture = true for overwriting the window listener\r\n        }\r\n        window.addEventListener(\"click\", () => {\r\n            this.setState({sectionClicked: false});\r\n        }, true); // useCapture = true for overwriting by section listener\r\n        window.addEventListener(\"keydown\", (event) => {\r\n            if (this.state.sectionClicked && event.ctrlKey) {\r\n                if (event.key === \"Enter\") {\r\n                    this.evalExpr();\r\n                    event.preventDefault();\r\n                }\r\n                else if (event.shiftKey && event.key.toLowerCase() === \"a\") {\r\n                    this.newExpression();\r\n                    event.preventDefault();\r\n                }\r\n                else if (event.shiftKey && event.key.toLowerCase() === \"d\") {\r\n                    this.deleteExpression();\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        });\r\n        this.updateErrors();\r\n    }\r\n\r\n    /**\r\n     * Updates displayed errors in the text area input.\r\n     */\r\n    public updateErrors = () => {\r\n        const text = this.getCurExpr().text;\r\n        const exprParser: ExprParser = new ExprParser(this.props.relations, this.props.nullValuesSupport);\r\n        const { errors } = exprParser.fakeParse(text, this.state.cursorIndex);\r\n        this.setState({\r\n            errors: errors.filter(err => err.range !== undefined)\r\n                // @ts-ignore\r\n                .map(err => {return {start: err.range.start, end: err.range.end + 1, msg: err.message}})\r\n        });\r\n    }\r\n\r\n    private getCurExpr(): Expression {\r\n        return this.props.expressions[this.props.currentExpressionIndex];\r\n    }\r\n\r\n    private handleSelectDifferentExpression(index: number): void {\r\n        this.setState({errors: []});\r\n        this.props.onSelectDifferentExpression(index);\r\n        this.showMessage(\"\");\r\n    }\r\n\r\n    private evalExpr = (): void => {\r\n        this.showMessage(\"\");\r\n        try {\r\n            const exprParser: ExprParser = new ExprParser(this.props.relations, this.props.nullValuesSupport);\r\n            const tree = exprParser.indexedParse(this.props.expressions[this.props.currentExpressionIndex].text);\r\n            tree.eval();\r\n            this.setState({errors: []});\r\n            this.props.onEval(tree);\r\n        }\r\n        catch (err) {\r\n            if (err instanceof ErrorWithTextRange) {\r\n                if (err.range !== undefined) {\r\n                    // change end to also highlight the last char\r\n                    err.range.end += 1;\r\n                    this.setState(state => {\r\n                        const errorRanges = state.errors;\r\n                        // does not push duplicate error range\r\n                        if (errorRanges.every(er => er.start !== err.range.start || er.end !== err.range.end)) {\r\n                            errorRanges.push({...err.range, msg: err.message});\r\n                        }\r\n                        return {errors: errorRanges}\r\n                    });\r\n                }\r\n            }\r\n            this.showError(err);\r\n        }\r\n    }\r\n\r\n    private newExpression = (): void => {\r\n        this.props.onNewExpression();\r\n    }\r\n\r\n    private deleteExpression = (): void => {\r\n        this.props.onDeleteExpression(this.updateErrors);\r\n    }\r\n\r\n    private saveExpressions = (): void => {\r\n        this.props.onExportExpressions(this.showMessage);\r\n    }\r\n\r\n    private loadExpressions = (): void => {\r\n        this.setState({errors: []});\r\n        this.props.onImportExpressions((msg) => {\r\n            this.showMessage(msg);\r\n            this.updateErrors();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds given special string into RA expression at the current cursor position.\r\n     *\r\n     * @param str string to be added\r\n     * @param shift move of the cursor from added string end position (to the beginning)\r\n     */\r\n    private addSpecialString = (str: string, shift: number): void => {\r\n        // @ts-ignore\r\n        const {start, end} = this.textAreaRef.current.getSelection();\r\n        const firstPart: string = this.getCurExpr().text.substring(0, start);\r\n        const secondPart: string = this.getCurExpr().text.substring(end);\r\n        const newPosition: number = firstPart.length + str.length - shift;\r\n        const newStr: string = firstPart + str + secondPart;\r\n        // updates text in textarea\r\n        this.handleExprChange(newStr, newPosition, () => {\r\n            // @ts-ignore - moves cursor to expected position\r\n            this.textAreaRef.current.setSelection(newPosition);\r\n            // @ts-ignore\r\n            this.textAreaRef.current.focus();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handles change of expression text. Updates text and notifies the parent.\r\n     *\r\n     * @param text\r\n     * @param cursorIndex\r\n     * @param onDone callback after updating the state\r\n     */\r\n    private handleExprChange = (text: string, cursorIndex: number, onDone: () => void = () => {}) => {\r\n        this.props.onChange(this.getCurExpr().name, text);  // must be called before setState for proper functionality of XTextArea\r\n        this.setState({cursorIndex: cursorIndex}, onDone);\r\n        this.lastChange = Date.now();\r\n    }\r\n\r\n    /**\r\n     * Shows current whispers and errors, if the text area is focused and there was a text change after last update.\r\n     */\r\n    private updateWhispersAndErrors = () => {\r\n        const textArea = this.textAreaRef.current;\r\n        if (textArea !== null && textArea.isFocused() && this.lastChange > this.lastWhisperAndErrorsUpdate) {\r\n            const text = this.getCurExpr().text;\r\n            const exprParser: ExprParser = new ExprParser(this.props.relations, this.props.nullValuesSupport);\r\n            const { whispers, errors } = exprParser.fakeParse(text, this.state.cursorIndex);\r\n            const wordBeforeCursor: string = text.slice(getStartOfWordBeforeIndex(text, this.state.cursorIndex), this.state.cursorIndex);\r\n            sortWhispers(whispers, wordBeforeCursor);\r\n            this.setState({\r\n                whispers: whispers,\r\n                errors: errors.filter(err => err.range !== undefined)\r\n                    // @ts-ignore\r\n                    .map(err => {return {start: err.range.start, end: err.range.end + 1, msg: err.message}})\r\n            });\r\n            this.lastWhisperAndErrorsUpdate = Date.now();\r\n        }\r\n    }\r\n\r\n    private handleExprNameChange = (name: string) => {\r\n        this.props.onChange(name, this.getCurExpr().text);\r\n    }\r\n\r\n    /**\r\n     * Shows the given message.\r\n     *\r\n     * @param msg message to be shown\r\n     * @param isError whether the message is error\r\n     */\r\n    private showMessage = (msg: string, isError: boolean = false) => {\r\n        this.setState({\r\n            messageText: msg,\r\n            isMessageError: isError\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handles and shows the given error. If the error is not of RASyntaxError or RASemanticError class, it is passed\r\n     * to the parent as unexpected error.\r\n     *\r\n     * @param err the error to handle\r\n     */\r\n    private showError = (err: Error) => {\r\n        // common user's errors\r\n        if (err instanceof RASyntaxError || err instanceof RASemanticError) {\r\n            this.showMessage(err.message, true);\r\n        }\r\n        else {\r\n            this.props.onUnexpectedError(err);\r\n            this.showMessage(\"UNEXPECTED ERROR: \" + err.message + \"\\n\" +\r\n                \"Please, report it with your last actions to kotliluk@fel.cvut.cz, thank you!\", true);\r\n        }\r\n    }\r\n\r\n    public render() {\r\n        const createExprMenuButtons = () => {\r\n            return this.props.expressions.map((expr, i) => {\r\n                const className: string = (this.props.darkTheme ?\r\n                    (this.props.currentExpressionIndex === i ? \"button-clicked-dark\" : \"button-dark\") :\r\n                    (this.props.currentExpressionIndex === i ? \"button-clicked-light\" : \"button-light\"));\r\n                return (<TooltipButton\r\n                    key={i}\r\n                    text={expr.name}\r\n                    onClick={() => this.handleSelectDifferentExpression(i)}\r\n                    className={className}\r\n                    style={{width: (98 / this.props.expressions.length) + \"%\"}}\r\n                    tooltip={expr.name}\r\n                    tooltipClassName={\"tooltip \" + (this.props.darkTheme ? \"tooltip-dark\" : \"tooltip-light\")}\r\n                />);\r\n            });\r\n        }\r\n\r\n        const createButton = (text: string, onClick: () => void, tooltip: string, style?: React.CSSProperties) => {\r\n            return (<TooltipButton\r\n                key={text}\r\n                text={text}\r\n                onClick={onClick}\r\n                className={this.props.darkTheme ? \"button-dark\" : \"button-light\"}\r\n                // @ts-ignore\r\n                style={style}\r\n                tooltip={tooltip}\r\n                tooltipClassName={\"tooltip \" + (this.props.darkTheme ? \"tooltip-dark\" : \"tooltip-light\")}\r\n            />);\r\n        }\r\n\r\n        const createOpButtons = (buttonProps: Array<OpButtonProps>) => {\r\n            return buttonProps.map(prop => {\r\n                return (<TooltipButton\r\n                    key={prop.key}\r\n                    text={prop.text}\r\n                    onClick={() => this.addSpecialString(prop.char, prop.shift)}\r\n                    className={this.props.darkTheme ? \"button-dark\" : \"button-light\"}\r\n                    tooltip={prop.tooltip}\r\n                    tooltipClassName={\"tooltip \" + (this.props.darkTheme ? \"tooltip-dark\" : \"tooltip-light\")}\r\n                />);\r\n            });\r\n        }\r\n\r\n        let sectionClassName = this.props.darkTheme ? \"section-border-dark\" : \"section-border-light\";\r\n        if (this.state.sectionClicked) {\r\n            sectionClassName = this.props.darkTheme ? \"section-border-dark-clicked\" : \"section-border-light-clicked\";\r\n        }\r\n        return (\r\n            <section\r\n                ref={this.sectionRef}\r\n                className={sectionClassName}>\r\n                <div className=\"expressions-list-menu\">\r\n                    {createExprMenuButtons()}\r\n                </div>\r\n\r\n                <XTextArea\r\n                    ref={this.textAreaRef}\r\n                    id=\"expression-section-textarea\"\r\n                    text={this.getCurExpr().text}\r\n                    placeholder=\"Write RA expression here...\"\r\n                    errors={this.state.errors}\r\n                    whispers={this.state.whispers}\r\n\r\n                    onChange={this.handleExprChange}\r\n\r\n                    darkTheme={this.props.darkTheme}\r\n                />\r\n\r\n                <div>\r\n                    {createOpButtons(this.buttonPropsFirstPart)}\r\n                    {this.props.nullValuesSupport ? createOpButtons(this.nullSupportRequiredButtonProps) : null}\r\n                    {createOpButtons(this.buttonPropsSecondPart)}\r\n                </div>\r\n\r\n                <div className=\"expressions-management-menu\">\r\n                    <div className=\"expressions-management-menu-left\">\r\n                        <TextInput\r\n                            label=\"\"\r\n                            value={this.getCurExpr().name}\r\n                            buttonText=\"Rename\"\r\n                            onSubmit={this.handleExprNameChange}\r\n                            forbidden={() => false}\r\n                            id=\"expression-name-input\"\r\n                            darkTheme={this.props.darkTheme}\r\n                        />\r\n                    </div>\r\n\r\n                    <div className=\"expressions-management-menu-right\">\r\n                        {createButton(\"Evaluate\", this.evalExpr, \"Evaluates given RA expression\", {marginRight: \"20px\"})}\r\n                        {createButton(\"New\", this.newExpression, \"Creates a new RA expression\")}\r\n                        {createButton(\"Delete\", this.deleteExpression, \"Deletes current RA expression\", {marginRight: \"20px\"})}\r\n                        {createButton(\"Import\", this.loadExpressions, \"Loads expressions from a file\")}\r\n                        {createButton(\"Export\", this.saveExpressions, \"Saves expressions to a file\")}\r\n                    </div>\r\n                </div>\r\n\r\n                <MessageLabel\r\n                    message={this.state.messageText}\r\n                    darkTheme={this.props.darkTheme}\r\n                    error={this.state.isMessageError}\r\n                />\r\n\r\n                <div style={{clear: \"both\"}}/>\r\n            </section>\r\n        );\r\n    }\r\n}","import React from \"react\";\r\nimport Relation from \"../relation/relation\";\r\nimport './css/resultRelationTable.css'\r\nimport Row from \"../relation/row\";\r\n\r\ninterface RelationTableProps {\r\n    // relation to be shown\r\n    relation: Relation,\r\n    // true if dark theme should be applied\r\n    darkTheme: boolean\r\n}\r\n\r\ninterface RelationTableState {\r\n    // index of the column which is used to order the table (or -1 if none is used)\r\n    orderBy: number,\r\n    // 1 = ascending, -1 = descending\r\n    orderDir: number\r\n}\r\n\r\n/**\r\n * Table which shows given relation. The relation cannot be edited\r\n * Rows can be ordered by column values when the column header is clicked.\r\n * When the same column header is clicked for the second time, the order direction is changed (asc, des, asc, des, ...).\r\n */\r\nexport class ResultRelationTable extends React.Component<RelationTableProps, RelationTableState> {\r\n\r\n    constructor(props: RelationTableProps) {\r\n        super(props);\r\n        this.state = {\r\n            orderBy: -1,\r\n            orderDir: 1\r\n        }\r\n    }\r\n\r\n    componentDidUpdate(prevProps: Readonly<RelationTableProps>, prevState: Readonly<RelationTableState>, snapshot?: any) {\r\n        if (prevProps.relation !== this.props.relation) {\r\n            this.setState({\r\n                orderDir: 1,\r\n                orderBy: -1\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates ordering column or direction. If the given orderBy index is already selected, switches ASC/DESC order.\r\n     * Otherwise, sets ASC ordering by new orderBy column index.\r\n     */\r\n    private updateOrderBy(orderBy: number): void {\r\n        this.setState(state => {\r\n            if (state.orderBy === orderBy) {\r\n                return {\r\n                    orderDir: -state.orderDir,\r\n                    orderBy: orderBy\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    orderDir: 1,\r\n                    orderBy: orderBy\r\n                };\r\n            }\r\n        });\r\n    }\r\n\r\n    private getOrderByText = (): string => {\r\n        return this.state.orderDir === 1 ? \" \" : \" \";\r\n    }\r\n\r\n    /**\r\n     * Creates a header row for a table (with given column names).\r\n     *\r\n     * @param columns\r\n     */\r\n    private createHeaderRow(columns: string[]) {\r\n        return (\r\n            <tr>\r\n                {columns.map((columnName, index) => {\r\n                    const text: string = this.state.orderBy === index ?\r\n                        (columnName + this.getOrderByText()) : columnName;\r\n                    return <th key={index} onClick={() => this.updateOrderBy(index)}>{text}</th>\r\n                })}\r\n            </tr>\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates rows for a table. If there is no row in a resultRelation, returns one cell \"<<NO ROWS>>\".\r\n     *\r\n     * @param columns\r\n     */\r\n    private createRows(columns: string[]) {\r\n        // creates default row if no exists\r\n        if (this.props.relation.getRowsCount() === 0) {\r\n            return (\r\n                <tr key='1'>\r\n                    <td key='1' colSpan={columns.length}>\r\n                        {'<<NO ROWS>>'}\r\n                    </td>\r\n                </tr>\r\n            );\r\n        }\r\n        const rows: Row[] = this.props.relation.getRows();\r\n        // sorts rows if orderBy is given (null values are after other values)\r\n        if (this.state.orderBy > -1 && this.state.orderBy < columns.length) {\r\n            const sortCol: string = columns[this.state.orderBy];\r\n            // @ts-ignore cannot be undefined\r\n            const type: \"string\" | \"number\" | \"boolean\" = rows[0].getType(sortCol);\r\n            if (type === \"number\") {\r\n                rows.sort((a, b) => {\r\n                    // @ts-ignore\r\n                    let aValue: number | null = a.getValue(sortCol);\r\n                    // @ts-ignore\r\n                    let bValue: number | null = b.getValue(sortCol);\r\n                    // a is null\r\n                    if (aValue === null && bValue !== null) {\r\n                        return this.state.orderDir * Number.MAX_SAFE_INTEGER;\r\n                    }\r\n                    // b is null\r\n                    if (aValue !== null && bValue === null) {\r\n                        return this.state.orderDir * Number.MIN_SAFE_INTEGER;\r\n                    }\r\n                    // no is null - compares as numbers\r\n                    if (aValue !== null && bValue !== null) {\r\n                        // @ts-ignore\r\n                        return this.state.orderDir * (a.getValue(sortCol) - b.getValue(sortCol));\r\n                    }\r\n                    // both are null\r\n                    return 0;\r\n                });\r\n            }\r\n            else {\r\n                rows.sort((a, b) => {\r\n                    // @ts-ignore\r\n                    let aValue: string | boolean | null = a.getValue(sortCol);\r\n                    // @ts-ignore\r\n                    let bValue: string | boolean | null = b.getValue(sortCol);\r\n                    // a is null\r\n                    if (aValue === null && bValue !== null) {\r\n                        return this.state.orderDir * Number.MAX_SAFE_INTEGER;\r\n                    }\r\n                    // b is null\r\n                    if (aValue !== null && bValue === null) {\r\n                        return this.state.orderDir * Number.MIN_SAFE_INTEGER;\r\n                    }\r\n                    // no is null - compares as strings\r\n                    if (aValue !== null && bValue !== null) {\r\n                        return this.state.orderDir * String(a.getValue(sortCol)).localeCompare(String(b.getValue(sortCol)));\r\n                    }\r\n                    // both are null\r\n                    return 0;\r\n                });\r\n            }\r\n        }\r\n        // creates all rows if any\r\n        return rows.map((row, index) => (\r\n            <tr key={index}>\r\n                {row.getOrderedValues(columns).map((value, index) => (\r\n                    <td key={index}>\r\n                        {String(value)}\r\n                    </td>\r\n                ))}\r\n            </tr>\r\n        ));\r\n    }\r\n\r\n    render(){\r\n        // creates header row\r\n        const columns: string[] = this.props.relation.getColumnNames();\r\n        const headerRow = this.createHeaderRow(columns);\r\n        const rows = this.createRows(columns);\r\n\r\n        let divClassName = \"result-table-container result-table-container-light cursor-container-light\";\r\n        let tableClassName = \"result-table result-table-light\";\r\n        if (this.props.darkTheme) {\r\n            divClassName = \"result-table-container result-table-container-dark cursor-container-dark\";\r\n            tableClassName = \"result-table result-table-dark\";\r\n        }\r\n\r\n        return (\r\n            <div className={divClassName}>\r\n                <table className={tableClassName}>\r\n                    <thead>\r\n                    {headerRow}\r\n                    </thead>\r\n                    <tbody>\r\n                    {rows}\r\n                    </tbody>\r\n                </table>\r\n            </div>\r\n        );\r\n    }\r\n}","import RATreeNode from \"./raTreeNode\";\r\nimport UnaryNode from \"./unaryNode\";\r\nimport BinaryNode from \"./binaryNode\";\r\n\r\n/**\r\n * Finds the root in the given tree with the given index with respect to depth first search. Root has index 0.\r\n *\r\n * @param root root of the searched tree\r\n * @param index index to be found\r\n * @return found root with given index or null if not found\r\n */\r\nexport function depthSearch(root: RATreeNode, index: number): RATreeNode | null {\r\n    let i: number = 0;\r\n    const findIndexInTree = (node: RATreeNode): RATreeNode | null => {\r\n        // wanted index found\r\n        if (i === index) {\r\n            return node;\r\n        }\r\n        i++;\r\n        if (node instanceof UnaryNode) {\r\n            return findIndexInTree(node.getSubtree());\r\n        }\r\n        if (node instanceof BinaryNode) {\r\n            const leftSearch = findIndexInTree(node.getLeftSubtree());\r\n            if (leftSearch === null) {\r\n                return findIndexInTree(node.getRightSubtree());\r\n            }\r\n            return leftSearch;\r\n        }\r\n        // end of the branch without the result\r\n        return null;\r\n    }\r\n    return findIndexInTree(root);\r\n}\r\n\r\n/**\r\n * Computes depth of the tree. One node has depth 0.\r\n *\r\n * @param root root of the tree to compute the depth for\r\n * @return tree depth\r\n */\r\nexport function getTreeDepth(root: RATreeNode): number {\r\n    if (root instanceof BinaryNode) {\r\n        const left: number = getTreeDepth(root.getLeftSubtree());\r\n        const right: number = getTreeDepth(root.getRightSubtree());\r\n        return Math.max(left, right) + 1;\r\n    }\r\n    if (root instanceof UnaryNode) {\r\n        return getTreeDepth(root.getSubtree()) + 1;\r\n    }\r\n    return 0;\r\n}","import React from \"react\";\r\nimport { Group } from '@visx/group';\r\nimport { Cluster, hierarchy } from '@visx/hierarchy';\r\nimport { HierarchyPointNode, HierarchyPointLink } from '@visx/hierarchy/lib/types';\r\nimport { LinkVertical } from '@visx/shape';\r\nimport ParentSize from \"@visx/responsive/lib/components/ParentSize\";\r\nimport {useTooltip, useTooltipInPortal} from '@visx/tooltip';\r\nimport './css/evaluationTree.css';\r\nimport RATreeNode from \"../ratree/raTreeNode\";\r\nimport UnaryNode from \"../ratree/unaryNode\";\r\nimport BinaryNode from \"../ratree/binaryNode\";\r\nimport {getTreeDepth} from \"../ratree/raTreeTools\";\r\nimport Relation from \"../relation/relation\";\r\nimport {computeFontSizeInPx} from \"../tools/font\";\r\n\r\ninterface EvaluationTreeProps {\r\n    // root of the evaluation tree to be displayed\r\n    tree: RATreeNode,\r\n    // index of the current selected node (with respect to depth first search)\r\n    selected: number,\r\n    // handler of click on nodes, it receives the index of the clicked node (with respect to depth first search)\r\n    onClick: (index: number) => void,\r\n    // true if dark theme should be applied\r\n    darkTheme: boolean\r\n}\r\n\r\n/**\r\n * Component displaying an evaluation tree. The tree is interactive and handles clicking on the nodes.\r\n */\r\nexport class EvaluationTree extends React.Component<EvaluationTreeProps, {}> {\r\n    render() {\r\n        return (\r\n            <ParentSize>{({ width }) =>\r\n                <TreeComponent\r\n                    raTree={this.props.tree}\r\n                    selected={this.props.selected}\r\n                    width={width}\r\n                    onClick={this.props.onClick}\r\n                    darkTheme={this.props.darkTheme}\r\n                />}\r\n            </ParentSize>\r\n        );\r\n    }\r\n}\r\n\r\n// @ts-ignore\r\nconst cssConstants: CSSStyleDeclaration = getComputedStyle(document.querySelector(':root'));\r\n\r\nconst fontSize: string = cssConstants.getPropertyValue('--eval-tree-font-size');\r\nconst fontFamily: string = cssConstants.getPropertyValue('--eval-tree-font-family');\r\nconst {fontWidth, fontHeight} = computeFontSizeInPx(fontFamily, fontSize);\r\nconst nodePaddingX2: number = 20;\r\nconst nodeHeight = fontHeight + nodePaddingX2;\r\n\r\nconst backgroundColorLight = cssConstants.getPropertyValue('--light-background');\r\nconst backgroundColorDark = cssConstants.getPropertyValue('--dark-background');\r\nconst textColorLight = cssConstants.getPropertyValue('--text-color-light');\r\nconst textColorDark = cssConstants.getPropertyValue('--text-color-dark');\r\nconst selectedNodeColorLight = cssConstants.getPropertyValue('--light-details');\r\nconst unselectedNodeColorLight = cssConstants.getPropertyValue('--light-section');\r\nconst selectedNodeColorDark = cssConstants.getPropertyValue('--dark-details');\r\nconst unselectedNodeColorDark = cssConstants.getPropertyValue('--dark-section');\r\n\r\ninterface DisplayTreeNode {\r\n    title: string;\r\n    tooltip: string,\r\n    index: number;\r\n    children?: this[];\r\n}\r\n\r\n/**\r\n * Creates a DisplayTreeNode tree from the given RATreeNode tree.\r\n *\r\n * @param tree RATreeNode tree to parse to DisplayTreeNode tree\r\n * @return parsed DisplayTreeNode tree\r\n */\r\nfunction parseTreeForDisplay(tree: RATreeNode): DisplayTreeNode {\r\n    let indexes = 0;\r\n    function parseTreeForDisplayHelper(node: RATreeNode): DisplayTreeNode {\r\n        const relation: Relation = node.getResult();\r\n        // @ts-ignore\r\n        const param: string = node.getParameter !== undefined ? \"\\n\\n\" + node.getParameter() : \"\";\r\n        const tooltip: string = relation.getName() + param + \"\\n\\n\" + relation.getColumnsCount() + \" columns\\n\" +\r\n            relation.getRowsCount() + \" rows\";\r\n\r\n        if (node instanceof UnaryNode) {\r\n            return {\r\n                title: node.getOperationName(),\r\n                tooltip: tooltip,\r\n                index: indexes++,\r\n                children: [\r\n                    parseTreeForDisplayHelper(node.getSubtree())\r\n                ]\r\n            }\r\n        }\r\n        else if (node instanceof BinaryNode) {\r\n            return {\r\n                title: node.getOperationName(),\r\n                tooltip: tooltip,\r\n                index: indexes++,\r\n                children: [\r\n                    parseTreeForDisplayHelper(node.getLeftSubtree()),\r\n                    parseTreeForDisplayHelper(node.getRightSubtree())\r\n                ]\r\n            }\r\n        }\r\n        else /* (tree instanceof RelationNode) */ {\r\n            return {\r\n                title: node.getOperationName(),\r\n                tooltip: tooltip,\r\n                index: indexes++\r\n            };\r\n        }\r\n    }\r\n    return parseTreeForDisplayHelper(tree);\r\n}\r\n\r\n/**\r\n * Component representing individual nodes of the displayed tree.\r\n *\r\n * Props:\r\n * - node: HierarchyPointNode<DisplayTreeNode>: node to be displayed wrapped as visx HierarchyPointNode.\r\n * - selected: boolean: boolean whether the given node is currently selected by the user\r\n * - onClick: (index: number) => void: handler of click on the node, it receives the index of the node (with\r\n * respect to depth first search)\r\n */\r\nfunction TreeNodeComponent({ node, selected, onClick, darkTheme }:\r\n                               { node: HierarchyPointNode<DisplayTreeNode>, selected: boolean, onClick: (index: number) => void, darkTheme: boolean }): JSX.Element {\r\n    const {\r\n        tooltipLeft,\r\n        tooltipTop,\r\n        tooltipOpen, // true when mouse is over\r\n        showTooltip,\r\n        hideTooltip\r\n    } = useTooltip();\r\n\r\n    // https://airbnb.io/visx/docs/tooltip\r\n    const { containerRef, TooltipInPortal } = useTooltipInPortal({\r\n        detectBounds: true,\r\n        scroll: true,\r\n    });\r\n\r\n    const handleMouseOver = () => {\r\n        showTooltip({ tooltipLeft: 0, tooltipTop: 0 });\r\n    };\r\n\r\n    // computes node width with respect to the text length and asserts it wider than taller\r\n    let nodeWidth = node.data.title.length * fontWidth + nodePaddingX2;\r\n    nodeWidth = nodeWidth > nodeHeight ? nodeWidth : nodeHeight;\r\n\r\n    return (\r\n        // top=y, left=x for vertical layout; top=x, left=y for horizontal layout\r\n        <Group top={node.y} left={node.x}>\r\n            <rect\r\n                height={nodeHeight} width={nodeWidth}\r\n                y={-nodeHeight / 2} x={-nodeWidth / 2} rx={10}\r\n                fill={darkTheme ?\r\n                    (selected ? selectedNodeColorDark : (tooltipOpen ? selectedNodeColorDark : unselectedNodeColorDark)) :\r\n                    (selected ? selectedNodeColorLight : (tooltipOpen ? selectedNodeColorLight : unselectedNodeColorLight))}\r\n                onClick={() => {\r\n                    onClick(node.data.index);\r\n                }}\r\n                ref={containerRef}\r\n                cursor=\"pointer\"\r\n                onMouseOver={handleMouseOver}\r\n                onMouseOut={hideTooltip}\r\n            >\r\n                {tooltipOpen && (\r\n                    <TooltipInPortal\r\n                        key={Math.random()}\r\n                        top={tooltipTop === undefined ? tooltipTop : tooltipTop + 20}\r\n                        left={tooltipLeft}\r\n                    >\r\n                        {node.data.tooltip}\r\n                    </TooltipInPortal>\r\n                )}\r\n            </rect>\r\n            <text\r\n                dy=\".33em\"\r\n                fontSize={fontSize}\r\n                fontFamily={fontFamily}\r\n                textAnchor=\"middle\"\r\n                style={{ pointerEvents: 'none' }}\r\n                fill={darkTheme ? textColorDark : textColorLight}\r\n            >\r\n                {node.data.title}\r\n            </text>\r\n        </Group>\r\n    );\r\n}\r\n\r\n/**\r\n * Internal component for displaying the evaluation tree. It uses visx Tree component.\r\n *\r\n * Props:\r\n * - tree: RATreeNode: root of the evaluation tree to be displayed\r\n * - selected: number: index of the current selected node (with respect to depth first search)\r\n * - width: number: width of the parent container\r\n * - onClick: (index: number) => void: handler of click on nodes, it receives the index of the clicked node (with\r\n * respect to depth first search)\r\n */\r\nfunction TreeComponent({raTree, selected, width, onClick, darkTheme}:\r\n                           {raTree: RATreeNode, selected: number, width: number, onClick: (index: number) => void, darkTheme: boolean}): JSX.Element | null {\r\n    const treeDepth: number = getTreeDepth(raTree);\r\n    const height = (treeDepth + 1) * nodeHeight * 1.5;\r\n    const margin = { top: nodeHeight / 2, left: 0 / 2, right: 0 / 2, bottom: nodeHeight / 2 };\r\n    const yMax = height - margin.top - margin.bottom;\r\n    const xMax = width - margin.left - margin.right;\r\n\r\n    const tree: DisplayTreeNode = parseTreeForDisplay(raTree);\r\n    const data = hierarchy<DisplayTreeNode>(tree);\r\n\r\n    // use Cluster for vertical tree layout, Tree for horizontal tree layout\r\n    return width < 10 ? null : (\r\n        <svg width={width} height={height}>\r\n            <rect width={width} height={height} rx={14} fill={darkTheme ? backgroundColorDark : backgroundColorLight} />\r\n            <Cluster<DisplayTreeNode> root={data} size={[xMax, yMax]}>\r\n                {cluster => (\r\n                    <Group top={margin.top} left={margin.left}>\r\n                        {cluster.links().map((link, i) => (\r\n                            <LinkVertical<HierarchyPointLink<DisplayTreeNode>, HierarchyPointNode<DisplayTreeNode>>\r\n                                key={`cluster-link-${i}`}\r\n                                data={link}\r\n                                stroke={darkTheme ? textColorDark : textColorLight}\r\n                                strokeWidth=\"1\"\r\n                                strokeOpacity={1}\r\n                                fill=\"none\"\r\n                            />\r\n                        ))}\r\n                        {cluster.descendants().map((node) => (\r\n                            <TreeNodeComponent\r\n                                key={`node-${node.data.index}`}\r\n                                node={node}\r\n                                selected={node.data.index === selected}\r\n                                onClick={onClick}\r\n                                darkTheme={darkTheme}\r\n                            />\r\n                        ))}\r\n                    </Group>\r\n                )}\r\n            </Cluster>\r\n        </svg>\r\n    );\r\n}","export interface File {\r\n    name: string,\r\n    text: string | null\r\n}\r\n\r\n/**\r\n * FileDialog for loading files to the application.\r\n */\r\nexport class FileDialog {\r\n\r\n    /**\r\n     * Loads asynchronously a textual content from one file selected by the user in the file browser.\r\n     *\r\n     * @param accept comma-separated list of extensions for filter (default are all extensions)\r\n     */\r\n    public static openFile(accept: string = \"*\"): Promise<File> {\r\n        return new Promise<File>(resolve => {\r\n            let element = document.createElement('div');\r\n            element.innerHTML = `<input type=\"file\" accept=${accept}>`;\r\n            let fileInput = element.firstChild;\r\n            // @ts-ignore\r\n            fileInput.addEventListener('change', function() {\r\n                // @ts-ignore\r\n                let file = fileInput.files[0];\r\n                let reader = new FileReader();\r\n                reader.onload = function() {\r\n                    // @ts-ignore\r\n                    resolve({name: file.name, text: reader.result});\r\n                };\r\n                reader.readAsText(file);\r\n            });\r\n            // @ts-ignore\r\n            fileInput.click();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Asynchronously loads textual content from multiple files selected by the user in the file browser.\r\n     *\r\n     * @param accept comma-separated list of extensions for filter (default are all extensions)\r\n     */\r\n    public static openFiles(accept: string = \"*\"): Promise<File[]> {\r\n        return new Promise<File[]>(resolve => {\r\n            FileDialog.openFilesHelper(resolve, accept);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Loads textual content from multiple files selected by the user in the file browser.\r\n     * Multiple file input handling inspired by xaedes on https://stackoverflow.com/a/13975217.\r\n     *\r\n     * @param resolve - function called when the loading is done, it should accept an array of file information\r\n     * {name: string, text: string | null}[] where name contains the filename and text contains the content of the file.\r\n     * @param accept comma-separated list of extensions for filter\r\n     */\r\n    private static openFilesHelper(resolve: (files: File[]) => void, accept: string): void {\r\n        let element = document.createElement('div');\r\n        element.innerHTML = `<input type=\"file\" accept=${accept} multiple>`;\r\n        // @ts-ignore\r\n        let fileInput: HTMLInputElement = element.firstChild;\r\n        const fileInfo: {name: string, text: string | null}[] = [];\r\n        fileInput.addEventListener('change', function() {\r\n            // @ts-ignore\r\n            const files: FileList = fileInput.files;\r\n            function readFile(index: number) {\r\n                if (index === files.length) {\r\n                    return resolve(fileInfo);\r\n                }\r\n                const file = files[index];\r\n                const reader = new FileReader();\r\n                reader.onload = function(e) {\r\n                    // @ts-ignore\r\n                    fileInfo.push({name: file.name, text: e.target.result});\r\n                    readFile(index+1);\r\n                    console.log('File ' + (index+1) + '/' + files.length + ' loaded');\r\n                }\r\n                reader.readAsText(file);\r\n            }\r\n            readFile(0);\r\n        });\r\n        fileInput.click();\r\n    }\r\n}\r\n","/**\r\n * Wrapper of JavaScript Map object to provide usage of object {row: number | \"name\", column: number} as a key.\r\n */\r\nexport class RCToStringMap {\r\n    private map: Map<string, string> = new Map<string, string>();\r\n\r\n    public get(row: number | \"name\", column: number): string | undefined {\r\n        return this.map.get(row + \":\" + column);\r\n    }\r\n\r\n    public set(row: number | \"name\", column: number, value: string): void {\r\n        this.map.set(row + \":\" + column, value);\r\n    }\r\n\r\n    public delete(row: number | \"name\", column: number): boolean {\r\n        return this.map.delete(row + \":\" + column);\r\n    }\r\n\r\n    public clear(): void {\r\n        this.map.clear();\r\n    }\r\n\r\n    public size(): number {\r\n        return this.map.size;\r\n    }\r\n\r\n    public forEach(f: (value: string, row: number | \"name\", column: number, index?: number) => void): void {\r\n        [...this.map.entries()]\r\n            .map((entry) => {return {value: entry[1], key: RCToStringMap.parseKey(entry[0])}})\r\n            .forEach((entry, index) => f(entry.value, entry.key.row, entry.key.column, index));\r\n    }\r\n\r\n    private static parseKey(key: string): {row: number | \"name\", column: number} {\r\n        const split = key.split(':');\r\n        return {row: Number(split[0]), column: Number(split[1])};\r\n    }\r\n}","import {isSupportedColumnType, SupportedColumnType} from \"./columnType\";\r\nimport Parser from \"../tools/parser\";\r\nimport {RCToStringMap} from \"../tools/rcToStringMap\";\r\nimport Relation from \"./relation\";\r\nimport Row from \"./row\";\r\nimport {isForbiddenColumnName} from \"../tools/keywords\";\r\n\r\n/**\r\n * Plain object representation of the stored relation.\r\n */\r\nexport interface StoredRelationData {\r\n    name: string;\r\n    columnNames: string[];\r\n    columnTypes: SupportedColumnType[];\r\n    rows: string[][];\r\n    columnCount: number;\r\n    rowCount: number;\r\n}\r\n\r\n/**\r\n * String representation of the relation for its storing. The relation may happen to be in inconsistent state.\r\n */\r\nexport class StoredRelation {\r\n\r\n    /**\r\n     * Creates a new stored relation with given name, one column and no rows.\r\n     */\r\n    static new(name: string, nullValuesSupport: boolean): StoredRelation {\r\n        return new StoredRelation(name, [\"Column1\"], [\"number\"], [], nullValuesSupport);\r\n    }\r\n\r\n    /**\r\n     * Creates a new stored relation from given plain relation object. If the object is not a valid StoredRelationData,\r\n     * throws error.\r\n     */\r\n    static fromData(data: any, nullValuesSupport: boolean): StoredRelation {\r\n        if (isStoredRelationData(data)) {\r\n            const d: StoredRelationData = data as StoredRelationData;\r\n            return new StoredRelation(d.name, d.columnNames, d.columnTypes, d.rows, nullValuesSupport);\r\n        }\r\n        throw new Error(\"Given object is not a valid relation.\");\r\n    }\r\n\r\n    /**\r\n     * Creates a new stored relation from given full relation representation.\r\n     */\r\n    static fromRelation(name: string, relation: Relation, nullValuesSupport: boolean): StoredRelation {\r\n        const columnNames: string[] = [];\r\n        const columnTypes: SupportedColumnType[] = [];\r\n        relation.getColumns().forEach((type, name) => {\r\n            columnNames.push(name);\r\n            columnTypes.push(type);\r\n        });\r\n        const rows: string[][] = relation.getRows().map(row => {\r\n            return row.getOrderedValues(columnNames).map(value => String(value));\r\n        });\r\n        return new StoredRelation(name, columnNames, columnTypes, rows, nullValuesSupport);\r\n    }\r\n\r\n    private name: string;\r\n    private readonly columnNames: string[];\r\n    private readonly columnTypes: SupportedColumnType[];\r\n    private rows: string[][];\r\n    private columnCount: number;\r\n    private rowCount: number;\r\n    private readonly errors: RCToStringMap;\r\n    private nullValuesSupport: boolean;\r\n    private actual: boolean;\r\n\r\n    /**\r\n     * Creates new relation with given name, one default column and no rows.\r\n     */\r\n    constructor(name: string, columnNames: string[], columnTypes: SupportedColumnType[],\r\n                        rows: string[][], nullValuesSupport: boolean) {\r\n        this.name = name;\r\n        this.columnNames = columnNames;\r\n        this.columnTypes = columnTypes;\r\n        this.rows = rows;\r\n        this.columnCount = columnNames.length;\r\n        this.rowCount = rows.length;\r\n        this.errors = new RCToStringMap();\r\n        this.nullValuesSupport = nullValuesSupport;\r\n        this.actual = false;\r\n        this.recomputeErrors();\r\n    }\r\n\r\n    /**\r\n     * Checks all possible errors in the relation.\r\n     */\r\n    private recomputeErrors(): void {\r\n        this.errors.clear();\r\n        this.checkColumnNames();\r\n        for (let c = 0; c < this.columnCount; ++c) {\r\n            [...new Array(this.rowCount).keys()].forEach(r => this.checkRowInput(c, r));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks whether the column name on given index is valid and not duplicit and updates error map.\r\n     */\r\n    private checkColumnNames(): void {\r\n        for (let columnIndex = 0; columnIndex < this.columnCount; ++columnIndex) {\r\n            const columnName: string = this.columnNames[columnIndex].trim();\r\n            if (columnName === \"\") {\r\n                this.errors.set(\"name\", columnIndex, \"Column name cannot be empty\");\r\n                continue;\r\n            }\r\n            const nameCount: number = this.columnNames.reduce((agg, name) => {\r\n                return (name === columnName) ? (agg + 1) : agg;\r\n            }, 0);\r\n            if (nameCount > 1) {\r\n                this.errors.set(\"name\", columnIndex, \"Duplicit column name\");\r\n                continue;\r\n            }\r\n            if (isForbiddenColumnName(columnName)) {\r\n                this.errors.set(\"name\", columnIndex, \"Column name cannot be a keyword\");\r\n                continue;\r\n            }\r\n            if (!Parser.isName(columnName)) {\r\n                this.errors.set(\"name\", columnIndex, \"Invalid characters in column name\");\r\n                continue;\r\n            }\r\n            this.errors.delete(\"name\", columnIndex);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks whether the row input on given index is valid and updates error map.\r\n     */\r\n    private checkRowInput(columnIndex: number, rowIndex: number): void {\r\n        const input: string = this.rows[rowIndex][columnIndex].trim();\r\n        const lower = input.toLowerCase();\r\n        // empty input = null\r\n        if (lower === \"\" || lower === \"null\") {\r\n            if (this.nullValuesSupport) {\r\n                this.errors.delete(rowIndex, columnIndex);\r\n            }\r\n            else {\r\n                this.errors.set(rowIndex, columnIndex, \"Null values are not supported\");\r\n            }\r\n            return;\r\n        }\r\n        if (this.columnTypes[columnIndex] === \"number\") {\r\n            if (!Parser.isNumber(input.replace(/\\s/g, \"\"))) {\r\n                this.errors.set(rowIndex, columnIndex, \"Given string is not a number\");\r\n                return;\r\n            }\r\n        }\r\n        else if (this.columnTypes[columnIndex] === \"string\") {\r\n            if (!Parser.isStringLiteral(input)) {\r\n                this.errors.set(rowIndex, columnIndex, \"Given string is not a string literal\");\r\n                return;\r\n            }\r\n        }\r\n        else /* this.columnTypes[columnIndex] === \"boolean\" */ {\r\n            if (lower !== \"true\" && lower !== \"t\" && lower !== \"false\" && lower !== \"f\") {\r\n                this.errors.set(rowIndex, columnIndex, \"Given string is not a boolean\");\r\n                return;\r\n            }\r\n        }\r\n        this.errors.delete(rowIndex, columnIndex);\r\n    }\r\n\r\n    /**\r\n     * Checks whether all row inputs on given column index are valid and updates error map.\r\n     */\r\n    private checkColumnTypes(columnIndex: number): void {\r\n        this.rows.forEach((_, i) => this.checkRowInput(columnIndex, i));\r\n    }\r\n\r\n    /**\r\n     * Creates a relation with full schema.\r\n     * WARNING: It expects that there are no errors in the stored relation before call.\r\n     */\r\n    public createRelation(): Relation {\r\n        const relation: Relation = new Relation(this.name);\r\n        for (let c = 0; c < this.columnCount; ++c) {\r\n            relation.addColumn(this.columnNames[c], this.columnTypes[c]);\r\n        }\r\n        this.rows.forEach(rowInput => {\r\n            const row: Row = new Row(relation.getColumns());\r\n            rowInput.forEach((input, c) => {\r\n                input = input.trim();\r\n                if (input === \"\" || input === \"null\") {\r\n                    row.addValue(this.columnNames[c], null);\r\n                }\r\n                else if (this.columnTypes[c] === \"string\") {\r\n                    row.addValue(this.columnNames[c], input);\r\n                }\r\n                else if (this.columnTypes[c] === \"number\") {\r\n                    row.addValue(this.columnNames[c], Number(input.replace(/\\s/g, \"\")));\r\n                }\r\n                else /* this.columnTypes[c] === \"boolean\" */ {\r\n                    const lower = input.toLowerCase();\r\n                    row.addValue(this.columnNames[c], lower === \"t\" || lower === \"true\");\r\n                }\r\n            });\r\n            relation.addRow(row);\r\n        });\r\n        relation.finishSchema();\r\n        return relation;\r\n    }\r\n\r\n    /**\r\n     * Creates plain object representation of the stored relation.\r\n     */\r\n    public toDataObject(): StoredRelationData {\r\n        return {\r\n            name: this.name,\r\n            columnNames: this.columnNames,\r\n            columnTypes: this.columnTypes,\r\n            rows: this.rows,\r\n            columnCount: this.columnCount,\r\n            rowCount: this.rowCount\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns map \"row/column => error\". Numeric row keys are for relation rows, row key \"name\" is for column name row.\r\n     */\r\n    public getErrors(): RCToStringMap {\r\n        return this.errors;\r\n    }\r\n\r\n    /**\r\n     * Returns true if there are no errors in the relation.\r\n     */\r\n    public isValid(): boolean {\r\n        return this.errors.size() === 0;\r\n    }\r\n\r\n    /**\r\n     * Sets null values support to check null errors in the relation.\r\n     */\r\n    public setNullValuesSupport(nullValuesSupport: boolean): void {\r\n        if (nullValuesSupport !== this.nullValuesSupport) {\r\n            this.nullValuesSupport = nullValuesSupport;\r\n            this.recomputeErrors();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a new column with default name \"Column n\", default type \"number\", and empty inputs \"\" in all rows.\r\n     */\r\n    public addNewColumn(): void {\r\n        let i = (this.columnNames.length + 1);\r\n        let name = \"Column\" + i;\r\n        while (this.columnNames.indexOf(name) > -1) {\r\n            name = \"Column\" + ++i;\r\n        }\r\n        this.columnNames.push(name);\r\n        this.columnTypes.push(\"number\");\r\n        if (this.nullValuesSupport) {\r\n            this.rows.forEach(r => r.push(\"\"));\r\n        }\r\n        else {\r\n            this.rows.forEach(r => r.push(\"0\"));\r\n        }\r\n        ++this.columnCount;\r\n        this.checkColumnNames();\r\n        this.actual = false;\r\n    }\r\n\r\n    /**\r\n     * Adds a new row with empty inputs \"\" in all columns.\r\n     */\r\n    public addNewRow(): void {\r\n        if (this.nullValuesSupport) {\r\n            this.rows.push([...new Array(this.columnCount).keys()].map(_ => \"\"));\r\n        }\r\n        else {\r\n            this.rows.push([...new Array(this.columnCount).keys()].map(i => {\r\n                if (this.columnTypes[i] === \"number\") {\r\n                    return \"0\";\r\n                }\r\n                else if (this.columnTypes[i] === \"boolean\") {\r\n                    return \"false\";\r\n                }\r\n                return '\"\"';\r\n            }));\r\n        }\r\n        ++this.rowCount;\r\n        this.actual = false;\r\n    }\r\n\r\n    /**\r\n     * Deletes a column with the given index. If the last column was deleted, removes all rows and creates\r\n     * new default column.\r\n     *\r\n     * @param columnIndex\r\n     */\r\n    public deleteColumn(columnIndex: number): void {\r\n        this.columnNames.splice(columnIndex, 1);\r\n        this.columnTypes.splice(columnIndex, 1);\r\n        this.rows.forEach(row => row.splice(columnIndex, 1));\r\n        --this.columnCount;\r\n        // if last column was deleted, removes all rows and creates new default column\r\n        if (this.columnCount === 0) {\r\n            this.rows = [];\r\n            this.addNewColumn();\r\n        }\r\n        this.errors.forEach((value, row, column) => {\r\n            // removes errors for given row\r\n            if (column === columnIndex) {\r\n                this.errors.delete(row, column);\r\n            }\r\n            // updates row index for errors in rows under deleted one\r\n            else if (column > columnIndex) {\r\n                this.errors.delete(row, column);\r\n                this.errors.set(row, column, value);\r\n            }\r\n        });\r\n        this.actual = false;\r\n    }\r\n\r\n    /**\r\n     * Deletes a row with given index.\r\n     *\r\n     * @param rowIndex\r\n     */\r\n    public deleteRow(rowIndex: number): void {\r\n        this.rows.splice(rowIndex, 1);\r\n        --this.rowCount;\r\n        this.errors.forEach((value, row, column) => {\r\n            // removes errors for given row\r\n            if (row === rowIndex) {\r\n                this.errors.delete(row, column);\r\n            }\r\n            // updates row index for errors in rows under deleted one\r\n            else if (row > rowIndex) {\r\n                this.errors.delete(row, column);\r\n                // @ts-ignore \"key.row > rowIndex\" is true only for numbers\r\n                this.errors.set({column: key.column, row: key.row - 1}, value);\r\n            }\r\n        });\r\n        this.actual = false;\r\n    }\r\n\r\n    public getRowCount(): number {\r\n        return this.rowCount;\r\n    }\r\n\r\n    public getColumnCount(): number {\r\n        return this.columnCount;\r\n    }\r\n\r\n    public setName(name: string): void {\r\n        this.name = name;\r\n        this.actual = false;\r\n    }\r\n\r\n    public getName(): string {\r\n        return this.name;\r\n    }\r\n\r\n    public getColumnNames(): string[] {\r\n        return this.columnNames;\r\n    }\r\n\r\n    public setColumnName(columnName: string, columnIndex: number): void {\r\n        this.columnNames[columnIndex] = columnName;\r\n        this.checkColumnNames();\r\n        this.actual = false;\r\n    }\r\n\r\n    public getColumnTypes(): SupportedColumnType[] {\r\n        return this.columnTypes;\r\n    }\r\n\r\n    public setColumnType(columnType: SupportedColumnType, columnIndex: number): void {\r\n        this.columnTypes[columnIndex] = columnType;\r\n        this.checkColumnTypes(columnIndex);\r\n        this.actual = false;\r\n    }\r\n\r\n    public getRows(): string[][] {\r\n        return this.rows;\r\n    }\r\n\r\n    public setRowInput(input: string, rowIndex: number, columnIndex: number): void {\r\n        this.rows[rowIndex][columnIndex] = input;\r\n        this.checkRowInput(columnIndex, rowIndex);\r\n        this.actual = false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if no changes were made after last setActual(true) call.\r\n     * The StoredRelation is created with isActual() = false.\r\n     */\r\n    public isActual(): boolean {\r\n        return this.actual;\r\n    }\r\n\r\n    /**\r\n     * Sets current StoredRelation state as actual. Any change sets the state as not actual automatically.\r\n     */\r\n    public setActual(actual: boolean): void {\r\n        this.actual = actual;\r\n    }\r\n}\r\n\r\n/**\r\n * Returns true if the relation relation object has at least one column, and all rows has the same length.\r\n */\r\nexport function isStoredRelationData(obj: any): boolean {\r\n    if (typeof obj !== \"object\") {\r\n        return false;\r\n    }\r\n    if (!(\"name\" in obj) || typeof obj.name !== \"string\") {\r\n        return false;\r\n    }\r\n    if (!(\"columnCount\" in obj) || typeof obj.columnCount !== \"number\" || obj.columnCount < 1) {\r\n        return false;\r\n    }\r\n    if (!(\"rowCount\" in obj) || typeof obj.rowCount !== \"number\") {\r\n        return false;\r\n    }\r\n    if (!(\"columnNames\" in obj) || !Array.isArray(obj.columnNames) || obj.columnNames.length !== obj.columnCount ||\r\n        obj.columnNames.some((o: any) => typeof o !== \"string\")) {\r\n        return false;\r\n    }\r\n    if (!(\"columnTypes\" in obj) || !Array.isArray(obj.columnTypes) || obj.columnTypes.length !== obj.columnCount ||\r\n        obj.columnTypes.some((o: any) => !isSupportedColumnType(o))) {\r\n        return false;\r\n    }\r\n    return (\"rows\" in obj && Array.isArray(obj.rows) && obj.rows.every((o: any) => {\r\n        return Array.isArray(o) && o.length === obj.columnCount && o.every((d: any) => typeof d === \"string\");\r\n    }));\r\n}","/**\r\n * Specifies supported column types in the application. When changed, update the keywords.ts file.\r\n */\r\n\r\n/**\r\n * Supported string names of types of columns for a relational schema.\r\n */\r\nexport type SupportedColumnType = \"string\" | \"number\" | \"boolean\";\r\n\r\n/**\r\n * Possible types of the content of columns (null values included).\r\n */\r\nexport type ColumnContent = string | number | boolean | null;\r\n\r\n/**\r\n * Returns true if the given obj is string with value SupportedColumnType value.\r\n */\r\nexport function isSupportedColumnType(obj: any): boolean {\r\n    if (typeof obj !== \"string\") {\r\n        return false;\r\n    }\r\n    return obj === \"string\" || obj === \"number\" || obj === \"boolean\";\r\n}","import {FileDialog} from \"../tools/fileDialog\";\r\nimport {\r\n    CsvValueSeparatorChar,\r\n    findValueSeparatorChar\r\n} from \"../tools/csvSupport\";\r\nimport {StoredRelation} from \"./storedRelation\";\r\nimport {SupportedColumnType} from \"./columnType\";\r\nimport {saveAs} from \"file-saver\";\r\nimport JSZip from \"jszip\";\r\nimport Parser from \"../tools/parser\";\r\n\r\n/**\r\n * Class for loading and saving relation definitions.\r\n */\r\nexport class RelationStoreManager {\r\n\r\n    /**\r\n     * Loads textual relation representations from multiple csv files selected by the user. If the csv does not have\r\n     * valid stricture, it is skipped. Loaded csv are parsed to StoredRelations and returned in a promise.\r\n     *\r\n     * @param nullValuesSupport null values support to set in created StoredRelations\r\n     */\r\n    public static load(nullValuesSupport: boolean): Promise<{relations: StoredRelation[], skipped: number}> {\r\n        return new Promise<{relations: StoredRelation[], skipped: number}>(resolve => {\r\n            FileDialog.openFiles(\".csv\").then(files => {\r\n                let relations: StoredRelation[] = [];\r\n                let skipped: number = 0;\r\n                files.forEach(file => {\r\n                    if (file.name.match(/\\.csv$/)) {\r\n                        try {\r\n                            relations.push(this.csvToRelation(RelationStoreManager.createValidName(file.name.slice(0, -4)),\r\n                                file.text, nullValuesSupport));\r\n                        }\r\n                        catch (err) {\r\n                            console.log('File ' + file.name + ' skipped for bad format of csv');\r\n                            skipped += 1;\r\n                        }\r\n                    }\r\n                    else {\r\n                        console.log('Unsupported filetype: ' + file.name);\r\n                        skipped += 1;\r\n                    }\r\n                });\r\n                resolve({relations: relations, skipped: skipped});\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Saves given relations into csv files (in one csv file each relation). Uses given value separator.\r\n     *\r\n     * @param relations map of the relations to be saved\r\n     * @param filename name of the downloaded file (without .zip/.csv extension)\r\n     * @param valueSeparator the separator of values\r\n     */\r\n    public static save(relations: StoredRelation[], filename: string, valueSeparator: CsvValueSeparatorChar): void {\r\n        if (relations.length === 0) {\r\n            return;\r\n        }\r\n        if (relations.length === 1) {\r\n            const blob = new Blob([this.relationToCsv(relations[0], valueSeparator)], {type: \"text/plain;charset=utf-8\"});\r\n            saveAs(blob, filename + '.csv');\r\n            return;\r\n        }\r\n        const zip: JSZip = JSZip();\r\n        relations.forEach(relation => {\r\n            zip.file(relation.getName() + '.csv', this.relationToCsv(relation, valueSeparator));\r\n        });\r\n        zip.generateAsync({type: \"blob\"}).then(content => {\r\n            saveAs(content, filename + \".zip\");\r\n        }).catch(err => {\r\n            throw err;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Parses a StoredRelation from given csv text. If the text is invalid, throws error.\r\n     *\r\n     * @param name name of the relation\r\n     * @param text csv content to parse a relation from\r\n     * @param nullValuesSupport null values support to set in created StoredRelation\r\n     */\r\n    private static csvToRelation(name: string, text: string | null, nullValuesSupport: boolean): StoredRelation {\r\n        if (text === null || text === \"\") {\r\n            console.log(\"null or empty string read from file \" + name);\r\n            throw Error();\r\n        }\r\n\r\n        text = text.trim().replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\r\n        const lines: string[] = text.split('\\n');\r\n\r\n        if (lines.length < 2) {\r\n            console.log(\"file \" + name + \" has only one line\");\r\n            throw Error();  // at least two lines are expected (names and types)\r\n        }\r\n\r\n        lines[0] = lines[0].replace(/\\s/g, '');\r\n        lines[1] = lines[1].replace(/\\s/g, '');\r\n\r\n        let separator = findValueSeparatorChar(lines[1]);\r\n        // if no separator is found, only one column is expected - sets separator to not defined value to unify the\r\n        // following process\r\n        if (separator === undefined) {\r\n            separator = ';';\r\n        }\r\n\r\n        const columnNames: string[] = lines[0].split(separator);\r\n        const columnTypes: SupportedColumnType[] = lines[1].split(separator).map(str => {\r\n            const lower = str.toLowerCase();\r\n            if (lower === \"string\" || lower === \"str\" || lower === \"s\") {\r\n                return \"string\";\r\n            }\r\n            else if (lower === \"number\" || lower === \"num\" || lower === \"n\") {\r\n                return \"number\";\r\n            }\r\n            return \"boolean\";\r\n        });\r\n        const rows: string[][] = lines.slice(2).map(line => {\r\n            const row: string[] = []\r\n            line = line.trim();\r\n            while (true) {\r\n                // @ts-ignore - separator cannot be undefined now\r\n                const split = RelationStoreManager.nextRowInput(line, separator);\r\n                row.push(split.input);\r\n                if (split.rest === undefined) {\r\n                    break;\r\n                }\r\n                line = split.rest;\r\n            }\r\n            return row;\r\n        });\r\n\r\n        // all rows must have equal column count\r\n        const columnCount = columnNames.length;\r\n        if (columnTypes.length !== columnCount || rows.some(row => row.length !== columnCount)) {\r\n            console.log(\"rows in file \" + name + \" do not have the same number of columns\");\r\n            throw new Error();\r\n        }\r\n\r\n        return new StoredRelation(name, columnNames, columnTypes, rows, nullValuesSupport);\r\n    }\r\n\r\n    /**\r\n     * Removes invalid characters for name. If the filtered name is empty, returns string \"relation\".\r\n     */\r\n    private static createValidName(name: string): string {\r\n        name = name.split('').filter(char => Parser.isNameChar(char)).join('');\r\n        if (name === \"\") {\r\n            return \"relation\";\r\n        }\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * Returns next part of the line before separator. Separators in string literals are ignored.\r\n     */\r\n    private static nextRowInput(line: string, separator: string): {input: string, rest: string | undefined} {\r\n        let inString = false;\r\n        let backslashes = 0;\r\n        let i = 0;\r\n        while (i < line.length) {\r\n            const char = line.charAt(i);\r\n            // separator found not in the string literal\r\n            if (!inString && char === separator) {\r\n                return {input: line.slice(0, i), rest: line.slice(i + 1)};\r\n            }\r\n            // next backslash found in a row\r\n            if (char === '\\\\') {\r\n                ++backslashes;\r\n            }\r\n            // resets backslashes in a row\r\n            else {\r\n                backslashes = 0;\r\n            }\r\n            // not escaped quotes found\r\n            if (char === '\"' && (backslashes % 2) === 0) {\r\n                inString = !inString;\r\n            }\r\n            ++i;\r\n        }\r\n        return {input: line, rest: undefined}\r\n    }\r\n\r\n    /**\r\n     * Creates a csv representation for the given relation.\r\n     */\r\n    private static relationToCsv(relation: StoredRelation, valueSeparator: CsvValueSeparatorChar): string {\r\n        const names: string = relation.getColumnNames().join(valueSeparator);\r\n        const types: string = relation.getColumnTypes().join(valueSeparator);\r\n        const rows: string[] = relation.getRows().map(row => row.join(valueSeparator));\r\n        return [names, types, ...rows].join('\\n');\r\n    }\r\n}","/**\r\n * Two possible CSV value separators: comma (,) and semicolon (;).\r\n */\r\nexport type CsvValueSeparatorChar = \",\" | \";\";\r\n\r\nexport function findValueSeparatorChar(str: string): string | undefined {\r\n    for (let i = 0; i < str.length; ++i) {\r\n        const char: string = str.charAt(i);\r\n        if (char === \",\") {\r\n            return \",\";\r\n        }\r\n        if (char === \";\") {\r\n            return \";\";\r\n        }\r\n    }\r\n    return undefined;\r\n}","import React from \"react\";\r\nimport Relation from \"../relation/relation\";\r\nimport {ResultRelationTable} from \"./resultRelationTable\";\r\nimport {TooltipButton} from \"./tooltipButton\";\r\nimport {MessageLabel} from \"./messageLabel\";\r\nimport RASyntaxError from \"../error/raSyntaxError\";\r\nimport RASemanticError from \"../error/raSemanticError\";\r\nimport RATreeNode from \"../ratree/raTreeNode\";\r\nimport {CsvValueSeparatorChar} from \"../tools/csvSupport\";\r\nimport {EvaluationTree} from \"./evaluationTree\";\r\nimport {depthSearch} from \"../ratree/raTreeTools\";\r\nimport {CodeErrorCodes, ErrorFactory} from \"../error/errorFactory\";\r\nimport {RelationStoreManager} from \"../relation/relationStoreManager\";\r\nimport {StoredRelation} from \"../relation/storedRelation\";\r\n\r\ninterface ResultSectionProps {\r\n    // the root of the current evaluation tree to display\r\n    evaluationTreeRoot: RATreeNode,\r\n    // name of the evaluated expression\r\n    expressionName: string,\r\n\r\n    // handler of adding the selected relation with given name to defined relations\r\n    onAddResult: (name: string, relation: Relation, onSuccess: () => void, onError: (msg: string) => void) => void,\r\n\r\n    // handler of unexpected errors\r\n    onUnexpectedError: (e: Error) => void,\r\n\r\n    // current selected value separator in csv files\r\n    csvValueSeparator: CsvValueSeparatorChar\r\n    // true if dark theme should be applied\r\n    darkTheme: boolean,\r\n}\r\n\r\ninterface ResultSectionState {\r\n    sectionClicked: boolean,\r\n    selectedIndex: number,\r\n    relationName: string,\r\n    messageText: string,\r\n    isMessageError: boolean\r\n}\r\n\r\n/**\r\n * Section to show the evaluation result. It contains a table with a result and text input and buttons to save it.\r\n * The component is hidden if given resultRelation is null.\r\n */\r\nexport class ResultSection extends React.Component<ResultSectionProps, ResultSectionState> {\r\n\r\n    // reference to this section element\r\n    private readonly sectionRef: React.RefObject<HTMLDivElement>;\r\n\r\n    constructor(props: ResultSectionProps) {\r\n        super(props);\r\n        this.state = {\r\n            sectionClicked: false,\r\n            selectedIndex: 0,\r\n            relationName: 'ResultRelation',\r\n            messageText: \"\",\r\n            isMessageError: false\r\n        }\r\n        this.sectionRef = React.createRef<HTMLDivElement>();\r\n    }\r\n\r\n    componentDidMount() {\r\n        const section = this.sectionRef.current;\r\n        if (section !== null) {\r\n            section.addEventListener(\"click\", () => {\r\n                this.setState({sectionClicked: true});\r\n            }, true); // useCapture = true for overwriting the window listener\r\n        }\r\n        window.addEventListener(\"click\", () => {\r\n            this.setState({sectionClicked: false});\r\n        }, true); // useCapture = true for overwriting by section listener\r\n    }\r\n\r\n    componentDidUpdate(prevProps: Readonly<ResultSectionProps>) {\r\n        if (prevProps.evaluationTreeRoot !== this.props.evaluationTreeRoot) {\r\n            this.setState({selectedIndex: 0});\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the result relation for the current selected node.\r\n     */\r\n    private getCurrentRelation = (): Relation | null => {\r\n        let currentNode: RATreeNode | null = depthSearch(this.props.evaluationTreeRoot, this.state.selectedIndex);\r\n        if (currentNode === null) {\r\n            currentNode = depthSearch(this.props.evaluationTreeRoot, 0);\r\n            if (currentNode === null) {\r\n                this.props.onUnexpectedError(ErrorFactory.codeError(CodeErrorCodes.resultSection_getCurrentRelation_nodeIndexNotFound));\r\n                return null;\r\n            }\r\n        }\r\n        try {\r\n            return currentNode.getResult();\r\n        }\r\n        catch (err) {\r\n            // errors should be handled in expression section\r\n            this.props.onUnexpectedError(ErrorFactory.codeError(CodeErrorCodes.resultSection_getCurrentRelation_evalError, err.message));\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private handleSelectedNodeChange = (index: number): void => {\r\n        this.setState({selectedIndex: index});\r\n    }\r\n\r\n    /**\r\n     * Saves the current selected relation to a file.\r\n     */\r\n    private saveResultRelation = (): void => {\r\n        if (this.getCurrentRelation() === null) {\r\n            this.showError(ErrorFactory.codeError(CodeErrorCodes.resultSection_saveResultRelation_nullRelationToSave));\r\n            return;\r\n        }\r\n        const name: string = this.state.relationName;\r\n        if (name === \"\") {\r\n            this.showMessage(\"Relation name cannot be empty.\", true);\r\n            return;\r\n        }\r\n        try {\r\n            RelationStoreManager.save([StoredRelation.fromRelation(name, this.getCurrentRelation() as Relation, true)],\r\n                name, this.props.csvValueSeparator);\r\n            this.showMessage(\"Relation saved to file.\", false);\r\n        }\r\n        catch (err) {\r\n            this.showMessage(\"Saving error: \" + err, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates resultRelationName.\r\n     *\r\n     * @param event event with the new name\r\n     */\r\n    private handleRelationNameChange = (event: React.ChangeEvent<HTMLInputElement>): void => {\r\n        this.setState({relationName: event.target.value})\r\n    }\r\n\r\n    /**\r\n     * Passes the current selected relation with the given name to the parent.\r\n     */\r\n    private handleAddRelation = (): void => {\r\n        if (this.getCurrentRelation() === null) {\r\n            this.showError(ErrorFactory.codeError(CodeErrorCodes.resultSection_handleAddRelation_nullRelationToAdd));\r\n            return;\r\n        }\r\n        // @ts-ignore\r\n        this.props.onAddResult(this.state.relationName, this.getCurrentRelation(),\r\n            () => this.showMessage(\"Relation \\\"\" + this.state.relationName + \"\\\" was added to definitions.\"),\r\n            (msg: string) => this.showMessage(msg, true));\r\n    }\r\n\r\n    /**\r\n     * Shows the given message.\r\n     *\r\n     * @param msg message to be shown\r\n     * @param isError whether the message is error\r\n     */\r\n    private showMessage = (msg: string, isError: boolean = false) => {\r\n        this.setState({\r\n            messageText: msg,\r\n            isMessageError: isError\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handles and shows the given error. If the error is not of RASyntaxError or RASemanticError class, it is passed\r\n     * to the parent as unexpected error.\r\n     *\r\n     * @param err the error to handle\r\n     */\r\n    private showError = (err: Error) => {\r\n        // common user's errors\r\n        if (err instanceof RASyntaxError || err instanceof RASemanticError) {\r\n            this.showMessage(err.message, true);\r\n        }\r\n        else {\r\n            this.props.onUnexpectedError(err);\r\n            this.showMessage(\"UNEXPECTED ERROR: \" + err.message + \"\\n\" +\r\n                \"Please, report it with your last actions to kotliluk@fel.cvut.cz, thank you!\", true);\r\n        }\r\n    }\r\n\r\n    render() {\r\n        // does not show null result\r\n        if (this.getCurrentRelation() === null) {\r\n            return null;\r\n        }\r\n        // one place to style buttons\r\n        const createButton = (text: string, onClick: () => void, tooltip: string) => {\r\n            return (\r\n                <TooltipButton\r\n                    text={text}\r\n                    onClick={onClick}\r\n                    className={this.props.darkTheme ? \"button-dark\" : \"button-light\"}\r\n                    tooltip={tooltip}\r\n                    tooltipClassName={\"tooltip \" + (this.props.darkTheme ? \"tooltip-dark\" : \"tooltip-light\")}\r\n            />);\r\n        }\r\n        const selectedNode: RATreeNode | null = depthSearch(this.props.evaluationTreeRoot, this.state.selectedIndex);\r\n        const tableTitle: string | null = selectedNode === null ? null : selectedNode.getResult().getName();\r\n\r\n        let sectionClassName = this.props.darkTheme ? \"section-border-dark\" : \"section-border-light\";\r\n        if (this.state.sectionClicked) {\r\n            sectionClassName = this.props.darkTheme ? \"section-border-dark-clicked\" : \"section-border-light-clicked\";\r\n        }\r\n        return (\r\n            <section\r\n                ref={this.sectionRef}\r\n                className={sectionClassName}>\r\n                <p><strong>{'Evaluation tree of \"' + this.props.expressionName + '\":'}</strong></p>\r\n\r\n                <EvaluationTree\r\n                    tree={this.props.evaluationTreeRoot}\r\n                    selected={this.state.selectedIndex}\r\n                    onClick={this.handleSelectedNodeChange}\r\n                    darkTheme={this.props.darkTheme}\r\n                />\r\n\r\n                <p><strong>{tableTitle}:</strong></p>\r\n\r\n                <ResultRelationTable\r\n                    relation={this.getCurrentRelation() as Relation}\r\n                    darkTheme={this.props.darkTheme}\r\n                />\r\n\r\n                <footer>\r\n                    <input\r\n                        type='text'\r\n                        className={this.props.darkTheme ? 'text-input-dark' : 'text-input-light'}\r\n                        spellCheck={false}\r\n                        value={this.state.relationName}\r\n                        onChange={this.handleRelationNameChange}\r\n                    />\r\n                    {createButton(\"Add\", this.handleAddRelation, \"Adds given relation to stored ones\")}\r\n                    {createButton(\"Save\", this.saveResultRelation, \"Saves given relation to a file\")}\r\n\r\n                    <MessageLabel\r\n                        message={this.state.messageText}\r\n                        darkTheme={this.props.darkTheme}\r\n                        error={this.state.isMessageError}\r\n                    />\r\n                </footer>\r\n            </section>\r\n        );\r\n    }\r\n}","import {FileDialog} from \"../tools/fileDialog\";\r\nimport {saveAs} from \"file-saver\";\r\nimport {Expression} from \"./expression\";\r\n\r\n/**\r\n * Promised relation in ExpressionStoreManager.load() function. Contains:\r\n * - expressions: Expression[] - successfully parsed expressions\r\n * - skippedExpressions: number - number of skipped expressions (from successfully loaded files)\r\n * - loadedFiles: number - number of successfully loaded files\r\n * - skippedFiles: number - number of skipped files (not .txt, null loaded...)\r\n */\r\nexport interface ExpressionLoadData {\r\n    expressions: Expression[],\r\n    skippedExpressions: number,\r\n    loadedFiles: number,\r\n    skippedFiles: number\r\n}\r\n\r\n/**\r\n * Class for loading and saving expressions.\r\n */\r\nexport class ExpressionStoreManager {\r\n\r\n    /**\r\n     * Loads expressions from multiple textual files selected by the user. Each file can contain multiple expressions,\r\n     * split by '\\n###\\n'. When different line separator is used (\\r, \\r\\n), it is replaced by \\n before return.\r\n     * All tabulators are replaces by 4 spaces.\r\n     */\r\n    public static load(): Promise<ExpressionLoadData> {\r\n        return new Promise<ExpressionLoadData>(resolve => {\r\n            FileDialog.openFiles(\".txt\").then(files =>{\r\n                let expressions: Expression[] = [];\r\n                let skippedExpressions: number = 0;\r\n                let loadedFiles: number = 0;\r\n                let skippedFiles: number = 0;\r\n                files.forEach(file => {\r\n                    if (file.text === null) {\r\n                        console.log('Null read from file ' + file.name);\r\n                        skippedFiles += 1;\r\n                    }\r\n                    else if (file.name.match(/\\.txt$/)) {\r\n                        // replaces line separators to expected '\\n' and tabulators to four spaces\r\n                        file.text = file.text.replace(/\\r\\n/g, '\\n')\r\n                            .replace(/\\r/g, '\\n').replace(/\\t/g, \"    \");\r\n                        // prepends newline for first expected splitting of the first expression\r\n                        ('\\n'.concat(file.text)).split('\\n### ').forEach(part => {\r\n                            try {\r\n                                if (part.trim().length !== 0) {\r\n                                    expressions.push(this.splitExpressionNameAndText(part.trim()));\r\n                                }\r\n                            }\r\n                            catch (err) {\r\n                                skippedExpressions += 1;\r\n                            }\r\n                        });\r\n                        loadedFiles += 1;\r\n                    }\r\n                    else {\r\n                        console.log('Unsupported filetype: ' + file.name);\r\n                        skippedFiles += 1;\r\n                    }\r\n                });\r\n                resolve({expressions, skippedExpressions, loadedFiles, skippedFiles});\r\n            });\r\n        });\r\n    }\r\n\r\n    private static splitExpressionNameAndText(expr: string): Expression {\r\n        const firstNewLineIndex: number = expr.indexOf('\\n');\r\n        if (firstNewLineIndex === -1) {\r\n            console.log(\"Expression does not contain first name line.\");\r\n            throw Error();\r\n        }\r\n        const firstRow: string = expr.slice(0, firstNewLineIndex).trim();\r\n        if (!firstRow.endsWith(' ###')) {\r\n            console.log(\"Expression does not contain name between hashes.\");\r\n            throw Error();\r\n        }\r\n        const name: string = firstRow.slice(0, -4);\r\n        const text: string = expr.slice(firstNewLineIndex).trim();\r\n        return {name: name, text: text};\r\n    }\r\n\r\n    /**\r\n     * Saves given expressions to a textual file. Each expression starts with \"### Expression name ###\\n\" line.\r\n     *\r\n     * @param expressions array of expressions to be saved\r\n     * @param filename name of the downloaded file (without extension)\r\n     */\r\n    public static save(expressions: Expression[], filename: string): void {\r\n        const textContent: string = expressions.map(e => {\r\n            return \"### \" + e.name + \" ###\\n\\n\" + e.text;\r\n        }).join('\\n\\n');\r\n        const blob = new Blob([textContent], {type: \"text/plain;charset=utf-8\"});\r\n        saveAs(blob, filename + '.txt');\r\n    }\r\n}","import React from \"react\";\r\nimport {CsvValueSeparatorChar} from \"../tools/csvSupport\";\r\nimport {SupportedLanguage} from \"../tools/supportedLanguage\";\r\n\r\ninterface ManagementSectionProps {\r\n    // handler of batch processing\r\n    onBatch: (onDone: (msg: string) => void) => void,\r\n\r\n    // handler of project import\r\n    onImportProject: (onDone: (msg: string) => void) => void,\r\n    // handler of project export\r\n    onExportProject: (onDone: (msg: string) => void) => void,\r\n\r\n    // current selected value separator in csv files\r\n    csvValueSeparator: CsvValueSeparatorChar,\r\n    // current selected language of the application\r\n    language: SupportedLanguage,\r\n    // current selected null values support\r\n    nullValuesSupport: boolean,\r\n    // true if dark theme should be applied\r\n    darkTheme: boolean,\r\n\r\n    // handler of change of the current selected value separator in csv files\r\n    onCsvValueSeparatorChange: (csvValueSeparator: CsvValueSeparatorChar) => void,\r\n    // handler of change of the current selected language of the application\r\n    onLanguageChange: (language: SupportedLanguage) => void,\r\n    // handler of change of the current selected null values support\r\n    onNullValuesSupportChange: (nullValuesSupport: boolean) => void,\r\n    // handler of change of the current selected theme\r\n    onDarkModeChange: (darkTheme: boolean) => void\r\n}\r\n\r\ninterface ManagementSectionState {\r\n    sectionClicked: boolean,\r\n    state: \"hidden\" | \"batch\" | \"project\" | \"settings\",\r\n    batchMessage: string,\r\n    projectMessage: string\r\n}\r\n\r\n/**\r\n * Section to manage batch processing, importing/exporting the project, and settings.\r\n */\r\nexport class ManagementSection extends React.Component<ManagementSectionProps, ManagementSectionState> {\r\n\r\n    // reference to this section element\r\n    private readonly sectionRef: React.RefObject<HTMLDivElement>;\r\n\r\n    constructor(props: ManagementSectionProps) {\r\n        super(props);\r\n        this.state = {\r\n            sectionClicked: false,\r\n            state: \"hidden\",\r\n            batchMessage: \"\",\r\n            projectMessage: \"\"\r\n        }\r\n        this.sectionRef = React.createRef<HTMLDivElement>();\r\n    }\r\n\r\n    componentDidMount() {\r\n        const section = this.sectionRef.current;\r\n        if (section !== null) {\r\n            section.addEventListener(\"click\", () => {\r\n                this.setState({sectionClicked: true});\r\n            }, true); // useCapture = true for overwriting the window listener\r\n        }\r\n        window.addEventListener(\"click\", () => {\r\n            this.setState({sectionClicked: false});\r\n        }, true); // useCapture = true for overwriting by section listener\r\n    }\r\n\r\n    /**\r\n     * Changes displayed tools after button click.\r\n     *\r\n     * @param toState clicked button state\r\n     */\r\n    private handleStateChange = (toState: \"batch\" | \"project\" | \"settings\") => {\r\n        // clears states messages\r\n        this.setState({\r\n            batchMessage: \"\",\r\n            projectMessage: \"\"\r\n        });\r\n        // hides after second click\r\n        if (this.state.state === toState) {\r\n            return this.setState({state: \"hidden\"});\r\n        }\r\n        this.setState({state: toState});\r\n    };\r\n\r\n    render() {\r\n        const createButtonChangeState = (text: string, changeTo: \"batch\" | \"project\" | \"settings\") => {\r\n            const className: string = (this.props.darkTheme ?\r\n                (this.state.state === changeTo ? \"button-clicked-dark\" : \"button-dark\") :\r\n                (this.state.state === changeTo ? \"button-clicked-light\" : \"button-light\"));\r\n            return (\r\n                <button\r\n                    onClick={() => this.handleStateChange(changeTo)}\r\n                    className={className}\r\n                >{text}</button>);\r\n        }\r\n\r\n        let openState = null;\r\n        if (this.state.state === \"batch\") {\r\n            openState = this.createBatch();\r\n        }\r\n        else if (this.state.state === \"project\") {\r\n            openState = this.createProject();\r\n        }\r\n        else if (this.state.state === \"settings\") {\r\n            openState = this.createSettings();\r\n        }\r\n\r\n        let sectionClassName = this.props.darkTheme ? \"section-border-dark\" : \"section-border-light\";\r\n        if (this.state.sectionClicked) {\r\n            sectionClassName = this.props.darkTheme ? \"section-border-dark-clicked\" : \"section-border-light-clicked\";\r\n        }\r\n        return (\r\n            <header\r\n                ref={this.sectionRef}\r\n                className={sectionClassName}\r\n                style={{paddingTop: \"5px\", paddingBottom: \"5px\", marginTop: \"5px\"}}>\r\n                <div>\r\n                    {createButtonChangeState(\"Batch processing\", \"batch\")}\r\n                    {createButtonChangeState(\"Project\", \"project\")}\r\n                    {createButtonChangeState(\"Settings\", \"settings\")}\r\n                </div>\r\n\r\n                {openState}\r\n            </header>\r\n        );\r\n    }\r\n\r\n    private createBatch = () => {\r\n        return (\r\n            <section>\r\n                <p>\r\n                    Select multiple input files with expressions. The expressions will be evaluated and the reports will be generated.\r\n                    Please be patient, the action freezes the application for couple of seconds.\r\n                    You can see progress in the browser console (F12).\r\n                </p>\r\n                <button\r\n                    onClick={() => this.props.onBatch((msg: string) => this.setState({batchMessage: msg}))}\r\n                    className={this.props.darkTheme ? 'button-dark' : 'button-light'}\r\n                >Select files and evaluate</button>\r\n                <p>\r\n                    {this.state.batchMessage}\r\n                </p>\r\n            </section>\r\n        );\r\n    }\r\n\r\n    private createProject = () => {\r\n        return (\r\n            <section>\r\n                <p>\r\n                    Import or export project's data (i.e., stored relations, all expressions and null values support flag).\r\n                </p>\r\n                <button\r\n                    onClick={() => this.props.onImportProject((msg: string) => this.setState({projectMessage: msg}))}\r\n                    className={this.props.darkTheme ? 'button-dark' : 'button-light'}\r\n                >Import</button>\r\n                <button\r\n                    onClick={() => this.props.onExportProject((msg: string) => this.setState({projectMessage: msg}))}\r\n                    className={this.props.darkTheme ? 'button-dark' : 'button-light'}\r\n                >Export</button>\r\n                <p>\r\n                    {this.state.projectMessage}\r\n                </p>\r\n            </section>\r\n        );\r\n    }\r\n\r\n    private createSettings = () => {\r\n        return (\r\n            <ul style={{listStyleType: \"none\"}}>\r\n                <li>\r\n                    Null values:\r\n                    <input\r\n                        type=\"radio\"\r\n                        name=\"null_values_support\"\r\n                        value=\"allowed\"\r\n                        id=\"null_values_support_allowed\"\r\n                        checked={this.props.nullValuesSupport}\r\n                        onClick={() => this.props.onNullValuesSupportChange(true)} />\r\n                    <label htmlFor=\"null_values_support_allowed\">allowed</label>\r\n                    <input\r\n                        type=\"radio\"\r\n                        name=\"null_values_support\"\r\n                        value=\"forbidden\"\r\n                        id=\"null_values_support_forbid\"\r\n                        checked={!this.props.nullValuesSupport}\r\n                        onClick={() => this.props.onNullValuesSupportChange(false)} />\r\n                    <label htmlFor=\"null_values_support_forbid\">forbidden</label>\r\n                </li>\r\n                <li>\r\n                    CSV separator:\r\n                    <input\r\n                        type=\"radio\"\r\n                        name=\"value_separator\"\r\n                        value=\"semicolon\"\r\n                        id=\"value_separator_semi\"\r\n                        checked={this.props.csvValueSeparator === \";\"}\r\n                        onClick={() => this.props.onCsvValueSeparatorChange(\";\")}/>\r\n                    <label htmlFor=\"value_separator_semi\">semicolon</label>\r\n                    <input\r\n                        type=\"radio\"\r\n                        name=\"value_separator\"\r\n                        value=\"comma\"\r\n                        id=\"value_separator_comma\"\r\n                        checked={this.props.csvValueSeparator === \",\"}\r\n                        onClick={() => this.props.onCsvValueSeparatorChange(\",\")}/>\r\n                    <label htmlFor=\"value_separator_comma\">comma</label>\r\n                </li>\r\n                {/*<li> // NOT SUPPORTED YET\r\n                    Language:\r\n                    <input\r\n                        type=\"radio\"\r\n                        name=\"language\"\r\n                        value=\"eng\"\r\n                        id=\"language_eng\"\r\n                        checked={this.props.language === \"ENG\"}\r\n                        onClick={() => this.props.onLanguageChange(\"ENG\")} />\r\n                    <label htmlFor=\"language_eng\">ENG</label>\r\n                    <input\r\n                        type=\"radio\"\r\n                        name=\"language\"\r\n                        value=\"cze\"\r\n                        id=\"language_cze\"\r\n                        checked={this.props.language === \"CZE\"}\r\n                        onClick={() => this.props.onLanguageChange(\"CZE\")} />\r\n                    <label htmlFor=\"language_cze\">CZE</label>\r\n                </li>*/}\r\n                <li>\r\n                    Theme:\r\n                    <input\r\n                        type=\"radio\"\r\n                        name=\"dark_mode\"\r\n                        value=\"on\"\r\n                        id=\"dark_mode_on\"\r\n                        checked={!this.props.darkTheme}\r\n                        onClick={() => this.props.onDarkModeChange(false)} />\r\n                    <label htmlFor=\"dark_mode_on\">light</label>\r\n                    <input\r\n                        type=\"radio\"\r\n                        name=\"dark_mode\"\r\n                        value=\"off\"\r\n                        id=\"dark_mode_off\"\r\n                        checked={this.props.darkTheme}\r\n                        onClick={() => this.props.onDarkModeChange(true)} />\r\n                    <label htmlFor=\"dark_mode_off\">dark</label>\r\n                </li>\r\n            </ul>\r\n        );\r\n    }\r\n}","import {Expression, isExpression} from \"../expression/expression\";\r\nimport {isStoredRelationData, StoredRelationData} from \"../relation/storedRelation\";\r\n\r\n/**\r\n * Project interface to store information about project relations and expressions relation.\r\n * Does not store custom settings about saving file types etc.\r\n */\r\nexport interface Project {\r\n    relations: StoredRelationData[],\r\n    expressions: Expression[],\r\n    nullValuesSupport: boolean\r\n}\r\n\r\n/**\r\n * Checks whether the given value is Project (i.e., has all required fields of required types).\r\n *\r\n * @param obj value to be checked\r\n * @return \"OK\" string if the given obj is Project or string description of found error in the structure\r\n */\r\nexport function isProjectObject(obj: any): string {\r\n    if (typeof obj !== \"object\") {\r\n        return 'The file cannot be parsed to an object.';\r\n    }\r\n    if (!(\"relations\" in obj) || !Array.isArray(obj.relations) || obj.relations.length === 0 ||\r\n        obj.relations.some((o: any) => !isStoredRelationData(o))) {\r\n        return 'The file must contain the field \"relations: StoredRelationData[]\" of length at least one';\r\n    }\r\n    if (!(\"expressions\" in obj) || !Array.isArray(obj.expressions) || obj.expressions.length === 0 ||\r\n        obj.expressions.some((o: any) => !isExpression(o))) {\r\n        return 'The file must contain the field \"expressions: Expression[]\" of length at least one';\r\n    }\r\n    if (!(\"nullValuesSupport\" in obj) || typeof obj.nullValuesSupport !== \"boolean\") {\r\n        return 'The file must contain the field \"nullValuesSupport: boolean\"';\r\n    }\r\n    return 'OK';\r\n}","/**\r\n * Representation of named RA expression.\r\n */\r\nexport interface Expression {\r\n    name: string,\r\n    text: string\r\n}\r\n\r\n/**\r\n * Checks whether the given obj is an Expression.\r\n *\r\n * @param obj\r\n */\r\nexport function isExpression(obj: any): boolean {\r\n    if (typeof obj !== \"object\") {\r\n        return false;\r\n    }\r\n    return (\"name\" in obj) && (typeof obj.name === \"string\") && (\"text\" in obj) && (typeof obj.text === \"string\");\r\n}","import {isProjectObject, Project} from \"./project\";\r\nimport {FileDialog} from \"../tools/fileDialog\";\r\nimport {saveAs} from \"file-saver\";\r\n\r\n/**\r\n * Class for loading and saving project relations and expressions relation.\r\n */\r\nexport class ProjectStoreManager {\r\n\r\n    /**\r\n     * Loads asynchronously the project from a JSON file selected by the user.\r\n     * The file must contain the representation of the project object: {\r\n     * relations: StoredRelationData[],\r\n     * expressionTexts: string[],\r\n     * nullValuesSupport: boolean\r\n     * }.\r\n     * Returned string values always use '\\n' as line separator.\r\n     */\r\n    public static load(): Promise<Project> {\r\n        return new Promise<Project>((resolve, reject) => {\r\n            FileDialog.openFile(\".json\").then(file => {\r\n                if (file.text === null) {\r\n                    reject(\"Reading of the content of the file \" + file.name + \" failed.\");\r\n                }\r\n                else if (file.name.match(/\\.json$/)) {\r\n                    // replaces line separators to expected '\\n'\r\n                    file.text = file.text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\r\n                    let obj = JSON.parse(file.text);\r\n                    const result: string = isProjectObject(obj);\r\n                    if (result === \"OK\") {\r\n                        const project: Project = obj;\r\n                        resolve(project);\r\n                    }\r\n                    else {\r\n                        reject(\"Invalid structure of the JSON file. \" + result)\r\n                    }\r\n                }\r\n                else {\r\n                    reject(\"Please select a JSON file to load a project relation from.\");\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Saves the given Project into the JSON file.\r\n     *\r\n     * @param project the Project object with all project relation\r\n     * @param filename name of the downloaded file (without extension)\r\n     */\r\n    public static save(project: Project, filename: string): void {\r\n        const blob = new Blob([JSON.stringify(project)], {type: \"text/plain;charset=utf-8\"});\r\n        saveAs(blob, filename + '.json');\r\n    }\r\n}","import {CsvValueSeparatorChar} from \"./csvSupport\";\r\nimport {isSupportedLanguage, SupportedLanguage} from \"./supportedLanguage\";\r\n\r\nconst defaultCsvValueSeparator: CsvValueSeparatorChar = \";\";\r\nconst defaultLanguage: SupportedLanguage = \"ENG\";\r\nconst defaultDarkMode: string = \"false\";\r\n\r\n/**\r\n * Static class for maintaining the access to local storage of the browser. It handles user settings:\r\n * saving file type, csv value separator, language, light/dark theme of the application.\r\n * If the local storage is not used, it uses the application memory and the default values.\r\n */\r\nexport class LocalStorage {\r\n\r\n    private static isInit: boolean = false;\r\n    private static storageSupported: boolean = typeof(Storage) !== \"undefined\";\r\n\r\n    private static csvValueSeparator: CsvValueSeparatorChar;\r\n    private static language: SupportedLanguage;\r\n    private static darkTheme: string;\r\n\r\n    /**\r\n     * Initializes the LocalStorage. If there are the requested values, loads them to application memory.\r\n     * If the local storage is not supported, uses the default values.\r\n     */\r\n    private static init(): void {\r\n        if (LocalStorage.storageSupported) {\r\n            const storedSeparator = localStorage.getItem(\"csvValueSeparator\");\r\n            if (storedSeparator !== \";\" && storedSeparator !== \",\") {\r\n                console.log(\"csvValueSeparator not found in localStorage and set to default\");\r\n                localStorage.setItem(\"csvValueSeparator\", defaultCsvValueSeparator);\r\n                LocalStorage.csvValueSeparator = defaultCsvValueSeparator;\r\n            }\r\n            else {\r\n                // @ts-ignore\r\n                LocalStorage.csvValueSeparator = localStorage.getItem(\"csvValueSeparator\");\r\n            }\r\n            if (!isSupportedLanguage(localStorage.getItem(\"language\"))) {\r\n                console.log(\"language not found in localStorage and set to default\");\r\n                localStorage.setItem(\"language\", defaultLanguage);\r\n                LocalStorage.language = defaultLanguage;\r\n            }\r\n            else {\r\n                // @ts-ignore\r\n                LocalStorage.language = localStorage.getItem(\"language\");\r\n            }\r\n\r\n            if (localStorage.getItem(\"darkTheme\") !== \"true\" && localStorage.getItem(\"darkTheme\") !== \"false\") {\r\n                console.log(\"darkTheme not found in localStorage and set to default\");\r\n                localStorage.setItem(\"darkTheme\", defaultDarkMode);\r\n                LocalStorage.darkTheme = defaultDarkMode;\r\n            }\r\n            else {\r\n                // @ts-ignore\r\n                LocalStorage.darkTheme = localStorage.getItem(\"darkTheme\");\r\n            }\r\n        }\r\n        else {\r\n            console.warn(\"LocalStorage not supported in the browser. Default values used.\");\r\n            LocalStorage.csvValueSeparator = defaultCsvValueSeparator;\r\n            LocalStorage.language = defaultLanguage;\r\n            LocalStorage.darkTheme = defaultDarkMode;\r\n        }\r\n        LocalStorage.isInit = true;\r\n    }\r\n\r\n    public static getCsvValueSeparator(): CsvValueSeparatorChar {\r\n        if (!LocalStorage.isInit) {\r\n            LocalStorage.init();\r\n        }\r\n        return LocalStorage.csvValueSeparator;\r\n    }\r\n\r\n    public static setCsvValueSeparator(csvValueSeparator: CsvValueSeparatorChar): void {\r\n        LocalStorage.csvValueSeparator = csvValueSeparator;\r\n        if (LocalStorage.storageSupported) {\r\n            localStorage.setItem(\"csvValueSeparator\", csvValueSeparator);\r\n        }\r\n    }\r\n\r\n    public static getLanguage(): SupportedLanguage {\r\n        if (!LocalStorage.isInit) {\r\n            LocalStorage.init();\r\n        }\r\n        return LocalStorage.language;\r\n    }\r\n\r\n    public static setLanguage(language: SupportedLanguage): void {\r\n        LocalStorage.language = language;\r\n        if (LocalStorage.storageSupported) {\r\n            localStorage.setItem(\"language\", language);\r\n        }\r\n    }\r\n\r\n    public static getDarkMode(): boolean {\r\n        if (!LocalStorage.isInit) {\r\n            LocalStorage.init();\r\n        }\r\n        return LocalStorage.darkTheme === \"true\";\r\n    }\r\n\r\n    public static setDarkMode(darkTheme: boolean): void {\r\n        LocalStorage.darkTheme = String(darkTheme);\r\n        if (LocalStorage.storageSupported) {\r\n            localStorage.setItem(\"darkTheme\", String(darkTheme));\r\n        }\r\n    }\r\n}","/**\r\n * Textual description of supported value separators.\r\n */\r\nexport type SupportedLanguage = \"ENG\" | \"CZE\";\r\n\r\nexport function isSupportedLanguage(x: any): boolean {\r\n    return x === \"ENG\" || x === \"CZE\";\r\n}","import React from \"react\";\r\nimport {SupportedLanguage} from \"../tools/supportedLanguage\";\r\nimport \"./css/footer.css\"\r\n\r\ninterface FooterProps {\r\n    // language of the application\r\n    language: SupportedLanguage,\r\n    // true if dark theme should be applied\r\n    darkTheme: boolean\r\n}\r\n\r\ninterface FooterState {\r\n\r\n}\r\n\r\n/**\r\n * Footer of the page with contact links.\r\n */\r\nexport class Footer extends React.Component<FooterProps, FooterState> {\r\n\r\n    render() {\r\n        const modeStr: string = this.props.darkTheme ? \"-dark\" : \"-light\";\r\n        return (\r\n            <footer className={\"page-footer page-footer\" + modeStr}>\r\n                <hr className={\"footer-hr\" + modeStr}/>\r\n                <ul className=\"footer-list\">\r\n                    <li>\r\n                        <a href=\"mailto:kotliluk@fel.cvut.cz\">Contact author</a>\r\n                    </li>\r\n                    <li>\r\n                        <a href=\"https://github.com/kotliluk/rachel\" target=\"_blank\" rel=\"noreferrer\">About</a>\r\n                    </li>\r\n                </ul>\r\n            </footer>\r\n        );\r\n    }\r\n}","import {FileDialog} from \"./fileDialog\";\r\nimport JSZip from \"jszip\";\r\nimport {saveAs} from \"file-saver\";\r\nimport Relation from \"../relation/relation\";\r\nimport RATreeNode from \"../ratree/raTreeNode\";\r\nimport UnaryNode from \"../ratree/unaryNode\";\r\nimport ProjectionNode from \"../ratree/projectionNode\";\r\nimport RenameNode from \"../ratree/renameNode\";\r\nimport SelectionNode from \"../ratree/selectionNode\";\r\nimport BinaryNode from \"../ratree/binaryNode\";\r\nimport AntijoinNode from \"../ratree/antijoinNode\";\r\nimport CartesianProductNode from \"../ratree/cartesianProductNode\";\r\nimport DivisionNode from \"../ratree/divisionNode\";\r\nimport OuterJoinNode from \"../ratree/outerJoinNode\";\r\nimport NaturalJoinNode, {NaturalJoinType} from \"../ratree/naturalJoinNode\";\r\nimport SetOperationNode from \"../ratree/setOperationNode\";\r\nimport {formatDate} from \"./date\";\r\nimport ThetaJoinNode, {ThetaJoinType} from \"../ratree/thetaJoinNode\";\r\nimport {isProjectObject, Project} from \"../project/project\";\r\nimport {ExprParser} from \"../expression/exprParser\";\r\nimport {StoredRelation, StoredRelationData} from \"../relation/storedRelation\";\r\nimport {Expression} from \"../expression/expression\";\r\n\r\n/**\r\n * Class for processing multiple input .txt files with expressions.\r\n */\r\nexport class BatchProcessor {\r\n\r\n    /**\r\n     * Opens file dialog and processes files selected by the user. For each JSON file creates a textual evaluation\r\n     * report. Files are expected to contain valid project data. Returns promise with string message about process.\r\n     */\r\n    public process(filename: string): Promise<string> {\r\n        return new Promise<string>((resolve, reject) => {\r\n            FileDialog.openFiles(\".json\").then(files => {\r\n                console.log(files.length + ' files loaded to BatchProcessor');\r\n                console.time(\"Batch duration\");\r\n                let reports: {name: string, text: string}[] = [];\r\n                let processed: number = 0;\r\n                let skipped: number = 0;\r\n                files.forEach(file => {\r\n                    if (file.text === null) {\r\n                        console.log('null read from ' + file.name);\r\n                        skipped += 1;\r\n                    }\r\n                    else if (file.name.match(/\\.json$/)) {\r\n                        // @ts-ignore - file.text cannot be null now\r\n                        reports.push(this.processFile(file));\r\n                        processed += 1;\r\n                    }\r\n                    else {\r\n                        console.log('Unsupported filetype: ' + file.name);\r\n                        skipped += 1;\r\n                    }\r\n                    console.log(\"Batch in progress... \" + (processed + skipped) + \"/\" + files.length);\r\n                });\r\n                console.timeEnd(\"Batch duration\");\r\n                if (reports.length === 0) {\r\n                    resolve(\"Batch finished: \" + processed + \" files processed, \" + skipped + \" skipped.\");\r\n                }\r\n                const zip: JSZip = JSZip();\r\n                reports.forEach(report => {\r\n                    zip.file(report.name, report.text);\r\n                });\r\n                zip.generateAsync({type: \"blob\"}).then(content => {\r\n                    saveAs(content, filename + \".zip\");\r\n                    console.log(\"Batch finished: \" + processed + \" files processed, \" + skipped + \" skipped.\");\r\n                    resolve(\"Batch finished: \" + processed + \" files processed, \" + skipped + \" skipped.\");\r\n                }).catch(err => {\r\n                    reject(\"Results saving error: \" + err.message);\r\n                });\r\n            });\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Tries to parse Project object from given file.text. If successful, parses relations in the project, evaluates\r\n     * expressions in the project and generates textual report: header (see reportHeader()),\r\n     * formatted relations (see formatRelations()) and formatted expressions (see processExpression()).\r\n     */\r\n    private processFile = (file: {name: string, text: string}): {name: string, text: string} => {\r\n        const project: Project = JSON.parse(file.text);\r\n        const status = isProjectObject(project);\r\n        if (status !== \"OK\") {\r\n            return {name: file.name.slice(0, -4) + '-eval-report.txt', text: \"Invalid JSON file: \" + status};\r\n        }\r\n        const relations: Map<string, Relation> = this.parseRelations(project.relations, project.nullValuesSupport);\r\n        const exprParser: ExprParser = new ExprParser(relations, project.nullValuesSupport);\r\n\r\n        const exprCount: number = project.expressions.length;\r\n        const reports = project.expressions.map(e => this.processExpression(e, exprParser));\r\n        const ops: OperationsCount = addOperations(...reports.map(r => r.counts));\r\n        const errors: number = reports.reduce((agg, report) => agg + report.error, 0);\r\n\r\n        return {\r\n            name: file.name.slice(0, -5) + '-eval-report.txt',\r\n            text: this.reportHeader(exprCount, errors, ops, project.nullValuesSupport) +\r\n                  this.formatRelations(project.relations) +\r\n                  reports.map(r => r.text).join('')\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Creates full Relation representation for given StoredRelationData array.\r\n     */\r\n    private parseRelations(storedData: StoredRelationData[], nullValuesSupport: boolean): Map<string, Relation> {\r\n        const map: Map<string, Relation> = new Map();\r\n        storedData.forEach(data => {\r\n            try {\r\n                const storedRelation: StoredRelation = StoredRelation.fromData(data, nullValuesSupport);\r\n                if (storedRelation.isValid()) {\r\n                    map.set(storedRelation.getName(), storedRelation.createRelation());\r\n                }\r\n            }\r\n            catch (err) {\r\n                console.log(\"Definition of relation \" + data.name + \" has errors, skipping.\");\r\n            }\r\n        })\r\n        return map;\r\n    }\r\n\r\n    /**\r\n     * Processes given expression in context of given parser. Returns formatted expression and its result (or error),\r\n     * count of used RA operations and 0/1 error indicator.\r\n     */\r\n    private processExpression = (expr: Expression, parser: ExprParser): {text: string, counts: OperationsCount, error: number} => {\r\n        try {\r\n            const evaluationTree = parser.parse(expr.text);\r\n            const counts: OperationsCount = operationsOfTree(evaluationTree);\r\n            const relation: Relation = evaluationTree.getResult();\r\n            return {\r\n                text: '### ' + expr.name + ' ###\\n\\n' + expr.text + '\\n\\n# Result #\\n\\n' + relation.contentString() + '\\n\\n',\r\n                counts: counts,\r\n                error: 0\r\n            };\r\n        }\r\n        catch (err) {\r\n            return {\r\n                text: '### ' + expr.name + ' ###\\n\\n' + expr.text + '\\n\\n# Error #\\n\\n' + err.message + '\\n\\n',\r\n                counts: zeroOperations(),\r\n                error: 1\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates the header of the report. The header contains the time of the report, count of expressions and errors,\r\n     * count of used operations and null values support info.\r\n     *\r\n     * @param expressions count of expressions\r\n     * @param errors count of errors\r\n     * @param operations count of operations\r\n     * @param nullValuesSupport\r\n     */\r\n    private reportHeader = (expressions: number, errors: number, operations: OperationsCount, nullValuesSupport: boolean): string => {\r\n        const total: number = totalOperations(operations);\r\n        const binary: number = binaryOperations(operations);\r\n        const unary: number = unaryOperations(operations);\r\n        return 'Rachel project report from ' + formatDate(new Date()) + '\\n\\n' +\r\n            'Expressions: ' + expressions + '    Errors: ' + errors + '\\n\\n' +\r\n            'Used operations (' + total + ' in total: ' + binary + ' binary, ' + unary + ' unary):\\n' +\r\n            '    Antijoin: ' + operations.antijoin + '\\n' +\r\n            '    Cartesian product: ' + operations.cartesian + '\\n' +\r\n            '    Division: ' + operations.division + '\\n' +\r\n            '    Natural join: ' + operations.natural + '\\n' +\r\n            '    Outer Join: ' + operations.outerJoin + '\\n' +\r\n            '    Projection: ' + operations.projection + '\\n' +\r\n            '    Rename: ' + operations.rename + '\\n' +\r\n            '    Selection: ' + operations.selection + '\\n' +\r\n            '    Semijoin: ' + operations.semijoin + '\\n' +\r\n            '    Set Operations: ' + operations.setOperation + '\\n' +\r\n            '    Theta Join: ' + operations.thetaJoin + '\\n' +\r\n            '    Theta Semijoin: ' + operations.thetaSemijoin + '\\n\\n' +\r\n            (nullValuesSupport ? 'Null values ALLOWED.\\n\\n' : 'Null values FORBIDDEN.\\n\\n');\r\n    }\r\n\r\n    /**\r\n     * Returns formatted string for given StoredRelationsData array.\r\n     */\r\n    private formatRelations = (storedData: StoredRelationData[]): string => {\r\n        return \"### Defined relations ###\\n\\n\" + storedData.map(data => {\r\n            return '# ' + data.name + ' #\\n' +\r\n                data.columnNames.join(', ') + '\\n' +\r\n                data.columnTypes.join(', ') + '\\n' +\r\n                data.rows.map(row => row.join(', ')).join('\\n') + '\\n\\n';\r\n        }).join('');\r\n    }\r\n}\r\n\r\n/**\r\n * Counts of all supported relational algebra operations.\r\n */\r\ninterface OperationsCount {\r\n    antijoin: number,\r\n    cartesian: number,\r\n    division: number,\r\n    natural: number,\r\n    outerJoin: number,\r\n    projection: number,\r\n    rename: number,\r\n    selection: number,\r\n    semijoin: number,\r\n    setOperation: number,\r\n    thetaJoin: number,\r\n    thetaSemijoin: number,\r\n}\r\n\r\n/**\r\n * @return zero count of all operations\r\n */\r\nfunction zeroOperations(): OperationsCount {\r\n    return addOperations();\r\n}\r\n\r\n/**\r\n * @return adds given OperationsCounts together\r\n */\r\nfunction addOperations(...counts: OperationsCount[]): OperationsCount {\r\n    return {\r\n        antijoin: counts.reduce((agg, count) => agg + count.antijoin, 0),\r\n        cartesian: counts.reduce((agg, count) => agg + count.cartesian, 0),\r\n        division: counts.reduce((agg, count) => agg + count.division, 0),\r\n        natural: counts.reduce((agg, count) => agg + count.natural, 0),\r\n        outerJoin: counts.reduce((agg, count) => agg + count.outerJoin, 0),\r\n        projection: counts.reduce((agg, count) => agg + count.projection, 0),\r\n        rename: counts.reduce((agg, count) => agg + count.rename, 0),\r\n        selection: counts.reduce((agg, count) => agg + count.selection, 0),\r\n        semijoin: counts.reduce((agg, count) => agg + count.semijoin, 0),\r\n        setOperation: counts.reduce((agg, count) => agg + count.setOperation, 0),\r\n        thetaJoin: counts.reduce((agg, count) => agg + count.thetaJoin, 0),\r\n        thetaSemijoin: counts.reduce((agg, count) => agg + count.thetaSemijoin, 0),\r\n    }\r\n}\r\n\r\n/**\r\n * @return sum of all operation counts\r\n */\r\nfunction totalOperations(o: OperationsCount): number {\r\n    return binaryOperations(o) + unaryOperations(o);\r\n}\r\n\r\n/**\r\n * @return sum of all binary operation counts\r\n */\r\nfunction binaryOperations(o: OperationsCount): number {\r\n    return o.antijoin + o.cartesian + o.division + o.natural + o.outerJoin + o.semijoin + o.setOperation + o.thetaJoin + o.thetaSemijoin;\r\n}\r\n\r\n/**\r\n * @return sum of all unary operation counts\r\n */\r\nfunction unaryOperations(o: OperationsCount): number {\r\n    return o.projection + o.rename + o.selection;\r\n}\r\n\r\n/**\r\n * @return counts all operations used in the given tree.\r\n */\r\nfunction operationsOfTree(tree: RATreeNode): OperationsCount {\r\n    if (tree instanceof UnaryNode) {\r\n        return addOperations(operationOfUnaryNode(tree), operationsOfTree(tree.getSubtree()));\r\n    }\r\n    if (tree instanceof BinaryNode) {\r\n        return addOperations(operationOfBinaryNode(tree), operationsOfTree(tree.getLeftSubtree()), operationsOfTree(tree.getRightSubtree()));\r\n    }\r\n    // no subtree - relation node\r\n    return zeroOperations();\r\n}\r\n\r\n/**\r\n * @return OperationsCount with one given unary operation count set to 1, other 0\r\n */\r\nfunction operationOfUnaryNode(node: UnaryNode): OperationsCount {\r\n    let ret: OperationsCount = zeroOperations();\r\n    if (node instanceof ProjectionNode) {\r\n        ret.projection = 1;\r\n        return ret;\r\n    }\r\n    if (node instanceof RenameNode) {\r\n        ret.rename = 1;\r\n        return ret;\r\n    }\r\n    if (node instanceof SelectionNode) {\r\n        ret.selection = 1;\r\n        return ret;\r\n    }\r\n    return ret;\r\n}\r\n\r\n/**\r\n * @return OperationsCount with one given binary operation count set to 1, other 0\r\n */\r\nfunction operationOfBinaryNode(node: BinaryNode): OperationsCount {\r\n    let ret: OperationsCount = zeroOperations();\r\n    if (node instanceof AntijoinNode) {\r\n        ret.antijoin = 1;\r\n        return ret;\r\n    }\r\n    if (node instanceof CartesianProductNode) {\r\n        ret.cartesian = 1;\r\n        return ret;\r\n    }\r\n    if (node instanceof DivisionNode) {\r\n        ret.division = 1;\r\n        return ret;\r\n    }\r\n    if (node instanceof OuterJoinNode) {\r\n        ret.outerJoin = 1;\r\n        return ret;\r\n    }\r\n    if (node instanceof NaturalJoinNode) {\r\n        if (node.getType() === NaturalJoinType.natural) {\r\n            ret.natural = 1;\r\n        }\r\n        else {\r\n            ret.semijoin = 1;\r\n        }\r\n        return ret;\r\n    }\r\n    if (node instanceof SetOperationNode) {\r\n        ret.setOperation = 1;\r\n        return ret;\r\n    }\r\n    if (node instanceof ThetaJoinNode) {\r\n        if (node.getType() === ThetaJoinType.full) {\r\n            ret.thetaJoin = 1;\r\n        }\r\n        else {\r\n            ret.thetaSemijoin = 1;\r\n        }\r\n        return ret;\r\n    }\r\n    return ret;\r\n}","/**\r\n * Formats given date to: dd.mm.yyyy hh:mm.\r\n *\r\n * @param date date to format\r\n */\r\nexport function formatDate(date: Date): string {\r\n    return String(date.getDate()).padStart(2, '0') + '.' + String(date.getMonth() + 1).padStart(2, '0') + '.' +\r\n        String(date.getFullYear()) + ' ' +\r\n        String(date.getHours()).padStart(2, '0') + ':' + String(date.getMinutes()).padStart(2, '0');\r\n}","import React from \"react\";\r\nimport './css/editRelationTable.css';\r\nimport {StoredRelation} from \"../relation/storedRelation\";\r\nimport {SupportedColumnType} from \"../relation/columnType\";\r\nimport {RCToStringMap} from \"../tools/rcToStringMap\";\r\n\r\ninterface EditRelationTableProps {\r\n    // storing representation of the relation to be edited\r\n    relation: StoredRelation,\r\n    // true when the displayed relation may be editable by the user, false otherwise\r\n    editable: boolean,\r\n\r\n    // handler of column name change\r\n    onColumnNameChange: (columnName: string, columnIndex: number) => void,\r\n    // handler of column type change\r\n    onColumnTypeChange: (columnType: SupportedColumnType, columnIndex: number) => void,\r\n    // handler of row input change\r\n    onRowInputChange: (input: string, columnIndex: number, rowIndex: number) => void,\r\n    // handler of adding new row\r\n    onNewRow: (onDone: () => void) => void,\r\n    // handler of adding new column\r\n    onNewColumn: (onDone: () => void) => void,\r\n    // handler of deleting the row of given index\r\n    onDeleteRow: (rowIndex: number) => void,\r\n    // handler of deleting the column of given index\r\n    onDeleteColumn: (columnIndex: number) => void,\r\n\r\n    // true if dark theme should be applied\r\n    darkTheme: boolean\r\n}\r\n\r\ninterface EditRelationTableState {\r\n    selectedColumn: number | undefined,\r\n    selectedRow: \"names\" | \"types\" | number | undefined\r\n}\r\n\r\n/**\r\n * Table for editing a relation relation. It supports adding new columns and rows and editing all relation (column names,\r\n * column types and row inputs).\r\n */\r\nexport default class EditRelationTable extends React.Component<EditRelationTableProps, EditRelationTableState> {\r\n\r\n    private readonly containerRef: React.RefObject<HTMLDivElement>;\r\n    private readonly deleteButtonRef: React.RefObject<HTMLButtonElement>;\r\n\r\n    constructor(props: EditRelationTableProps) {\r\n        super(props);\r\n        this.state = {\r\n            selectedColumn: undefined,\r\n            selectedRow: undefined\r\n        }\r\n        this.containerRef = React.createRef<HTMLDivElement>();\r\n        this.deleteButtonRef = React.createRef<HTMLButtonElement>();\r\n    }\r\n\r\n    /**\r\n     * Adds listeners on window object to hide delete button\r\n     */\r\n    componentDidMount() {\r\n        window.addEventListener(\"click\", () => {\r\n            if (this.deleteButtonRef.current !== null) {\r\n                this.deleteButtonRef.current.style.visibility = \"hidden\";\r\n            }\r\n        });\r\n        window.addEventListener(\"keydown\", (ev) => {\r\n            if (ev.key === \"Escape\" || ev.key === \"Esc\") {\r\n                if (this.deleteButtonRef.current !== null) {\r\n                    this.deleteButtonRef.current.style.visibility = \"hidden\";\r\n                }\r\n                this.setSelectedInput(undefined, undefined);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns error of the relation to edit.\r\n     */\r\n    private getErrors = (): RCToStringMap => {\r\n        return this.props.relation.getErrors();\r\n    }\r\n\r\n    /**\r\n     * Sets selected input column and row to given values.\r\n     */\r\n    private setSelectedInput = (column: number | undefined, row: \"names\" | \"types\" | number | undefined): void => {\r\n        if (this.props.editable) {\r\n            this.setState({\r\n                selectedColumn: column,\r\n                selectedRow: row\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves selected input to right if it is defined and not in the last column.\r\n     */\r\n    private moveSelectedInputRight = (): void => {\r\n        const selectedColumn = this.state.selectedColumn;\r\n        const selectedRow = this.state.selectedRow;\r\n        if (selectedColumn !== undefined && selectedRow !== undefined) {\r\n            // if not last column was selected\r\n            if (selectedColumn < this.props.relation.getColumnCount() - 1) {\r\n                this.setState({selectedColumn: selectedColumn + 1});\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves selected input to left if it is defined and not in the first column.\r\n     */\r\n    private moveSelectedInputLeft = (): void => {\r\n        const selectedColumn = this.state.selectedColumn;\r\n        const selectedRow = this.state.selectedRow;\r\n        if (selectedColumn !== undefined && selectedRow !== undefined) {\r\n            // if not first column was selected\r\n            if (selectedColumn > 0) {\r\n                this.setState({selectedColumn: selectedColumn - 1});\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves selected input up if it is defined and not in the first row.\r\n     */\r\n    private moveSelectedInputUp = (): void => {\r\n        const selectedColumn = this.state.selectedColumn;\r\n        const selectedRow = this.state.selectedRow;\r\n        if (selectedColumn !== undefined && selectedRow !== undefined) {\r\n            // if not first row was selected\r\n            if (typeof selectedRow === \"number\") {\r\n                if (selectedRow === 0) {\r\n                    this.setState({selectedRow: \"names\"});\r\n                }\r\n                else {\r\n                    this.setState({selectedRow: selectedRow - 1});\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves selected input down if it is defined and not in the last row.\r\n     */\r\n    private moveSelectedInputDown = (): void => {\r\n        const selectedColumn = this.state.selectedColumn;\r\n        const selectedRow = this.state.selectedRow;\r\n        if (selectedColumn !== undefined && selectedRow !== undefined) {\r\n            if (selectedRow === \"names\" && this.props.relation.getRowCount() > 0) {\r\n                this.setState({selectedRow: 0});\r\n            }\r\n            // if not last row was selected\r\n            if (typeof selectedRow === \"number\" && selectedRow < this.props.relation.getRowCount() - 1) {\r\n                this.setState({selectedRow: selectedRow + 1});\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Displays the delete button at the right click position if the table is editable.\r\n     * If the given row is \"names\" or \"types\", the button is set to delete the column.\r\n     * Otherwise, it is set to delete the given data row.\r\n     */\r\n    private handleRightClick = (e: React.MouseEvent, column: number | undefined, row: \"names\" | \"types\" | number | undefined) => {\r\n        if (this.props.editable) {\r\n            // @ts-ignore\r\n            const button: HTMLButtonElement = this.deleteButtonRef.current;\r\n            if ((row === \"names\" || row === \"types\") && column !== undefined) {\r\n                button.onclick = (e) => this.handleDeleteColumn(e, column);\r\n                button.innerText = \"Delete column \" + this.props.relation.getColumnNames()[column];\r\n                button.style.top = e.clientY + \"px\";\r\n                // @ts-ignore\r\n                button.style.left = (e.clientX - this.containerRef.current.getBoundingClientRect().left) + \"px\";\r\n                button.style.visibility = \"visible\";\r\n            }\r\n            else if (typeof row === \"number\") {\r\n                button.onclick = (e) => this.handleDeleteRow(e, row);\r\n                button.innerText = \"Delete row \" + (row + 1);\r\n                button.style.top = e.clientY + \"px\";\r\n                // @ts-ignore\r\n                button.style.left = (e.clientX - this.containerRef.current.getBoundingClientRect().left) + \"px\";\r\n                button.style.visibility = \"visible\";\r\n            }\r\n            e.preventDefault();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Catches key inputs with special effects in tht table.\r\n     */\r\n    private handleKeyDown = (event: React.KeyboardEvent): void => {\r\n        if (event.key === \"Enter\") {\r\n            this.setSelectedInput(undefined, undefined);\r\n        }\r\n        else if (event.key === \"Tab\" || (event.ctrlKey && event.key === \"ArrowRight\")) {\r\n            this.moveSelectedInputRight();\r\n            event.preventDefault();\r\n        }\r\n        else if (event.ctrlKey && event.key === \"ArrowLeft\") {\r\n            this.moveSelectedInputLeft();\r\n            event.preventDefault();\r\n        }\r\n        else if (event.ctrlKey && event.key === \"ArrowUp\") {\r\n            this.moveSelectedInputUp();\r\n            event.preventDefault();\r\n        }\r\n        else if (event.ctrlKey && event.key === \"ArrowDown\") {\r\n            this.moveSelectedInputDown();\r\n            event.preventDefault();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Passes the change of the column name, column type or row input to the parent element.\r\n     * When row = \"types\", it is expected that value is of SupportedColumnType type.\r\n     */\r\n    private handleChange = (value: string, column: number, row: \"names\" | \"types\" | number): void => {\r\n        if (row === \"names\") {\r\n            this.props.onColumnNameChange(value, column);\r\n        }\r\n        else if (row === \"types\") {\r\n            // @ts-ignore - should be ensured before method call\r\n            this.props.onColumnTypeChange(value, column);\r\n        }\r\n        else {\r\n            this.props.onRowInputChange(value, column, row);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a new column to the relation and scrolls to it.\r\n     */\r\n    private handleNewColumn = (): void => {\r\n        this.props.onNewColumn(() => {\r\n            // @ts-ignore\r\n            this.containerRef.current.scrollTo(this.containerRef.current.clientWidth, this.containerRef.current.scrollTop)\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds a new row to the relation and scrolls to it.\r\n     */\r\n    private handleNewRow = (): void => {\r\n        this.props.onNewRow(() => {\r\n            // @ts-ignore\r\n            this.containerRef.current.scrollTo(this.containerRef.current.scrollLeft, this.containerRef.current.clientHeight)\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deletes the given column if really = true. Otherwise, asks for confirmation and prepares callback to itself with\r\n     * really = true.\r\n     */\r\n    private handleDeleteColumn = (e: MouseEvent, column: number, really: boolean = false): void => {\r\n        // @ts-ignore\r\n        const button: HTMLButtonElement = this.deleteButtonRef.current;\r\n        if (really) {\r\n            this.props.onDeleteColumn(column);\r\n            button.style.visibility = \"hidden\";\r\n        }\r\n        else {\r\n            button.onclick = (e) => this.handleDeleteColumn(e, column, true);\r\n            button.innerText = \"Really delete this column?\";\r\n        }\r\n        e.stopPropagation();\r\n        e.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * Deletes the given row if really = true. Otherwise, asks for confirmation and prepares callback to itself with\r\n     * really = true.\r\n     */\r\n    private handleDeleteRow = (e: MouseEvent, row: number, really: boolean = false): void => {\r\n        // @ts-ignore\r\n        const button: HTMLButtonElement = this.deleteButtonRef.current;\r\n        if (really) {\r\n            this.props.onDeleteRow(row);\r\n            button.style.visibility = \"hidden\";\r\n        }\r\n        else {\r\n            button.onclick = (e) => this.handleDeleteRow(e, row, true);\r\n            button.innerText = \"Really delete this row?\";\r\n        }\r\n        e.stopPropagation();\r\n        e.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * Creates a text input bind to handling change of given column and row.\r\n     */\r\n    private createInput(value: string, column: number, row: \"names\" | \"types\" | number) {\r\n        return (\r\n            <input\r\n                type='text'\r\n                className={this.props.darkTheme ? 'text-input-dark' : 'text-input-light'}\r\n                spellCheck={false}\r\n                value={value}\r\n                onChange={(e) => this.handleChange(e.target.value, column, row)}\r\n                autoFocus={true}\r\n            />\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Creates a tooltip with given text.\r\n     */\r\n    private createTooltip(text: string, style?: React.CSSProperties) {\r\n        return (\r\n            <span\r\n                className={\"tooltip \" + (this.props.darkTheme ? \"tooltip-dark\" : \"tooltip-light\")}\r\n                style={style}\r\n            >{text}</span>\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Creates a first row of the table with column names. If the table is editable and \"names\" row is selected,\r\n     * the entry in selected column is changed to text input. Otherwise, plain text is displayed.\r\n     * If the table is editable, additional blank column is added for \"add column\" button in next rows.\r\n     */\r\n    private createNamesRow() {\r\n        const rowData = this.props.relation.getColumnNames().map((columnName, columnIndex) => {\r\n            let content: string | JSX.Element = columnName;\r\n            if (this.state.selectedColumn === columnIndex && this.state.selectedRow === \"names\" && this.props.editable) {\r\n                content = this.createInput(columnName, columnIndex, \"names\");\r\n            }\r\n            let span: null | JSX.Element = null;\r\n            let className: string = \"name-th\";\r\n            const error = this.getErrors().get(\"name\", columnIndex);\r\n            if (error !== undefined) {\r\n                span = this.createTooltip(error, {top: \"120%\", bottom: \"auto\"});\r\n                className += \" error-input\";\r\n            }\r\n            return (\r\n                <th\r\n                    key={columnIndex}\r\n                    className={className}\r\n                    onClick={() => this.setSelectedInput(columnIndex, \"names\")}\r\n                    onContextMenu={(e) => this.handleRightClick(e, columnIndex, \"names\")}\r\n                >{content}{span}</th>\r\n            )});\r\n        // pushes empty input to create a new column for \"add column\" button (if the table is editable)\r\n        this.props.editable && rowData.push(<td key=\"add-column-column\" style={{width: \"20px\", border: \"none\"}}/>);\r\n        return (\r\n            <tr>{rowData}</tr>\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a first row of the table with column types. If the table is editable,\r\n     * the entries in the row are select elements. Otherwise, plain texts are displayed.\r\n     * If the table is editable, \"add column\" button is added in the last column with row span to the end of the table.\r\n     */\r\n    private createTypesRow() {\r\n        const rowData = this.props.relation.getColumnTypes().map((columnType, columnIndex) => {\r\n            const content = !this.props.editable ? columnType : (\r\n                <select\r\n                    value={columnType}\r\n                    onChange={(e) => this.handleChange(e.target.value, columnIndex, \"types\")}>\r\n                    <option>number</option>\r\n                    <option>string</option>\r\n                    <option>boolean</option>\r\n                </select>\r\n            );\r\n            return (\r\n                <th key={columnIndex}\r\n                    className=\"type-th\"\r\n                    onContextMenu={(e) => this.handleRightClick(e, columnIndex, \"types\")}\r\n                >{content}</th>\r\n            )});\r\n        // pushes \"add column\" button in last column (if the table is editable)\r\n        this.props.editable && rowData.push(\r\n            <td key='add-column'\r\n                rowSpan={this.props.relation.getRowCount() + 1}\r\n                style={{width: \"20px\", border: \"none\", padding: \"1px\"}}>\r\n                <button\r\n                    onClick={this.handleNewColumn}\r\n                    className={this.props.darkTheme ? \"button-dark\" : \"button-light\"}\r\n                    style={{width: \"100%\", height: \"100%\"}}><strong>+</strong></button>\r\n            </td>);\r\n        return (\r\n            <tr>{rowData}</tr>\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a data rows of the table. If the table is editable and any data row is selected,\r\n     * the entry in selected column is changed to text input. Otherwise, plain text is displayed.\r\n     */\r\n    private createRows() {\r\n        // creates default row if no exists\r\n        if (this.props.relation.getRows().length === 0) {\r\n            return null;\r\n        }\r\n        const rows: string[][] = this.props.relation.getRows();\r\n        // creates all rows if any\r\n        return rows.map((row, rowIndex) => (\r\n            <tr key={rowIndex}\r\n                onContextMenu={(e) => this.handleRightClick(e, undefined, rowIndex)}>\r\n                {row.map((value, columnIndex) => {\r\n                    let content: string | JSX.Element = value;\r\n                    if (this.state.selectedColumn === columnIndex && this.state.selectedRow === rowIndex && this.props.editable) {\r\n                        content = this.createInput(value, columnIndex, rowIndex);\r\n                    }\r\n                    let span: null | JSX.Element = null;\r\n                    let className: string = \"\";\r\n                    const error = this.getErrors().get(rowIndex, columnIndex);\r\n                    if (error !== undefined) {\r\n                        span = this.createTooltip(error);\r\n                        className = \"error-input\";\r\n                    }\r\n                    return (\r\n                        <td\r\n                            key={columnIndex}\r\n                            className={className}\r\n                            onClick={() => this.setSelectedInput(columnIndex, rowIndex)}\r\n                        >{content}{span}</td>\r\n                    )})}\r\n            </tr>\r\n        ));\r\n    }\r\n\r\n    /**\r\n     * Creates the last row of the table with button for adding rows.\r\n     */\r\n    private createAddRow() {\r\n        return (\r\n            <tr key='add-row'>\r\n                <td key='add-row-column'\r\n                    colSpan={this.props.relation.getColumnCount()}\r\n                    style={{border: \"none\", padding: \"2px\"}}>\r\n                    <button\r\n                        onClick={this.handleNewRow}\r\n                        className={this.props.darkTheme ? \"button-dark\" : \"button-light\"}\r\n                        style={{width: \"100%\", height: \"100%\"}}><strong>+</strong></button>\r\n                </td>\r\n            </tr>\r\n        );\r\n    }\r\n\r\n    public render() {\r\n        const namesRow = this.createNamesRow();\r\n        const typesRow = this.createTypesRow();\r\n        const rows = this.createRows();\r\n        const addRow = this.props.editable ? this.createAddRow() : null;\r\n\r\n        let divClassName = \"edit-table-container edit-table-container-light cursor-container-light\";\r\n        let tableClassName = \"edit-table edit-table-light\";\r\n        let contextButtonClassName = \"table-right-click-menu button-light\";\r\n        if (this.props.darkTheme) {\r\n            divClassName = \"edit-table-container edit-table-container-dark cursor-container-dark\";\r\n            tableClassName = \"edit-table edit-table-dark\";\r\n            contextButtonClassName = \"table-right-click-menu button-dark\";\r\n        }\r\n\r\n        return (\r\n            <div\r\n                className={divClassName}\r\n                ref={this.containerRef}\r\n                onKeyDown={this.handleKeyDown}>\r\n                <button className={contextButtonClassName} ref={this.deleteButtonRef}/>\r\n                <table\r\n                    className={tableClassName}\r\n                    onBlur={() => this.setSelectedInput(undefined, undefined)}>\r\n                    <thead>\r\n                        {namesRow}\r\n                    </thead>\r\n                    <tbody>\r\n                        {typesRow}\r\n                        {rows}\r\n                        {addRow}\r\n                    </tbody>\r\n                </table>\r\n            </div>\r\n        );\r\n    }\r\n}","import React from \"react\";\r\nimport \"./css/relationSection.css\"\r\nimport Relation from \"../relation/relation\";\r\nimport {TooltipButton} from \"./tooltipButton\";\r\nimport {MessageLabel} from \"./messageLabel\";\r\nimport {SupportedColumnType} from \"../relation/columnType\";\r\nimport EditRelationTable from \"./editRelationTable\";\r\nimport {StoredRelation} from \"../relation/storedRelation\";\r\nimport {TextInput} from \"./textInput\";\r\nimport {getForbiddenRelationNames} from \"../tools/keywords\";\r\nimport Parser from \"../tools/parser\";\r\n\r\ninterface RelationsSectionProps {\r\n    // all stored relations\r\n    storedRelations: StoredRelation[],\r\n    // index of the current selected relation\r\n    storedRelationIndex: number,\r\n\r\n    // all currently loaded relations in the application\r\n    loadedRelations: Relation[],\r\n\r\n    // handler of change of the name of the current selected relation\r\n    onRelationNameChange: (newName: string) => void,\r\n    // handler of change of the name of the column at given index in the current selected relation\r\n    onColumnNameChange: (columnName: string, columnIndex: number) => void,\r\n    // handler of change of the type of the column at given index in the current selected relation\r\n    onColumnTypeChange: (columnType: SupportedColumnType, columnIndex: number) => void,\r\n    // handler of change of the row input at given column/row index in the current selected relation\r\n    onRowInputChange: (input: string, columnIndex: number, rowIndex: number) => void,\r\n    // handler of adding a new row in the current selected relation\r\n    onNewRow: (onDone: () => void) => void,\r\n    // handler of adding a new column in the current selected relation\r\n    onNewColumn: (onDone: () => void) => void,\r\n    // handler of deleting the row on given index\r\n    onDeleteRow: (rowIndex: number) => void,\r\n    // handler of deleting the column on given index\r\n    onDeleteColumn: (columnIndex: number) => void,\r\n\r\n    // handler of loading the current selected relation into the application\r\n    onLoadRelation: (onDone: (msg: string) => void) => void,\r\n    // handler of loading all valid relations into the application\r\n    onLoadAllRelations: (onDone: (msg: string) => void) => void,\r\n\r\n    // handler of selecting a different relation as current\r\n    onSelectDifferentRelation: (newIndex: number) => void,\r\n    // handler of creating a new relation\r\n    onNewRelation: () => void,\r\n    // handler of deleting the current stored relation\r\n    onDeleteStoredRelation: () => void,\r\n\r\n    // handler of deleting the loaded relation with specific name or all loaded relations if specific = false\r\n    onDeleteLoadedRelation: (specific: string | false, onDone: (msg: string) => void) => void,\r\n\r\n    // handler of saving the stored relations into the files\r\n    onExportRelations: (onDone: (msg: string) => void) => void,\r\n    // handler of loading new relations from files\r\n    onImportRelations: (onDone: (msg: string) => void) => void,\r\n\r\n    // handler of unexpected errors\r\n    onUnexpectedError: (err: Error) => void,\r\n\r\n    // whether to support null values\r\n    nullValuesSupport: boolean,\r\n    // true if dark theme should be applied\r\n    darkTheme: boolean\r\n}\r\n\r\ninterface RelationsSectionState {\r\n    sectionClicked: boolean,\r\n    contentToShow: \"stored\" | \"loaded\",\r\n    loadedRelationIndex: number,\r\n    messageText: string,\r\n    isMessageError: boolean\r\n}\r\n\r\n/**\r\n * Section to type the RA expression. It contains textarea for relations definition and control buttons.\r\n */\r\nexport class RelationsSection extends React.Component<RelationsSectionProps, RelationsSectionState> {\r\n\r\n    // reference to this section element\r\n    private readonly sectionRef: React.RefObject<HTMLDivElement>;\r\n\r\n    constructor(props: RelationsSectionProps) {\r\n        super(props);\r\n        this.state = {\r\n            sectionClicked: false,\r\n            contentToShow: \"stored\",\r\n            loadedRelationIndex: 0,\r\n            messageText: \"\",\r\n            isMessageError: false\r\n        }\r\n        this.sectionRef = React.createRef<HTMLDivElement>();\r\n    }\r\n\r\n    componentDidMount() {\r\n        // adds listeners for loading on Ctrl+Enter\r\n        const section = this.sectionRef.current;\r\n        if (section !== null) {\r\n            section.addEventListener(\"click\", () => {\r\n                this.setState({sectionClicked: true});\r\n            }, true); // useCapture = true for overwriting the window listener\r\n        }\r\n        window.addEventListener(\"click\", () => {\r\n            this.setState({sectionClicked: false});\r\n        }, true); // useCapture = true for overwriting by section listener\r\n        window.addEventListener(\"keydown\", (event) => {\r\n            if (this.state.sectionClicked && event.ctrlKey) {\r\n                if (event.key === \"Enter\" && this.isShowingStored()) {\r\n                    this.loadRelation();\r\n                    event.preventDefault();\r\n                }\r\n                else if (event.shiftKey && event.key.toLowerCase() === \"a\" && this.isShowingStored()) {\r\n                    this.newRelation();\r\n                    event.preventDefault();\r\n                }\r\n                else if (event.shiftKey && event.key.toLowerCase() === \"d\") {\r\n                    this.deleteRelation();\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns true if the relation section now displays stored relations.\r\n     */\r\n    private isShowingStored = (): boolean => {\r\n        return this.state.contentToShow === \"stored\";\r\n    }\r\n\r\n    /**\r\n     * Returns selected stored relation if isShowingStored = true. Otherwise, returns selected loaded relation\r\n     * changed to StoredRelation type.\r\n     */\r\n    private getCurRel = (): StoredRelation => {\r\n        if (this.isShowingStored()) {\r\n            return this.props.storedRelations[this.props.storedRelationIndex];\r\n        }\r\n        else {\r\n            const loadedRelation: Relation = [...this.props.loadedRelations.values()][this.state.loadedRelationIndex];\r\n            return StoredRelation.fromRelation(loadedRelation.name, loadedRelation, this.props.nullValuesSupport);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Changes content to display between stored and loaded relations.\r\n     */\r\n    private changeContentToShow = (): void => {\r\n        if (this.isShowingStored()) {\r\n            if (this.props.loadedRelations.length === 0) {\r\n                this.showMessage(\"No relations loaded in the application at the moment.\");\r\n            }\r\n            else {\r\n                this.setState({\r\n                    contentToShow: \"loaded\",\r\n                    loadedRelationIndex: 0\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            this.setState({\r\n                contentToShow: \"stored\"\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Passes change to the parent element if isShowingStored = true. Otherwise, changes the state.loadedRelationIndex.\r\n     */\r\n    private handleSelectDifferentRelation(index: number): void {\r\n        if (this.isShowingStored()) {\r\n            this.props.onSelectDifferentRelation(index);\r\n            this.showMessage(\"\");\r\n        }\r\n        else {\r\n            this.setState({loadedRelationIndex: index});\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Passes change of the relation name to the parent element.\r\n     */\r\n    private handleRelationNameChange = (name: string) => {\r\n        this.props.onRelationNameChange(name);\r\n    }\r\n\r\n    /**\r\n     * Loads the selected relation to the application if there are no errors in it. Otherwise, displays a message to user.\r\n     */\r\n    private loadRelation = () => {\r\n        if (this.getCurRel().isValid()) {\r\n            this.props.onLoadRelation(this.showMessage);\r\n        }\r\n        else {\r\n            this.showMessage(\"Cannot use the invalid relation. Check errors and try again.\", true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Passes the load all relations call to the parent.\r\n     */\r\n    private loadAllRelations = () => {\r\n        this.props.onLoadAllRelations(this.showMessage);\r\n    }\r\n\r\n    /**\r\n     * Passes the export stored relations call to the parent.\r\n     */\r\n    private exportRelations = () => {\r\n        this.props.onExportRelations(this.showMessage);\r\n    }\r\n\r\n    /**\r\n     * Passes the import stored relations call to the parent.\r\n     */\r\n    private importRelations = () => {\r\n        this.props.onImportRelations(this.showMessage);\r\n    }\r\n\r\n    /**\r\n     * If isShowingStored = true, passes the call to delete current selected stored relation.\r\n     * If isShowingStored = false, passes the call to delete current selected loaded relation.\r\n     */\r\n    private deleteRelation = () => {\r\n        if (this.isShowingStored()) {\r\n            this.props.onDeleteStoredRelation();\r\n        }\r\n        else {\r\n            const nameToDelete: string = this.props.loadedRelations[this.state.loadedRelationIndex].getName();\r\n            let upgrade = {};\r\n            // if there is only one loaded relation, content to show is needed to be changed to stored after deleting\r\n            if (this.props.loadedRelations.length <= 1) {\r\n                upgrade = {contentToShow: \"stored\"};\r\n            }\r\n            // if the last relation in the menu list is selected\r\n            else if (this.state.loadedRelationIndex === this.props.loadedRelations.length - 1) {\r\n                upgrade = {loadedRelationIndex: this.state.loadedRelationIndex - 1};\r\n            }\r\n            this.setState(upgrade, () => this.props.onDeleteLoadedRelation(nameToDelete, this.showMessage));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Passes the import create new stored relation to the parent.\r\n     */\r\n    private newRelation = () => {\r\n        this.props.onNewRelation();\r\n    }\r\n\r\n    /**\r\n     * Passes the delete all loaded relations call to the parent.\r\n     */\r\n    private deleteAllLoadedRelations = () => {\r\n        // does not show loaded relations after deleting them\r\n        this.setState({contentToShow: \"stored\"}, () => this.props.onDeleteLoadedRelation(false, this.showMessage));\r\n    }\r\n\r\n    /**\r\n     * Shows the given message.\r\n     *\r\n     * @param msg message to be shown\r\n     * @param isError whether the message is error\r\n     */\r\n    private showMessage = (msg: string, isError: boolean = false) => {\r\n        this.setState({\r\n            messageText: msg,\r\n            isMessageError: isError\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates menu buttons. If isShowingStored = true, creates button for each stored relation. Otherwise, creates\r\n     * button for each loaded relation. Buttons for stored relations with errors are highlighted.\r\n     */\r\n    private createRelationMenuButtons = () => {\r\n        if (this.isShowingStored()) {\r\n            return this.props.storedRelations.map((rel, i) => {\r\n                const className: string = (this.props.darkTheme ?\r\n                    (this.props.storedRelationIndex === i ? \"button-clicked-dark\" : \"button-dark\") :\r\n                    (this.props.storedRelationIndex === i ? \"button-clicked-light\" : \"button-light\"));\r\n                const actuality: string = rel.isActual() ? \"\" : \" *\";\r\n                const actualityTooltip: string = rel.isActual() ? \" (loaded)\" : \" (NOT loaded)\";\r\n                const width: string = (96 / this.props.storedRelations.length) + \"%\";\r\n                const style = rel.isValid() ? {width: width} : {width: width, border: \"2px solid red\"};\r\n                return (<TooltipButton\r\n                    key={i}\r\n                    text={rel.getName() + actuality}\r\n                    onClick={() => this.handleSelectDifferentRelation(i)}\r\n                    className={className}\r\n                    style={style}\r\n                    tooltip={rel.getName() + actualityTooltip}\r\n                    tooltipClassName={\"tooltip \" + (this.props.darkTheme ? \"tooltip-dark\" : \"tooltip-light\")}\r\n                />);\r\n            });\r\n        }\r\n        else {\r\n            return this.props.loadedRelations.map((rel, i) => {\r\n                const className: string = (this.props.darkTheme ?\r\n                    (this.state.loadedRelationIndex === i ? \"button-clicked-dark\" : \"button-dark\") :\r\n                    (this.state.loadedRelationIndex === i ? \"button-clicked-light\" : \"button-light\"));\r\n                return (<TooltipButton\r\n                    key={i}\r\n                    text={rel.getName()}\r\n                    onClick={() => this.handleSelectDifferentRelation(i)}\r\n                    className={className}\r\n                    style={{width: (96 / this.props.loadedRelations.length) + \"%\"}}\r\n                    tooltip={rel.getName() + \" (current version loaded)\"}\r\n                    tooltipClassName={\"tooltip \" + (this.props.darkTheme ? \"tooltip-dark\" : \"tooltip-light\")}\r\n                />);\r\n            });\r\n        }\r\n    }\r\n\r\n    public render() {\r\n        const createButton = (text: string, onClick: () => void, tooltip: string, style?: React.CSSProperties) => {\r\n            return (<TooltipButton\r\n                key={text}\r\n                text={text}\r\n                onClick={onClick}\r\n                className={this.props.darkTheme ? \"button-dark\" : \"button-light\"}\r\n                style={style}\r\n                tooltip={tooltip}\r\n                tooltipClassName={\"tooltip \" + (this.props.darkTheme ? \"tooltip-dark\" : \"tooltip-light\")}\r\n            />);\r\n        }\r\n\r\n        // the relation cannot be renamed to forbidden relation names and other currently used relation names\r\n        const forbiddenRelationNames: string[] = this.props.storedRelations\r\n            .filter((sr, i) => i !== this.props.storedRelationIndex)\r\n            .map(sr => sr.getName());\r\n        forbiddenRelationNames.push(...getForbiddenRelationNames());\r\n        const forbiddenNamesFunction = (text: string): boolean => {\r\n            if (forbiddenRelationNames.indexOf(text) > -1) {\r\n                return true;\r\n            }\r\n            return !Parser.isName(text);\r\n        }\r\n\r\n        let sectionClassName = \"relation-section \";\r\n        if (this.state.sectionClicked) {\r\n            sectionClassName += this.props.darkTheme ? \"section-border-dark-clicked\" : \"section-border-light-clicked\";\r\n        }\r\n        else {\r\n            sectionClassName += this.props.darkTheme ? \"section-border-dark\" : \"section-border-light\";\r\n        }\r\n        return (\r\n            <section\r\n                ref={this.sectionRef}\r\n                className={sectionClassName}>\r\n                <div className=\"relations-names-menu\">\r\n                    {this.createRelationMenuButtons()}\r\n                </div>\r\n\r\n                <EditRelationTable\r\n                    relation={this.getCurRel()}\r\n                    editable={this.isShowingStored()}\r\n\r\n                    onColumnNameChange={this.props.onColumnNameChange}\r\n                    onColumnTypeChange={this.props.onColumnTypeChange}\r\n                    onRowInputChange={this.props.onRowInputChange}\r\n                    onNewRow={this.props.onNewRow}\r\n                    onNewColumn={this.props.onNewColumn}\r\n                    onDeleteRow={this.props.onDeleteRow}\r\n                    onDeleteColumn={this.props.onDeleteColumn}\r\n\r\n                    darkTheme={this.props.darkTheme}\r\n                />\r\n\r\n                <div className=\"relations-management-menu\">\r\n                    <div className=\"relations-management-menu-left\">\r\n                        <TextInput\r\n                            label=\"\"\r\n                            value={this.getCurRel().getName()}\r\n                            buttonText=\"Rename\"\r\n                            onSubmit={this.handleRelationNameChange}\r\n                            forbidden={forbiddenNamesFunction}\r\n                            id=\"relation-name-input\"\r\n                            darkTheme={this.props.darkTheme}\r\n                            style={this.isShowingStored() ? {} : {visibility: \"hidden\"}}\r\n                        />\r\n                    </div>\r\n\r\n                    <div className=\"relations-management-menu-right\">\r\n                        {createButton(\"Load\", this.loadRelation, \"Loads the relation into the application\",\r\n                            this.isShowingStored() ? undefined : {visibility: \"hidden\"})}\r\n                        {createButton(\"Load all\", this.loadAllRelations, \"Loads all valid relations into the application\",\r\n                            this.isShowingStored() ? {marginRight: \"20px\"} : {visibility: \"hidden\"})}\r\n                        {createButton(\"New\", this.newRelation, \"Creates a new relation\",\r\n                            this.isShowingStored() ? {} : {visibility: \"hidden\"})}\r\n                        {createButton(\"Delete\",\r\n                            this.deleteRelation,\r\n                            this.isShowingStored() ? \"Deletes current selected stored relation\" :\r\n                                                            \"Deletes current selected loaded relation\",\r\n                            {marginRight: \"20px\"})}\r\n                        {createButton(this.isShowingStored() ? \"Show loaded\" : \"Show stored\",\r\n                            this.changeContentToShow,\r\n                            this.isShowingStored() ? \"Shows relations currently loaded in the application\" :\r\n                                                            \"Shows relations currently stored for editing\"\r\n                        )}\r\n                        {createButton(\"Delete loaded\", this.deleteAllLoadedRelations,\r\n                            \"Deletes relations loaded in the application\", {marginRight: \"20px\"})}\r\n                        {createButton(\"Import\", this.importRelations, \"Adds new relations from files\")}\r\n                        {createButton(\"Export\", this.exportRelations, \"Saves stored relations to files\")}\r\n                    </div>\r\n                </div>\r\n\r\n                <MessageLabel\r\n                    message={this.state.messageText}\r\n                    darkTheme={this.props.darkTheme}\r\n                    error={this.state.isMessageError}\r\n                />\r\n\r\n                <div style={{clear: \"both\"}}/>\r\n            </section>\r\n        );\r\n    }\r\n}","interface SendData {\r\n    access_token: string,\r\n    subject: string,\r\n    text: string\r\n}\r\n\r\n/**\r\n * Class for sending emails. Powered by https://postmail.invotes.com/.\r\n * My TypeScript version of JavaScript Copy & Paste Example from PostMail webpage.\r\n */\r\nexport class PostMail {\r\n\r\n    /**\r\n     * Creates a mailer with given PostMail access token.\r\n     *\r\n     * @param accessToken token which specifies PostMail receiver of mails\r\n     */\r\n    constructor(readonly accessToken: string) {}\r\n\r\n    /**\r\n     * Sends given subject and body of the email to the PostMail receiver.\r\n     *\r\n     * @param subject subject of the mail\r\n     * @param body body of the mail\r\n     */\r\n    public send(subject: string, body: string): void {\r\n        const data_js: SendData = {\r\n            access_token: this.accessToken,\r\n            subject: subject,\r\n            text: body\r\n        };\r\n\r\n        const request = new XMLHttpRequest();\r\n        request.onreadystatechange = function() {\r\n            if (request.readyState === 4 && request.status === 200) {\r\n            } else if(request.readyState === 4) {\r\n                console.log(\"failed creating XMLHttpRequest in PostMail.send: \" + request.response);\r\n            }\r\n        };\r\n\r\n        let params = PostMail.toParams(data_js);\r\n        request.open(\"POST\", \"https://postmail.invotes.com/send\", true);\r\n        request.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\r\n        request.send(params);\r\n    }\r\n\r\n    private static toParams(data: SendData): string {\r\n        return encodeURIComponent(\"access_token\") + \"=\" + encodeURIComponent(data.access_token) + \"&\" +\r\n            encodeURIComponent(\"subject\") + \"=\" + encodeURIComponent(data.subject) + \"&\" +\r\n                encodeURIComponent(\"text\") + \"=\" + encodeURIComponent(data.text);\r\n    }\r\n}","import React, {Component} from 'react';\r\nimport Relation from '../relation/relation';\r\nimport RATreeNode from \"../ratree/raTreeNode\";\r\nimport Parser from \"../tools/parser\";\r\nimport {ExpressionSection} from \"./expressionSection\";\r\nimport {ResultSection} from \"./resultSection\";\r\nimport {ExpressionStoreManager} from \"../expression/expressionStoreManager\";\r\nimport {ManagementSection} from \"./managementSection\";\r\nimport {CsvValueSeparatorChar} from \"../tools/csvSupport\";\r\nimport {ProjectStoreManager} from \"../project/projectStoreManager\";\r\nimport {SupportedLanguage} from \"../tools/supportedLanguage\";\r\nimport {LocalStorage} from \"../tools/localStorage\";\r\nimport {Footer} from \"./footer\";\r\nimport {BatchProcessor} from \"../tools/batchProcessor\";\r\nimport {Expression} from \"../expression/expression\";\r\nimport {RelationsSection} from \"./relationsSection\";\r\nimport {StoredRelation, StoredRelationData} from \"../relation/storedRelation\";\r\nimport {SupportedColumnType} from \"../relation/columnType\";\r\nimport {RelationStoreManager} from \"../relation/relationStoreManager\";\r\nimport {PostMail} from \"../tools/postMail\";\r\n\r\ninterface MainScreenProps {}\r\n\r\ninterface MainScreenState {\r\n    loadedRelations: Map<string, Relation>,\r\n    storedRelations: StoredRelation[],\r\n    selectedRelation: number,\r\n\r\n    expressions: Expression[],\r\n    selectedExpression: number,\r\n\r\n    evaluationTreeRoot: RATreeNode | null,\r\n    evaluatedExpressionName: string,\r\n\r\n    nullValuesSupport: boolean,\r\n    csvValueSeparator: CsvValueSeparatorChar,\r\n    language: SupportedLanguage,\r\n    darkTheme: boolean\r\n}\r\n\r\n/**\r\n * Main component of Rachel web page. It wraps all page sections and passes messages between them.\r\n */\r\nexport default class MainScreen extends Component<MainScreenProps, MainScreenState> {\r\n\r\n    private readonly expressionSectionRef: React.RefObject<ExpressionSection>;\r\n\r\n    constructor(props: MainScreenProps) {\r\n        super(props);\r\n\r\n        const sR1Data: StoredRelationData = {\r\n            name: \"Car\",\r\n            columnNames: [\"Id\", \"Owner\", \"Color\", \"Electric\"],\r\n            columnTypes: [\"number\", \"number\", \"string\", \"boolean\"],\r\n            rows: [\r\n                ['1', '1', '\"Blue\"', 'true'],\r\n                ['2', '1', '\"Green\"', 'false'],\r\n                ['3', '2', '\"Blue\"', 'false'],\r\n                ['4', '3', '\"Black\"', 'true']\r\n            ],\r\n            columnCount: 4,\r\n            rowCount: 4\r\n        }\r\n        const sR2Data: StoredRelationData = {\r\n            name: \"Owner\",\r\n            columnNames: [\"Id\", \"Name\"],\r\n            columnTypes: [\"number\", \"string\"],\r\n            rows: [\r\n                ['1', '\"Luk Kotlk\"'],\r\n                ['2', '\"Karel IV.\"'],\r\n                ['3', '\"Eminem\"']\r\n            ],\r\n            columnCount: 2,\r\n            rowCount: 3\r\n        }\r\n        const sR1 = StoredRelation.fromData(sR1Data, true);\r\n        const sR2 = StoredRelation.fromData(sR2Data, true);\r\n\r\n        this.state = {\r\n            loadedRelations: new Map<string, Relation>(),\r\n            storedRelations: [\r\n                sR1,\r\n                sR2\r\n            ],\r\n            selectedRelation: 0,\r\n\r\n            expressions: [\r\n                {name: \"Expression 1\", text: \"Car\"},\r\n                {name: \"Expression 2\", text: \"Car*Owner\"},\r\n                {name: \"Expression 3\", text: \"Owner(Id = 1)\"}\r\n            ],\r\n            selectedExpression: 0,\r\n\r\n            evaluationTreeRoot: null,\r\n            evaluatedExpressionName: \"\",\r\n\r\n            nullValuesSupport: true,\r\n            csvValueSeparator: LocalStorage.getCsvValueSeparator(),\r\n            language: LocalStorage.getLanguage(),\r\n            darkTheme: LocalStorage.getDarkMode()\r\n        }\r\n        this.expressionSectionRef = React.createRef();\r\n    }\r\n\r\n    /**\r\n     * Reports an error to the author of the application via email.\r\n     *\r\n     * @param err unexpected error\r\n     */\r\n    private reportUnexpectedError = (err: Error): void => {\r\n        const postMail: PostMail = new PostMail(\"5uog26ex8q9qu7sqib8ea0qd\");\r\n        let body: string = \"Unexpected error \" + err.name + \" in Rachel application.\" +\r\n            \"\\n\\nMessage:\\n\" + err.message +\r\n            \"\\n\\nDate:\\n\" + new Date().toString() +\r\n            \"\\n\\nStack trace:\\n\" + err.stack +\r\n\r\n            \"\\n\\nLoaded relations: ----------------------------\\n\" +\r\n            [...this.state.loadedRelations.values()].map(relation => {\r\n                return relation.getName() + \"\\n\" + relation.contentString();\r\n            }).join(\"\\n\\n\") +\r\n\r\n            \"\\n\\nStored relations: ----------------------------\" +\r\n            \"\\nSelected relation (1-index): \" + (this.state.selectedRelation + 1) + \"\\n\\n\" +\r\n            this.state.storedRelations.map(relation => {\r\n                return relation.getName() + \"\\n\" +\r\n                    relation.getColumnNames().join(\", \") + \"\\n\" +\r\n                    relation.getColumnTypes().join(\", \") + \"\\n\" +\r\n                    relation.getRows().map(row => row.join(\", \")).join(\"\\n\");\r\n            }).join(\"\\n\\n\") +\r\n\r\n            \"\\n\\nExpressions: ----------------------------\" +\r\n            \"\\nSelected expression (1-index): \" + (this.state.selectedExpression + 1) + \"\\n\\n\" +\r\n            this.state.expressions.map(expr => expr.text).join(\"\\n\\n###\\n\\n\") +\r\n\r\n            \"\\n\\nEvaluation tree:\\n\" + this.state.evaluationTreeRoot?.printInLine() +\r\n\r\n            \"\\n\\nOther state: ----------------------------\" +\r\n            \"\\ncsvValueSeparator: \" + this.state.csvValueSeparator +\r\n            \"\\nlanguage:          \" + this.state.language +\r\n            \"\\nnullValuesSupport: \" + this.state.nullValuesSupport +\r\n            \"\\ndarkTheme:         \" + this.state.darkTheme;\r\n\r\n        postMail.send(\"Rachel application unexpected error\", body);\r\n        console.error('Unexpected error: ' + err.stack);\r\n    }\r\n\r\n    /****************************************** MANAGEMENT SECTION HANDLERS ******************************************/\r\n\r\n    /**\r\n     * Processes multiple selected files with expressions by the user and saves the reports of the evaluation in textual\r\n     * files.\r\n     *\r\n     * @param onDone callback function to show the message\r\n     */\r\n    private handleBatch = (onDone: (msg: string) => void) => {\r\n        const processor: BatchProcessor = new BatchProcessor();\r\n        processor.process('rachel-eval-results').then(onDone).catch(onDone);\r\n    }\r\n\r\n    /**\r\n     * Imports the project relation from the JSON file selected by the user.\r\n     *\r\n     * @param onDone callback function to show the message\r\n     */\r\n    private handleImportProject = (onDone: (msg: string) => void): void => {\r\n        ProjectStoreManager.load().then(project => {\r\n            this.setState({\r\n                loadedRelations: new Map<string, Relation>(),\r\n                storedRelations: project.relations.map(r => StoredRelation.fromData(r, project.nullValuesSupport)),\r\n                expressions: project.expressions,\r\n                nullValuesSupport: project.nullValuesSupport,\r\n                selectedExpression: 0,\r\n                evaluationTreeRoot: null,\r\n                evaluatedExpressionName: \"\"\r\n            }, () => {\r\n                onDone(\"Project loaded.\");\r\n                this.updateExpressionsErrors();\r\n            });\r\n        }).catch(onDone);\r\n    }\r\n\r\n    /**\r\n     * Exports the project relation to the JSON file.\r\n     *\r\n     * @param onDone callback function to show the message\r\n     */\r\n    private handleExportProject = (onDone: (msg: string) => void): void => {\r\n        try {\r\n            ProjectStoreManager.save({\r\n                relations: this.state.storedRelations.map(sr => sr.toDataObject()),\r\n                expressions: this.state.expressions,\r\n                nullValuesSupport: this.state.nullValuesSupport\r\n                }, \"rachel_project\");\r\n            onDone(\"Project saved.\");\r\n        }\r\n        catch (err) {\r\n            onDone(\"Project saving failed: \" + err.message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Changes the support of the null values in relations.\r\n     *\r\n     * @param nullValuesSupport new support of the null values in relations\r\n     */\r\n    private handleNullValuesSupportChange = (nullValuesSupport: boolean): void => {\r\n        this.state.storedRelations.forEach(sr => sr.setNullValuesSupport(nullValuesSupport));\r\n        // null values change can change validity of the relations, therefore set as not actual\r\n        this.setState({nullValuesSupport: nullValuesSupport}, this.updateExpressionsErrors);\r\n    }\r\n\r\n    /**\r\n     * Changes the value separator used in generated CSV files.\r\n     *\r\n     * @param csvValueSeparator new value separator used in generated CSV files\r\n     */\r\n    private handleCsvValueSeparatorChange = (csvValueSeparator: CsvValueSeparatorChar): void => {\r\n        LocalStorage.setCsvValueSeparator(csvValueSeparator);\r\n        this.setState({csvValueSeparator: csvValueSeparator});\r\n    }\r\n\r\n    /**\r\n     * Changes the language of the application.\r\n     *\r\n     * @param language new language of the application\r\n     */\r\n    private handleLanguageChange = (language: SupportedLanguage): void => {\r\n        LocalStorage.setLanguage(language);\r\n        this.setState({language: language});\r\n    }\r\n\r\n    /**\r\n     * Changes the dark/light mode of the application.\r\n     *\r\n     * @param darkTheme true if dark theme is on\r\n     */\r\n    private handleDarkModeChange = (darkTheme: boolean) => {\r\n        LocalStorage.setDarkMode(darkTheme);\r\n        this.setState({darkTheme: darkTheme});\r\n        document.body.classList.toggle( 'body-dark', darkTheme);\r\n        document.body.classList.toggle( 'cursor-container-dark', darkTheme);\r\n        document.body.classList.toggle( 'body-light', !darkTheme);\r\n        document.body.classList.toggle( 'cursor-container-light', !darkTheme);\r\n    }\r\n\r\n    /******************************************* RELATION SECTION HANDLERS *******************************************/\r\n\r\n    private handleRelationNameChange = (name: string): void => {\r\n        this.setState(state => {\r\n            const storedRelations = state.storedRelations;\r\n            storedRelations[this.state.selectedRelation].setName(name);\r\n            return {storedRelations: storedRelations};\r\n        });\r\n    }\r\n\r\n    private handleRelationColumnNameChange = (columnName: string, columnIndex: number): void => {\r\n        this.setState(state => {\r\n            const storedRelations = state.storedRelations;\r\n            storedRelations[this.state.selectedRelation].setColumnName(columnName, columnIndex);\r\n            return {storedRelations: storedRelations};\r\n        });\r\n    }\r\n\r\n    private handleRelationColumnTypeChange = (columnType: SupportedColumnType, columnIndex: number): void => {\r\n        this.setState(state => {\r\n            const storedRelations = state.storedRelations;\r\n            storedRelations[this.state.selectedRelation].setColumnType(columnType, columnIndex);\r\n            return {storedRelations: storedRelations};\r\n        });\r\n    }\r\n\r\n    private handleRelationRowInputChange = (input: string, columnIndex: number, rowIndex: number): void => {\r\n        this.setState(state => {\r\n            const storedRelations = state.storedRelations;\r\n            storedRelations[this.state.selectedRelation].setRowInput(input, rowIndex, columnIndex);\r\n            return {storedRelations: storedRelations};\r\n        });\r\n    }\r\n\r\n    private handleRelationNewRow = (onDone: () => void): void => {\r\n        this.state.storedRelations[this.state.selectedRelation].addNewRow();\r\n        // forces update\r\n        this.setState({}, onDone);\r\n    }\r\n\r\n    private handleRelationNewColumn = (onDone: () => void): void => {\r\n        this.state.storedRelations[this.state.selectedRelation].addNewColumn();\r\n        // forces update\r\n        this.setState({}, onDone);\r\n    }\r\n\r\n    private handleRelationDeleteRow = (rowIndex: number): void => {\r\n        this.state.storedRelations[this.state.selectedRelation].deleteRow(rowIndex);\r\n        // forces update\r\n        this.setState({});\r\n    }\r\n\r\n    private handleRelationDeleteColumn = (columnIndex: number): void => {\r\n        this.state.storedRelations[this.state.selectedRelation].deleteColumn(columnIndex);\r\n        // forces update\r\n        this.setState({});\r\n    }\r\n\r\n    /**\r\n     * Selects a new relation from the relations list as the current one.\r\n     */\r\n    private handleSelectDifferentRelation = (newIndex: number): void => {\r\n        this.setState({selectedRelation: newIndex});\r\n    }\r\n\r\n    /**\r\n     * Creates a new empty relation and adds it in the relation list.\r\n     */\r\n    private handleCreateNewRelation = (): void => {\r\n        // inserts a new empty relation in the array\r\n        const newIndex: number = this.state.selectedRelation + 1;\r\n        let name: string = \"NewRelation\";\r\n        for (let i = 1; true; ++i) {\r\n            if (this.state.storedRelations.map(sr => sr.getName()).indexOf(name + i) === -1) {\r\n                name += i;\r\n                break;\r\n            }\r\n        }\r\n        this.state.storedRelations.splice(newIndex, 0,\r\n            StoredRelation.new(name, this.state.nullValuesSupport));\r\n        this.setState({selectedRelation: newIndex});\r\n    }\r\n\r\n    /**\r\n     * Deletes the current relation from the relations list (or clears it if it is the last relation in the list).\r\n     */\r\n    private handleDeleteRelation = (): void => {\r\n        // if there is the last relation, only clears it\r\n        if (this.state.storedRelations.length === 1) {\r\n            this.setState({storedRelations: [StoredRelation.new(\"Relation\", this.state.nullValuesSupport)]});\r\n            return;\r\n        }\r\n        const selected: number = this.state.selectedRelation;\r\n        this.state.storedRelations.splice(selected, 1);\r\n        if (selected === this.state.storedRelations.length) {\r\n            this.setState({selectedRelation: selected - 1}, this.updateExpressionsErrors);\r\n        }\r\n        else {\r\n            // forces update\r\n            this.setState({}, this.updateExpressionsErrors);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes the specific relation or all relations loaded in the application.\r\n     *\r\n     * @param specific\r\n     * @param onDone\r\n     */\r\n    private handleDeleteLoadedRelation = (specific: string | false, onDone: (msg: string) => void): void => {\r\n        if (specific === false) {\r\n            this.state.loadedRelations.clear();\r\n            this.state.storedRelations.forEach(sr => sr.setActual(false));\r\n            onDone(\"All loaded relations deleted.\");\r\n        }\r\n        else {\r\n            this.state.loadedRelations.delete(specific);\r\n            this.state.storedRelations.filter(sr => sr.getName() === specific).forEach(sr => sr.setActual(false));\r\n            onDone('Relation \"' + specific + '\" deleted from loaded relations.');\r\n        }\r\n        // forces update\r\n        this.setState({}, this.updateExpressionsErrors);\r\n    }\r\n\r\n    /**\r\n     * Saves the relations list in a textual file.\r\n     *\r\n     * @param onDone\r\n     */\r\n    private handleExportRelations = (onDone: (msg: string) => void): void => {\r\n        try {\r\n            RelationStoreManager.save(this.state.storedRelations, \"rachel_relations\", this.state.csvValueSeparator);\r\n            onDone(this.state.storedRelations.length + \" relations saved.\");\r\n        }\r\n        catch (err) {\r\n            onDone(\"Saving error: \" + err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads the relations list from the textual file selected by the user.\r\n     *\r\n     * @param onDone\r\n     */\r\n    private handleImportRelations = (onDone: (msg: string) => void): void => {\r\n        RelationStoreManager.load(this.state.nullValuesSupport).then(info => {\r\n            const countBefore: number = this.state.storedRelations.length;\r\n            // loads relations to application\r\n            info.relations.forEach(relation => {\r\n                let name = relation.getName();\r\n                // renames existing names\r\n                if (this.state.storedRelations.map(sr => sr.getName()).indexOf(name) > -1) {\r\n                    for (let i = 2; true; ++i) {\r\n                        if (this.state.storedRelations.map(sr => sr.getName()).indexOf(name + i) === -1) {\r\n                            relation.setName(name + i);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                this.state.storedRelations.push(relation);\r\n            });\r\n            if (info.relations.length > 0) {\r\n                // shows first loaded relation\r\n                this.setState({selectedRelation: countBefore});\r\n            }\r\n            onDone(info.relations.length + \" relations loaded, \" + info.skipped + \" files skipped.\")\r\n        });\r\n    }\r\n\r\n    private handleLoadRelation = (onDone: (msg: string) => void): void => {\r\n        const currRelation: StoredRelation = this.state.storedRelations[this.state.selectedRelation];\r\n        currRelation.setActual(true);\r\n        this.state.loadedRelations.set(currRelation.getName(), currRelation.createRelation());\r\n        onDone(\"Relation loaded to application.\\n\" +\r\n            \"All current loaded relations (\" + this.state.loadedRelations.size + \"): \" +\r\n            [...this.state.loadedRelations.keys()].join(', ') + \".\");\r\n        // forces update\r\n        this.setState({}, this.updateExpressionsErrors);\r\n    }\r\n\r\n    private handleLoadAllRelations = (onDone: (msg: string) => void): void => {\r\n        let loaded: number = 0;\r\n        let skipped: number = 0;\r\n        this.state.storedRelations.forEach(sr => {\r\n            if (sr.isValid()) {\r\n                sr.setActual(true);\r\n                this.state.loadedRelations.set(sr.getName(), sr.createRelation());\r\n                ++loaded;\r\n            }\r\n            else {\r\n                ++skipped;\r\n            }\r\n        });\r\n        onDone(loaded + \" relations loaded to application, \" + skipped + \" skipped.\\n\" +\r\n            \"All current loaded relations (\" + this.state.loadedRelations.size + \"): \" +\r\n            [...this.state.loadedRelations.keys()].join(', ') + \".\");\r\n        // forces update\r\n        this.setState({}, this.updateExpressionsErrors);\r\n    }\r\n\r\n    /****************************************** EXPRESSION SECTION HANDLERS ******************************************/\r\n\r\n    private updateExpressionsErrors = (): void => {\r\n        const expressionSection = this.expressionSectionRef.current;\r\n        if (expressionSection !== null) {\r\n            expressionSection.updateErrors();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Saves evaluation tree for the evaluated RA expression.\r\n     */\r\n    private handleExprEval = (tree: RATreeNode): void => {\r\n        this.setState({\r\n            evaluationTreeRoot: tree,\r\n            evaluatedExpressionName: this.state.expressions[this.state.selectedExpression].name\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates the text of the current expression and sets it as not actual.\r\n     */\r\n    private handleExprTextChange = (name: string, text: string): void => {\r\n        this.setState(state => {\r\n            let expressions: Expression[] = state.expressions;\r\n            expressions[state.selectedExpression] = {name: name, text: text};\r\n            return { expressions: expressions }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Selects a new expression from the expression list as the current one.\r\n     */\r\n    private handleSelectDifferentExpression = (newIndex: number): void => {\r\n        this.setState({ selectedExpression: newIndex }, this.updateExpressionsErrors);\r\n    }\r\n\r\n    /**\r\n     * Creates a new empty expression and adds it in the expression list.\r\n     */\r\n    private handleCreateNewExpression = (): void => {\r\n        // inserts a new empty expression in the array\r\n        const newIndex: number = this.state.selectedExpression + 1;\r\n        this.state.expressions.splice(newIndex, 0, {name: \"New expression\", text: \"\"});\r\n        this.setState({selectedExpression: newIndex});\r\n    }\r\n\r\n    /**\r\n     * Deletes the current expression from the expression list (or clears it if it is the last expression in the list).\r\n     */\r\n    private handleDeleteExpression = (onDone: () => void): void => {\r\n        // if there is the last expression, only clears it\r\n        if (this.state.expressions.length === 1) {\r\n            return this.handleExprTextChange(\"Expression 1\", \"\");\r\n        }\r\n        const selected: number = this.state.selectedExpression;\r\n        this.state.expressions.splice(selected, 1);\r\n        if (selected === this.state.expressions.length) {\r\n            this.setState({selectedExpression: selected - 1}, onDone);\r\n        }\r\n        else {\r\n            // forces update\r\n            this.setState({}, onDone);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Saves the expression list in a textual file.\r\n     *\r\n     * @param onDone\r\n     */\r\n    private handleExportExpressions = (onDone: (msg: string) => void): void => {\r\n        try {\r\n            ExpressionStoreManager.save(this.state.expressions, 'rachel_expressions');\r\n            onDone(\"Expressions saved in a textual file.\");\r\n        }\r\n        catch (err) {\r\n            onDone(\"Expressions saving failed: \" + err.message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads the expression list from the textual file selected by the user.\r\n     *\r\n     * @param onDone\r\n     */\r\n    private handleImportExpressions = (onDone: (msg: string) => void): void => {\r\n        ExpressionStoreManager.load().then(info => {\r\n            this.state.expressions.push(...info.expressions);\r\n            this.setState({});\r\n            onDone(info.expressions.length + \" expressions loaded from \" + info.loadedFiles + \" files (\" +\r\n                + info.skippedExpressions + \" expressions skipped, \" + info.skippedFiles + \" files skipped).\");\r\n        });\r\n    }\r\n\r\n    /******************************************** RESULT SECTION HANDLERS ********************************************/\r\n\r\n    /**\r\n     * Adds the given relation to defined relations.\r\n     *\r\n     * @return message and its color (red for errors, black for information)\r\n     */\r\n    private addResultRelation = (name: string, relation: Relation, onSuccess: () => void, onError: (msg: string) => void): void => {\r\n        if (name === \"\") {\r\n            return onError(\"Relation name cannot be empty.\");\r\n        }\r\n        if (!Parser.isName(name)) {\r\n            return onError(\"\\\"\" + name + \"\\\" is not a valid name.\");\r\n        }\r\n        if (this.state.storedRelations.map(sr => sr.getName()).indexOf(name) > -1) {\r\n            return onError(\"Name \\\"\" + name + \"\\\" is already used.\");\r\n        }\r\n        this.state.storedRelations.push(StoredRelation.fromRelation(name, relation, this.state.nullValuesSupport));\r\n        this.setState({selectedRelation: this.state.storedRelations.length - 1});\r\n        onSuccess();\r\n    }\r\n\r\n    /***************************************************** RENDER *****************************************************/\r\n\r\n    public render() {\r\n        let resultSection = null;\r\n        if (this.state.evaluationTreeRoot !== null) {\r\n            resultSection = (\r\n                <ResultSection\r\n                    evaluationTreeRoot={this.state.evaluationTreeRoot}\r\n                    expressionName={this.state.evaluatedExpressionName}\r\n\r\n                    onAddResult={this.addResultRelation}\r\n                    onUnexpectedError={this.reportUnexpectedError}\r\n\r\n                    csvValueSeparator={this.state.csvValueSeparator}\r\n                    darkTheme={this.state.darkTheme}\r\n                />\r\n            );\r\n        }\r\n\r\n        return (\r\n        <div style={{height: \"100%\" /* for correct position of the footer*/}}>\r\n            <main>\r\n                <ManagementSection\r\n                    onBatch={this.handleBatch}\r\n\r\n                    onImportProject={this.handleImportProject}\r\n                    onExportProject={this.handleExportProject}\r\n\r\n                    csvValueSeparator={this.state.csvValueSeparator}\r\n                    language={this.state.language}\r\n                    nullValuesSupport={this.state.nullValuesSupport}\r\n                    darkTheme={this.state.darkTheme}\r\n\r\n                    onCsvValueSeparatorChange={this.handleCsvValueSeparatorChange}\r\n                    onLanguageChange={this.handleLanguageChange}\r\n                    onNullValuesSupportChange={this.handleNullValuesSupportChange}\r\n                    onDarkModeChange={this.handleDarkModeChange}\r\n                />\r\n\r\n                <div /*className={this.state.darkTheme ? \"section-border-dark\" : \"section-border-light\"}*/>\r\n                    <RelationsSection\r\n                        storedRelations={this.state.storedRelations}\r\n                        storedRelationIndex={this.state.selectedRelation}\r\n\r\n                        loadedRelations={[...this.state.loadedRelations.values()]}\r\n\r\n                        onRelationNameChange={this.handleRelationNameChange}\r\n                        onColumnNameChange={this.handleRelationColumnNameChange}\r\n                        onColumnTypeChange={this.handleRelationColumnTypeChange}\r\n                        onRowInputChange={this.handleRelationRowInputChange}\r\n                        onNewRow={this.handleRelationNewRow}\r\n                        onNewColumn={this.handleRelationNewColumn}\r\n                        onDeleteRow={this.handleRelationDeleteRow}\r\n                        onDeleteColumn={this.handleRelationDeleteColumn}\r\n\r\n                        onLoadRelation={this.handleLoadRelation}\r\n                        onLoadAllRelations={this.handleLoadAllRelations}\r\n\r\n                        onSelectDifferentRelation={this.handleSelectDifferentRelation}\r\n                        onNewRelation={this.handleCreateNewRelation}\r\n                        onDeleteStoredRelation={this.handleDeleteRelation}\r\n\r\n                        onDeleteLoadedRelation={this.handleDeleteLoadedRelation}\r\n\r\n                        onExportRelations={this.handleExportRelations}\r\n                        onImportRelations={this.handleImportRelations}\r\n\r\n                        onUnexpectedError={this.reportUnexpectedError}\r\n\r\n                        nullValuesSupport={this.state.nullValuesSupport}\r\n                        darkTheme={this.state.darkTheme}\r\n                    />\r\n\r\n                    <ExpressionSection\r\n                        ref={this.expressionSectionRef}\r\n\r\n                        expressions={this.state.expressions}\r\n                        currentExpressionIndex={this.state.selectedExpression}\r\n                        relations={this.state.loadedRelations}\r\n\r\n                        onChange={this.handleExprTextChange}\r\n                        onEval={this.handleExprEval}\r\n\r\n                        onSelectDifferentExpression={this.handleSelectDifferentExpression}\r\n                        onNewExpression={this.handleCreateNewExpression}\r\n                        onDeleteExpression={this.handleDeleteExpression}\r\n                        onExportExpressions={this.handleExportExpressions}\r\n                        onImportExpressions={this.handleImportExpressions}\r\n\r\n                        onUnexpectedError={this.reportUnexpectedError}\r\n                        nullValuesSupport={this.state.nullValuesSupport}\r\n                        darkTheme={this.state.darkTheme}\r\n                    />\r\n                </div>\r\n                {resultSection}\r\n            </main>\r\n            <Footer\r\n                language={this.state.language}\r\n                darkTheme={this.state.darkTheme}\r\n            />\r\n        </div>\r\n        );\r\n    }\r\n}","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport * as serviceWorker from './serviceWorker';\r\nimport MainScreen from \"./components/mainScreen\";\r\nimport {LocalStorage} from \"./tools/localStorage\";\r\n\r\n/**\r\n * @license The software is Licensed under the MIT License\r\n *\r\n * Copyright (c) Luk Kotlk\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\r\n * documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\r\n * to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions\r\n * of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO\r\n * THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\r\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n * ********* Used, Licensed third party code: *********\r\n *\r\n * JSZIP - Create, read and edit .zip files with Javascript\r\n * Version: 3.5.0\r\n * https://github.com/Stuk/jszip\r\n * MIT License - Copyright (c) 2009-2016 Stuart Knightley, David Duponchel, Franz Buchinger, Antnio Afonso\r\n *\r\n * visx - visualization components\r\n * visx/group - version: 1.0.0\r\n * visx/hierarchy - version: 1.0.0\r\n * visx/shape - version: 1.4.0\r\n * visx/responsive - version: 1.3.0\r\n * visx/tooltip - version: 1.3.0\r\n * https://github.com/airbnb/visx\r\n * MIT License - Copyright (c) 2017-2018 Harrison Shoff\r\n *\r\n * FileSaver.js - An HTML5 saveAs() FileSaver implementation\r\n * Version: 2.0.5\r\n * https://github.com/eligrey/FileSaver.js\r\n * MIT License - Copyright (c) 2016 Eli Grey\r\n *\r\n * Lodash - A modern JavaScript utility library delivering modularity, performance, & extras.\r\n * Version: 4.17.20\r\n * https://github.com/lodash/lodash\r\n * MIT License - Copyright JS Foundation and other contributors <https://js.foundation/>\r\n * Based on Underscore.js, copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors <http://underscorejs.org/>\r\n * This software consists of voluntary contributions made by many individuals. For exact contribution history, see the revision history available at https://github.com/lodash/lodash\r\n *\r\n * React - A declarative, efficient, and flexible JavaScript library for building user interfaces.\r\n * Version: 16.13.1\r\n * https://github.com/facebook/react\r\n * MIT License - Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * Jest - Delightful JavaScript Testing.\r\n * Version: 26.6.0\r\n * https://github.com/facebook/jest\r\n * MIT License - Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * create-react-app - Set up a modern web app by running one command.\r\n * Version: 3.4.1\r\n * https://github.com/facebook/create-react-app\r\n * MIT License - Copyright (c) 2013-present, Facebook, Inc.\r\n *\r\n * TypeScript - TypeScript is a superset of JavaScript that compiles to clean JavaScript output.\r\n * Version: 3.7.5\r\n * https://github.com/microsoft/TypeScript\r\n * Apache License 2.0\r\n *\r\n * ********* Used, not Licensed, free to use code and services: *********\r\n *\r\n * PostMail - Send email from JavaScript or static HTML without backend code\r\n * https://postmail.invotes.com/\r\n */\r\nReactDOM.render(\r\n    <React.StrictMode>\r\n        <MainScreen/>\r\n    </React.StrictMode>,\r\n    document.getElementById('root')\r\n);\r\n\r\n// sets body template by settings from local storage\r\ndocument.body.classList.toggle('body-dark', LocalStorage.getDarkMode());\r\ndocument.body.classList.toggle('body-light', !LocalStorage.getDarkMode());\r\ndocument.body.classList.toggle('cursor-container-dark', LocalStorage.getDarkMode());\r\ndocument.body.classList.toggle('cursor-container-light', !LocalStorage.getDarkMode());\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.register();\r\n"],"sourceRoot":""}
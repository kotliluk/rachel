{"version":3,"sources":["serviceWorker.ts","components/tooltipButton.tsx","error/errorWithTextRange.ts","utils/localStorage.ts","language/language.ts","language/en.ts","language/cs.ts","error/raSyntaxError.ts","error/raSemanticError.ts","utils/fontUtils.ts","utils/whisperUtils.ts","components/xTextArea.tsx","utils/math.ts","relation/relation.ts","error/codeError.ts","error/errorFactory.ts","expression/exprTokens.ts","utils/stringUtils.ts","ratree/raTreeNode.ts","ratree/relationNode.ts","types/indexedString.ts","utils/indexedStringUtils.ts","ratree/unaryNode.ts","relation/row.ts","ratree/projectionNode.ts","utils/keywords.ts","types/isToISMap.ts","vetree/comparingOperator.ts","ratree/renameNode.ts","vetree/veTreeNode.ts","vetree/logicalOperator.ts","vetree/computingOperator.ts","vetree/literalValue.ts","vetree/referenceValue.ts","expression/valueTokens.ts","expression/valueParser.ts","ratree/binaryNode.ts","ratree/raTreeTools.ts","ratree/antijoinNode.ts","ratree/selectionNode.ts","ratree/outerJoinNode.ts","ratree/cartesianProductNode.ts","ratree/divisionNode.ts","ratree/naturalJoinNode.ts","ratree/setOperationNode.ts","ratree/thetaJoinNode.ts","expression/exprParser.ts","ratree/raTreeFactory.ts","components/textInput.tsx","components/messageBox.ts","components/expressionSection.tsx","components/resultRelationTable.tsx","components/evaluationTree.tsx","utils/fileDialog.ts","types/nnToSMap.ts","relation/storedRelation.ts","relation/columnType.ts","relation/relationStoreManager.ts","types/csvSupport.ts","components/resultSection.tsx","expression/expressionStoreManager.ts","project/samples.ts","components/managementSection.tsx","project/project.ts","expression/expression.ts","project/projectStoreManager.ts","batch/batchProcessor.ts","utils/dateUtils.ts","components/editRelationTable.tsx","components/relationsSection.tsx","utils/mail.ts","components/mainScreen.tsx","index.tsx"],"names":["isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","console","log","onUpdate","onSuccess","catch","error","TooltipButton","className","this","props","onClick","style","text","undefined","tooltipClassName","tooltipStyle","event","stopPropagation","preventDefault","tooltip","React","Component","ErrorWithTextRange","msg","range","Error","insertRangeIfUndefined","err","defaultLanguage","defaultDarkMode","LocalStorage","storageSupported","storedSeparator","localStorage","getItem","setItem","csvValueSeparator","x","allSupportedLanguages","includes","language","darkTheme","warn","isInit","init","String","Storage","EN","abbr","relationErrors","emptyColumn","duplicitColumn","keywordColumn","invalidColumn","unsupportedNull","invalidNumber","invalidBoolean","codeErrors","resultSection_nodeIndexNotFound","resultSection_evalError","resultSection_nullRelationToSave","resultSection_nullRelationToAdd","row_absentColumn","valueParser_unexpectedToken","exprParser_unexpectedToken","exprParser_thetaJoinBranchError","exprParser_projectionBranchError","semanticErrors","exprParser_relationNotDefined","binaryNode_commonColumns","setOperationNode_notEqualColumns","divisionNode_rightColumnsNotSubset","divisionNode_rightColumnsNotProperSubset","renameNode_absentOriginalColumn","renameNode_changeToDuplicit","projectionNode_absentColumn","referenceValue_absentColumn","semanticError","syntaxErrors","exprParser_emptyStringGiven","exprParser_outerJoinWhenNullNotSupported","exprParser_unexpectedPart","exprParser_bothBranchesError","exprParser_invalidExpression","exprParser_invalidParentheses","exprParser_invalidStart","exprParser_invalidEnd","exprParser_relationAfterRelation","exprParser_relationAfterUnary","exprParser_relationAfterClosing","exprParser_unaryAfterBinary","exprParser_unaryAfterOpening","exprParser_binaryAfterBinary","exprParser_binaryAfterOpening","exprParser_openingAfterRelation","exprParser_openingAfterUnary","exprParser_openingAfterClosing","exprParser_closingAfterBinary","exprParser_closingAfterOpening","valueParser_emptyInput","valueParser_unsupportedNull","valueParser_unexpectedPart","valueParser_missingOpeningParenthesis","valueParser_missingClosingParenthesis","valueParser_invalidExpression","valueParser_invalidStart","valueParser_invalidEnd","valueParser_literalAfterLiteral","valueParser_literalAfterReference","valueParser_literalAfterClosing","valueParser_referenceAfterLiteral","valueParser_referenceAfterReference","valueParser_referenceAfterClosing","valueParser_notAfterLiteral","valueParser_notAfterReference","valueParser_notAfterClosing","valueParser_binaryAfterOperator","valueParser_binaryAfterOpening","valueParser_openingAfterLiteral","valueParser_openingAfterReference","valueParser_openingAfterClosing","valueParser_closingAfterOperator","valueParser_closingAfterOpening","stringUtils_missingClosingChar","stringUtils_charNotFound","renameNode_missingArrow","renameNode_invalidNewName","renameNode_keywordNewName","renameNode_multipleRenameOfTheColumn","selectionNode_resultNotBoolean","thetaJoinNode_resultNotBoolean","comparingOperator_differentInputTypes","computingOperator_inputTypesNotNumbers","logicalOperator_leftInputNotBoolean","logicalOperator_rightInputNotBoolean","syntaxError","userMessages","loadedRelationsTotalNo","loadedRelationsTotalSome","loadRelationNew","loadAllRelationsNew","deleteLoadedRelations","relationsExportOK","relationsExportErr","relationsImport","expressionsExportOK","expressionsExportErr","expressionsImport","operations","selection","projection","rename","union","intersection","difference","naturalJoin","cartesianProduct","leftSemiJoin","rightSemiJoin","leftAntijoin","rightAntijoin","thetaJoin","leftThetaSemiJoin","rightThetaSemiJoin","fullOuterJoin","leftOuterJoin","rightOuterJoin","division","managementSection","batchButton","loadButton","saveButton","samplesButton","samplesMenuTitle","settingsButton","settingsNullValues","settingsNullValuesAllowed","settingsNullValuesForbidden","settingsCSVSeparator","settingsCSVSeparatorSemicolon","settingsCSVSeparatorComma","settingsTheme","settingsThemeLight","settingsThemeDark","settingsLanguage","aboutButton","relationSection","relationSectionHeader","loadAllButton","loadAllButtonTooltip","removeLoadedButton","removeLoadedButtonTooltip","importButton","importButtonTooltip","exportButton","exportButtonTooltip","loadButtonTooltip","renameButton","deleteButton","deleteButtonTooltip","revertButton","revertButtonTooltip","expressionSection","expressionSectionHeader","evaluateButton","evaluateButtonTooltip","expressionTextareaPlaceholder","lineComment","blockComment","resultSection","resultSectionHeader","exportEvalTreeButton","exportEvalTreeButtonTooltip","evalTreeTitle","resultRelationTitle","intermediateRelationTitle","addButton","addButtonTooltip","exportRelationButton","exportRelationButtonTooltip","languageMap","Map","lang","get","getLanguage","RASyntaxError","captureStackTrace","name","RASemanticError","computeFontSizeInPx","fontFamily","fontSize","div","document","createElement","setAttribute","innerText","documentElement","appendChild","divWidth","clientWidth","divHeight","clientHeight","remove","fontWidth","length","fontHeight","getStartOfWordBeforeIndex","str","index","prefixText","slice","i","charAt","cssConstants","getComputedStyle","querySelector","getPropertyValue","lineHeight","Number","numsBackgroundLight","numsBackgroundDark","numsColorLight","numsColorDark","XTextArea","textarea","start","selectionStart","end","selectionEnd","setSelectionRange","activeElement","id","focus","getElementById","table","classList","add","tr","td1","td2","ta","mouseIsDown","placeholder","value","canvas","width","canvasWidth","canvasLines","whisperDiv","isShown","selectedIndex","changeSelected","indexDiff","setSelected","newIndex","n","m","childElementCount","children","getSelectedWhisper","paintLineNumbers","height","ctx","getContext","fillStyle","fillRect","scrollHeight","font","linesCount","fillText","e","update","lines","updateParentheses","createWhisper","whispers","hideWhisper","innerHTML","forEach","whisper","onclick","ondblclick","insertCurrentSelectedWhisper","notAutoShowWhisper","moveWhisper","cursorLineAndColumn","getPositionLineAndColumn","cursorDistanceFromTATotalTop","line","cursorDistanceFromTATotalLeft","column","yPos","scrollTop","xPos","scrollLeft","getBoundingClientRect","y","innerHeight","currWhisper","beforeAdd","afterAdd","newCursorPos","onChange","errorDivs","moveErrors","highlight","startLine","rangeLength","startColumn","innerWidth","messageSpan","updateErrors","ranges","pushHighlight","parentElement","push","createHighlightDiv","getLineLength","parentheses","parenthesesDivs","c1","c2","around","filter","p","first","div1","createParenthesesDiv","div2","toggle","moveParentheses","insertPairSymbol","second","before","between","after","checkPairSymbolDelete","prevI","nextI","prev","next","addEventListener","onscroll","onmousedown","setTimeout","onmouseup","onmousemove","oninput","ev","target","onkeydown","key","ctrlKey","cursor","onCtrlInput","errors","prevProps","position","textBeforeCursor","lastNewLine","lastIndexOf","newLinesFound","lineStart","lineEnd","newEvent","MouseEvent","type","dispatchEvent","span","Relation","columns","columnNames","rows","finishedSchema","hasColumn","hasFinishedSchema","set","some","cn","f","row","isEqual","getTypes","finishSchema","finish","r","equals","map","s","join","columnTypes","getOrderedPrintValues","longest","d","pad","ss","padEnd","repeat","other","Set","CodeError","ErrorFactory","params","assertParamsCount","joinStringArrays","expectedCount","a","b","aLen","toConcat","Array","concat","ExprToken","getRange","ParenthesisToken","OpeningParenthesis","ClosingParenthesis","RelationToken","UnaryOperatorToken","BinaryOperatorToken","precedence","precedenceLevelA","precedenceLevelB","StringUtils","split","every","c","isLetter","isNameChar","res","exec","toLowerCase","toUpperCase","isDigit","test","substring","char","digitFound","dotFound","backslashes","curChar","escape","depth","inQuotes","nesting","escapeCount","indexOf","charFound","RATreeNode","resultRelation","eval","RelationNode","relation","cursorIndex","result","getName","IndexedString","chars","startIndex","arr","ic","isEmpty","NaN","RangeError","separator","empty","sepLen","strSplit","prefixSum","separatorIndexes","strSplitLenMinusOne","ps","indexAt","_start","_end","newFromArray","trimStr","trim","strings","is","searchString","startsWith","endsWith","searchValue","replaceValue","replace","IndexedStringUtils","isWord","toString","isName","isWhitespacesOnly","isNumber","strParts","nextWord","nextName","nextNonWhitespacePart","nextNumber","nextQuotedString","getFirstIndex","nextBorderedPart","copy","getChars","inLineComment","blockCommentStart","errStart","skippedStr","skipWhitespacesAndChar","UnaryNode","subtree","Row","types","values","finished","keys","has","orderedColumns","ret","codeError","ProjectionNode","stringRange","part","isEvaluated","source","getResult","projectedIndexed","parseProjection","projected","forEachColumn","addColumn","getRows","newRow","getColumns","getValues","addValue","addRow","fakeEval","getColumnNames","absent","strName","printInLine","getOperationSymbol","forbiddenColumnNames","forbiddenRelationNames","isForbiddenColumnName","ComparingOperatorType","ISToISMap","keyValue","delete","clear","size","RenameNode","doThrow","handleError","parts","words","w","beforeError","afterError","changes","parseChanges","toChange","newName","returned","duplicit","beforeStr","afterStr","VETreeNode","LogicalOperatorType","ComparingOperator","operator","left","right","equal","nonEqual","less","more","lessOrEqual","moreOrEqual","leftResult","rightResult","ComputingOperatorType","LogicalOperator","and","or","not","LiteralValue","ReferenceValue","columnName","getValue","getType","ComputingOperator","plus","minus","multiplication","ValueToken","OperatorToken","LogicalNotToken","LogicalAndToken","LogicalOrToken","ComputingMultiplicationToken","ComputingDivisionToken","ComputingPlusToken","ComputingMinusToken","ComparingToken","OpeningParentheses","ClosingParentheses","LiteralToken","ReferenceToken","ValueParser","nullValuesSupport","tokens","parseTokens","assertValidInfixTokens","simplify","rpn","toRPN","rpnToVETree","token","rest","i2","token1","token2","notIndexes","indexesToRemove","t","rpnQueue","operatorsStack","pop","curToken","rpnToVETreeRecursive","deduct","multiply","divide","JSON","stringify","BinaryNode","leftSubtree","rightSubtree","depthSearch","root","findIndexInTree","node","getSubtree","leftSearch","getLeftSubtree","getRightSubtree","getTreeDepth","Math","max","isInRangeAndNotInQuotes","len","cursorIndexInStr","insideQuotes","AntijoinType","SelectionNode","boolExpr","parse","bool","newResult","fakeParse","OuterJoinType","AntijoinNode","rowsToKeep","rowsToHelp","leftSource","rightSource","commonColumns","lc","keptRow","helpRow","fakeEvalBinary","CartesianProductNode","leftRow","rightRow","leftColumn","DivisionNode","leftColumns","rightColumns","getSchemaString","resultColumns","getNamesSchemaString","leftRows","rightRows","testRow","lr","entries","NaturalJoinType","OuterJoinNode","full","SetOperationType","NaturalJoinNode","leftSemi","natural","rightSemi","ThetaJoinType","SetOperationNode","typeStr","getOperationName","rr","AssertType","ThetaJoinNode","condition","bothSourceColumns","booleanResult","sourceColumns","RATreeFactory","unaryClass","expr","binaryClass","ExprParser","relations","deleteAllComments","new","THROW_STRICT","rpnToRATree","fakeParseTokens","NOT_THROW","innerResult","selectionExpected","alternativeTokens","errorAlternative","message","rightThetaSemijoin","errorRange","isNaN","leftSemijoin","rightSemijoin","leftThetaSemijoin","THROW_NOT_STRICT","ignored","pushParentheses","getLastIndex","restStartIndex","recursiveReturn","containsAny","missing","splice","rpnToRATreeRecursive","createUnary","createBinary","TextInput","inputRef","handleChange","disable","forbidden","setState","buttonDisable","handleKeyDown","handleSubmit","current","blur","onSubmit","createRef","ref","spellCheck","autoComplete","onKeyDown","disabled","buttonText","boxMargin","MessageBox","box","visibility","onmouseenter","clearHideTimeout","onmouseleave","setHideTimeout","paragraph","button","hideBox","moveBox","body","firstElementChild","display","hideTimeout","hideIntervalId","clearTimeout","ExpressionSection","textAreaRef","lastChange","lastWhisperAndErrorsUpdate","whispersAndErrorsUpdateRate","updateErrorsAndParentheses","getCurExpr","evalExpr","tree","expressions","currentExpressionIndex","onEval","errorRanges","er","showError","newExpression","onNewExpression","deleteExpression","onDeleteExpression","exportExpressions","onExportExpressions","importExpressions","onImportExpressions","addSpecialString","shift","getSelection","firstPart","secondPart","newPosition","newStr","handleExprChange","setSelection","onDone","Date","now","handleCtrlInput","updateWhispersAndErrors","textArea","isFocused","fakeParseResult","wordBeforeCursor","helpArray","likelihood","wordStart","wordEnd","sort","help","sortWhispers","handleExprNameChange","onUnexpectedError","handleDragDrop","from","dataTransfer","getData","onDragExpression","sectionClicked","setInterval","onSelectDifferentExpression","ops","createButton","createOpButton","buttonGroupMargin","marginRight","handleSelectDifferentExpression","draggable","onDragStart","setData","onDragOver","onDrop","minWidth","marginLeft","padding","ResultRelationTable","getOrderByText","orderDir","orderBy","prevState","snapshot","updateOrderBy","getRowsCount","colSpan","sortCol","aValue","bValue","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","localeCompare","headerRow","createHeaderRow","createRows","EvaluationTree","TreeComponent","raTree","selected","nodeHeight","backgroundColorLight","backgroundColorDark","textColorLight","textColorDark","selectedNodeColorLight","unselectedNodeColorLight","selectedNodeColorDark","unselectedNodeColorDark","TreeNodeComponent","useTooltip","tooltipOpen","showTooltip","hideTooltip","nodeWidth","data","title","symbol","Group","top","rx","fill","onMouseOver","tooltipLeft","tooltipTop","onMouseOut","dy","textAnchor","pointerEvents","treeDepth","margin","bottom","yMax","xMax","indexes","parseTreeForDisplayHelper","maxNodeTextLength","parseTreeForDisplay","hierarchy","Tree","links","link","LinkVertical","stroke","strokeWidth","strokeOpacity","descendants","FileDialog","accept","Promise","resolve","element","fileInput","firstChild","file","files","reader","FileReader","onload","readAsText","click","openFilesHelper","fileInfo","readFile","NNToSMap","entry","parseKey","StoredRelation","columnCount","rowCount","actual","revertState","toDataObject","recomputeErrors","isStoredRelationData","rel","checkColumnNames","checkRowInput","columnIndex","reduce","agg","rowIndex","input","lower","_","rowInput","addNewColumn","columnType","checkColumnTypes","obj","isArray","o","isSupportedColumnType","RelationStoreManager","openFiles","skipped","csvToRelation","createValidName","filename","valueSeparator","zip","JSZip","relationToCsv","generateAsync","content","saveAs","blob","Blob","findValueSeparator","nextRowInput","inString","names","getColumnTypes","ResultSection","sectionRef","getCurrentRelation","currentNode","evaluationTreeRoot","handleSelectedNodeChange","exportEvalTreeAsPng","svg","rect","options","expressionName","downloadSVG","exportRelation","save","fromRelation","addRelation","onAddResult","relationType","selectedNode","tableTitle","ExpressionStoreManager","skippedExpressions","loadedFiles","skippedFiles","splitExpressionNameAndText","firstNewLineIndex","firstRow","textContent","samples","project","getSamples","ManagementSection","onBatch","onLoadProject","onSaveProject","samplesMenu","sample","onLoadSample","createSamplesButton","settingsMenu","checked","onNullValuesSupportChange","htmlFor","onCsvValueSeparatorChange","onDarkModeChange","onLanguageChange","createSettingsButton","href","isProjectObject","isExpression","copyProject","proj","exp","ProjectStoreManager","reject","openFile","BatchProcessor","time","reports","processed","downloadReports","report","timeEnd","processNext","processFile","storedData","storedRelation","fromData","isValid","createRelation","status","parseRelations","exprParser","exprCount","processExpression","addOperations","counts","reportHeader","formatRelations","sectionLine","parser","evaluationTree","operationsOfTree","contentLine","contentString","zeroOperations","date","total","binaryOperations","unaryOperations","binary","unary","getDate","padStart","getMonth","getFullYear","getHours","getMinutes","setOperation","cartesian","semijoin","antijoin","thetaSemijoin","outerJoin","inlines","format","count","operationOfUnaryNode","operationOfBinaryNode","cellPaddingSides","inputMarginSides","EditRelationTable","containerRef","tableHeadRowRef","columnWidths","handleInputResize","inputElement","scrollWidth","getErrors","setSelectedInput","selectedColumn","selectedRow","moveSelectedInputRight","getColumnCount","moveSelectedInputLeft","moveSelectedInputUp","moveSelectedInputDown","getRowCount","onColumnNameChange","onColumnTypeChange","onRowInputChange","handleNewColumn","onNewColumn","scrollTo","handleNewRow","onNewRow","handleDeleteColumn","onDeleteColumn","handleDeleteRow","onDeleteRow","createInput","autoFocus","createDeleteButton","callback","componentDidUpdate","headRow","cells","cell","rowData","createTooltip","rowSpan","border","createNamesRow","createTypesRow","createAddRow","RelationsSection","getCurRel","storedRelations","storedRelationIndex","handleRelationNameChange","onRelationNameChange","loadRelation","onLoadRelation","loadAllRelations","onLoadAllRelations","exportRelations","onExportRelations","importRelations","onImportRelations","deleteRelation","onDeleteStoredRelation","revertRelation","onRevertRelation","newRelation","onNewRelation","removeLoadedRelations","onRemoveLoadedRelations","createRelationMenuButtons","actuality","isActual","handleSelectDifferentRelation","onDragRelation","onSelectDifferentRelation","sr","getRevertName","Mail","accessToken","subject","data_js","access_token","request","XMLHttpRequest","onreadystatechange","readyState","response","toParams","open","setRequestHeader","send","encodeURIComponent","MainScreen","expressionSectionRef","reportUnexpectedError","postMail","stack","loadedRelations","selectedRelation","selectedExpression","loadProject","evaluatedExpressionName","updateExpressionsErrors","ensureUniqueRelationName","handleBatch","process","handleLoadProject","load","handleSaveProject","handleLoadSampleProject","handleNullValuesSupportChange","setNullValuesSupport","handleCsvValueSeparatorChange","setCsvValueSeparator","handleLanguageChange","setLanguage","handleDarkModeChange","setDarkMode","setName","handleRelationColumnNameChange","setColumnName","handleRelationColumnTypeChange","setColumnType","handleRelationRowInputChange","setRowInput","handleRelationNewRow","addNewRow","handleRelationNewColumn","handleRelationDeleteRow","deleteRow","handleRelationDeleteColumn","deleteColumn","handleDragRelation","to","moved","fromValue","newArray","handleCreateNewRelation","handleDeleteRelation","handleRevertRelation","revert","handleRemoveLoadedRelations","previous","setActual","handleExportRelations","handleImportRelations","info","countBefore","handleLoadRelation","currRelation","msgPart2","handleLoadAllRelations","loaded","handleExprEval","handleExprTextChange","handleDragExpression","handleCreateNewExpression","handleDeleteExpression","handleExportExpressions","handleImportExpressions","addResultRelation","getDarkMode","getCsvValueSeparator","ReactDOM","render","StrictMode","URL","origin","fetch","headers","contentType","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.6f97ff88.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\r\n\r\ninterface TooltipButtonProps {\r\n    // text on the button\r\n    text: string,\r\n    // handler of the button click\r\n    onClick: () => void,\r\n    // css class of the button\r\n    className?: string,\r\n    // inline styling for button\r\n    style?: React.CSSProperties,\r\n\r\n    // text of the tooltip\r\n    tooltip: string,\r\n    // css class of the tooltip (it always has default .tooltip class)\r\n    tooltipClassName?: string,\r\n    // inline styling for tooltip\r\n    tooltipStyle?: React.CSSProperties,\r\n}\r\n\r\ninterface TooltipButtonState {\r\n}\r\n\r\n/**\r\n * Button with a tooltip text.\r\n */\r\nexport class TooltipButton extends React.Component<TooltipButtonProps, TooltipButtonState> {\r\n\r\n    render() {\r\n        return (\r\n            <button\r\n                className={this.props.className}\r\n                onClick={this.props.onClick}\r\n                style={this.props.style}\r\n                >{this.props.text}\r\n                <span\r\n                    className={\"tooltip \" + (this.props.tooltipClassName !== undefined ? this.props.tooltipClassName : \"\")}\r\n                    style={this.props.tooltipStyle}\r\n                    onClick={event => {\r\n                        event.stopPropagation();\r\n                        event.preventDefault();\r\n                    }}\r\n                >{this.props.tooltip}</span>\r\n            </button>\r\n        );\r\n    }\r\n}","import {StartEndPair} from \"../types/startEndPair\";\r\n\r\n/**\r\n * Error with optional text range of the error.\r\n */\r\nexport default class ErrorWithTextRange extends Error {\r\n    constructor(msg: string, public range?: StartEndPair | undefined) {\r\n        super(msg);\r\n    }\r\n}\r\n\r\n/**\r\n * If the given error is ErrorWithTextRange instance and has undefined range, sets its range to given value.\r\n * Returns (possibly modified) input error.\r\n *\r\n * @param err\r\n * @param range\r\n */\r\nexport function insertRangeIfUndefined<T>(err: T, range: StartEndPair | undefined): T {\r\n    if (err instanceof ErrorWithTextRange && err.range === undefined) {\r\n        err.range = range;\r\n    }\r\n    return err;\r\n}","import {CsvValueSeparator} from \"../types/csvSupport\";\r\nimport {isSupportedLanguage, SupportedLanguage} from \"../language/language\";\r\n\r\nconst defaultCsvValueSeparator: CsvValueSeparator = \";\";\r\nconst defaultLanguage: SupportedLanguage = \"EN\";\r\nconst defaultDarkMode: string = \"false\";\r\n\r\n/**\r\n * Static class for maintaining the access to local storage of the browser. It handles user settings:\r\n * saving file type, csv value separator, language, light/dark theme of the application.\r\n * If the local storage is not used, it uses the application memory and the default values.\r\n */\r\nexport class LocalStorage {\r\n\r\n    private static isInit: boolean = false;\r\n    private static storageSupported: boolean = typeof(Storage) !== \"undefined\";\r\n\r\n    private static csvValueSeparator: CsvValueSeparator;\r\n    private static language: SupportedLanguage;\r\n    private static darkTheme: string;\r\n\r\n    /**\r\n     * Initializes the LocalStorage. If there are the requested values, loads them to application memory.\r\n     * If the local storage is not supported, uses the default values.\r\n     */\r\n    private static init(): void {\r\n        if (LocalStorage.storageSupported) {\r\n            const storedSeparator = localStorage.getItem(\"csvValueSeparator\");\r\n            if (storedSeparator !== \";\" && storedSeparator !== \",\") {\r\n                console.log(\"csvValueSeparator not found in localStorage and set to default\");\r\n                localStorage.setItem(\"csvValueSeparator\", defaultCsvValueSeparator);\r\n                LocalStorage.csvValueSeparator = defaultCsvValueSeparator;\r\n            }\r\n            else {\r\n                // @ts-ignore\r\n                LocalStorage.csvValueSeparator = localStorage.getItem(\"csvValueSeparator\");\r\n            }\r\n            if (!isSupportedLanguage(localStorage.getItem(\"language\"))) {\r\n                console.log(\"language not found in localStorage and set to default\");\r\n                localStorage.setItem(\"language\", defaultLanguage);\r\n                LocalStorage.language = defaultLanguage;\r\n            }\r\n            else {\r\n                // @ts-ignore\r\n                LocalStorage.language = localStorage.getItem(\"language\");\r\n            }\r\n\r\n            if (localStorage.getItem(\"darkTheme\") !== \"true\" && localStorage.getItem(\"darkTheme\") !== \"false\") {\r\n                console.log(\"darkTheme not found in localStorage and set to default\");\r\n                localStorage.setItem(\"darkTheme\", defaultDarkMode);\r\n                LocalStorage.darkTheme = defaultDarkMode;\r\n            }\r\n            else {\r\n                // @ts-ignore\r\n                LocalStorage.darkTheme = localStorage.getItem(\"darkTheme\");\r\n            }\r\n        }\r\n        else {\r\n            console.warn(\"LocalStorage not supported in the browser. Default values used.\");\r\n            LocalStorage.csvValueSeparator = defaultCsvValueSeparator;\r\n            LocalStorage.language = defaultLanguage;\r\n            LocalStorage.darkTheme = defaultDarkMode;\r\n        }\r\n        LocalStorage.isInit = true;\r\n    }\r\n\r\n    public static getCsvValueSeparator(): CsvValueSeparator {\r\n        if (!LocalStorage.isInit) {\r\n            LocalStorage.init();\r\n        }\r\n        return LocalStorage.csvValueSeparator;\r\n    }\r\n\r\n    public static setCsvValueSeparator(csvValueSeparator: CsvValueSeparator): void {\r\n        LocalStorage.csvValueSeparator = csvValueSeparator;\r\n        if (LocalStorage.storageSupported) {\r\n            localStorage.setItem(\"csvValueSeparator\", csvValueSeparator);\r\n        }\r\n    }\r\n\r\n    public static getLanguage(): SupportedLanguage {\r\n        if (!LocalStorage.isInit) {\r\n            LocalStorage.init();\r\n        }\r\n        return LocalStorage.language;\r\n    }\r\n\r\n    public static setLanguage(language: SupportedLanguage): void {\r\n        LocalStorage.language = language;\r\n        if (LocalStorage.storageSupported) {\r\n            localStorage.setItem(\"language\", language);\r\n        }\r\n    }\r\n\r\n    public static getDarkMode(): boolean {\r\n        if (!LocalStorage.isInit) {\r\n            LocalStorage.init();\r\n        }\r\n        return LocalStorage.darkTheme === \"true\";\r\n    }\r\n\r\n    public static setDarkMode(darkTheme: boolean): void {\r\n        LocalStorage.darkTheme = String(darkTheme);\r\n        if (LocalStorage.storageSupported) {\r\n            localStorage.setItem(\"darkTheme\", String(darkTheme));\r\n        }\r\n    }\r\n}","import {LocalStorage} from \"../utils/localStorage\";\r\nimport {EN} from \"./en\";\r\nimport {CS} from \"./cs\";\r\nimport {CodeErrorMessages} from \"../error/codeError\";\r\nimport {SemanticErrorMessages} from \"../error/raSemanticError\";\r\nimport {SyntaxErrorMessages} from \"../error/raSyntaxError\";\r\n\r\n/**\r\n * IF YOU WANT TO ADD A NEW LANGUAGE, READ THIS:\r\n *\r\n * Adding a language is simple, follow these steps:\r\n * 1) Copy the \"en.ts\" file in this package and name it as the lowercase new language abbreviation, e.g., \"cs.ts\"\r\n * 2) Rename the language definition object to the uppercase language abbreviation, e.g., \"CS\"\r\n * 3) Translate the messages in the new file. Some messages are split into an array - if you are not sure what to\r\n * write in each part, see its usage or other languages.\r\n * 4) Add the uppercase language abbreviation, e.g., \"CS\", in the allSupportedLanguages array in this file.\r\n * 5) Import your language definition in this file, e.g., \"import {CS} from \"./cs\";\"\r\n * 6) Add the imported language definition into languageMap map in this file, e.g., \"[\"CS\", CS],\"\r\n * 7) (voluntary) Create a project sample in your language in /project/samples.ts - you can translate existing samples.\r\n * 8) Test whether the application works.\r\n */\r\n\r\n/**\r\n * All languages supported in the application.\r\n * NOTE FOR NEW LANGUAGES: If you define a new language file \"lang.ts\", add \"LANG\" to this array.\r\n */\r\nexport const allSupportedLanguages = (<L extends string>(arr: L[]) => arr)([\"EN\", \"CS\"]);\r\n\r\n/**\r\n * Abbreviation of supported languages in the application.\r\n */\r\nexport type SupportedLanguage = (typeof allSupportedLanguages)[number];\r\n\r\n/**\r\n * Definition of a language for Rachel.\r\n * NOTE FOR NEW LANGUAGES: If you want to define a new language, it must be through this interface in a new file in\r\n * this package (see en.ts file as an example of English language definition).\r\n */\r\nexport interface LanguageDef {\r\n    /**\r\n     * Abbreviation of the language\r\n     */\r\n    abbr: SupportedLanguage,\r\n    /**\r\n     * Description of errors in relation definitions.\r\n     */\r\n    relationErrors: {\r\n        emptyColumn: string,\r\n        duplicitColumn: string,\r\n        keywordColumn: string,\r\n        invalidColumn: string,\r\n\r\n        unsupportedNull: string,\r\n        invalidNumber: string,\r\n        invalidBoolean: string,\r\n    },\r\n    /**\r\n     * Description of unexpected errors.\r\n     */\r\n    codeErrors: CodeErrorMessages,\r\n    /**\r\n     * Description of semantic errors in expressions.\r\n     */\r\n    semanticErrors: SemanticErrorMessages,\r\n    semanticError: string,\r\n    /**\r\n     * Description of syntactic errors in expressions.\r\n     */\r\n    syntaxErrors: SyntaxErrorMessages,\r\n    syntaxError: string,\r\n    /**\r\n     * Info messages for the user in pop-up message box.\r\n     */\r\n    userMessages: {\r\n        loadedRelationsTotalNo: string,\r\n        loadedRelationsTotalSome: string,\r\n        loadRelationNew: string,\r\n        // 2 parts expected - see English language as an example\r\n        loadAllRelationsNew: string[],\r\n        deleteLoadedRelations: string,\r\n\r\n        relationsExportOK: string,\r\n        relationsExportErr: string,\r\n        // 2 parts expected - see English language as an example\r\n        relationsImport: string[],\r\n\r\n        expressionsExportOK: string,\r\n        expressionsExportErr: string,\r\n        // 4 parts expected - see English language as an example\r\n        expressionsImport: string[]\r\n    },\r\n    /**\r\n     * Names of RA operations.\r\n     */\r\n    operations: {\r\n        selection: string,\r\n        projection: string,\r\n        rename: string,\r\n        union: string,\r\n        intersection: string,\r\n        difference: string,\r\n        naturalJoin: string,\r\n        cartesianProduct: string,\r\n        leftSemiJoin: string,\r\n        rightSemiJoin: string,\r\n        leftAntijoin: string,\r\n        rightAntijoin: string,\r\n        thetaJoin: string,\r\n        leftThetaSemiJoin: string,\r\n        rightThetaSemiJoin: string,\r\n        fullOuterJoin: string,\r\n        leftOuterJoin: string,\r\n        rightOuterJoin: string,\r\n        division: string\r\n    }\r\n    /**\r\n     * Description of elements in management section.\r\n     */\r\n    managementSection: {\r\n        batchButton: string,\r\n        loadButton: string,\r\n        saveButton: string,\r\n\r\n        samplesButton: string,\r\n        samplesMenuTitle: string,\r\n\r\n        settingsButton: string,\r\n        settingsNullValues: string,\r\n        settingsNullValuesAllowed: string,\r\n        settingsNullValuesForbidden: string,\r\n        settingsCSVSeparator: string,\r\n        settingsCSVSeparatorSemicolon: string,\r\n        settingsCSVSeparatorComma: string,\r\n        settingsTheme: string,\r\n        settingsThemeLight: string,\r\n        settingsThemeDark: string,\r\n        settingsLanguage: string,\r\n\r\n        aboutButton: string\r\n    },\r\n    /**\r\n     * Description of elements in relation section.\r\n     */\r\n    relationSection: {\r\n        relationSectionHeader: string,\r\n\r\n        loadAllButton: string,\r\n        loadAllButtonTooltip: string,\r\n        removeLoadedButton: string,\r\n        removeLoadedButtonTooltip: string,\r\n        importButton: string,\r\n        importButtonTooltip: string,\r\n        exportButton: string,\r\n        exportButtonTooltip: string,\r\n\r\n        loadButton: string,\r\n        loadButtonTooltip: string,\r\n        renameButton: string,\r\n        deleteButton: string,\r\n        deleteButtonTooltip: string,\r\n        revertButton: string,\r\n        revertButtonTooltip: string\r\n    },\r\n    /**\r\n     * Description of elements in expression section.\r\n     */\r\n    expressionSection: {\r\n        expressionSectionHeader: string,\r\n\r\n        importButton: string,\r\n        importButtonTooltip: string,\r\n        exportButton: string,\r\n        exportButtonTooltip: string,\r\n\r\n        evaluateButton: string,\r\n        evaluateButtonTooltip: string,\r\n        renameButton: string,\r\n        deleteButton: string,\r\n        deleteButtonTooltip: string,\r\n\r\n        expressionTextareaPlaceholder: string,\r\n\r\n        lineComment: string,\r\n        blockComment: string\r\n    }\r\n    /**\r\n     * Description of elements in result section.\r\n     */\r\n    resultSection: {\r\n        resultSectionHeader: string,\r\n\r\n        exportEvalTreeButton: string,\r\n        exportEvalTreeButtonTooltip: string,\r\n        evalTreeTitle: string,\r\n\r\n        resultRelationTitle: string,\r\n        intermediateRelationTitle: string,\r\n        addButton: string,\r\n        addButtonTooltip: string,\r\n        exportRelationButton: string,\r\n        exportRelationButtonTooltip: string,\r\n    }\r\n}\r\n\r\n/**\r\n * Map of supported languages to their definition.\r\n * NOTE FOR NEW LANGUAGES: If you define a new language, add its definition mapping here.\r\n */\r\nconst languageMap: Map<SupportedLanguage, LanguageDef> = new Map<SupportedLanguage, LanguageDef>([\r\n    [\"EN\", EN],\r\n    [\"CS\", CS],\r\n]);\r\n\r\n/**\r\n * Returns true if the given value is a supported language.\r\n */\r\nexport function isSupportedLanguage(x: any): boolean {\r\n    return allSupportedLanguages.includes(x);\r\n}\r\n\r\n/**\r\n * Returns definition of the current select language.\r\n */\r\nexport function language(): LanguageDef {\r\n    const lang = languageMap.get(LocalStorage.getLanguage());\r\n    if (lang === undefined) {\r\n        return EN;\r\n    }\r\n    return lang;\r\n}","import {LanguageDef} from \"./language\";\r\nimport {CodeErrorMessages} from \"../error/codeError\";\r\nimport {SemanticErrorMessages} from \"../error/raSemanticError\";\r\nimport {SyntaxErrorMessages} from \"../error/raSyntaxError\";\r\n\r\n/**\r\n * English messages for CodeErrors mapped by their error codes.\r\n */\r\nconst codeErrors: CodeErrorMessages = {\r\n    resultSection_nodeIndexNotFound:\r\n        [\"ResultSection.getCurrentRelation: Selected node index in evaluation tree not found.\"],\r\n    resultSection_evalError:\r\n        [\"ResultSection.getCurrentRelation: Evaluation error in result section: \", /* error */ \".\"],\r\n    resultSection_nullRelationToSave:\r\n        [\"ResultSection.saveResultRelation: Result relation is null when tried to save it.\"],\r\n    resultSection_nullRelationToAdd:\r\n        [\"ResultSection.handleAddRelation: Result relation is null when tried to add it.\"],\r\n\r\n    row_absentColumn:\r\n        [\"Row.getOrderedValues: Column \", /* column */ \" is absent in row with columns: \", /* column */ \".\"],\r\n\r\n    valueParser_unexpectedToken:\r\n        [\"ValueParser.rpnToVETreeRecursive: Unexpected token: \", /* token */ \".\"],\r\n\r\n    exprParser_unexpectedToken:\r\n        [\"ExprParser.isValidSequence: Unexpected token: \", /* token */ \".\"],\r\n    exprParser_thetaJoinBranchError:\r\n        [\"ExprParser.parseTokensForWhisper: Error in theta join branch: \", /* error */ \".\"],\r\n    exprParser_projectionBranchError:\r\n        [\"ExprParser.parseTokensForWhisper: Error in projection branch: \", /* error */ \".\"]\r\n};\r\n\r\n/**\r\n * English messages for RASemanticErrors mapped by their error codes.\r\n */\r\nconst semanticErrors: SemanticErrorMessages = {\r\n    exprParser_relationNotDefined: [\"Relation \\\"\", /* relation */ \"\\\" is not defined. Check relations definitions.\"],\r\n\r\n    binaryNode_commonColumns: [\"Source relations for \", /* operator */ \" have common columns \\\"\", /* columns */ \"\\\".\"],\r\n    setOperationNode_notEqualColumns:\r\n        [\"Source relations \\\"\", /* left */ \"\\\" and \\\"\", /* right */ \"\\\" for set \", /* operation */ \" do not have the same column sets.\"],\r\n    divisionNode_rightColumnsNotSubset:\r\n        [\"Right source relation schema \\\"\", /* schema */ \"\\\" is not a subset of the left source relation schema \\\"\", /* schema */ \"\\\".\"],\r\n    divisionNode_rightColumnsNotProperSubset:\r\n        [\"Right source relation schema \\\"\", /* schema */ \"\\\" is not a proper subset of the left source relation schema \\\"\",\r\n        /* schema */ \". There must exist a column in the left relation which is not present in the right relation.\"],\r\n    renameNode_absentOriginalColumn: [\"Invalid rename, column \\\"\", /* column */ \"\\\" does not exist in the source relation.\"],\r\n    renameNode_changeToDuplicit: [\"Invalid rename, new column name \\\"\", /* column */ \"\\\" is duplicit in the changed relation.\"],\r\n    projectionNode_absentColumn: [\"Invalid projection of the column \\\"\", /* column */ \"\\\". It does not exist in the source relation.\"],\r\n\r\n    referenceValue_absentColumn: [\"Column \\\"\", /* column */ \"\\\" is absent in a schema with columns: \", /* columns */ \".\"]\r\n};\r\n\r\n/**\r\n * English messages for RASyntaxErrors mapped by their error codes.\r\n */\r\nconst syntaxErrors: SyntaxErrorMessages = {\r\n    exprParser_emptyStringGiven: [\"Cannot parse an expression from an empty string.\"],\r\n    exprParser_outerJoinWhenNullNotSupported: [\"Found \", /* outer join */ \" when null values are not supported.\"],\r\n    exprParser_unexpectedPart: [\"Unexpected part \\\"\", /* part */ \"\\\" in RA expression.\"],\r\n    exprParser_bothBranchesError: [\"All combinations throw error in \\\"\", /* part */ \"\\\". When treated as projection:\\n\",\r\n        /* error */ \"\\nWhen treated as theta join:\\n\", /* error */ \"\"],\r\n    exprParser_invalidExpression: [\"Given string is not a valid expression.\"],\r\n    exprParser_invalidParentheses: [\"Invalid structure of parentheses in the expression.\"],\r\n    exprParser_invalidStart: [\"RA expression cannot start with \", /* start */ \".\"],\r\n    exprParser_invalidEnd: [\"RA expression cannot end with \", /* end */ \".\"],\r\n    exprParser_relationAfterRelation: [\"Relation \\\"\", /* relation */ \"\\\" after relation \\\"\", /* relation */\"\\\".\"],\r\n    exprParser_relationAfterUnary: [\"Relation \\\"\", /* relation */ \"\\\" after unary operator \\\"\", /* unary */ \"\\\".\"],\r\n    exprParser_relationAfterClosing: [\"Relation \\\"\", /* relation */ \"\\\" after closing parenthesis.\"],\r\n    exprParser_unaryAfterBinary: [\"Unary operator \\\"\", /* unary */ \"\\\" after binary operator \\\"\", /* binary */ \"\\\".\"],\r\n    exprParser_unaryAfterOpening: [\"Unary operator \\\"\", /* unary */ \"\\\" after opening parenthesis.\"],\r\n    exprParser_binaryAfterBinary: [\"Binary operator \\\"\", /* unary */ \"\\\" after binary operator \\\"\", /* binary */ \"\\\".\"],\r\n    exprParser_binaryAfterOpening: [\"Binary operator \\\"\", /* binary */ \"\\\" after opening parenthesis.\"],\r\n    exprParser_openingAfterRelation: [\"Opening parentheses after relation \\\"\", /* relation */ \"\\\".\"],\r\n    exprParser_openingAfterUnary: [\"Opening parentheses after unary operator \\\"\", /* unary */ \"\\\".\"],\r\n    exprParser_openingAfterClosing: [\"Opening parentheses after closing parentheses.\"],\r\n    exprParser_closingAfterBinary: [\"Closing parentheses after binary operator \\\"\", /* binary */ \"\\\".\"],\r\n    exprParser_closingAfterOpening: [\"Closing parentheses after opening parentheses.\"],\r\n\r\n    valueParser_emptyInput: [\"An empty string given as a condition.\"],\r\n    valueParser_unsupportedNull: [\"Null constant used when null values are not supported.\"],\r\n    valueParser_unexpectedPart: [\"Unexpected part \\\"\", /* part */ \"\\\" in expression.\"],\r\n    valueParser_missingOpeningParenthesis: [\"Missing opening parenthesis '(' in an expression.\"],\r\n    valueParser_missingClosingParenthesis: [\"Missing closing parenthesis ')' in an expression.\"],\r\n    valueParser_invalidExpression: [\"Given string is not a valid expression.\"],\r\n    valueParser_invalidStart: [\"Expression cannot start with \\\"\", /* start */ \"\\\".\"],\r\n    valueParser_invalidEnd: [\"Expression cannot end with \\\"\", /* end */ \"\\\".\"],\r\n    valueParser_literalAfterLiteral: [\"Literal \\\"\", /* literal */ \"\\\" after literal \\\"\", /* literal */ \"\\\".\"],\r\n    valueParser_literalAfterReference: [\"Literal \\\"\", /* literal */ \"\\\" after reference to column \\\"\", /* column */ \"\\\".\"],\r\n    valueParser_literalAfterClosing: [\"Literal \\\"\", /* literal */ \"\\\" after closing parentheses.\"],\r\n    valueParser_referenceAfterLiteral: [\"Reference to column \\\"\", /* column */ \"\\\" after literal \\\"\", /* literal */ \"\\\".\"],\r\n    valueParser_referenceAfterReference: [\"Reference to column \\\"\", /* column */ \"\\\" after reference to column \\\"\", /* column */ \"\\\".\"],\r\n    valueParser_referenceAfterClosing: [\"Reference to column \\\"\", /* column */ \"\\\" after closing parentheses.\"],\r\n    valueParser_notAfterLiteral: [\"Logical not operator \\\"\", /* not */ \"\\\" after literal \\\"\", /* literal */ \"\\\".\"],\r\n    valueParser_notAfterReference: [\"Logical not operator \\\"\", /* not */ \"\\\" after reference to column \\\"\", /* column */ \"\\\".\"],\r\n    valueParser_notAfterClosing: [\"Logical not operator \\\"\", /* not */ \"\\\" after closing parentheses.\"],\r\n    valueParser_binaryAfterOperator: [\"Binary operator \\\"\", /* binary */ \"\\\" after binary operator \\\"\", /* binary */ \"\\\".\"],\r\n    valueParser_binaryAfterOpening: [\"Binary operator \\\"\", /* binary */ \"\\\" after opening parentheses.\"],\r\n    valueParser_openingAfterLiteral: [\"Opening parentheses after literal \\\"\", /* literal */ \"\\\".\"],\r\n    valueParser_openingAfterReference: [\"Opening parentheses after reference to column \\\"\", /* column */ \"\\\".\"],\r\n    valueParser_openingAfterClosing: [\"Opening parentheses after closing parentheses.\"],\r\n    valueParser_closingAfterOperator: [\"Closing parentheses after binary operator \\\"\", /* binary */ \"\\\".\"],\r\n    valueParser_closingAfterOpening: [\"Closing parentheses after opening parentheses.\"],\r\n\r\n    stringUtils_missingClosingChar: [\"Missing '\", /* opening char */ \"' after opening '\", /* closing char */ \"'.\"],\r\n    stringUtils_charNotFound: [\"Expected \\\"\", /* char */ \"\\\" not found.\"],\r\n\r\n    renameNode_missingArrow: [\"Invalid rename, use \\\"OldName -> NewName\\\" format separated by commas.\"],\r\n    renameNode_invalidNewName: [\"Invalid rename to \\\"\", /* name */\r\n        \"\\\". New column name must contain letters, numbers and underscores only and start with a letter or an underscore.\"],\r\n    renameNode_keywordNewName: [\"Invalid rename to \\\"\", /* name */ \"\\\". New column name cannot be a keyword.\"],\r\n    renameNode_multipleRenameOfTheColumn: [\"Multiple rename of column \\\"\", /* name */ \"\\\".\"],\r\n\r\n    selectionNode_resultNotBoolean: [\"Result of the selection condition \", /* condition */ \" is not a boolean value, but \", /* type */ \".\"],\r\n    thetaJoinNode_resultNotBoolean: [\"Result of the theta join condition \", /* condition */ \" is not a boolean value, but \", /* type */ \".\"],\r\n\r\n    comparingOperator_differentInputTypes: [\"Inputs for \\\"\", /* operator */ \"\\\"  have different types \", /* type */ \" and \", /* type */ \".\"],\r\n    computingOperator_inputTypesNotNumbers: [\"Inputs for \\\"\", /* operator */ \"\\\" are not both numbers, they are \", /* type */ \" and \", /* type */ \".\"],\r\n    logicalOperator_leftInputNotBoolean: [\"Left input value for \\\"\", /* operator */ \"\\\" is not a boolean, but \", /* type */ \".\"],\r\n    logicalOperator_rightInputNotBoolean: [\"Right input value for \\\"\", /* operator */ \"\\\" is not a boolean, but \", /* type */ \".\"]\r\n};\r\n\r\nexport const EN: LanguageDef = {\r\n    abbr: \"EN\",\r\n\r\n    relationErrors: {\r\n        emptyColumn: \"Column name cannot be empty\",\r\n        duplicitColumn: \"Duplicit column name\",\r\n        keywordColumn: \"Column name cannot be a keyword\",\r\n        invalidColumn: \"Invalid characters in column name\",\r\n\r\n        unsupportedNull: \"Null values are not supported\",\r\n        invalidNumber: \"Given string is not a number\",\r\n        invalidBoolean: \"Given string is not a boolean\"\r\n    },\r\n\r\n    codeErrors: codeErrors,\r\n\r\n    semanticErrors: semanticErrors,\r\n    semanticError: \"Semantic error: \",\r\n\r\n    syntaxErrors: syntaxErrors,\r\n    syntaxError: \"Syntax error: \",\r\n\r\n    userMessages: {\r\n        loadedRelationsTotalNo: \"No relations loaded in the application at the moment.\",\r\n        loadedRelationsTotalSome: \" relations loaded at the moment: \",\r\n        loadRelationNew: \"Relation loaded to application.\",\r\n        loadAllRelationsNew: [/* number of loaded */ \" relations loaded to application, \", /* number of skipped */ \" skipped for errors.\"],\r\n        deleteLoadedRelations: \" relations deleted.\",\r\n\r\n        relationsExportOK: \"Relations saved.\",\r\n        relationsExportErr: \"Relations saving failed: \",\r\n        relationsImport: [/* number of loaded */ \" relations loaded, \", /* number of skipped */ \" files skipped.\"],\r\n\r\n        expressionsExportOK: \"Expressions saved.\",\r\n        expressionsExportErr: \"Expressions saving failed: \",\r\n        expressionsImport: [/* number of expressions */ \" expressions loaded from \", /* number of files */ \" files (\",\r\n        /* number of skipped expressions */ \" expressions skipped, \", /* number of skipped files */ \" files skipped).\"]\r\n    },\r\n\r\n    operations: {\r\n        selection: \"Selection\",\r\n        projection: \"Projection\",\r\n        rename: \"Rename\",\r\n        union: \"Union\",\r\n        intersection: \"Intersection\",\r\n        difference: \"Difference\",\r\n        naturalJoin: \"Natural join\",\r\n        cartesianProduct: \"Cartesian product\",\r\n        leftSemiJoin: \"Left semijoin\",\r\n        rightSemiJoin: \"Right semijoin\",\r\n        leftAntijoin: \"Left antijoin\",\r\n        rightAntijoin: \"Right antijoin\",\r\n        thetaJoin: \"Theta join\",\r\n        leftThetaSemiJoin: \"Left theta semijoin\",\r\n        rightThetaSemiJoin: \"Right theta semijoin\",\r\n        fullOuterJoin: \"Full outer join\",\r\n        leftOuterJoin: \"Left outer join\",\r\n        rightOuterJoin: \"Right outer join\",\r\n        division: \"Division\"\r\n    },\r\n\r\n    managementSection: {\r\n        batchButton: \"Batch\",\r\n        loadButton: \"Load\",\r\n        saveButton: \"Save\",\r\n        samplesButton: \"Samples\",\r\n        samplesMenuTitle: \"Prepared sample projects\",\r\n        settingsButton: \"Settings\",\r\n        settingsNullValues: \"Null values\",\r\n        settingsNullValuesAllowed: \"allowed\",\r\n        settingsNullValuesForbidden: \"forbidden\",\r\n        settingsCSVSeparator: \"CSV separator\",\r\n        settingsCSVSeparatorSemicolon: \"semicolon\",\r\n        settingsCSVSeparatorComma: \"comma\",\r\n        settingsTheme: \"Theme\",\r\n        settingsThemeLight: \"light\",\r\n        settingsThemeDark: \"dark\",\r\n        settingsLanguage: \"Language\",\r\n        aboutButton: \"About\"\r\n    },\r\n\r\n    relationSection: {\r\n        relationSectionHeader: \"Relations\",\r\n        loadAllButton: \"Load all\",\r\n        loadAllButtonTooltip: \"Loads all valid relation into the application\",\r\n        removeLoadedButton: \"Remove loaded\",\r\n        removeLoadedButtonTooltip: \"Removes all loaded relations\",\r\n        importButton: \"Import\",\r\n        importButtonTooltip: \"Adds new relations from files\",\r\n        exportButton: \"Export\",\r\n        exportButtonTooltip: \"Saves stored relations to files\",\r\n        loadButton: \"Load\",\r\n        loadButtonTooltip: \"Loads the relation into the application\",\r\n        renameButton: \"Rename\",\r\n        deleteButton: \"Delete\",\r\n        deleteButtonTooltip: \"Deletes the relation\",\r\n        revertButton: \"Revert\",\r\n        revertButtonTooltip: \"Reverts to last loaded state\"\r\n    },\r\n\r\n    expressionSection: {\r\n        expressionSectionHeader: \"Expressions\",\r\n\r\n        importButton: \"Import\",\r\n        importButtonTooltip: \"Adds new expressions from a file\",\r\n        exportButton: \"Export\",\r\n        exportButtonTooltip: \"Saves expressions to a file\",\r\n\r\n        evaluateButton: \"Evaluate\",\r\n        evaluateButtonTooltip: \"Evaluates selected RA expression\",\r\n        renameButton: \"Rename\",\r\n        deleteButton: \"Delete\",\r\n        deleteButtonTooltip: \"Deletes selected RA expression\",\r\n\r\n        expressionTextareaPlaceholder: \"Write RA expression here...\",\r\n\r\n        lineComment: \"Line comment\",\r\n        blockComment: \"Block comment\"\r\n    },\r\n\r\n    resultSection: {\r\n        resultSectionHeader: \"Result\",\r\n\r\n        exportEvalTreeButton: \"Export\",\r\n        exportEvalTreeButtonTooltip: \"Saves the evaluation tree as a picture\",\r\n        evalTreeTitle: \"Evaluation tree of\",\r\n\r\n        resultRelationTitle: \"Result relation\",\r\n        intermediateRelationTitle: \"Intermediate relation\",\r\n        addButton: \"Add\",\r\n        addButtonTooltip: \"Adds the given relation to stored ones\",\r\n        exportRelationButton: \"Export\",\r\n        exportRelationButtonTooltip: \"Saves the given relation to a file\",\r\n    }\r\n}","import {LanguageDef} from \"./language\";\r\nimport {EN} from \"./en\";\r\nimport {SyntaxErrorMessages} from \"../error/raSyntaxError\";\r\nimport {SemanticErrorMessages} from \"../error/raSemanticError\";\r\n\r\n/**\r\n * Czech messages for RASemanticErrors mapped by their error codes.\r\n */\r\nconst semanticErrors: SemanticErrorMessages = {\r\n    exprParser_relationNotDefined: [\"Relace \\\"\", \"\\\" není definována. Zkontrolujte definice relací.\"],\r\n\r\n    binaryNode_commonColumns: [\"Vstupní relace pro \", \" mají společné sloupce \\\"\", \"\\\".\"],\r\n    setOperationNode_notEqualColumns: [\"Vstupní relace \\\"\", \"\\\" a \\\"\", \"\\\" pro množinové \", \" nemají stejné schéma.\"],\r\n    divisionNode_rightColumnsNotSubset:\r\n        [\"Schéma pravé vstupní relace \\\"\", \"\\\" není podmnožinou schématu levé vstupní relace \\\"\", \"\\\".\"],\r\n    divisionNode_rightColumnsNotProperSubset:\r\n        [\"Schéma pravé vstupní relace \\\"\", \"\\\" není vlastní podmnožinou schématu levé vstupní relace \\\"\",\r\n        \". V levé relaci musí existovat sloupec, který neexistuje v pravé relaci.\"],\r\n    renameNode_absentOriginalColumn: [\"Nepovolené přejmenování, sloupec \\\"\", \"\\\" neexistuje ve vstupní relaci.\"],\r\n    renameNode_changeToDuplicit: [\"Nepovolené přejmenování, nový název sloupce \\\"\", \"\\\" je duplicitní ve změněné relaci.\"],\r\n    projectionNode_absentColumn: [\"Nepovolená projekce sloupce \\\"\", \"\\\". Tento sloupec neexistuje ve vstupní relaci.\"],\r\n\r\n    referenceValue_absentColumn: [\"Sloupec \\\"\", \"\\\" neexistuje ve schématu se sloupci \", \".\"]\r\n};\r\n\r\n/**\r\n * Czech messages for RASyntaxErrors mapped by their error codes.\r\n */\r\nconst syntaxErrors: SyntaxErrorMessages = {\r\n    exprParser_emptyStringGiven: [\"Výraz nelze parsovat z prázdného řetězce.\"],\r\n    exprParser_outerJoinWhenNullNotSupported: [\"Nalezeno \", \", přestože null hodnoty jsou zakázány.\"],\r\n    exprParser_unexpectedPart: [\"Nečekaná část \\\"\", \"\\\" v RA výrazu.\"],\r\n    exprParser_bothBranchesError: [\"Všechny kombinace způsobují chybu v \\\"\", \"\\\". Považováno za projekci:\\n\",\r\n        \"\\nPovažováno za theta spojení:\\n\", \"\"],\r\n    exprParser_invalidExpression: [\"Daný výraz není korektní výraz relační algebry.\"],\r\n    exprParser_invalidParentheses: [\"Chybné uzávorkování ve výrazu.\"],\r\n    exprParser_invalidStart: [\"RA výraz nemůže začínat na \", \".\"],\r\n    exprParser_invalidEnd: [\"RA výraz nemůže končit na \", \".\"],\r\n    exprParser_relationAfterRelation: [\"Relace \\\"\", \"\\\" po relaci \\\"\", \"\\\".\"],\r\n    exprParser_relationAfterUnary: [\"Relace \\\"\", \"\\\" po unárním operátoru \\\"\", \"\\\".\"],\r\n    exprParser_relationAfterClosing: [\"Relace \\\"\", \"\\\" po uzavírací závorce.\"],\r\n    exprParser_unaryAfterBinary: [\"Unární operátor \\\"\", \"\\\" po binárním operátoru \\\"\", \"\\\".\"],\r\n    exprParser_unaryAfterOpening: [\"Unární operátor \\\"\", \"\\\" po otevírací závorce.\"],\r\n    exprParser_binaryAfterBinary: [\"Binární operátor \\\"\", \"\\\" po binárním operátoru \\\"\", \"\\\".\"],\r\n    exprParser_binaryAfterOpening: [\"Binární operátor \\\"\", \"\\\" po otevírací závorce.\"],\r\n    exprParser_openingAfterRelation: [\"Otevírací závorka po relaci \\\"\", \"\\\".\"],\r\n    exprParser_openingAfterUnary: [\"Otevírací závorka po unárním operátoru \\\"\", \"\\\".\"],\r\n    exprParser_openingAfterClosing: [\"Otevírací závorka po uzavírací závorce.\"],\r\n    exprParser_closingAfterBinary: [\"Uzavírací závorka po binárním operátoru \\\"\", \"\\\".\"],\r\n    exprParser_closingAfterOpening: [\"Uzavírací závorka po otevírací závorce.\"],\r\n\r\n    valueParser_emptyInput: [\"Jako podmínka nemůže být prázdný řetězec.\"],\r\n    valueParser_unsupportedNull: [\"Nalezena null konstanta, přestože null hodnoty jsou zakázány.\"],\r\n    valueParser_unexpectedPart: [\"Nečekaná část \\\"\", \"\\\" ve výrazu.\"],\r\n    valueParser_missingOpeningParenthesis: [\"Chybějící otevírací závorka ve výrazu.\"],\r\n    valueParser_missingClosingParenthesis: [\"Chybějící uzavírací závorka ve výrazu.\"],\r\n    valueParser_invalidExpression: [\"Daný výraz není korektní.\"],\r\n    valueParser_invalidStart: [\"Výraz nemůže začínat na \\\"\", \"\\\".\"],\r\n    valueParser_invalidEnd: [\"Výraz nemůže končit na \\\"\", \"\\\".\"],\r\n    valueParser_literalAfterLiteral: [\"Konstanta \\\"\", \"\\\" po konstantě \\\"\", \"\\\".\"],\r\n    valueParser_literalAfterReference: [\"Konstanta \\\"\", \"\\\" po referenci sloupce \\\"\", \"\\\".\"],\r\n    valueParser_literalAfterClosing: [\"Konstanta \\\"\", \"\\\" po uzavírací závorce.\"],\r\n    valueParser_referenceAfterLiteral: [\"Reference sloupce \\\"\", \"\\\" po konstantě \\\"\", \"\\\".\"],\r\n    valueParser_referenceAfterReference: [\"Reference sloupce \\\"\", \"\\\" po referenci sloupce \\\"\", \"\\\".\"],\r\n    valueParser_referenceAfterClosing: [\"Reference sloupce \\\"\", \"\\\" po uzavírací závorce.\"],\r\n    valueParser_notAfterLiteral: [\"Logická negace \\\"\", \"\\\" po konstantě \\\"\", \"\\\".\"],\r\n    valueParser_notAfterReference: [\"Logická negace \\\"\", \"\\\" po referenci sloupce \\\"\", \"\\\".\"],\r\n    valueParser_notAfterClosing: [\"Logická negace \\\"\", \"\\\" po uzavírací závorce.\"],\r\n    valueParser_binaryAfterOperator: [\"Binární operátor \\\"\", \"\\\" po binárním operátoru \\\"\", \"\\\".\"],\r\n    valueParser_binaryAfterOpening: [\"Binární operátor \\\"\", \"\\\" po otevírací závroce.\"],\r\n    valueParser_openingAfterLiteral: [\"Otevírací závorka po konstantě \\\"\", \"\\\".\"],\r\n    valueParser_openingAfterReference: [\"Otevírací závorka po referenci sloupce \\\"\", \"\\\".\"],\r\n    valueParser_openingAfterClosing: [\"Otevírací závorka po uzavírací závorce.\"],\r\n    valueParser_closingAfterOperator: [\"Uzavírací závorka po binárním operátoru \\\"\", \"\\\".\"],\r\n    valueParser_closingAfterOpening: [\"Uzavírací závorka po otevírací závroce.\"],\r\n\r\n    stringUtils_missingClosingChar: [\"Chybějící '\", \"' po úvodní '\", \"'.\"],\r\n    stringUtils_charNotFound: [\"Očekávaný znak \\\"\", \"\\\" nenalezen.\"],\r\n\r\n    renameNode_missingArrow: [\"Chybné přejmenování, použijte formát \\\"StarýNázev -> NovýNázev\\\" oddělený čárkami.\"],\r\n    renameNode_invalidNewName: [\"Chybné přejmenování na \\\"\",\r\n        \"\\\". Nový název sloupce musí obsahovat pouze písmena, čísla a podtržítka a začínat písmenem nebo podtržítkem.\"],\r\n    renameNode_keywordNewName: [\"Chybné přejmenování na \\\"\", \"\\\". Nový název nemůže být klíčové slovo.\"],\r\n    renameNode_multipleRenameOfTheColumn: [\"Vícenásobné přejmenování sloupce \\\"\", \"\\\".\"],\r\n\r\n    selectionNode_resultNotBoolean: [\"Výsledek podmínky v selekci \", \" není boolean, ale \", \".\"],\r\n    thetaJoinNode_resultNotBoolean: [\"Výsledek podmínky v theta joinu \", \" není boolean, ale \", \".\"],\r\n\r\n    comparingOperator_differentInputTypes: [\"Vstupy pro \\\"\", \"\\\" nemají stejné typy, ale \", \" a \", \".\"],\r\n    computingOperator_inputTypesNotNumbers: [\"Vstupy pro \\\"\", \"\\\" nejsou čísla, ale \", \" a \", \".\"],\r\n    logicalOperator_leftInputNotBoolean: [\"Levý vstup logického operátoru \\\"\", \"\\\" není boolean, ale \", \".\"],\r\n    logicalOperator_rightInputNotBoolean: [\"Pravý vstup logického operátoru \\\"\", \"\\\" není boolean, ale \", \".\"],\r\n};\r\n\r\nexport const CS: LanguageDef = {\r\n    abbr: \"CS\",\r\n\r\n    relationErrors: {\r\n        emptyColumn: \"Název sloupce nemůže být prázdný\",\r\n        duplicitColumn: \"Duplicitní název sloupce\",\r\n        keywordColumn: \"Název sloupce nemůže být klíčové slovo\",\r\n        invalidColumn: \"Nepovolené znaky v názvu sloupce\",\r\n\r\n        unsupportedNull: \"Null hodonoty nejsou podporovány\",\r\n        invalidNumber: \"Daný řetězec není číslo\",\r\n        invalidBoolean: \"Daný řetězec není boolean\",\r\n    },\r\n\r\n    codeErrors: EN.codeErrors,\r\n\r\n    semanticErrors: semanticErrors,\r\n    semanticError: \"Sémantická chyba: \",\r\n\r\n    syntaxErrors: syntaxErrors,\r\n    syntaxError: \"Syntaktická chyba: \",\r\n\r\n    userMessages: {\r\n        loadedRelationsTotalNo: \"Nyní nejsou v aplikaci nahrané žádné relace.\",\r\n        loadedRelationsTotalSome: \" relací celkově nahráno v aplikaci: \",\r\n        loadRelationNew: \"Relace nahrána do aplikace.\",\r\n        loadAllRelationsNew: [/* number of loaded */ \" relací nahráno do aplikace, \", /* number of skipped */ \" přeskočeno kvůli chybám.\"],\r\n        deleteLoadedRelations: \" relací odebráno.\",\r\n\r\n        relationsExportOK: \"Relace staženy.\",\r\n        relationsExportErr: \"Stahování relací selhalo: \",\r\n        relationsImport: [\" relací nahráno, \", \" souborů přeskočeno.\"],\r\n\r\n        expressionsExportOK: \"Výrazy staženy do souboru.\",\r\n        expressionsExportErr: \"Stahování výrazů selhalo: \",\r\n        expressionsImport: [/* number of expressions */ \" výrazů nahráno z \", /* number of files */ \" souborů (\",\r\n            /* number of skipped expressions */ \" výrazů přeskočeno, \", /* number of skipped files */ \" souborů přeskočeno).\"]\r\n    },\r\n\r\n    operations: {\r\n        selection: \"Selekce\",\r\n        projection: \"Projekce\",\r\n        rename: \"Přejmenování\",\r\n        union: \"Sjednocení\",\r\n        intersection: \"Průnik\",\r\n        difference: \"Rozdíl\",\r\n        naturalJoin: \"Přirozené spojení\",\r\n        cartesianProduct: \"Kartézský součin\",\r\n        leftSemiJoin: \"Levé vnitřní spojení\",\r\n        rightSemiJoin: \"Pravé vnitřní spojení\",\r\n        leftAntijoin: \"Levý antijoin\",\r\n        rightAntijoin: \"Pravý antijoin\",\r\n        thetaJoin: \"Theta spojení\",\r\n        leftThetaSemiJoin: \"Levé theta spojení\",\r\n        rightThetaSemiJoin: \"Pravé theta spojení\",\r\n        fullOuterJoin: \"Plné vnější spojení\",\r\n        leftOuterJoin: \"Levé vnější spojení\",\r\n        rightOuterJoin: \"Pravé vnější spojení\",\r\n        division: \"Dělení\"\r\n    },\r\n\r\n    managementSection: {\r\n        batchButton: \"Batch\",\r\n        loadButton: \"Nahrát\",\r\n        saveButton: \"Uložit\",\r\n        samplesButton: \"Ukázky\",\r\n        samplesMenuTitle: \"Připravené vzorové projekty\",\r\n        settingsButton: \"Nastavení\",\r\n        settingsNullValues: \"Null hodnoty\",\r\n        settingsNullValuesAllowed: \"povoleny\",\r\n        settingsNullValuesForbidden: \"zakázány\",\r\n        settingsCSVSeparator: \"CSV oddělovač\",\r\n        settingsCSVSeparatorSemicolon: \"středník\",\r\n        settingsCSVSeparatorComma: \"čárka\",\r\n        settingsTheme: \"Režim\",\r\n        settingsThemeLight: \"světlý\",\r\n        settingsThemeDark: \"tmavý\",\r\n        settingsLanguage: \"Jazyk\",\r\n        aboutButton: \"O aplikaci\"\r\n    },\r\n\r\n    relationSection: {\r\n        relationSectionHeader: \"Relace\",\r\n        loadAllButton: \"Nahrát všechny\",\r\n        loadAllButtonTooltip: \"Nahraje všechny bezchybné relace do aplikace\",\r\n        removeLoadedButton: \"Odebrat nahrané\",\r\n        removeLoadedButtonTooltip: \"Odebere všechny nahrané relace z aplikace\",\r\n        importButton: \"Import\",\r\n        importButtonTooltip: \"Nahraje nové relace ze souborů\",\r\n        exportButton: \"Export\",\r\n        exportButtonTooltip: \"Stáhne editované relace do souborů\",\r\n        loadButton: \"Nahrát\",\r\n        loadButtonTooltip: \"Nahraje relaci do aplikace\",\r\n        renameButton: \"Přejmenovat\",\r\n        deleteButton: \"Odstranit\",\r\n        deleteButtonTooltip: \"Odstraní vybranou relaci\",\r\n        revertButton: \"Obnovit\",\r\n        revertButtonTooltip: \"Obnoví relaci do posledního nahraného stavu\"\r\n    },\r\n\r\n    expressionSection: {\r\n        expressionSectionHeader: \"Výrazy\",\r\n\r\n        importButton: \"Import\",\r\n        importButtonTooltip: \"Nahraje nové výrazy ze souboru\",\r\n        exportButton: \"Export\",\r\n        exportButtonTooltip: \"Stáhne výrazy do souboru\",\r\n\r\n        evaluateButton: \"Vyhodnotit\",\r\n        evaluateButtonTooltip: \"Vyhodnotí vybraný relační výraz\",\r\n        renameButton: \"Přejmenovat\",\r\n        deleteButton: \"Odstranit\",\r\n        deleteButtonTooltip: \"Odstraní vybraný relační výraz\",\r\n\r\n        expressionTextareaPlaceholder: \"Zde napište svůj relační výraz...\",\r\n\r\n        lineComment: \"Řádkový komentář\",\r\n        blockComment: \"Blokový komentář\"\r\n    },\r\n\r\n    resultSection: {\r\n        resultSectionHeader: \"Výsledek\",\r\n\r\n        exportEvalTreeButton: \"Export\",\r\n        exportEvalTreeButtonTooltip: \"Uloží evaluační strom jako obrázek\",\r\n        evalTreeTitle: \"Evaluační strom pro\",\r\n\r\n        resultRelationTitle: \"Výsledná relace\",\r\n        intermediateRelationTitle: \"Mezivýsledná relace\",\r\n        addButton: \"Přidat\",\r\n        addButtonTooltip: \"Přidá zvolenou relaci mezi editované\",\r\n        exportRelationButton: \"Export\",\r\n        exportRelationButtonTooltip: \"Stáhne zvolenou relaci do souboru\",\r\n    }\r\n}","import ErrorWithTextRange from \"./errorWithTextRange\";\r\nimport {language} from \"../language/language\";\r\nimport {StartEndPair} from \"../types/startEndPair\";\r\n\r\n/**\r\n * Codes for RASyntaxErrors.\r\n * The description is a string array - between its members are inserted error parameters (names of invalid relations: string[],\r\n * invalid input parts, etc.). See english language definition for expected structure of each error description.\r\n */\r\nexport interface SyntaxErrorMessages {\r\n    // expects 1 part\r\n    exprParser_emptyStringGiven: string[],\r\n    // expects 2 parts\r\n    exprParser_outerJoinWhenNullNotSupported: string[],\r\n    // expects 2 parts\r\n    exprParser_unexpectedPart: string[],\r\n    // expects 4 parts\r\n    exprParser_bothBranchesError: string[],\r\n    // expects 1 part\r\n    exprParser_invalidExpression: string[],\r\n    // expects 1 part\r\n    exprParser_invalidParentheses: string[],\r\n    // expects 2 parts\r\n    exprParser_invalidStart: string[],\r\n    // expects 2 parts\r\n    exprParser_invalidEnd: string[],\r\n    // expects 3 parts\r\n    exprParser_relationAfterRelation: string[],\r\n    // expects 3 parts\r\n    exprParser_relationAfterUnary: string[],\r\n    // expects 2 parts\r\n    exprParser_relationAfterClosing: string[],\r\n    // expects 3 parts\r\n    exprParser_unaryAfterBinary: string[],\r\n    // expects 2 parts\r\n    exprParser_unaryAfterOpening: string[],\r\n    // expects 3 parts\r\n    exprParser_binaryAfterBinary: string[],\r\n    // expects 2 parts\r\n    exprParser_binaryAfterOpening: string[],\r\n    // expects 2 parts\r\n    exprParser_openingAfterRelation: string[],\r\n    // expects 2 parts\r\n    exprParser_openingAfterUnary: string[],\r\n    // expects 1 part\r\n    exprParser_openingAfterClosing: string[],\r\n    // expects 2 parts\r\n    exprParser_closingAfterBinary: string[],\r\n    // expects 1 part\r\n    exprParser_closingAfterOpening: string[],\r\n\r\n    // expects 1 part\r\n    valueParser_emptyInput: string[],\r\n    // expects 1 part\r\n    valueParser_unsupportedNull: string[],\r\n    // expects 2 parts\r\n    valueParser_unexpectedPart: string[],\r\n    // expects 1 part\r\n    valueParser_missingOpeningParenthesis: string[],\r\n    // expects 1 part\r\n    valueParser_missingClosingParenthesis: string[],\r\n    // expects 1 part\r\n    valueParser_invalidExpression: string[],\r\n    // expects 2 parts\r\n    valueParser_invalidStart: string[],\r\n    // expects 2 parts\r\n    valueParser_invalidEnd: string[],\r\n    // expects 3 parts\r\n    valueParser_literalAfterLiteral: string[],\r\n    // expects 3 parts\r\n    valueParser_literalAfterReference: string[],\r\n    // expects 2 parts\r\n    valueParser_literalAfterClosing: string[],\r\n    // expects 3 parts\r\n    valueParser_referenceAfterLiteral: string[],\r\n    // expects 3 parts\r\n    valueParser_referenceAfterReference: string[],\r\n    // expects 2 parts\r\n    valueParser_referenceAfterClosing: string[],\r\n    // expects 3 parts\r\n    valueParser_notAfterLiteral: string[],\r\n    // expects 3 parts\r\n    valueParser_notAfterReference: string[],\r\n    // expects 2 parts\r\n    valueParser_notAfterClosing: string[],\r\n    // expects 3 parts\r\n    valueParser_binaryAfterOperator: string[],\r\n    // expects 2 parts\r\n    valueParser_binaryAfterOpening: string[],\r\n    // expects 2 parts\r\n    valueParser_openingAfterLiteral: string[],\r\n    // expects 2 parts\r\n    valueParser_openingAfterReference: string[],\r\n    // expects 1 part\r\n    valueParser_openingAfterClosing: string[],\r\n    // expects 2 parts\r\n    valueParser_closingAfterOperator: string[],\r\n    // expects 1 part\r\n    valueParser_closingAfterOpening: string[],\r\n\r\n    // expects 3 parts\r\n    stringUtils_missingClosingChar: string[],\r\n    // expects 2 parts\r\n    stringUtils_charNotFound: string[],\r\n\r\n    // expects 1 part\r\n    renameNode_missingArrow: string[],\r\n    // expects 2 parts\r\n    renameNode_invalidNewName: string[],\r\n    // expects 2 parts\r\n    renameNode_keywordNewName: string[],\r\n    // expects 2 parts\r\n    renameNode_multipleRenameOfTheColumn: string[],\r\n\r\n    // expects 3 parts\r\n    selectionNode_resultNotBoolean: string[],\r\n    // expects 3 parts\r\n    thetaJoinNode_resultNotBoolean: string[],\r\n\r\n    // expects 4 parts\r\n    comparingOperator_differentInputTypes: string[],\r\n    // expects 4 parts\r\n    computingOperator_inputTypesNotNumbers: string[],\r\n    // expects 3 parts\r\n    logicalOperator_leftInputNotBoolean: string[],\r\n    // expects 3 parts\r\n    logicalOperator_rightInputNotBoolean: string[]\r\n}\r\n\r\n/**\r\n * Syntax error in an expression structure.\r\n */\r\nexport default class RASyntaxError extends ErrorWithTextRange {\r\n    /**\r\n     * @param msg Adds \"Syntax error: \" before given message\r\n     * @param range optional text range of the error\r\n     */\r\n    constructor(msg: string, range: StartEndPair | undefined) {\r\n        super(language().syntaxError + msg, range);\r\n        if (Error.captureStackTrace) {\r\n            Error.captureStackTrace(this, RASyntaxError);\r\n        }\r\n        this.name = 'RASyntaxError';\r\n    }\r\n}","import ErrorWithTextRange from \"./errorWithTextRange\";\r\nimport {language} from \"../language/language\";\r\nimport {StartEndPair} from \"../types/startEndPair\";\r\n\r\n/**\r\n * Codes for RASemanticErrors.\r\n * The description is a string array - between its members are inserted error parameters (names of invalid relations,\r\n * invalid input parts, etc.). See english language definition for expected structure of each error description.\r\n */\r\nexport interface SemanticErrorMessages {\r\n    // expects 2 parts\r\n    exprParser_relationNotDefined: string[],\r\n\r\n    // expects 3 parts\r\n    binaryNode_commonColumns: string[],\r\n    // expects 4 parts\r\n    setOperationNode_notEqualColumns: string[],\r\n    // expects 3 parts\r\n    divisionNode_rightColumnsNotSubset: string[],\r\n    // expects 3 parts\r\n    divisionNode_rightColumnsNotProperSubset: string[],\r\n    // expects 2 parts\r\n    renameNode_absentOriginalColumn: string[],\r\n    // expects 2 parts\r\n    renameNode_changeToDuplicit: string[],\r\n    // expects 2 parts\r\n    projectionNode_absentColumn: string[],\r\n\r\n    // expects 3 parts\r\n    referenceValue_absentColumn: string[]\r\n}\r\n\r\n/**\r\n * Semantic error in an expression structure.\r\n */\r\nexport default class RASemanticError extends ErrorWithTextRange {\r\n    /**\r\n     * @param msg Adds \"Semantic error: \" before given message\r\n     * @param range optional text range of the error\r\n     */\r\n    constructor(msg: string, range: StartEndPair | undefined) {\r\n        super(language().semanticError + msg, range);\r\n        if (Error.captureStackTrace) {\r\n            Error.captureStackTrace(this, RASemanticError);\r\n        }\r\n        this.name = 'RASemanticError';\r\n    }\r\n}","/**\r\n * Computes width (average on sample of characters) and its height of the given font with given size in pixels.\r\n *\r\n * @param fontFamily\r\n * @param fontSize\r\n */\r\nexport function computeFontSizeInPx(fontFamily: string, fontSize: string): {fontWidth: number, fontHeight: number} {\r\n    const text: string = \"0123456789qwertyuiopasdfghjkllzxcvbnmQWERTYUIOOPASDFGHJKLLZXCVBNM!@#$%^&*()_+[];',./\";\r\n    const div = document.createElement(\"div\");\r\n    div.setAttribute('style', `font-family: ${fontFamily}; font-size: ${fontSize}; position: absolute; white-space: nowrap;`);\r\n    div.innerText = text;\r\n    document.documentElement.appendChild(div);\r\n    const divWidth: number = div.clientWidth;\r\n    const divHeight: number = div.clientHeight;\r\n    div.remove();\r\n    return { fontWidth: divWidth / text.length, fontHeight: divHeight };\r\n}","/**\r\n * Returns start index of the word before given index in the given string.\r\n *\r\n * @param str\r\n * @param index\r\n */\r\nexport function getStartOfWordBeforeIndex(str: string, index: number): number {\r\n    const prefixText: string = str.slice(0, index);\r\n    let i: number = prefixText.length - 1;\r\n    while (true) {\r\n        // if non-name-character is reached\r\n        if (!prefixText.charAt(i).match(/\\w/)) {\r\n            ++i;\r\n            break;\r\n        }\r\n        if (i === 0) {\r\n            break;\r\n        }\r\n        --i;\r\n    }\r\n    return i;\r\n}\r\n\r\n/**\r\n * Returns sorted given array of whispers with respect to given last word before cursor.\r\n * Matched word parts in the whispers are highlighted by CSS span. Not-matched words are made grey.\r\n */\r\nexport function sortWhispers(whispers: string[], wordBeforeCursor: string): string[] {\r\n    // values for sorting whispers\r\n    const startsWithWord: number = 2;\r\n    const containsWord: number = 1;\r\n    // creates help array with whisper likelihoods and highlighted matched parts\r\n    const helpArray: {whisper: string, likelihood: number}[] = whispers.map(whisper => {\r\n        let likelihood = 0;\r\n        const wordStart = whisper.toLowerCase().indexOf(wordBeforeCursor.toLowerCase());\r\n        if (wordStart > -1) {\r\n            likelihood += wordStart === 0 ? startsWithWord : containsWord;\r\n            const wordEnd = wordStart + wordBeforeCursor.length;\r\n            whisper = whisper.slice(0, wordStart) + \"<span class='whisper-matched-word'>\" +\r\n                whisper.slice(wordStart, wordEnd) + \"</span>\" + whisper.slice(wordEnd);\r\n        }\r\n        if (likelihood === 0) {\r\n            whisper = \"<span class='whisper-rejected-word'>\" + whisper + \"</span>\"\r\n        }\r\n        return {whisper, likelihood};\r\n    });\r\n    if (wordBeforeCursor !== \"\") {\r\n        helpArray.sort((x, y) => y.likelihood - x.likelihood);\r\n    }\r\n    return helpArray.map(help => help.whisper);\r\n}","import React from \"react\";\r\nimport './css/xTextArea.css';\r\nimport {mod} from \"../utils/math\";\r\nimport {computeFontSizeInPx} from \"../utils/fontUtils\";\r\nimport {getStartOfWordBeforeIndex} from \"../utils/whisperUtils\";\r\nimport {StartEndPair} from \"../types/startEndPair\";\r\n\r\ninterface XTextAreaProps {\r\n    // id of the component\r\n    id: string;\r\n    // current text content of the textarea\r\n    text: string;\r\n    // text to be shown as textarea placeholder\r\n    placeholder: string;\r\n    // error messages and ranges to be highlighted in text area\r\n    errors: {start: number, end: number, msg: string}[];\r\n    // pairs of parentheses\r\n    parentheses: StartEndPair[];\r\n    // strings whispered to the user to be added at the current position\r\n    whispers: string[];\r\n    // handler of text change\r\n    onChange: (text: string, cursorIndex: number) => void;\r\n    // handler of input with Ctrl key\r\n    onCtrlInput: (ev: KeyboardEvent) => void;\r\n    // true if dark theme should be applied\r\n    darkTheme: boolean;\r\n}\r\n\r\ninterface XTextAreaState {}\r\n\r\n/**\r\n * HTMLTextAreaElement extended for painting number lines, inserting strings given from parent and whispering.\r\n */\r\ntype ExtendedHTMLTextArea = HTMLTextAreaElement & {\r\n    /**\r\n     * (Re)paints line numbers next to textarea.\r\n     *\r\n     * @param darkTheme style to be applied to numbers\r\n     */\r\n    paintLineNumbers: (darkTheme: boolean) => void,\r\n    // reference to canvas element used to paint line numbers\r\n    canvasLines: HTMLCanvasElement,\r\n    // true when the mouse button is clicked down\r\n    mouseIsDown: boolean,\r\n\r\n    /**\r\n     * Updates textarea content to the given value. Updates number of lines.\r\n     */\r\n    update: (value: string, darkTheme: boolean) => void,\r\n    // number of lines in the textarea\r\n    linesCount: number,\r\n\r\n    /**\r\n     * Whispers given array of strings to the user at the current cursor position.\r\n     *\r\n     * @param toWhisper\r\n     */\r\n    createWhisper: (whispers: string[]) => void,\r\n    /**\r\n     * Moves the WhisperDiv to be located next to the current cursor position.\r\n     * The WhisperDiv is moved only if the whisperDiv.isShown is true.\r\n     */\r\n    moveWhisper: () => void,\r\n    /**\r\n     * Hides the WhisperDiv (whisperDiv.isShown is set to false).\r\n     */\r\n    hideWhisper: () => void,\r\n    /**\r\n     * Inserts current selected whisper.\r\n     *\r\n     * @param onChange callback to the parent after text change\r\n     */\r\n    insertCurrentSelectedWhisper: () => void,\r\n    // true when the whisper should not be shown automatically (e.g., after pressing Enter)\r\n    notAutoShowWhisper: boolean,\r\n    // reference to whisper div\r\n    whisperDiv: WhisperDiv,\r\n\r\n    /**\r\n     * Creates error div elements for given ranges.\r\n     */\r\n    updateErrors: (ranges: {start: number, end: number, msg: string}[]) => void,\r\n    /**\r\n     * Moves error div elements to current position.\r\n     */\r\n    moveErrors: () => void,\r\n    // div elements for highlighting errors\r\n    errorDivs: ErrorDiv[],\r\n\r\n    /**\r\n     * Creates parentheses div elements for parentheses next to the cursor.\r\n     */\r\n    updateParentheses: () => void,\r\n    /**\r\n     * Moves parentheses div elements to current position.\r\n     */\r\n    moveParentheses: () => void,\r\n    // positions of parentheses pairs in text\r\n    parentheses: StartEndPair[],\r\n    // div elements for highlighting parentheses\r\n    parenthesesDivs: ParenthesesDiv[],\r\n\r\n    /**\r\n     * Insert given pair of symbols at the cursor position. If a part of text is selected, it inserts the first symbol\r\n     * before it and the second symbol after it.\r\n     */\r\n    insertPairSymbol: (first: string, second: string) => void,\r\n    /**\r\n     * Deletes characters before and after the cursor if the adjacent characters are pair symbols: (), [], <>, \"\".\r\n     * If the pair was deleted, returns true, otherwise returns false.\r\n     */\r\n    checkPairSymbolDelete: () => boolean\r\n};\r\n\r\n/**\r\n * HTMLDivElement extended by functions for easy whispering.\r\n */\r\ntype WhisperDiv = HTMLDivElement & {\r\n    // true when the whisper should be shown\r\n    isShown: boolean,\r\n    // index of the selected whisper\r\n    selectedIndex: number,\r\n    /**\r\n     * Updates selected whisper by given difference. Removes highlights from previous highlighted whisper and\r\n     * highlights the new selected. The new index is modulo actual whisper count. The function does nothing, when\r\n     * there no whispers at the moment.\r\n     *\r\n     * @param indexDiff\r\n     */\r\n    changeSelected: (indexDiff: number) => void,\r\n    /**\r\n     * Updates selected whisper to given index. Removes highlights from previous highlighted whisper and\r\n     * highlights the new selected. The new index is modulo actual whisper count. The function does nothing, when\r\n     * there no whispers at the moment.\r\n     *\r\n     * @param newIndex\r\n     */\r\n    setSelected: (newIndex: number) => void,\r\n    /**\r\n     * Returns current selected whisper or undefined, when no whisper is selected.\r\n     */\r\n    getSelectedWhisper: () => string | undefined\r\n};\r\n\r\ntype ErrorDiv = HTMLDivElement & {\r\n    startLine: number,\r\n    startColumn: number,\r\n    rangeLength: number,\r\n    messageSpan: HTMLSpanElement\r\n}\r\n\r\ntype ParenthesesDiv = HTMLDivElement & {\r\n    startLine: number,\r\n    startColumn: number\r\n}\r\n\r\n// @ts-ignore\r\nconst cssConstants: CSSStyleDeclaration = getComputedStyle(document.querySelector(':root'));\r\n\r\nconst fontSize: string = cssConstants.getPropertyValue('--x-textarea-font-size');\r\nconst fontFamily: string = cssConstants.getPropertyValue('--x-textarea-font-family');\r\nconst {fontWidth} = computeFontSizeInPx(fontFamily, fontSize);\r\nconst lineHeight: number = Number(cssConstants.getPropertyValue('--x-textarea-line-height'));\r\nconst numsBackgroundLight: string = cssConstants.getPropertyValue('--light-color-b');\r\nconst numsBackgroundDark: string = cssConstants.getPropertyValue('--dark-color-b');\r\nconst numsColorLight: string = cssConstants.getPropertyValue('--text-color-light');\r\nconst numsColorDark: string = cssConstants.getPropertyValue('--text-color-dark');\r\nconst canvasWidth: number = 24;\r\n\r\n/**\r\n * TextArea extended by line numbers and text highlighting. The component is maintained by JavaScript HTML functions,\r\n * not by React.\r\n */\r\nexport class XTextArea extends React.Component<XTextAreaProps, XTextAreaState> {\r\n    // @ts-ignore - always set before usage in componentDidMount\r\n    private textarea: ExtendedHTMLTextArea;\r\n\r\n    /**\r\n     * Returns current text area selection start and end.\r\n     */\r\n    public getSelection(): StartEndPair {\r\n        return {start: this.textarea.selectionStart, end: this.textarea.selectionEnd};\r\n    }\r\n\r\n    /**\r\n     * Sets text area selection start and end. If end is not given, start value is used as end value as well.\r\n     *\r\n     * @param start\r\n     * @param end\r\n     */\r\n    public setSelection(start: number, end?: number): void {\r\n        this.textarea.setSelectionRange(start, end ? end : start);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the textarea has focus.\r\n     */\r\n    public isFocused(): boolean {\r\n        return document.activeElement !== null && document.activeElement.id === this.props.id + '-ta';\r\n    }\r\n\r\n    /**\r\n     * The text area gains focus in the window.\r\n     */\r\n    public focus(): void {\r\n        this.textarea.focus();\r\n    }\r\n\r\n    /**\r\n     * The component is build by JavaScript HTML functions after mount of the empty div in render function.\r\n     */\r\n    componentDidMount() {\r\n        const props: Readonly<XTextAreaProps> = this.props;\r\n        // @ts-ignore - gets parent div\r\n        const div: HTMLDivElement = document.getElementById(props.id);\r\n\r\n        // LAYOUT (table with 1 row and 2 columns)\r\n        const table = document.createElement('table');\r\n        table.setAttribute('cellspacing','0');\r\n        table.setAttribute('cellpadding','0');\r\n        table.classList.add('x-textarea-table');\r\n        const tr = document.createElement('tr');\r\n        const td1 = document.createElement('td');\r\n        td1.setAttribute('id', props.id + '-td1');\r\n        td1.classList.add('x-textarea-table-td1');\r\n        const td2 = document.createElement('td');\r\n        td2.classList.add('x-textarea-table-td2');\r\n        tr.appendChild(td1);\r\n        tr.appendChild(td2);\r\n        table.appendChild(tr);\r\n\r\n        // TEXTAREA\r\n        // @ts-ignore - extended later in componentDidMount\r\n        const ta: ExtendedHTMLTextArea = document.createElement('textarea');\r\n        ta.setAttribute('id', props.id + '-ta');\r\n        ta.setAttribute('spellcheck', 'false');\r\n        ta.mouseIsDown = false;\r\n        ta.setAttribute('placeholder', this.props.placeholder);\r\n        ta.classList.add('x-textarea', 'scrollbar-container');\r\n        ta.value = props.text;\r\n\r\n        // TEXTAREA NUMBERS (Canvas)\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = canvasWidth + 4;    // must not set width & height in css !!!\r\n        canvas.classList.add('x-textarea-canvas');\r\n        ta.canvasLines = canvas;\r\n        td1.appendChild(canvas);\r\n        td2.appendChild(ta);\r\n        div.appendChild(table);\r\n\r\n        // TEXTAREA WHISPER DIV\r\n        // @ts-ignore - extended later in componentDidMount\r\n        const whisperDiv: WhisperDiv = document.createElement('div');\r\n        whisperDiv.classList.add('whisper-div');\r\n        whisperDiv.isShown = false;\r\n        whisperDiv.selectedIndex = -1;\r\n        whisperDiv.changeSelected = function (indexDiff: number) {\r\n            this.setSelected(this.selectedIndex + indexDiff);\r\n        }\r\n        whisperDiv.setSelected = function (newIndex: number) {\r\n            if (this.childElementCount > 0) {\r\n                // removes selected highlight from previous selected whisper (if it is valid)\r\n                if (this.selectedIndex > -1 && this.selectedIndex < this.childElementCount) {\r\n                    this.children[this.selectedIndex].classList.remove(\"selected-whisper\");\r\n                }\r\n                // updates the index modulo child count\r\n                this.selectedIndex = mod(newIndex, this.childElementCount);\r\n                // adds selected highlight\r\n                this.children[this.selectedIndex].classList.add(\"selected-whisper\");\r\n            }\r\n        }\r\n        whisperDiv.getSelectedWhisper = function (): string | undefined {\r\n            if (this.selectedIndex > -1 && this.childElementCount > 0) {\r\n                // @ts-ignore\r\n                return this.children[this.selectedIndex].innerText;\r\n            }\r\n            return undefined;\r\n        }\r\n        ta.whisperDiv = whisperDiv;\r\n        td2.appendChild(whisperDiv);\r\n\r\n        // Line numbers rendering inspired by: https://www.w3schools.com/code/tryit.asp?filename=G68VMFWS12UH,\r\n        // Nikola Bozovic, nigerija@gmail.com\r\n        ta.paintLineNumbers = function(darkTheme: boolean): void {\r\n            try {\r\n                const canvas = this.canvasLines;\r\n                if (canvas.height !== this.clientHeight) {\r\n                    canvas.height = this.clientHeight; // on resize\r\n                }\r\n                // @ts-ignore\r\n                const ctx: CanvasRenderingContext2D = canvas.getContext(\"2d\");\r\n                ctx.fillStyle = darkTheme ? numsBackgroundDark : numsBackgroundLight;\r\n                ctx.fillRect(0, 0, canvasWidth + 2, this.scrollHeight + 1);\r\n                ctx.fillStyle = darkTheme ? numsColorDark : numsColorLight;\r\n                ctx.font = fontSize + \" \" + fontFamily;\r\n                for (let i = 0; i < this.linesCount; i++) {\r\n                    const text = \"\" + (i + 1);  // line number\r\n                    ctx.fillText(text,canvasWidth - (text.length * 8), 19 + (i * lineHeight));\r\n                }\r\n            }\r\n            catch(e) {\r\n                console.log('XTextArea paintLineNumbers error: ' + e);\r\n            }\r\n        };\r\n\r\n        ta.update = function (value: string, darkTheme: boolean) {\r\n            this.value = value;\r\n            // computes lines count\r\n            let lines: number = 1;\r\n            for (let i = 0; i < value.length; ++i) {\r\n                if (value.charAt(i) === \"\\n\") {\r\n                    ++lines;\r\n                }\r\n            }\r\n            this.linesCount = lines;\r\n            // set height to fit all lines\r\n            this.style.height = (lines * lineHeight + 8) + \"px\";\r\n            // if the horizontal scrollbar is visible, fits it into the height\r\n            if (this.scrollHeight > this.clientHeight) {\r\n                this.style.height = (this.scrollHeight + lineHeight + 10) + \"px\";\r\n            }\r\n            this.paintLineNumbers(darkTheme);\r\n            this.updateParentheses();\r\n        }\r\n\r\n        ta.createWhisper = function (whispers: string[]): void {\r\n            if (whispers.length === 0) {\r\n                this.hideWhisper();\r\n            }\r\n            else {\r\n                this.whisperDiv.innerHTML = \"\";\r\n                whispers.forEach((whisper, i) => {\r\n                    const div = document.createElement(\"div\");\r\n                    div.innerHTML = whisper;\r\n                    div.onclick = event => {\r\n                        this.focus();\r\n                        this.whisperDiv.setSelected(i);\r\n                        event.stopPropagation();\r\n                    };\r\n                    div.ondblclick = event => {\r\n                        this.focus();\r\n                        this.insertCurrentSelectedWhisper();\r\n                        this.notAutoShowWhisper = true;\r\n                        event.stopPropagation();\r\n                    };\r\n                    this.whisperDiv.appendChild(div);\r\n                });\r\n                // selects the first whisper after change\r\n                this.whisperDiv.setSelected(0);\r\n                // needs to be set to true before moveWhisper call\r\n                this.whisperDiv.isShown = true;\r\n                // sets the div position\r\n                this.moveWhisper();\r\n            }\r\n        }\r\n\r\n        ta.moveWhisper = function () {\r\n            // updates only if the whisper is shown\r\n            if (this.whisperDiv.isShown) {\r\n                // finds cursor position in the whole string\r\n                const cursorLineAndColumn = getPositionLineAndColumn(this.value, this.selectionEnd);\r\n                // computes position of the bottom end of the cursor relative to the text\r\n                const cursorDistanceFromTATotalTop: number = (cursorLineAndColumn.line + 1) * lineHeight;\r\n                const cursorDistanceFromTATotalLeft: number = cursorLineAndColumn.column * fontWidth;\r\n                const yPos: number = cursorDistanceFromTATotalTop - this.scrollTop;\r\n                const xPos: number = cursorDistanceFromTATotalLeft - this.scrollLeft + 4;\r\n                // shows the div at computed position if the cursor is visible\r\n                if (0 <= yPos && yPos < this.clientHeight && 0 <= xPos && xPos < this.clientWidth) {\r\n                    // if the div is in the upper part of the screen, shows it under the cursor\r\n                    if (this.getBoundingClientRect().y + yPos <= window.innerHeight / 2) {\r\n                        this.whisperDiv.setAttribute('style', `display: block; top: ${yPos + 4}px; left: ${xPos}px;`);\r\n                    }\r\n                    // if the div is in the lower part of the screen, shows it above the cursor\r\n                    else {\r\n                        this.whisperDiv.setAttribute('style',\r\n                            `display: block; bottom: ${this.getBoundingClientRect().height - yPos + lineHeight}px; left: ${xPos}px;`);\r\n                    }\r\n                }\r\n                // hides the div if the cursor is not visible (but DOES NOT SET whisperDiv.isShown to false to re-appear it again)\r\n                else {\r\n                    this.whisperDiv.setAttribute('style', `display: none;`);\r\n                }\r\n            }\r\n        }\r\n\r\n        ta.hideWhisper = function () {\r\n            //whisperDiv.innerHTML = '';\r\n            this.whisperDiv.setAttribute('style', 'display: none;');\r\n            this.whisperDiv.isShown = false;\r\n        }\r\n\r\n        ta.insertCurrentSelectedWhisper = function () {\r\n            const currWhisper: string | undefined = this.whisperDiv.getSelectedWhisper();\r\n            if (currWhisper !== undefined) {\r\n                const i: number = getStartOfWordBeforeIndex(this.value, this.selectionEnd);\r\n                const beforeAdd: string = this.value.slice(0, i);\r\n                const afterAdd: string = this.value.slice(this.selectionEnd);\r\n                const newCursorPos: number = i + currWhisper.length;\r\n                props.onChange(beforeAdd + currWhisper + afterAdd, newCursorPos);\r\n                this.setSelectionRange(newCursorPos, newCursorPos);\r\n                this.hideWhisper();\r\n            }\r\n        }\r\n\r\n        ta.notAutoShowWhisper = false;\r\n\r\n        // TEXTAREA ERROR RANGE HIGHLIGHTS\r\n        ta.errorDivs = [];\r\n\r\n        ta.moveErrors = function () {\r\n            this.errorDivs.forEach(highlight => {\r\n                // computes position of the highlight relative to the text\r\n                const yPos: number = (highlight.startLine + 1) * lineHeight + 1 - this.scrollTop;\r\n                // shows the div at computed position if the line is visible\r\n                if (1 < yPos && yPos < this.clientHeight) {\r\n                    let width: number = highlight.rangeLength * fontWidth;\r\n                    let xPos: number = highlight.startColumn * fontWidth + 7 - this.scrollLeft;\r\n                    // if the whole highlight is out of the width, does not display it\r\n                    if (xPos > this.clientWidth || xPos + width < 3) {\r\n                        highlight.setAttribute('style', `display: none;`);\r\n                    }\r\n                    else {\r\n                        // updates position of highlights starting before first visible column\r\n                        if (xPos < 3) {\r\n                            width += xPos - 3;\r\n                            xPos = 3;\r\n                        }\r\n                        // updates width of highlights ending after last visible column\r\n                        if (xPos + width > this.clientWidth) {\r\n                            width = this.clientWidth - xPos;\r\n                        }\r\n                        // updates the position of message span when the highlight is on the right side of the screen\r\n                        if (this.getBoundingClientRect().x + xPos >= window.innerWidth / 2) {\r\n                            highlight.messageSpan.setAttribute('style', `right: 50%; left: unset;`);\r\n                        }\r\n                        highlight.setAttribute('style', `display: block; top: ${yPos}px; left: ${xPos}px; width: ${width}px`);\r\n                    }\r\n                }\r\n                // hides the div if the line is not visible\r\n                else {\r\n                    highlight.setAttribute('style', `display: none;`);\r\n                }\r\n            });\r\n        }\r\n\r\n        ta.updateErrors = function (ranges: {start: number, end: number, msg: string}[]) {\r\n            // removes old highlight divs\r\n            this.errorDivs.forEach(highlight => {\r\n                highlight.remove();\r\n            });\r\n            this.errorDivs = [];\r\n\r\n            // appends the highlight div as textarea child and adds it to highlights array\r\n            const pushHighlight = (highlight: ErrorDiv) => {\r\n                // @ts-ignore - adds it to the parent element\r\n                this.parentElement.appendChild(highlight);\r\n                this.errorDivs.push(highlight);\r\n            }\r\n\r\n            ranges.forEach(range => {\r\n                // finds highlight start and end lines and columns\r\n                const start = getPositionLineAndColumn(this.value, range.start);\r\n                const end = getPositionLineAndColumn(this.value, range.end);\r\n                // error on one line only\r\n                if (start.line === end.line) {\r\n                    pushHighlight(createHighlightDiv(start.line, start.column, end.column - start.column,\r\n                        range.msg, this));\r\n                }\r\n                // error on multiple lines\r\n                else {\r\n                    // pushes first line part - from error start to line end\r\n                    pushHighlight(createHighlightDiv(start.line, start.column,\r\n                        getLineLength(this.value, start.line) - start.column, range.msg, this));\r\n                    // pushes middle lines\r\n                    for (let line = start.line + 1; line < end.line; ++line) {\r\n                        pushHighlight(createHighlightDiv(line, 0, getLineLength(this.value, line),\r\n                            range.msg, this));\r\n                    }\r\n                    // pushes last line part - from line start to error end\r\n                    pushHighlight(createHighlightDiv(end.line, 0, end.column, range.msg, this));\r\n                }\r\n            });\r\n\r\n            // moves highlight to current positions\r\n            this.moveErrors();\r\n        }\r\n\r\n        ta.parentheses = [];\r\n        ta.parenthesesDivs = [];\r\n\r\n        ta.updateParentheses = function () {\r\n            ta.parenthesesDivs.forEach(div => {\r\n                div.remove();\r\n            });\r\n            ta.parenthesesDivs = [];\r\n            if (ta.selectionStart === ta.selectionEnd) {\r\n                const c1 = ta.selectionStart;\r\n                const c2 = c1 - 1;\r\n                const around = ta.parentheses.filter(p => p.start === c1 || p.start === c2 || p.end === c1 || p.end === c2);\r\n                // true when the first pair is processed\r\n                let first = true;\r\n                around.forEach(parentheses => {\r\n                    // finds highlight start and end lines and columns\r\n                    const start = getPositionLineAndColumn(ta.value, parentheses.start);\r\n                    const end = getPositionLineAndColumn(ta.value, parentheses.end);\r\n                    const div1 = createParenthesesDiv(start.line, start.column, ta);\r\n                    const div2 = createParenthesesDiv(end.line, end.column, ta);\r\n                    // @ts-ignore\r\n                    ta.parentElement.appendChild(div1);\r\n                    // @ts-ignore\r\n                    ta.parentElement.appendChild(div2);\r\n                    ta.parenthesesDivs.push(div1);\r\n                    ta.parenthesesDivs.push(div2);\r\n                    // changes color to distinguish two pairs\r\n                    div1.classList.toggle('first-pair', first);\r\n                    div1.classList.toggle('second-pair', !first);\r\n                    div2.classList.toggle('first-pair', first);\r\n                    div2.classList.toggle('second-pair', !first);\r\n                    first = false;\r\n                });\r\n                ta.moveParentheses();\r\n            }\r\n        }\r\n\r\n        ta.moveParentheses = function () {\r\n            ta.parenthesesDivs.forEach(div => {\r\n                // computes position of the highlight relative to the text\r\n                const yPos: number = (div.startLine + 1) * lineHeight + 1 - this.scrollTop;\r\n                // shows the div at computed position if the line is visible\r\n                if (1 < yPos && yPos < this.clientHeight) {\r\n                    let width: number = fontWidth;\r\n                    let xPos: number = div.startColumn * fontWidth + 7 - this.scrollLeft;\r\n                    // if the whole highlight is out of the width, does not display it\r\n                    if (xPos > this.clientWidth || xPos + width < 3) {\r\n                        div.setAttribute('style', `display: none;`);\r\n                    }\r\n                    else {\r\n                        // updates position of highlights starting before first visible column\r\n                        if (xPos < 3) {\r\n                            width += xPos - 3;\r\n                            xPos = 3;\r\n                        }\r\n                        // updates width of highlights ending after last visible column\r\n                        if (xPos + width > this.clientWidth) {\r\n                            width = this.clientWidth - xPos;\r\n                        }\r\n                        div.setAttribute('style', `display: block; top: ${yPos}px; left: ${xPos}px; width: ${width}px`);\r\n                    }\r\n                }\r\n                // hides the div if the line is not visible\r\n                else {\r\n                    div.setAttribute('style', `display: none;`);\r\n                }\r\n            });\r\n        }\r\n\r\n        ta.insertPairSymbol = function (first: string, second: string) {\r\n            const before: string = ta.value.slice(0, this.selectionStart);\r\n            const between: string = ta.value.slice(this.selectionStart, this.selectionEnd)\r\n            const after: string = ta.value.slice(this.selectionEnd);\r\n            const newCursorPos: number = ta.selectionEnd + 1;\r\n            props.onChange(before + first + between + second + after, newCursorPos);\r\n            this.setSelectionRange(newCursorPos, newCursorPos);\r\n            this.hideWhisper();\r\n        }\r\n\r\n        ta.checkPairSymbolDelete = function (): boolean {\r\n            // only if nothing is selected\r\n            if (ta.selectionStart === ta.selectionEnd) {\r\n                const prevI = ta.selectionStart - 1;\r\n                const nextI = ta.selectionStart;\r\n                if (0 <= prevI && nextI < ta.value.length) {\r\n                    const prev = this.value.charAt(prevI);\r\n                    const next = this.value.charAt(nextI);\r\n                    // if the cursor is between pair symbol\r\n                    if ((prev === '(' && next === ')') || (prev === '[' && next === ']') ||\r\n                      (prev === '\"' && next === '\"' && this.value.charAt(prevI - 1) !== '\\\\')) {\r\n                        const before: string = ta.value.slice(0, prevI);\r\n                        const after: string = ta.value.slice(nextI + 1);\r\n                        props.onChange(before + after, prevI);\r\n                        this.setSelectionRange(prevI, prevI);\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        // handles whisper div position when scrolling on page\r\n        window.addEventListener('scroll', () => ta.moveWhisper());\r\n        window.addEventListener('resize', () => {\r\n            ta.moveWhisper();\r\n            ta.moveErrors();\r\n            ta.moveParentheses();\r\n        });\r\n        window.addEventListener('click', () => ta.hideWhisper());\r\n        ta.onscroll     = () => {\r\n            ta.paintLineNumbers(this.props.darkTheme);\r\n            ta.moveWhisper();\r\n            ta.moveErrors();\r\n            ta.moveParentheses();\r\n        };\r\n        ta.onmousedown  = event => {\r\n            ta.mouseIsDown = true;\r\n            setTimeout(ta.updateParentheses, 0);\r\n            event.stopPropagation();\r\n        }\r\n        ta.onmouseup    = () => {\r\n            ta.mouseIsDown = false;\r\n            ta.paintLineNumbers(this.props.darkTheme);\r\n            setTimeout(ta.updateParentheses, 0);\r\n        };\r\n        ta.onmousemove  = () => {\r\n            if (ta.mouseIsDown) ta.paintLineNumbers(this.props.darkTheme);\r\n        };\r\n        ta.oninput      = (ev) => {\r\n            // @ts-ignore\r\n            this.props.onChange(ev.target.value, ev.target.selectionStart);\r\n        }\r\n        // prevents default behavior of special keys input when whisperDiv is shown, passes key event to the parent\r\n        ta.onkeydown    = (ev) => {\r\n            if (ta.whisperDiv.isShown) {\r\n                if (ev.key === \"ArrowDown\") {\r\n                    ta.whisperDiv.changeSelected(1);\r\n                    ev.preventDefault();\r\n                }\r\n                if (ev.key === \"ArrowUp\") {\r\n                    ta.whisperDiv.changeSelected(-1);\r\n                    ev.preventDefault();\r\n                }\r\n                if (ev.key === \"PageDown\") {\r\n                    // moves selected whisper to bottom\r\n                    ta.whisperDiv.setSelected(-1);\r\n                    ev.preventDefault();\r\n                }\r\n                if (ev.key === \"PageUp\") {\r\n                    // moves selected whisper to top\r\n                    ta.whisperDiv.setSelected(0);\r\n                    ev.preventDefault();\r\n                }\r\n                if (ev.key === \"End\" || ev.key === \"Home\") {\r\n                    ta.hideWhisper();\r\n                    // keeps default behaviour\r\n                }\r\n                if (ev.key === \"Escape\" || ev.key === \"Esc\") {\r\n                    ta.hideWhisper();\r\n                    ev.preventDefault();\r\n                }\r\n                if (ev.key === \"Enter\" && !ev.ctrlKey) {\r\n                    ta.insertCurrentSelectedWhisper();\r\n                    ev.preventDefault();\r\n                }\r\n                if (ev.key === \"Enter\" && ev.ctrlKey) {\r\n                    ta.hideWhisper();\r\n                    ev.preventDefault();\r\n                }\r\n                if (ev.key === \"Tab\") {\r\n                    ta.insertCurrentSelectedWhisper();\r\n                    ev.preventDefault();\r\n                }\r\n                if (ev.key === \"ArrowLeft\") {\r\n                    const cursor = (ta.selectionStart === 0) ? 0 : (ta.selectionStart - 1);\r\n                    // forces update to recompute whispers if needed\r\n                    this.props.onChange(ta.value, cursor);\r\n                    // keeps default behaviour\r\n                }\r\n                if (ev.key === \"ArrowRight\") {\r\n                    const cursor = (ta.selectionStart === ta.value.length) ? ta.selectionStart : ta.selectionStart + 1;\r\n                    // forces update to recompute whispers if needed\r\n                    this.props.onChange(ta.value, cursor);\r\n                    // keeps default behaviour\r\n                }\r\n            }\r\n            if (ev.key === \"Enter\" || ev.key === \"Tab\") {\r\n                // does not show whisper after pressing Enter or Tab\r\n                ta.notAutoShowWhisper = true;\r\n            }\r\n            if (ev.key === \"Backspace\" && !ta.whisperDiv.isShown) {\r\n                // does not show whisper after pressing Backspace when it is closed\r\n                ta.notAutoShowWhisper = true;\r\n            }\r\n            if (ev.ctrlKey) {\r\n                if (ev.key === \" \") {\r\n                    if (ta.whisperDiv.isShown) {\r\n                        ta.hideWhisper();\r\n                    }\r\n                    else {\r\n                        this.props.onChange(ta.value, ta.selectionStart);\r\n                    }\r\n                }\r\n                this.props.onCtrlInput(ev);\r\n            }\r\n            if (ev.key === \"ArrowLeft\" || ev.key === \"ArrowRight\" || ev.key === \"ArrowUp\" || ev.key === \"ArrowDown\" ||\r\n                ev.key === \"Home\" || ev.key === \"End\" || ev.key === \"PageUp\" || ev.key === \"PageDown\") {\r\n                setTimeout(ta.updateParentheses, 0);\r\n            }\r\n            if (ev.key === \"(\") {\r\n                ta.insertPairSymbol(\"(\", \")\");\r\n                ev.preventDefault();\r\n            }\r\n            if (ev.key === \"[\") {\r\n                ta.insertPairSymbol(\"[\", \"]\");\r\n                ev.preventDefault();\r\n            }\r\n            if (ev.key === '\"' && ta.value.charAt(ta.selectionStart - 1) !== \"\\\\\") {\r\n                ta.insertPairSymbol('\"', '\"');\r\n                ev.preventDefault();\r\n            }\r\n            // if the text area deletes pair symbol, default backspace behavior is prevented\r\n            if (ev.key === \"Backspace\" && ta.checkPairSymbolDelete()) {\r\n                ev.preventDefault();\r\n            }\r\n        }\r\n\r\n        // make sure numbers are painted\r\n        ta.update(this.props.text, this.props.darkTheme);\r\n        // shows highlights\r\n        ta.updateErrors(this.props.errors);\r\n        this.textarea = ta;\r\n    }\r\n\r\n    /**\r\n     * Updates text content and component style.\r\n     */\r\n    componentDidUpdate(prevProps: Readonly<XTextAreaProps>) {\r\n        this.textarea.update(this.props.text, this.props.darkTheme);\r\n        if (prevProps.darkTheme !== this.props.darkTheme) {\r\n            this.textarea.paintLineNumbers(this.props.darkTheme);\r\n        }\r\n        // whispers\r\n        if (this.props.whispers !== prevProps.whispers) {\r\n            if (this.textarea.notAutoShowWhisper) {\r\n                this.textarea.notAutoShowWhisper = false;\r\n            }\r\n            else {\r\n                this.textarea.createWhisper(this.props.whispers);\r\n            }\r\n        }\r\n        // highlights error\r\n        if (this.props.errors !== undefined) {\r\n            this.textarea.updateErrors(this.props.errors);\r\n        }\r\n        // first undefined highlight removes 'x-textarea-err' from textarea.className to show selection with blue color\r\n        else if (this.props.errors !== prevProps.errors) {\r\n            this.textarea.classList.remove('x-textarea-err');\r\n        }\r\n        // highlights parentheses\r\n        if (this.props.parentheses !== prevProps.parentheses) {\r\n            this.textarea.parentheses = this.props.parentheses;\r\n            this.textarea.updateParentheses();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders only an empty div. Other maintaining is not provided by React.\r\n     */\r\n    public render() {\r\n        return <div id={this.props.id} className=\"x-textarea-div\" />;\r\n    }\r\n}\r\n\r\n/**\r\n * Computes line and column number for given position in text.\r\n */\r\nfunction getPositionLineAndColumn(text: string, position: number): {line: number, column: number} {\r\n    const textBeforeCursor: string = text.slice(0, position);\r\n    const line: number = (textBeforeCursor.match(/\\n/g) || []).length;\r\n    const lastNewLine: number = textBeforeCursor.lastIndexOf('\\n');\r\n    const column: number = textBeforeCursor.length - lastNewLine - 1;\r\n    return {line, column};\r\n}\r\n\r\n/**\r\n * Returns number of characters on the given line.\r\n */\r\nfunction getLineLength(text: string, line: number): number {\r\n    let newLinesFound = 0;\r\n    let lineStart = 0;  // index of line-th newline\r\n    let lineEnd = 0;    // index of (line+1)-th newline\r\n    for (let i = 0; i < text.length; ++i) {\r\n        if (text.charAt(i) === '\\n') {\r\n            ++newLinesFound;\r\n            if (newLinesFound === line) {\r\n                lineStart = i;\r\n            }\r\n            else if (newLinesFound === line + 1) {\r\n                lineEnd = i;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (lineEnd === 0) {\r\n        lineEnd = text.length; // handles case of last line in text\r\n    }\r\n    return lineEnd - lineStart;\r\n}\r\n\r\n/**\r\n * Creates a div for highlighting errors in the given textarea.\r\n */\r\nfunction createHighlightDiv(startLine: number, startColumn: number, rangeLength: number, msg: string,\r\n                            textarea: ExtendedHTMLTextArea): ErrorDiv {\r\n    // @ts-ignore\r\n    const highlight: ErrorDiv = document.createElement('div');\r\n    highlight.classList.add(\"x-textarea-highlight\");\r\n    highlight.startLine = startLine;\r\n    highlight.startColumn = startColumn;\r\n    highlight.rangeLength = rangeLength;\r\n    // dispatches click event to not block textarea underneath highlights\r\n    highlight.onclick = (ev: MouseEvent) => {\r\n        const newEvent: MouseEvent = new MouseEvent(ev.type, {...ev});\r\n        textarea.dispatchEvent(newEvent);\r\n        ev.stopPropagation();\r\n    }\r\n    const span: HTMLSpanElement = document.createElement('span');\r\n    span.classList.add(\"highlight-tooltip\");\r\n    span.innerText = msg;\r\n    highlight.messageSpan = span;\r\n    highlight.appendChild(span);\r\n    return highlight;\r\n}\r\n\r\n/**\r\n * Creates a div for highlighting parentheses in the given textarea.\r\n */\r\nfunction createParenthesesDiv(startLine: number, startColumn: number, textarea: ExtendedHTMLTextArea): ParenthesesDiv {\r\n    // @ts-ignore\r\n    const div: ParenthesesDiv = document.createElement('div');\r\n    div.classList.add(\"x-textarea-parentheses\");\r\n    div.startLine = startLine;\r\n    div.startColumn = startColumn;\r\n    // dispatches click event to not block textarea underneath highlights\r\n    div.onclick = (ev: MouseEvent) => {\r\n        const newEvent: MouseEvent = new MouseEvent(ev.type, {...ev});\r\n        textarea.dispatchEvent(newEvent);\r\n        ev.stopPropagation();\r\n    }\r\n    return div;\r\n}","/**\r\n * Modulo operation with positive result for negative numbers (as % in JavaScript can give negative results).\r\n *\r\n * @param n base number\r\n * @param m dividing number\r\n */\r\nexport function mod(n: number, m: number) {\r\n    return ((n % m) + m) % m;\r\n}","import Row from \"./row\";\r\nimport {SupportedColumnType} from \"./columnType\";\r\nimport { isEqual } from \"lodash\";\r\n\r\n/**\r\n * Relation from relational algebra. It contains relational schema (set of columns' names and types)\r\n * and relation's relation (set of rows).\r\n */\r\nexport default class Relation {\r\n\r\n    public readonly name: string;\r\n    private columns = new Map<string, SupportedColumnType>();\r\n    private columnNames: string[] = []; // array to have an ordered printing of columns\r\n    private rows: Row[] = [];\r\n    private finishedSchema = false;\r\n\r\n    /**\r\n     * Creates an empty relation of the given name.\r\n     *\r\n     * @param name name of the relation\r\n     */\r\n    constructor(name: string) {\r\n        this.name = name;\r\n    }\r\n\r\n    /**\r\n     * Returns name of the relation.\r\n     */\r\n    public getName(): string {\r\n        return this.name;\r\n    }\r\n\r\n    /**\r\n     * @return true if the relational schema is finished (no more columns can be added)\r\n     */\r\n    public hasFinishedSchema(): boolean {\r\n        return this.finishedSchema;\r\n    }\r\n\r\n    /**\r\n     * Sets the relational schema finished (no more columns can be added).\r\n     */\r\n    public finishSchema(): void {\r\n        this.finishedSchema = true;\r\n    }\r\n\r\n    /**\r\n     * Adds a column to a relational schema if the relational schema is not finished yet.\r\n     *\r\n     * @param name name of the column\r\n     * @param type type of the column\r\n     * @return true if the column was added (relation did not contain a column with the same name before)\r\n     */\r\n    public addColumn(name: string, type: SupportedColumnType): boolean {\r\n        if (!this.hasColumn(name) && !this.hasFinishedSchema()) {\r\n            this.columns.set(name, type);\r\n            this.columnNames.push(name);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks whether the relation has a column with the same name\r\n     * (NOTE: type of the column does not matter).\r\n     *\r\n     * @param name Column name to be checked\r\n     * @return true if the relation has a column with the same name\r\n     */\r\n    public hasColumn(name: string): boolean {\r\n        return this.columnNames.some(cn => cn === name);\r\n    }\r\n\r\n    /**\r\n     * @return map (name -> value) of columns' values in a relation.\r\n     */\r\n    public getColumns(): Map<string, SupportedColumnType> {\r\n        return this.columns;\r\n    }\r\n\r\n    /**\r\n     * @param f function to be applied for each column in the relation\r\n     */\r\n    public forEachColumn(f: (type: SupportedColumnType, name: string) => void): void {\r\n        return this.columns.forEach(f);\r\n    }\r\n\r\n    /**\r\n     * @return array of column names in a relation.\r\n     */\r\n    public getColumnNames(): string[] {\r\n        return this.columnNames;\r\n    }\r\n\r\n    /**\r\n     * @return Number of columns in a relation.\r\n     */\r\n    public getColumnsCount(): number {\r\n        return this.columnNames.length;\r\n    }\r\n\r\n    /**\r\n     * Adds a row to a relation. The row must have the same column set as the relation. If the row was added,\r\n     * sets the row finished and returns true. Also the relational schema of this relation\r\n     * is set finished (no more columns can be added). If the row was not added, returns false.\r\n     * NOTE: Rows in a relation cannot be duplicit, adding a duplicit row returns true, but only one is kept.\r\n     *\r\n     * @param row row to be added\r\n     * @return true if the row was added, false otherwise\r\n     */\r\n    public addRow(row: Row): boolean {\r\n        if (isEqual(row.getTypes(), this.columns)) {\r\n            this.finishSchema();\r\n            row.finish();\r\n            if (!this.rows.some(r => r.equals(row))) {\r\n                this.rows.push(row);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @return array of rows in a relation.\r\n     */\r\n    public getRows(): Row[] {\r\n        return this.rows;\r\n    }\r\n\r\n    /**\r\n     * @return Number of rows in a relation.\r\n     */\r\n    public getRowsCount(): number {\r\n        return this.rows.length;\r\n    }\r\n\r\n    /**\r\n     * Returns a relational schema in a format: RelationName(ColumnOneName: ColumnOneType, ...) - both column names\r\n     * and column types are used.\r\n     *\r\n     * @return relational schema as a string\r\n     */\r\n    public getSchemaString(): string {\r\n        return this.name + \"(\" + [...this.columns].map(s => s[0] + \": \" + s[1]).join(\", \") + \")\";\r\n    }\r\n\r\n    /**\r\n     * Returns a relational schema in a format: RelationName(ColumnOneName, ...) - only column names are used.\r\n     *\r\n     * @return relational schema as a string\r\n     */\r\n    public getNamesSchemaString(): string {\r\n        return this.name + \"(\" + this.columnNames.join(\", \") + \")\";\r\n    }\r\n\r\n    /**\r\n     * Returns a formatted string representation of the relation content (column names, column types and rows).\r\n     *\r\n     * @return string representation of the relation\r\n     */\r\n    public contentString(): string {\r\n        // @ts-ignore - prepares array representation of types and rows\r\n        const columnTypes: SupportedColumnType[] = this.columnNames.map(name => this.columns.get(name));\r\n        const rows = [...this.rows].map(row => row.getOrderedPrintValues(this.columnNames));\r\n        // finds longest inputs in each column\r\n        const longest = this.columnNames.map(n => n.length);\r\n        columnTypes.forEach((type, i) => {\r\n            if (type.length > longest[i]) {\r\n                longest[i] = type.length;\r\n            }\r\n        })\r\n        rows.forEach(r => {\r\n            r.forEach((d, i) => {\r\n                if (longest[i] < d.length) {\r\n                    longest[i] = d.length;\r\n                }\r\n            });\r\n        });\r\n        // function for end-padding strings with spaces\r\n        const pad = (ss: string[]) => ss.map((s, i) => s.padEnd(longest[i], \" \")).join(' | ');\r\n        return pad(this.columnNames) + '\\n' +\r\n            pad(columnTypes) + '\\n' +\r\n            longest.map(n => \"-\".repeat(n)).join(\"-+-\") + '\\n' +\r\n            rows.map(r => pad(r)).join('\\n');\r\n    }\r\n\r\n    /**\r\n     * Custom equals function for testing purposes.\r\n     *\r\n     * @param other\r\n     */\r\n    public equals(other: any): boolean {\r\n        if (other instanceof Relation) {\r\n            return this.name === other.name &&\r\n                isEqual(this.columns, other.columns) &&\r\n                isEqual(new Set(this.rows), new Set(other.rows));\r\n        }\r\n        return false;\r\n    }\r\n}","/**\r\n * Codes for CodeErrors.\r\n * The description is a string array - between its members are inserted error parameters (names of invalid relations,\r\n * invalid input parts, etc.). See english language definition for expected structure of each error description.\r\n */\r\nexport interface CodeErrorMessages {\r\n    // expects 1 part\r\n    resultSection_nodeIndexNotFound: string[],\r\n    // expects 2 part\r\n    resultSection_evalError: string[],\r\n    // expects 1 part\r\n    resultSection_nullRelationToSave: string[],\r\n    // expects 1 part\r\n    resultSection_nullRelationToAdd: string[],\r\n\r\n    // expects 3 parts\r\n    row_absentColumn: string[],\r\n\r\n    // expects 2 parts\r\n    valueParser_unexpectedToken: string[],\r\n\r\n    // expects 2 parts\r\n    exprParser_unexpectedToken: string[],\r\n    // expects 2 parts\r\n    exprParser_thetaJoinBranchError: string[],\r\n    // expects 2 parts\r\n    exprParser_projectionBranchError: string[]\r\n}\r\n\r\n/**\r\n * Error caused by fatal error in code of the application.\r\n */\r\nexport default class CodeError extends Error {\r\n    constructor(msg: string) {\r\n        super(msg);\r\n        if (Error.captureStackTrace) {\r\n            Error.captureStackTrace(this, CodeError);\r\n        }\r\n        this.name = 'CodeError';\r\n    }\r\n}","import RASemanticError from \"./raSemanticError\";\r\nimport RASyntaxError from \"./raSyntaxError\";\r\nimport CodeError from \"./codeError\";\r\nimport {StartEndPair} from \"../types/startEndPair\";\r\n\r\n/**\r\n * Factory for creating custom application errors: CodeError, RASemanticError, RASyntaxError.\r\n * It creates an error message by given error code and string parameters.\r\n */\r\nexport class ErrorFactory {\r\n\r\n    /**\r\n     * Creates a new code error. Params are used to join error messages. See CodeErrorMessages interface definition.\r\n     *\r\n     * @param msg predefined error description\r\n     * @param params textual specification\r\n     */\r\n    public static codeError(msg: string[], ...params: string[]): CodeError {\r\n        assertParamsCount(msg.length - 1, params);\r\n        return new CodeError(joinStringArrays(msg, params));\r\n    }\r\n\r\n    /**\r\n     * Creates a new RASemanticError. Params are used to join error messages. See SemanticErrorMessages interface definition.\r\n     *\r\n     * @param msg predefined error description\r\n     * @param range text range of the error in the input when defined\r\n     * @param params textual specification\r\n     */\r\n    public static semanticError(msg: string[], range: StartEndPair | undefined, ...params: string[]): RASemanticError {\r\n        assertParamsCount(msg.length - 1, params);\r\n        return new RASemanticError(joinStringArrays(msg, params), range);\r\n    }\r\n\r\n    /**\r\n     * Creates a new RASyntaxError. Params are used to join error messages. See SyntaxErrorMessages interface definition.\r\n     *\r\n     * @param msg predefined error description\r\n     * @param range text range of the error in the input when defined\r\n     * @param params textual specification\r\n     */\r\n    public static syntaxError(msg: string[], range: StartEndPair | undefined, ...params: string[]): RASyntaxError {\r\n        assertParamsCount(msg.length - 1, params);\r\n        return new RASyntaxError(joinStringArrays(msg, params), range);\r\n    }\r\n}\r\n\r\n/**\r\n * Extends the given params array with empty strings to have the length of expectedCount. When the initial length of the\r\n * given params array is same or greater, the array is not changed.\r\n *\r\n * @param expectedCount\r\n * @param params\r\n */\r\nexport function assertParamsCount(expectedCount: number, params: string[]): void {\r\n    if (params.length !== expectedCount) {\r\n        console.log(\"Unexpected params count, expected \" + expectedCount + \", given \" + params.length);\r\n        while (params.length < expectedCount) {\r\n            params.push(\"\");\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Joins given string arrays [a1, a2, ..., an] and [b1, b2, ..., bn-1] to one string \"a1b1a2b2...an-1bn-1an\".\r\n * WARNING: a.length is expected to be at least 1. b.length is expected to be at least \"a.length - 1\".\r\n *\r\n * @param a array of length at least 1\r\n * @param b array of length at least \"a.length - 1\"\r\n */\r\nexport function joinStringArrays(a: string[], b: string[]): string {\r\n    const aLen: number = a.length;\r\n    const toConcat: string[] = Array<string>(2 * aLen - 2);\r\n    for (let i = 1; i < aLen; i++) {\r\n        toConcat[2 * i - 2] = b[i - 1];\r\n        toConcat[2 * i - 1] = a[i];\r\n    }\r\n    return a[0].concat(...toConcat);\r\n}","import {BinaryNodeClass} from \"../ratree/binaryNode\";\r\nimport {IndexedString} from \"../types/indexedString\";\r\nimport {UnaryNodeClass} from \"../ratree/unaryNode\";\r\nimport {StartEndPair} from \"../types/startEndPair\";\r\n\r\n/**\r\n * Abstract parent class for all RATokens.\r\n */\r\nexport abstract class ExprToken {\r\n    protected constructor(public readonly str: IndexedString) {\r\n    }\r\n\r\n    /**\r\n     * Gets token start and end index in the text (if the token has IndexedString representation) or undefined.\r\n     */\r\n    public getRange(): StartEndPair | undefined {\r\n        return this.str.getRange();\r\n    }\r\n}\r\n\r\n/**\r\n * Parentheses.\r\n */\r\nexport abstract class ParenthesisToken extends ExprToken {}\r\n\r\nexport class OpeningParenthesis extends ParenthesisToken {\r\n    public constructor(str: IndexedString) {\r\n        super(str);\r\n    }\r\n}\r\n\r\nexport class ClosingParenthesis extends ParenthesisToken {\r\n    public constructor(str: IndexedString) {\r\n        super(str);\r\n    }\r\n}\r\n\r\n/**\r\n * Relation reference.\r\n */\r\nexport class RelationToken extends ExprToken {\r\n    public constructor(name: IndexedString) {\r\n        super(name);\r\n    }\r\n}\r\n\r\n/**\r\n * Unary operators.\r\n */\r\nexport class UnaryOperatorToken extends ExprToken {\r\n\r\n    public static selection(selection: IndexedString) {\r\n        return new UnaryOperatorToken(selection, \"selection\");\r\n    }\r\n\r\n    public static projection(projection: IndexedString) {\r\n        return new UnaryOperatorToken(projection, \"projection\");\r\n    }\r\n\r\n    public static rename(rename: IndexedString) {\r\n        return new UnaryOperatorToken(rename, \"rename\");\r\n    }\r\n\r\n    private constructor(str: IndexedString, public readonly type: UnaryNodeClass) {\r\n        super(str);\r\n    }\r\n}\r\n\r\n/**\r\n * Precedence values for binary operators (highest to lowest).\r\n */\r\nconst precedenceLevelA: number = 10;\r\nconst cartesianPrecedence: number = precedenceLevelA;\r\nconst naturalPrecedence: number = precedenceLevelA;\r\nconst thetaPrecedence: number = precedenceLevelA;\r\nconst semiPrecedence: number = precedenceLevelA;\r\nconst antiPrecedence: number = precedenceLevelA;\r\nconst thetaSemiPrecedence: number = precedenceLevelA;\r\nconst outerPrecedence: number = precedenceLevelA;\r\nconst divisionPrecedence: number = precedenceLevelA;\r\n\r\nconst precedenceLevelB: number = precedenceLevelA - 1;\r\nconst intersectionPrecedence: number = precedenceLevelB;\r\n\r\nconst precedenceLevelC: number = precedenceLevelB - 1;\r\nconst differencePrecedence: number = precedenceLevelC;\r\nconst unionPrecedence: number = precedenceLevelC;\r\n\r\n/**\r\n * Binary operators.\r\n */\r\nexport class BinaryOperatorToken extends ExprToken {\r\n\r\n    static naturalJoin(str: IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, naturalPrecedence, \"natural join\");\r\n    }\r\n\r\n    static cartesianProduct(str: IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, cartesianPrecedence, \"cartesian product\");\r\n    }\r\n\r\n    static union(str: IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, unionPrecedence, \"union\");\r\n    }\r\n\r\n    static intersection(str: IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, intersectionPrecedence, \"intersection\");\r\n    }\r\n\r\n    static difference(str: IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, differencePrecedence, \"difference\");\r\n    }\r\n\r\n    static leftSemijoin(str: IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, semiPrecedence, \"left semijoin\");\r\n    }\r\n\r\n    static rightSemijoin(str: IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, semiPrecedence, \"right semijoin\");\r\n    }\r\n\r\n    static leftAntijoin(str: IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, antiPrecedence, \"left antijoin\");\r\n    }\r\n\r\n    static rightAntijoin(str: IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, antiPrecedence, \"right antijoin\");\r\n    }\r\n\r\n    static thetaJoin(str: IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, thetaPrecedence, \"theta join\");\r\n    }\r\n\r\n    static leftThetaSemijoin(str: IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, thetaSemiPrecedence, \"left theta semijoin\");\r\n    }\r\n\r\n    static rightThetaSemijoin(str: IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, thetaSemiPrecedence, \"right theta semijoin\");\r\n    }\r\n\r\n    static fullOuterJoin(str: IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, outerPrecedence, \"full outer join\");\r\n    }\r\n\r\n    static leftOuterJoin(str: IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, outerPrecedence, \"left outer join\");\r\n    }\r\n\r\n    static rightOuterJoin(str: IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, outerPrecedence, \"right outer join\");\r\n    }\r\n\r\n    static division(str: IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, divisionPrecedence, \"division\");\r\n    }\r\n\r\n    private constructor(str: IndexedString, public readonly precedence: number, public readonly type: BinaryNodeClass) {\r\n        super(str);\r\n    }\r\n}","import {ErrorFactory} from \"../error/errorFactory\";\r\nimport RASyntaxError from \"../error/raSyntaxError\";\r\nimport {language} from \"../language/language\";\r\n\r\n/**\r\n * Class providing general helper functions for strings.\r\n */\r\nexport default class StringUtils {\r\n\r\n    /**\r\n     * @param str Checked string\r\n     * @return true if the string contains letters only and has length at least 1\r\n     */\r\n    public static isWord(str: string): boolean {\r\n        return str.length > 0 && str.split(\"\").every(c => StringUtils.isLetter(c));\r\n    }\r\n\r\n    /**\r\n     * @param str Checked string\r\n     * @return true if the string contains letters, numbers and underscores only, has length at least 1 and starts with\r\n     * a letter or an underscore\r\n     */\r\n    public static isName(str: string): boolean {\r\n        if (str.length === 0) {\r\n            return false;\r\n        }\r\n        if (!StringUtils.isLetter(str.charAt(0)) && str.charAt(0) !== '_') {\r\n            return false;\r\n        }\r\n        return str.split(\"\").every(c => StringUtils.isNameChar(c));\r\n    }\r\n\r\n    /**\r\n     * @param str Checked string\r\n     * @return true if the string contains whitespaces only\r\n     */\r\n    public static isWhitespacesOnly(str: string): boolean {\r\n        const regex = /\\s*/;\r\n        const res = regex.exec(str);\r\n        return res === null ? false : res[0] === str;\r\n    }\r\n\r\n    /**\r\n     * @param c Checked character\r\n     * @return true if the given string has length one and the character is a letter\r\n     */\r\n    public static isLetter(c: string): boolean {\r\n        return c.length === 1 && c.toLowerCase() !== c.toUpperCase();\r\n    }\r\n\r\n    /**\r\n     * @param c Checked character\r\n     * @return true if the given string has length one and the character is a letter, a number or an underscore\r\n     */\r\n    public static isNameChar(c: string): boolean {\r\n        return StringUtils.isLetter(c) || StringUtils.isDigit(c) || c === '_';\r\n    }\r\n\r\n    /**\r\n     * @param c Checked character\r\n     * @return true if the given string has length one and the character is a digit\r\n     */\r\n    public static isDigit(c: string): boolean {\r\n        return c.length === 1 && c.match(/\\d/) !== null;\r\n    }\r\n\r\n    /**\r\n     * @param str Checked string\r\n     * @return true if the string represents a decimal number\r\n     */\r\n    public static isNumber(str: string): boolean {\r\n        return /^[-]?[\\d]+([.][\\d]+)?$/.test(str);\r\n    }\r\n\r\n    /**\r\n     * Splits given string to a starting sequence of letters and its rest and returns these parts in a pair.\r\n     * NOTE: if the string does not start with a letter, as a word is returned an empty string.\r\n     *\r\n     * @param str string to be split\r\n     * @return split string in a pair { word, rest }\r\n     */\r\n    public static nextWord(str: string): { first: string, second: string } {\r\n        if (str === \"\") {\r\n            return { first: \"\", second: \"\" };\r\n        }\r\n        let i: number = 0;\r\n        while (i < str.length) {\r\n            if (!StringUtils.isLetter(str.charAt(i))) {\r\n                return { first: str.substring(0, i), second: str.substring(i)};\r\n            }\r\n            ++i;\r\n        }\r\n        return { first: str, second: \"\"};\r\n    }\r\n\r\n    /**\r\n     * Splits given string to a starting sequence of letters, numbers and underscores, which starts with a letter or\r\n     * an underscore and its rest and returns these parts in a pair.\r\n     * NOTE: if the string does not start with a letter, or an underscore, as a name is returned an empty string.\r\n     *\r\n     * @param str string to be split\r\n     * @return split string in a pair { name, rest }\r\n     */\r\n    public static nextName(str: string): { first: string, second: string } {\r\n        if (str === \"\") {\r\n            return { first: \"\", second: \"\" };\r\n        }\r\n        if (!StringUtils.isLetter(str.charAt(0)) && str.charAt(0) !== '_') {\r\n            return { first: \"\", second: str };\r\n        }\r\n        let i: number = 0;\r\n        while (i < str.length) {\r\n            const char: string = str.charAt(i);\r\n            if (!StringUtils.isLetter(char) && !StringUtils.isDigit(char) && char !== '_') {\r\n                return { first: str.substring(0, i), second: str.substring(i)};\r\n            }\r\n            ++i;\r\n        }\r\n        return { first: str, second: \"\"};\r\n    }\r\n\r\n    /**\r\n     * Splits given string to a starting sequence of non-whitespace characters and its rest and returns these parts in a pair.\r\n     *\r\n     * @param str string to be split\r\n     * @return split string in a pair { word, rest }\r\n     */\r\n    public static nextNonWhitespacePart(str: string): { first: string, second: string } {\r\n        if (str === \"\") {\r\n            return { first: \"\", second: \"\" };\r\n        }\r\n        let i: number = 0;\r\n        while (i < str.length) {\r\n            if (str.charAt(i).match(/\\s/)) {\r\n                return { first: str.substring(0, i), second: str.substring(i)};\r\n            }\r\n            ++i;\r\n        }\r\n        return { first: str, second: \"\"};\r\n    }\r\n\r\n    /**\r\n     * Splits given string to a starting number and its rest and returns these parts in a pair.\r\n     * NOTE: if the string does not start with a digit, as a number is returned an empty string.\r\n     *\r\n     * @param str string to be split\r\n     * @return split string in a pair (word, rest)\r\n     */\r\n    static nextNumber(str: string): { first: string, second: string } {\r\n        if (str === \"\") {\r\n            return { first: \"\", second: \"\" };\r\n        }\r\n        let i: number = 0;\r\n        // string starts with '-' sign\r\n        if (str.charAt(0) === '-') {\r\n            // if there is a digit after '-', shifts the start\r\n            if (str.length > 1 && StringUtils.isDigit(str.charAt(1))) {\r\n                i = 1;\r\n            }\r\n            // there is no digit\r\n            else {\r\n                return { first: \"\", second: str };\r\n            }\r\n        }\r\n        let digitFound: boolean = false;\r\n        let dotFound: boolean = false;\r\n        while (i < str.length) {\r\n            if (StringUtils.isDigit(str.charAt(i))) {\r\n                digitFound = true;\r\n                ++i;\r\n            }\r\n            else if (str.charAt(i) === '.') {\r\n                // second dot or a dot without previous digits\r\n                if (dotFound || !digitFound) {\r\n                    break;\r\n                }\r\n                else {\r\n                    dotFound = true;\r\n                    ++i;\r\n                }\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        const numStr = str.substring(0, i);\r\n        const rest = str.substring(i);\r\n        return { first: numStr, second: rest };\r\n    }\r\n\r\n    /**\r\n     * Splits the given string into starting quoted part and the rest. Quotes can be escaped by an odd count of\r\n     * backslashes.\r\n     * NOTE: When the closing quote is not found until the rest of the line, unclosed string is returned\r\n     * => the error is not thrown, it is only added to the return object.\r\n     * NOTE: First character of the string is expected to be '\"'.\r\n     *\r\n     * @param str string to be split\r\n     * @return pair of the starting bordered part and the rest\r\n     */\r\n    static nextQuotedString(str: string): { first: string, second: string, error: RASyntaxError | undefined } {\r\n        let i: number = 1;\r\n        // backslashes escape the quote character only in odd count\r\n        let backslashes: number = 0;\r\n        while (i < str.length) {\r\n            const curChar = str.charAt(i);\r\n            // increases index for using \"i\" in slicing\r\n            ++i;\r\n            if (curChar === '\"' && (backslashes % 2) === 0) {\r\n                return { first: str.slice(0, i), second: str.slice(i), error: undefined };\r\n            }\r\n            // end of line breaks the string\r\n            if (curChar === '\\n') {\r\n                return {\r\n                    first: str.slice(0, i),\r\n                    second: str.slice(i),\r\n                    error: ErrorFactory.syntaxError(language().syntaxErrors.stringUtils_missingClosingChar,\r\n                        undefined, '\"', '\"')\r\n                };\r\n            }\r\n            // updates backslash count\r\n            if (curChar === '\\\\') {\r\n                ++backslashes;\r\n            }\r\n            else {\r\n                backslashes = 0;\r\n            }\r\n        }\r\n        return {\r\n            first: str,\r\n            second: \"\",\r\n            error: ErrorFactory.syntaxError(language().syntaxErrors.stringUtils_missingClosingChar,\r\n                undefined, '\"', '\"')\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Splits the string to the starting bordered part and the rest and returns these parts in a pair.\r\n     * If there is only one ending character and it differs from the starting one, nested bordering is supported.\r\n     * Characters after an odd count of escape characters are ignored and cannot start or end a bordered part.\r\n     * Starting and ending characters in quoted part are ignored, quotes can be escaped by an odd count of backslashes.\r\n     * NOTE: First character of the string is expected to be 'start'.\r\n     * NOTE: Should not be used for slicing quoted strings, use nextQuotedString instead.\r\n     * NOTE: It is expected, that there are no comments in the given string.\r\n     *\r\n     * @param str string to be split\r\n     * @param start starting character of the string and also starting character of the bordered part (one character)\r\n     * @param end ending characters of the bordered part (one or more characters)\r\n     * @param escape character which makes next character being ignored (default '\\0')\r\n     * @return pair of the starting bordered part and the rest\r\n     */\r\n    static nextBorderedPart(str: string, start: string, end: string, escape: string = '\\0'): { first: string, second: string } {\r\n        let depth: number = 1;\r\n        let i: number = 1;\r\n        // to ignore special characters\r\n        let inQuotes: boolean = false;\r\n        // nested bordering is supported if there is only one ending character\r\n        const nesting: boolean = end.length === 1;\r\n        // backslashes escape the quote character only in odd count\r\n        let backslashes: number = 0;\r\n        // escape characters escape the end character only in odd count\r\n        let escapeCount: number = 0;\r\n        while (i < str.length) {\r\n            const curChar = str.charAt(i);\r\n            // checks end of the part (before checking start for a case when start == end)\r\n            if (end.indexOf(curChar) > -1 && (escapeCount % 2) === 0 && !inQuotes) {\r\n                --depth;\r\n            }\r\n            // checks start of the bordered part (if only one ending character was given)\r\n            else if (curChar === start && (escapeCount % 2) === 0 && nesting && !inQuotes) {\r\n                ++depth;\r\n            }\r\n            // found quote if even number of backslashes before\r\n            else if (curChar === '\"' && (backslashes % 2) === 0) {\r\n                inQuotes = !inQuotes;\r\n            }\r\n            // updates escape chars count\r\n            if (curChar === escape) {\r\n                ++escapeCount;\r\n            }\r\n            else {\r\n                escapeCount = 0;\r\n            }\r\n            // updates backslash count\r\n            if (curChar === '\\\\') {\r\n                ++backslashes;\r\n            }\r\n            else {\r\n                backslashes = 0;\r\n            }\r\n            // increases index for before slicing\r\n            ++i;\r\n            if (depth === 0) {\r\n                return { first: str.slice(0, i), second: str.slice(i) };\r\n            }\r\n        }\r\n        throw ErrorFactory.syntaxError(language().syntaxErrors.stringUtils_missingClosingChar, undefined,\r\n            end.split('').join(\"' / '\"), start);\r\n    }\r\n\r\n    /**\r\n     * Skips all whitespaces and exactly one given character and returns rest of the string.\r\n     * If the string does not match this pattern, throws error.\r\n     *\r\n     * @param str string to be skipped in\r\n     * @param char char to be skipped exactly one time (expected to be string of length 1)\r\n     * @return given string without starting sequence of whitespaces and exactly one char\r\n     */\r\n    public static skipWhitespacesAndChar(str: string, char: string): string {\r\n        let charFound: boolean = false;\r\n        let i: number = 0;\r\n        while (i < str.length) {\r\n            if (str.charAt(i).match(/\\s/)) {\r\n                ++i;\r\n            }\r\n            else if (str.charAt(i) === char && !charFound) {\r\n                charFound = true;\r\n                ++i;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        if (!charFound) {\r\n            throw ErrorFactory.syntaxError(language().syntaxErrors.stringUtils_charNotFound, undefined, char);\r\n        }\r\n        return str.substring(i);\r\n    }\r\n}","import Relation from \"../relation/relation\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\n\r\n/**\r\n * Abstract general node of the relational algebra syntactic tree.\r\n */\r\nexport default abstract class RATreeNode {\r\n\r\n    protected resultRelation: Relation | undefined;\r\n\r\n    protected constructor() {\r\n    }\r\n\r\n    /**\r\n     * Evaluates the RA query in this node and its subtree.\r\n     * After successful call, this.resultRelation must be set to valid Relation.\r\n     */\r\n    public abstract eval(): void;\r\n\r\n    /**\r\n     * Evaluates the RA query in this node and its subtree.\r\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\r\n     * Otherwise returns the result relation schema (only column names, no rows).\r\n     * When an error occurs, it is faked to work, and adds it to the errors array.\r\n     *\r\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper\r\n     */\r\n    public abstract fakeEval(cursorIndex: number): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]};\r\n\r\n    /**\r\n     * @return true if this node and its subtree was already evaluated\r\n     */\r\n    public isEvaluated(): boolean {\r\n        return this.resultRelation !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Returns the resulting relation. The node and its subtree is evaluated if it was not evaluated before.\r\n     *\r\n     * @return resulting relation gained by evaluating this node and its subtree\r\n     */\r\n    public getResult(): Relation {\r\n        if (this.resultRelation === undefined) {\r\n            this.eval();\r\n        }\r\n        // @ts-ignore\r\n        return this.resultRelation;\r\n    }\r\n\r\n    /**\r\n     * Creates a string with a structure of the RA tree in one line.\r\n     *\r\n     * @return string with a structure of the RA tree in one line\r\n     */\r\n    public abstract printInLine(): string;\r\n\r\n    /**\r\n     * Return the word name of the RA operation of the node.\r\n     * Example: returns \"Selection\" for SelectionNode.\r\n     *\r\n     * @return name of the RA operation of the node\r\n     */\r\n    public abstract getOperationName(): string;\r\n\r\n    /**\r\n     * Return the symbolic representation of the RA operation of the node.\r\n     * Example: returns \"(some + expr = 15)\" for SelectionNode.\r\n     *\r\n     * @return name of the RA operation of the node\r\n     */\r\n    public abstract getOperationSymbol(): string;\r\n}","import Relation from \"../relation/relation\";\r\nimport RATreeNode from \"./raTreeNode\";\r\n\r\n/**\r\n * Leave node of the relational algebra syntactic tree with reference to a source relation.\r\n */\r\nexport default class RelationNode extends RATreeNode {\r\n\r\n    public constructor(relation: Relation) {\r\n        super();\r\n        this.resultRelation = relation;\r\n    }\r\n\r\n    public eval(): void {\r\n        // nothing to evaluate\r\n    }\r\n\r\n    public fakeEval(cursorIndex: number) {\r\n        // @ts-ignore\r\n        const relation: Relation = this.resultRelation;\r\n        return {result: relation, whispers: [], errors: []};\r\n    }\r\n\r\n    public printInLine(): string {\r\n        // @ts-ignore\r\n        return this.resultRelation.getName();\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        // @ts-ignore\r\n        return this.resultRelation.getName();\r\n    }\r\n\r\n    public getOperationSymbol(): string {\r\n        return \"\";\r\n    }\r\n}","import {StartEndPair} from \"./startEndPair\";\r\n\r\n/**\r\n * String representation with index of each character. Provides some usual string functions.\r\n */\r\nexport class IndexedString {\r\n\r\n    /**\r\n     * Creates a new IndexedString instance representing the given string. StartIndex is used as the offset for indexes.\r\n     * When the startIndex is omitted, 0 is used. When NaN is given, all indexes are NaN.\r\n     * Indexes of the characters are (0 + startIndex, ..., str.length - 1 + startIndex).\r\n     * NOTE: Each character has its own index. That means '\\r\\n' line separator has two indexes. For expected behavior, use\r\n     * '\\n' separator instead.\r\n     */\r\n    public static new(str: string, startIndex: number = 0): IndexedString {\r\n        return new IndexedString(str, str.split('').map((char, index) => {return {char: char, index: index + startIndex}}));\r\n    }\r\n\r\n    /**\r\n     * Creates a new IndexedString instance representing an empty string \"\".\r\n     */\r\n    public static empty(): IndexedString {\r\n        return new IndexedString('', []);\r\n    }\r\n\r\n    /**\r\n     * Creates a new IndexedString instance representing the given array of IndexedChars.\r\n     */\r\n    public static newFromArray(arr: IndexedChar[]): IndexedString {\r\n        return new IndexedString(arr.map(ic => ic.char).join(''), arr);\r\n    }\r\n\r\n    /**\r\n     * Private constructor to ensure compatible string and IndexCharArray.\r\n     *\r\n     * @param str string representation\r\n     * @param chars IndexedChar representation\r\n     */\r\n    private constructor(private readonly str: string, private readonly chars: IndexedChar[]) { }\r\n\r\n    /**\r\n     * Returns string representation of the IndexedString.\r\n     */\r\n    public toString(): string {\r\n        return this.str;\r\n    }\r\n\r\n    /**\r\n     * Returns length of the string.\r\n     */\r\n    public length(): number {\r\n        return this.str.length;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the IndexedString represents an empty string \"\".\r\n     */\r\n    public isEmpty(): boolean {\r\n        return this.length() === 0;\r\n    }\r\n\r\n    /**\r\n     * Returns IndexedChar array representing the IndexedString.\r\n     * The array is reference to inner IndexedString structure.\r\n     */\r\n    public getChars(): IndexedChar[] {\r\n        return this.chars;\r\n    }\r\n\r\n    /**\r\n     * Returns the first index of a character of the IndexedString. Returns NaN if empty.\r\n     */\r\n    public getFirstIndex(): number {\r\n        if (this.isEmpty()) {\r\n            return NaN;\r\n        }\r\n        return this.chars[0].index;\r\n    }\r\n\r\n    /**\r\n     * Returns the last index of a character of the IndexedString. Returns NaN if empty.\r\n     */\r\n    public getLastIndex(): number {\r\n        if (this.isEmpty()) {\r\n            return NaN;\r\n        }\r\n        return this.chars[this.length() - 1].index;\r\n    }\r\n\r\n    /**\r\n     * Returns indexes of the first and the last character of the IndexedString. Returns undefined if empty.\r\n     */\r\n    public getRange(): StartEndPair | undefined {\r\n        if (this.isEmpty()) {\r\n            return undefined;\r\n        }\r\n        return { start: this.chars[0].index, end: this.chars[this.length() - 1].index };\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of the character at the given index. Throws RangeError if the index is\r\n     * out of IndexedString bounds.\r\n     *\r\n     * @param index\r\n     */\r\n    public charAt(index: number): string {\r\n        if (index < 0 || index >= this.length()) {\r\n            throw new RangeError();\r\n        }\r\n        return this.chars[index].char;\r\n    }\r\n\r\n    /**\r\n     * Returns an original position index of the character at the given current index. Throws RangeError if the given index is\r\n     * out of IndexedString bounds.\r\n     *\r\n     * @param index\r\n     */\r\n    public indexAt(index: number): number {\r\n        if (index < 0 || index >= this.length()) {\r\n            throw new RangeError();\r\n        }\r\n        return this.chars[index].index;\r\n    }\r\n\r\n    /**\r\n     * Split a string into substrings using the specified separator and return them as an array.\r\n     * It does not accept RegEx separators and array limit as built-in string.\r\n     *\r\n     * @param separator string separator\r\n     */\r\n    public split(separator: string): IndexedString[] {\r\n        if (this.isEmpty()) {\r\n            if (separator === '') {\r\n                return [];\r\n            }\r\n            return [IndexedString.empty()];\r\n        }\r\n        const sepLen: number = separator.length;\r\n        const strSplit: string[] = this.str.split(separator);\r\n        const prefixSum: number[] = Array<number>(strSplit.length);\r\n        prefixSum[0] = 0;\r\n        for (let i = 1; i < strSplit.length; i++) {\r\n            prefixSum[i] = prefixSum[i - 1] + strSplit[i - 1].length + sepLen;\r\n        }\r\n\r\n        return strSplit.map((strSplit, index) => {\r\n            return new IndexedString(strSplit, this.chars.slice(prefixSum[index], prefixSum[index] + strSplit.length));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Split a string into substrings using the '\\n' separator and return them as an array.\r\n     * Also, it returns indexes of removed '\\n's.\r\n     */\r\n    public splitToLines(): {split: IndexedString[], separatorIndexes: number[]} {\r\n        if (this.isEmpty()) {\r\n            return {split: [IndexedString.empty()], separatorIndexes: []};\r\n        }\r\n        const strSplit: string[] = this.str.split('\\n');\r\n        const strSplitLenMinusOne = strSplit.length - 1;\r\n        const prefixSum: number[] = Array<number>(strSplit.length);\r\n        const separatorIndexes: number[] = Array<number>(strSplit.length - 1);\r\n        prefixSum[0] = 0;\r\n        for (let i = 0; i < strSplitLenMinusOne; i++) {\r\n            const ps = prefixSum[i] + strSplit[i].length + 1;\r\n            separatorIndexes[i] = this.indexAt(ps - 1);\r\n            prefixSum[i + 1] = ps;\r\n        }\r\n\r\n        const split = strSplit.map((strSplit, index) => {\r\n            return new IndexedString(strSplit, this.chars.slice(prefixSum[index], prefixSum[index] + strSplit.length));\r\n        });\r\n        return {split, separatorIndexes};\r\n    }\r\n\r\n    /**\r\n     * Returns a section of a IndexedString.\r\n     *\r\n     * @param start The index of the beginning of the specified portion of stringObj.\r\n     * @param end The index of the end of the specified portion of IndexedString. The substring includes the characters\r\n     * up to, but not including, the character indicated by end. If this value is not specified, the substring\r\n     * continues to the end of IndexedString.\r\n     */\r\n    public slice(start: number, end?: number): IndexedString {\r\n        const _start = start < 0 ? this.length() + start : start;\r\n        const _end = end !== undefined ? (end < 0 ? this.length() + end : end) : this.length();\r\n        if (_start > _end || _start < 0 || _end > this.length()) {\r\n            throw new RangeError();\r\n        }\r\n        return IndexedString.newFromArray(this.chars.slice(_start, _end));\r\n    }\r\n\r\n    /**\r\n     * Removes the leading and trailing white space and line terminator characters from a string.\r\n     */\r\n    public trim(): IndexedString {\r\n        const trimStr: string = this.str.trim();\r\n        if (trimStr === '') {\r\n            return new IndexedString('', []);\r\n        }\r\n        const start: number = this.str.indexOf(trimStr.charAt(0));\r\n        return IndexedString.newFromArray(this.chars.slice(start, start + trimStr.length));\r\n    }\r\n\r\n    /**\r\n     * Returns a string that contains the concatenation of this IndexedString with multiple other.\r\n     *\r\n     * @param strings The IndexedStrings to append to the end of the string.\r\n     */\r\n    public concat(...strings: IndexedString[]) {\r\n        return IndexedString.newFromArray(this.chars.concat(...strings.map(is => is.chars)));\r\n    }\r\n\r\n    /**\r\n     * Returns true if the searchString sequence is the same as the corresponding\r\n     * elements of this object starting at position. Otherwise returns false.\r\n     *\r\n     * @param searchString\r\n     * @param position\r\n     */\r\n    public startsWith(searchString: string, position?: number | undefined): boolean {\r\n        return this.str.startsWith(searchString, position);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the searchString sequence is the same as the corresponding\r\n     * elements of this object starting at endPosition – searchString.length. Otherwise returns false.\r\n     *\r\n     * @param searchString\r\n     * @param position\r\n     */\r\n    public endsWith(searchString: string, position?: number | undefined): boolean {\r\n        return this.str.endsWith(searchString, position);\r\n    }\r\n\r\n    /**\r\n     * Replaces text in a string, using a regular expression or search string.\r\n     * NOTE: Returns built-in string.\r\n     *\r\n     * @param searchValue A string or RegEx to search for.\r\n     * @param replaceValue A string containing the text to replace for every successful match of searchValue in this string.\r\n     */\r\n    public replace(searchValue: string | RegExp, replaceValue: string): string {\r\n        return this.str.replace(searchValue, replaceValue);\r\n    }\r\n\r\n    /**\r\n     * Creates a deep copy of the IndexedString.\r\n     */\r\n    public copy(): IndexedString {\r\n        return new IndexedString(this.str, this.chars.map(ic => {return {char: ic.char, index: ic.index}}));\r\n    }\r\n\r\n    /**\r\n     * Returns true if it contains any of the characters from string chars. Otherwise, returns false.\r\n     */\r\n    public containsAny(chars: string): boolean {\r\n        for (let i = 0; i < chars.length; ++i) {\r\n            if (this.str.indexOf(chars[i]) > -1) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Indexed representation of one character.\r\n * WARNING: It is always assumed that IndexedChar.char is a string of length 1.\r\n */\r\nexport interface IndexedChar {\r\n    char: string,\r\n    index: number\r\n}","import {IndexedString} from \"../types/indexedString\";\r\nimport StringUtils from \"./stringUtils\";\r\nimport {insertRangeIfUndefined} from \"../error/errorWithTextRange\";\r\nimport RASyntaxError from \"../error/raSyntaxError\";\r\nimport {ErrorFactory} from \"../error/errorFactory\";\r\nimport {language} from \"../language/language\";\r\n\r\n/**\r\n * Class providing general helper functions for IndexedString.\r\n */\r\nexport default class IndexedStringUtils {\r\n\r\n    /**\r\n     * @param str Checked indexed string\r\n     * @return true if the string contains letters only and has length at least 1\r\n     */\r\n    public static isWord(str: IndexedString): boolean {\r\n        return StringUtils.isWord(str.toString());\r\n    }\r\n\r\n    /**\r\n     * @param str Checked string\r\n     * @return true if the string contains letters, numbers and underscores only, has length at least 1 and starts with\r\n     * a letter or an underscore\r\n     */\r\n    public static isName(str: IndexedString): boolean {\r\n        return StringUtils.isName(str.toString());\r\n    }\r\n\r\n    /**\r\n     * @param str Checked string\r\n     * @return true if the string contains whitespaces only\r\n     */\r\n    public static isWhitespacesOnly(str: IndexedString): boolean {\r\n        return StringUtils.isWhitespacesOnly(str.toString());\r\n    }\r\n\r\n    /**\r\n     * @param c Checked character\r\n     * @return true if the given string has length one and the character is a letter\r\n     */\r\n    public static isLetter(c: IndexedString): boolean {\r\n        return StringUtils.isLetter(c.toString());\r\n    }\r\n\r\n    /**\r\n     * @param c Checked character\r\n     * @return true if the given string has length one and the character is a letter, a number or an underscore\r\n     */\r\n    public static isNameChar(c: IndexedString): boolean {\r\n        return StringUtils.isNameChar(c.toString());\r\n    }\r\n\r\n    /**\r\n     * @param c Checked character\r\n     * @return true if the given string has length one and the character is a digit\r\n     */\r\n    public static isDigit(c: IndexedString): boolean {\r\n        return StringUtils.isDigit(c.toString());\r\n    }\r\n\r\n    /**\r\n     * @param str Checked string\r\n     * @return true if the string represents a decimal number\r\n     */\r\n    public static isNumber(str: IndexedString): boolean {\r\n        return StringUtils.isNumber(str.toString());\r\n    }\r\n\r\n    /**\r\n     * Splits given indexed string to a starting sequence of letters and its rest and returns these parts in a pair.\r\n     * NOTE: if the string does not start with a letter, as a word is returned an empty string.\r\n     *\r\n     * @param str indexed string to be split\r\n     * @return split indexed string in a pair { word, rest }\r\n     */\r\n    public static nextWord(str: IndexedString): { first: IndexedString, second: IndexedString } {\r\n        const strParts: { first: string, second: string } = StringUtils.nextWord(str.toString());\r\n        return { first: str.slice(0, strParts.first.length), second: str.slice(strParts.first.length)};\r\n    }\r\n\r\n    /**\r\n     * Splits given indexed string to a starting sequence of letters, numbers and underscores, which starts with a letter or\r\n     * an underscore and its rest and returns these parts in a pair.\r\n     * NOTE: if the string does not start with a letter, or an underscore, as a name is returned an empty string.\r\n     *\r\n     * @param str string to be split\r\n     * @return split indexed string in a pair { name, rest }\r\n     */\r\n    public static nextName(str: IndexedString): { first: IndexedString, second: IndexedString } {\r\n        const strParts: { first: string, second: string } = StringUtils.nextName(str.toString());\r\n        return { first: str.slice(0, strParts.first.length), second: str.slice(strParts.first.length)};\r\n    }\r\n\r\n    /**\r\n     * Splits given indexed string to a starting sequence of non-whitespace characters and its rest and returns these\r\n     * parts in a pair.\r\n     *\r\n     * @param str string to be split\r\n     * @return split indexed string in a pair { name, rest }\r\n     */\r\n    public static nextNonWhitespacePart(str: IndexedString): { first: IndexedString, second: IndexedString } {\r\n        const strParts: { first: string, second: string } = StringUtils.nextNonWhitespacePart(str.toString());\r\n        return { first: str.slice(0, strParts.first.length), second: str.slice(strParts.first.length)};\r\n    }\r\n\r\n    /**\r\n     * Splits given indexed string to a starting number and its rest and returns these parts in a pair.\r\n     * NOTE: if the string does not start with a digit, as a number is returned an empty string.\r\n     *\r\n     * @param str indexed string to be split\r\n     * @return split indexed string in a pair (word, rest)\r\n     */\r\n    static nextNumber(str: IndexedString): { first: IndexedString, second: IndexedString } {\r\n        const strParts: { first: string, second: string } = StringUtils.nextNumber(str.toString());\r\n        return { first: str.slice(0, strParts.first.length), second: str.slice(strParts.first.length)};\r\n    }\r\n\r\n    /**\r\n     * Splits the given indexed string into starting quoted part and the rest. Quotes can be escaped by an odd count of\r\n     * backslashes.\r\n     * NOTE: When the closing quote is not found until the rest of the line, unclosed string is returned\r\n     * => the error is not thrown, it is only added to the return object.\r\n     * NOTE: First character of the string is expected to be '\"'.\r\n     *\r\n     * @param str string to be split\r\n     * @return pair of the starting bordered part and the rest\r\n     */\r\n    static nextQuotedString(str: IndexedString): { first: IndexedString, second: IndexedString, error: RASyntaxError | undefined } {\r\n        const strParts: { first: string, second: string, error: RASyntaxError | undefined } = StringUtils.nextQuotedString(str.toString());\r\n        return {\r\n            first: str.slice(0, strParts.first.length),\r\n            second: str.slice(strParts.first.length),\r\n            error: insertRangeIfUndefined(strParts.error, {start: str.getFirstIndex(), end: str.getFirstIndex()})\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Splits the indexed string to the starting bordered part and the rest and returns these parts in a pair.\r\n     * If there is only one ending character and it differs from the starting one, nested bordering is supported.\r\n     * Characters after escape character are ignored and cannot start or end a bordered part.\r\n     * Starting and ending characters in quoted part are ignored.\r\n     * NOTE: First character of the string is expected to be 'start'.\r\n     * NOTE: Should not be used for slicing quoted strings, use nextQuotedString instead.\r\n     * NOTE: It is expected, that there are no comments in the given string.\r\n     *\r\n     * @param str indexed string to be split\r\n     * @param start starting character of the string and also starting character of the bordered part (one character)\r\n     * @param end ending characters of the bordered part (one or more characters)\r\n     * @param escape character which makes next character being ignored (default '\\0')\r\n     * @return pair of the starting bordered part and the rest as indexed strings\r\n     */\r\n    static nextBorderedPart(str: IndexedString, start: string, end: string, escape: string = '\\0'):\r\n        { first: IndexedString, second: IndexedString } {\r\n        try {\r\n            const strParts: { first: string, second: string } = StringUtils.nextBorderedPart(str.toString(), start, end, escape);\r\n            return { first: str.slice(0, strParts.first.length), second: str.slice(strParts.first.length)};\r\n        }\r\n        catch (err) {\r\n            throw insertRangeIfUndefined(err, {start: str.getFirstIndex(), end: str.getFirstIndex()});\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes all line and block comments from the given IndexedString.\r\n     * If there is unclosed block comment, return the error as well.\r\n     * Line comment \"//comment\\n\" will be changed to \"\\n\" - new line is kept.\r\n     * Block comment \"/\\*comment* /\" will be changed to \" \" - it is replaced by a space to ensure splitting of the content around.\r\n     */\r\n    public static deleteAllComments(str: IndexedString): {str: IndexedString, err: RASyntaxError | undefined} {\r\n        const chars = str.copy().getChars();\r\n        // to ignore special characters\r\n        let inQuotes: boolean = false;\r\n        let inLineComment: boolean = false;\r\n        let blockCommentStart: number = -1;\r\n        let backslashes: number = 0;\r\n\r\n        for (let i = 0; i < chars.length; ++i) {\r\n            const curChar = chars[i].char;\r\n            // found quote if even number of backslashes before\r\n            if (curChar === '\"' && (backslashes % 2) === 0 && !inLineComment && blockCommentStart === -1) {\r\n                inQuotes = !inQuotes;\r\n            }\r\n            // found start of a line comment if it is not in a comment already\r\n            else if (curChar === '/' && i + 1 < chars.length && chars[i + 1].char === '/' && !inQuotes && !inLineComment && blockCommentStart === -1) {\r\n                inLineComment = true;\r\n                chars[i].char = '\\0';\r\n                ++i;    // skips '/'\r\n            }\r\n            // newlines ends the line comment\r\n            else if (curChar === '\\n') {\r\n                inLineComment = false;\r\n            }\r\n            // found start of a block comment if it is not in a comment already\r\n            else if (curChar === '/' && i + 1 < chars.length && chars[i + 1].char === '*' && !inQuotes && !inLineComment && blockCommentStart === -1) {\r\n                blockCommentStart = i;\r\n                chars[i].char = '\\0';\r\n                ++i;    // skips '*'\r\n                chars[i].char = ' ';\r\n            }\r\n            // found end of a block comment\r\n            else if (curChar === '*' && i + 1 < chars.length && chars[i + 1].char === '/' && blockCommentStart !== -1) {\r\n                blockCommentStart = -1;\r\n                chars[i].char = '\\0';\r\n                ++i;    // replaces '/' with space to force splitting of string in the comment place\r\n                chars[i].char = ' ';\r\n            }\r\n            // updates backslash count\r\n            if (curChar === '\\\\') {\r\n                ++backslashes;\r\n            }\r\n            else {\r\n                backslashes = 0;\r\n            }\r\n            if (inLineComment || blockCommentStart !== -1) {\r\n                chars[i].char = '\\0';\r\n            }\r\n        }\r\n        let err = undefined;\r\n        if (blockCommentStart !== -1) {\r\n            const errStart = chars[blockCommentStart].index;\r\n            err = ErrorFactory.syntaxError(language().syntaxErrors.stringUtils_missingClosingChar,\r\n              {start: errStart, end: errStart + 1}, '*/', '/*');\r\n        }\r\n        // creates a new string from non-null characters\r\n        return {str: IndexedString.newFromArray(chars.filter(c => c.char !== '\\0')), err: err};\r\n    }\r\n\r\n    /**\r\n     * Skips all whitespaces and exactly one given character and returns rest of the string.\r\n     * If the string does not match this pattern, throws error.\r\n     *\r\n     * @param str string to be skipped in\r\n     * @param char char to be skipped exactly one time (expected to be string of length 1)\r\n     * @return given string without starting sequence of whitespaces and exactly one char\r\n     */\r\n    public static skipWhitespacesAndChar(str: IndexedString, char: string): IndexedString {\r\n        try {\r\n            const skippedStr: string = StringUtils.skipWhitespacesAndChar(str.toString(), char);\r\n            return str.slice(str.length() - skippedStr.length);\r\n        }\r\n        catch (err) {\r\n            throw insertRangeIfUndefined(err, str.getRange());\r\n        }\r\n    }\r\n}","import RATreeNode from \"./raTreeNode\";\r\n\r\n/**\r\n * Classes extending unary node.\r\n */\r\nexport type UnaryNodeClass = \"rename\" | \"projection\" | \"selection\";\r\n\r\n/**\r\n * Abstract node of the relational algebra syntactic tree with one subtree.\r\n */\r\nexport default abstract class UnaryNode extends RATreeNode {\r\n\r\n    protected subtree: RATreeNode;\r\n\r\n    protected constructor(subtree: RATreeNode) {\r\n        super();\r\n        this.subtree = subtree;\r\n    }\r\n\r\n    public getSubtree(): RATreeNode {\r\n        return this.subtree;\r\n    }\r\n}","import {ColumnContent, SupportedColumnType} from \"./columnType\";\r\nimport {isEqual} from \"lodash\";\r\nimport {ErrorFactory} from \"../error/errorFactory\";\r\nimport {language} from \"../language/language\";\r\n\r\n/**\r\n * Row stores a set of columns' values in a relation.\r\n */\r\nexport default class Row {\r\n\r\n    private readonly types = new Map<string, SupportedColumnType>();\r\n    private values = new Map<string, ColumnContent>();\r\n    private finished: boolean;\r\n\r\n    /**\r\n     * Creates a new row with given columns. Given column set is final, no more column can be added.\r\n     * Given columns' values are set to null. They can be set to a new value by addColumn function, as long as the row\r\n     * is not set finished.\r\n     *\r\n     * @param columns set of columns in a row\r\n     */\r\n    public constructor(columns: Map<string, SupportedColumnType>) {\r\n        // adds empty columns\r\n        columns.forEach((value, name) => {\r\n            this.values.set(name, null);\r\n        });\r\n        this.types = columns;\r\n        this.finished = false;\r\n    }\r\n\r\n    /**\r\n     * Returns whether the row is finished and no more column change is possible.\r\n     *\r\n     * @return true if the row is finished\r\n     */\r\n    public isFinished(): boolean {\r\n        return this.finished;\r\n    }\r\n\r\n    /**\r\n     * Sets the row as finished, no more changes in column values are possible.\r\n     */\r\n    public finish(): void {\r\n        this.finished = true;\r\n    }\r\n\r\n    /**\r\n     * Gets name of all columns in a row.\r\n     *\r\n     * @return set of all columns' names\r\n     */\r\n    public getColumnNames(): IterableIterator<string> {\r\n        return this.types.keys();\r\n    }\r\n\r\n    /**\r\n     * Adds a value to the row. If the addition succeeded, returns true. It can fail, if the row is finished,\r\n     * if there is no column of the given name or if there is a column with the name, but different type.\r\n     *\r\n     * @param name name of the column\r\n     * @param value new value of the column\r\n     * @return true if addition succeeded\r\n     */\r\n    public addValue(name: string, value: ColumnContent): boolean {\r\n        // finished row or not present column\r\n        if (this.finished || !this.types.has(name)) {\r\n            return false;\r\n        }\r\n        let givenType = typeof value;\r\n        // null can be set all column types\r\n        if (value !== null && givenType !== this.types.get(name)) {\r\n            return false;\r\n        }\r\n        this.values.set(name, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets the value (possibly null) of the column with the given name. If there is no column with this name, undefined is returned.\r\n     *\r\n     * @param name name of the column\r\n     * @return value of the column or undefined if there is no such column\r\n     */\r\n    public getValue(name: string): ColumnContent | undefined {\r\n        return this.values.get(name);\r\n    }\r\n\r\n    /**\r\n     * Returns the type of the given column or undefined if the column is absent.\r\n     *\r\n     * @param name name of the column\r\n     * @return the type of the column\r\n     */\r\n    public getType(name: string): SupportedColumnType | undefined {\r\n        return this.types.get(name);\r\n    }\r\n\r\n    /**\r\n     * Gets types of all columns.\r\n     *\r\n     * @return map of columns (name -> type)\r\n     */\r\n    public getTypes(): Map<string, SupportedColumnType> {\r\n        return this.types;\r\n    }\r\n\r\n    /**\r\n     * Gets values of all columns.\r\n     *\r\n     * @return map of columns (name -> value)\r\n     */\r\n    public getValues(): Map<string, ColumnContent> {\r\n        return this.values;\r\n    }\r\n\r\n    /**\r\n     * Returns values of all columns ordered by given array of column names. OrderedColumns are expected to be from the\r\n     * relation that contains the row. The returned values are converted to string type. String column values are\r\n     * changed to printing representation - escaped '\\\\' and '\"' are returned without the escape '\\\\'.\r\n     *\r\n     * @param orderedColumns order of columns to be returned\r\n     * @return ordered array of values\r\n     */\r\n    public getOrderedPrintValues(orderedColumns: string[]): string[] {\r\n        let ret: string[] = [];\r\n        orderedColumns.forEach(column => {\r\n            const value = this.values.get(column);\r\n            const type = this.types.get(column);\r\n            // should be handled before call\r\n            if (value === undefined || type === undefined) {\r\n                throw ErrorFactory.codeError(language().codeErrors.row_absentColumn, column, [...this.types.values()].join(', '));\r\n            }\r\n            if (type === \"string\") {\r\n                const str = String(value).replace(/\\\\\"/g, '\"').replace(/\\\\\\\\/g, '\\\\');\r\n                ret.push(str);\r\n            }\r\n            else {\r\n                ret.push(String(value));\r\n            }\r\n        });\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Custom equals function.\r\n     *\r\n     * @param other\r\n     */\r\n    public equals(other: Object): boolean {\r\n        if (other instanceof Row) {\r\n            return isEqual(this.types, other.types) && isEqual(this.values, other.values);\r\n        }\r\n        return false;\r\n    }\r\n}\r\n","import UnaryNode from \"./unaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport Row from \"../relation/row\";\r\nimport {IndexedString} from \"../types/indexedString\";\r\nimport {ErrorFactory} from \"../error/errorFactory\";\r\nimport {language} from \"../language/language\";\r\nimport {StartEndPair} from \"../types/startEndPair\";\r\n\r\n/**\r\n * Projection node of the relational algebra syntactic tree.\r\n */\r\nexport default class ProjectionNode extends UnaryNode {\r\n\r\n    private readonly projection: IndexedString;\r\n    private readonly stringRange: StartEndPair | undefined;\r\n\r\n    /**\r\n     * Expects the projection string to start with '[' and end with ']'.\r\n     *\r\n     * @param projection\r\n     * @param subtree\r\n     */\r\n    constructor(projection: IndexedString, subtree: RATreeNode) {\r\n        super(subtree);\r\n        this.projection = projection;\r\n        this.stringRange = projection.getRange();\r\n    }\r\n\r\n    /**\r\n     * Parses projection string to set of projected columns.\r\n     * If doThrow is true, throws found errors. Otherwise, adds found errors to given errors array.\r\n     */\r\n    private parseProjection(): Set<IndexedString> {\r\n        const ret: Set<IndexedString> = new Set<IndexedString>();\r\n        // @ts-ignore\r\n        let str: IndexedString = this.projection.slice(1, -1);\r\n        let parts: IndexedString[] = str.split(\",\");\r\n        parts.forEach(part => ret.add(part.trim()));\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Expectations: projected names are subset of source schema\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n        const source: Relation = this.subtree.getResult();\r\n        const projectedIndexed: IndexedString[] = [...this.parseProjection()];\r\n        // checks if projected columns really exist in source relation\r\n        projectedIndexed.forEach(name => {\r\n            if (!source.hasColumn(name.toString())) {\r\n                throw ErrorFactory.semanticError(language().semanticErrors.projectionNode_absentColumn,\r\n                    name.getRange(), name.toString());\r\n            }\r\n        });\r\n\r\n        const projected: string[] = projectedIndexed.map(p => p.toString());\r\n        const result: Relation = new Relation(source.getName() + \"[...]\");\r\n        // projection of relational schema\r\n        source.forEachColumn((type, name) => {\r\n            if (projected.indexOf(name) > -1) {\r\n                result.addColumn(name, type);\r\n            }\r\n        });\r\n        // projection of relation rows\r\n        source.getRows().forEach(row => {\r\n             let newRow: Row = new Row(result.getColumns());\r\n             row.getValues().forEach((value, name) => {\r\n                 if (projected.indexOf(name) > -1) {\r\n                     newRow.addValue(name, value);\r\n                 }\r\n             });\r\n             result.addRow(newRow);\r\n        });\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: projected names are subset of source schema\r\n     * Returned schema: intersection of projected names and source schema\r\n     * Second possible approach would be to return all projected names - less strict.\r\n     */\r\n    public fakeEval(cursorIndex: number) {\r\n        let source = this.subtree.fakeEval(cursorIndex);\r\n        // checks whether the cursor is in this projection block - saves current available columns\r\n        let whispers = source.whispers;\r\n        if (this.stringRange !== undefined && this.stringRange.start < cursorIndex && cursorIndex <= this.stringRange.end) {\r\n            whispers = source.result.getColumnNames();\r\n        }\r\n        // adds errors from current expression\r\n        const errors = source.errors;\r\n        const projected: Set<IndexedString> = this.parseProjection();\r\n        // creates relational schema - \"projected columns\"\r\n        const result: Relation = new Relation(source.result.name + \"[...]\");\r\n        // adds only projected, which exist in source\r\n        const absent: IndexedString[] = [];\r\n        projected.forEach(name => {\r\n            const strName = name.toString();\r\n            if (source.result.hasColumn(strName)) {\r\n                // @ts-ignore - strName must be in the source now\r\n                result.addColumn(strName, source.result.getColumns().get(strName));\r\n            }\r\n            else {\r\n                absent.push(name);\r\n            }\r\n        });\r\n        absent.forEach(column => {\r\n            errors.push(ErrorFactory.semanticError(language().semanticErrors.projectionNode_absentColumn,\r\n                column.getRange(), column.toString()));\r\n        });\r\n        return {result, whispers, errors};\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return this.subtree.printInLine() + this.getOperationSymbol();\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        return language().operations.projection;\r\n    }\r\n\r\n    public getOperationSymbol(): string {\r\n        return this.projection.replace(/\\s+/g, ' ');\r\n    }\r\n}","import {IndexedString} from \"../types/indexedString\";\r\n\r\n/**\r\n * Lowercase reserved keywords which cannot be used for column names. They are:\r\n * - Null value: null\r\n * - Boolean values: true, false\r\n * - Empty string: \"\"\r\n */\r\nconst forbiddenColumnNames: string[] = [\"null\", \"true\", \"false\", \"\"];\r\n\r\n/**\r\n * Reserved keywords which cannot be used for relation names. They are:\r\n * - First characters of outer joins: F, L, R\r\n * - Empty string: \"\"\r\n */\r\nconst forbiddenRelationNames: string[] = [\"F\", \"L\", \"R\", \"\"];\r\n\r\n/**\r\n * Returns lowercase reserved keywords which cannot be used for column names. They are:\r\n * - Null value: null\r\n * - Boolean values: true, false\r\n * - Empty string: \"\"\r\n */\r\nexport function getForbiddenColumnNames(): string[] {\r\n    return forbiddenColumnNames;\r\n}\r\n\r\n/**\r\n * Returns reserved keywords which cannot be used for relation names. They are:\r\n * - First characters of outer joins: F, L, R, f, l, r\r\n * - Empty string: \"\"\r\n */\r\nexport function getForbiddenRelationNames(): string[] {\r\n    return forbiddenRelationNames;\r\n}\r\n\r\n/**\r\n * Returns true if the given string is forbidden as a column name.\r\n */\r\nexport function isForbiddenColumnName(str: string | IndexedString): boolean {\r\n    return forbiddenColumnNames.indexOf(str.toString().toLowerCase()) > -1;\r\n}\r\n\r\n/**\r\n * Returns true if the given string is forbidden as a relation name.\r\n */\r\nexport function isForbiddenRelationName(str: string | IndexedString): boolean {\r\n    // does not use to lower because forbidden names are upper\r\n    return forbiddenRelationNames.indexOf(str.toString()) > -1;\r\n}","import {IndexedString} from \"./indexedString\";\r\n\r\ninterface KeyValue {\r\n    key: IndexedString,\r\n    value: IndexedString\r\n}\r\n\r\n/**\r\n * Wrapper of JavaScript Map object to provide usage of object IndexedString as a key for IndexedString values.\r\n */\r\nexport class ISToISMap {\r\n    private map: Map<string, KeyValue> = new Map<string, KeyValue>();\r\n\r\n    public get(key: string | IndexedString): IndexedString | undefined {\r\n        const keyValue = this.map.get(key.toString());\r\n        return keyValue === undefined ? undefined : keyValue.value;\r\n    }\r\n\r\n    public set(key: IndexedString, value: IndexedString): void {\r\n        this.map.set(key.toString(), {key, value});\r\n    }\r\n\r\n    public delete(key: IndexedString): boolean {\r\n        return this.map.delete(key.toString());\r\n    }\r\n\r\n    public has(key: string | IndexedString): boolean {\r\n        return this.map.has(key.toString());\r\n    }\r\n\r\n    public clear(): void {\r\n        this.map.clear();\r\n    }\r\n\r\n    public size(): number {\r\n        return this.map.size;\r\n    }\r\n\r\n    public forEach(f: (value: IndexedString, row: IndexedString, index?: number) => void): void {\r\n        [...this.map.values()].forEach((keyValue, index) => f(keyValue.value, keyValue.key, index));\r\n    }\r\n}","import Row from \"../relation/row\";\r\nimport {VETreeNode} from \"./veTreeNode\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\nimport {ErrorFactory} from \"../error/errorFactory\";\r\nimport {IndexedString} from \"../types/indexedString\";\r\nimport {language} from \"../language/language\";\r\n\r\n/**\r\n * Types of ComparingOperator class.\r\n */\r\nexport enum ComparingOperatorType {\r\n    equal,\r\n    nonEqual,\r\n    less,\r\n    more,\r\n    lessOrEqual,\r\n    moreOrEqual\r\n}\r\n\r\n/**\r\n * Comparing operator compares two values and returns boolean.\r\n */\r\nexport class ComparingOperator extends VETreeNode {\r\n\r\n    /**\r\n     * Creates new ComparingOperator instance of equality type (type = ComparingOperatorType.equal).\r\n     *\r\n     * @param operator used string representation of equality operator\r\n     * @param left left subtree producing a value\r\n     * @param right right subtree producing a value\r\n     * @return new ComparingOperator instance of equality type\r\n     */\r\n    public static equal(operator: IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\r\n        return new ComparingOperator(ComparingOperatorType.equal, operator, left, right);\r\n    }\r\n\r\n    /**\r\n     * Creates new ComparingOperator instance of non-equality type (type = ComparingOperatorType.nonEqual).\r\n     *\r\n     * @param operator used string representation of non-equality operator\r\n     * @param left left subtree producing a value\r\n     * @param right right subtree producing a value\r\n     * @return new ComparingOperator instance of non-equality type\r\n     */\r\n    public static nonEqual(operator: IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\r\n        return new ComparingOperator(ComparingOperatorType.nonEqual, operator, left, right);\r\n    }\r\n\r\n    /**\r\n     * Creates new ComparingOperator instance of less type (type = ComparingOperatorType.less).\r\n     *\r\n     * @param operator used string representation of less operator\r\n     * @param left left subtree producing a value\r\n     * @param right right subtree producing a value\r\n     * @return new ComparingOperator instance of less type\r\n     */\r\n    public static less(operator: IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\r\n        return new ComparingOperator(ComparingOperatorType.less, operator, left, right);\r\n    }\r\n\r\n    /**\r\n     * Creates new ComparingOperator instance of more type (type = ComparingOperatorType.more).\r\n     *\r\n     * @param operator used string representation of more operator\r\n     * @param left left subtree producing a value\r\n     * @param right right subtree producing a value\r\n     * @return new ComparingOperator instance of more type\r\n     */\r\n    public static more(operator: IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\r\n        return new ComparingOperator(ComparingOperatorType.more, operator, left, right);\r\n    }\r\n\r\n    /**\r\n     * Creates new ComparingOperator instance of less-or-equal type (type = ComparingOperatorType.lessOrEqual).\r\n     *\r\n     * @param operator used string representation of less-or-equal operator\r\n     * @param left left subtree producing a value\r\n     * @param right right subtree producing a value\r\n     * @return new ComparingOperator instance of less-or-equal type\r\n     */\r\n    public static lessOrEqual(operator: IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\r\n        return new ComparingOperator(ComparingOperatorType.lessOrEqual, operator, left, right);\r\n    }\r\n\r\n    /**\r\n     * Creates new ComparingOperator instance of more-or-equal type (type = ComparingOperatorType.moreOrEqual).\r\n     *\r\n     * @param operator used string representation of more-or-equal operator\r\n     * @param left left subtree producing a value\r\n     * @param right right subtree producing a value\r\n     * @return new ComparingOperator instance of more-or-equal type\r\n     */\r\n    public static moreOrEqual(operator: IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\r\n        return new ComparingOperator(ComparingOperatorType.moreOrEqual, operator, left, right);\r\n    }\r\n\r\n    /**\r\n     * Creates new ComparingOperator of the given type.\r\n     *\r\n     * @param type ComparingOperator type\r\n     * @param operator used string representation of the operator\r\n     * @param left left subtree producing a value\r\n     * @param right right subtree producing a value\r\n     */\r\n    public constructor(private readonly type: ComparingOperatorType, private readonly operator: IndexedString,\r\n                       private readonly left: VETreeNode, private readonly right: VETreeNode) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Evaluate the node and its subtrees and compares their value results to produce a boolean value. It needs to\r\n     * receive results of the same type from its subtrees.\r\n     * NOTE: If one of the subtrees' results is null, only equality and non-equality are valid. Other comparing\r\n     * operations returns always false.\r\n     *\r\n     * @param source row with actual values of columns recursively passed to leaf reference nodes\r\n     * @return boolean comparing left and right subtrees' values\r\n     */\r\n    public eval(source: Row): { value: boolean, type: \"boolean\" } {\r\n        const leftResult: { value: ColumnContent, type: SupportedColumnType | \"null\" } = this.left.eval(source);\r\n        const rightResult: { value: ColumnContent, type: SupportedColumnType | \"null\" } = this.right.eval(source);\r\n\r\n        if (leftResult.type !== \"null\" && rightResult.type !== \"null\" && leftResult.type !== rightResult.type) {\r\n            throw ErrorFactory.syntaxError(language().syntaxErrors.comparingOperator_differentInputTypes,\r\n                this.operator.getRange(), this.operator.toString(), leftResult.type, rightResult.type);\r\n        }\r\n\r\n        // if both values are null but both types are not null, returns false\r\n        if (leftResult.value === null && rightResult.value === null && leftResult.type !== \"null\" && rightResult.type !== \"null\") {\r\n            return {value: false, type: \"boolean\"};\r\n        }\r\n        if (this.type === ComparingOperatorType.equal) {\r\n            return {value: leftResult.value === rightResult.value, type: \"boolean\"};\r\n        }\r\n        if (this.type === ComparingOperatorType.nonEqual) {\r\n            // if any value of non-null type is null, returns false\r\n            if ((leftResult.value === null && leftResult.type !== \"null\") || (rightResult.value === null && rightResult.type !== \"null\")) {\r\n                return {value: false, type: \"boolean\"};\r\n            }\r\n            return {value: leftResult.value !== rightResult.value, type: \"boolean\"};\r\n        }\r\n        if (this.type === ComparingOperatorType.less) {\r\n            if (leftResult.value === null || rightResult.value === null) {\r\n                return {value: false, type: \"boolean\"};\r\n            }\r\n            return {value: leftResult.value < rightResult.value, type: \"boolean\"};\r\n        }\r\n        if (this.type === ComparingOperatorType.more) {\r\n            if (leftResult.value === null || rightResult.value === null) {\r\n                return {value: false, type: \"boolean\"};\r\n            }\r\n            return {value: leftResult.value > rightResult.value, type: \"boolean\"};\r\n        }\r\n        if (this.type === ComparingOperatorType.lessOrEqual) {\r\n            if (leftResult.value === null || rightResult.value === null) {\r\n                return {value: false, type: \"boolean\"};\r\n            }\r\n            return {value: leftResult.value <= rightResult.value, type: \"boolean\"};\r\n        }\r\n        // if (this.type === ComparingOperatorType.moreOrEqual)\r\n            if (leftResult.value === null || rightResult.value === null) {\r\n                return {value: false, type: \"boolean\"};\r\n            }\r\n            return {value: leftResult.value >= rightResult.value, type: \"boolean\"};\r\n    }\r\n\r\n    public toString(): string {\r\n        return \"(\" + this.left.toString() + \" \" + this.operator.toString() + \" \" + this.right.toString() + \")\";\r\n    }\r\n}","import UnaryNode from \"./unaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport StringUtils from \"../utils/stringUtils\";\r\nimport Relation from \"../relation/relation\";\r\nimport {SupportedColumnType} from \"../relation/columnType\";\r\nimport Row from \"../relation/row\";\r\nimport {IndexedString} from \"../types/indexedString\";\r\nimport {ErrorFactory} from \"../error/errorFactory\";\r\nimport {isForbiddenColumnName} from \"../utils/keywords\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\nimport {ISToISMap} from \"../types/isToISMap\";\r\nimport {language} from \"../language/language\";\r\nimport {StartEndPair} from \"../types/startEndPair\";\r\n\r\n/**\r\n * Renaming node of the relational algebra syntactic tree.\r\n */\r\nexport default class RenameNode extends UnaryNode {\r\n\r\n    private readonly rename: IndexedString;\r\n    private readonly stringRange: StartEndPair | undefined;\r\n\r\n    /**\r\n     * Creates a new renaming node with given subtree.\r\n     * The rename string is expected to start with '<' and end with '>'.\r\n     *\r\n     * @param rename string describing each renaming\r\n     * @param subtree source subtree for renaming\r\n     */\r\n    public constructor(rename: IndexedString, subtree: RATreeNode) {\r\n        super(subtree);\r\n        this.rename = rename;\r\n        this.stringRange = rename.getRange();\r\n    }\r\n\r\n    private parseChanges(doThrow: boolean, errors: ErrorWithTextRange[] = []): ISToISMap {\r\n        const handleError = (error: SyntaxError) => {\r\n            if (doThrow) {\r\n                throw error;\r\n            } else {\r\n                errors.push(error);\r\n            }\r\n        }\r\n        const parts: IndexedString[] = this.rename.slice(1, -1).split(\",\");\r\n        const ret: ISToISMap = new ISToISMap();\r\n        for (let part of parts) {\r\n            // @ts-ignore\r\n            let words: IndexedString[] = part.split(\"->\").map(w => w.trim());\r\n            let beforeError = false; // true when there was an error in before in \"before -> after\"\r\n            let afterError = false;  // true when there was an error in after in \"before -> after\"\r\n            if (words.length !== 2) {\r\n                let range = part.getRange();\r\n                if (part.isEmpty() && this.stringRange !== undefined) {\r\n                    range = {start: this.stringRange.start, end: this.stringRange.start};\r\n                }\r\n                handleError(ErrorFactory.syntaxError(language().syntaxErrors.renameNode_missingArrow, range));\r\n                beforeError = true;\r\n                afterError = true;\r\n            }\r\n            if (!beforeError && ret.has(words[0])) {\r\n                handleError(ErrorFactory.syntaxError(language().syntaxErrors.renameNode_multipleRenameOfTheColumn,\r\n                    words[0].getRange(), words[0].toString()));\r\n                beforeError = true;\r\n            }\r\n            if (!afterError && !StringUtils.isName(words[1].toString())) {\r\n                handleError(ErrorFactory.syntaxError(language().syntaxErrors.renameNode_invalidNewName,\r\n                    words[1].getRange(), words[1].toString()));\r\n                afterError = true;\r\n            }\r\n            if (!afterError && isForbiddenColumnName(words[1])) {\r\n                handleError(ErrorFactory.syntaxError(language().syntaxErrors.renameNode_keywordNewName,\r\n                    words[1].getRange(), words[1].toString()));\r\n                afterError = true;\r\n            }\r\n            // if no error found, adds original rename pair\r\n            if (!beforeError && !afterError) {\r\n                ret.set(words[0], words[1]);\r\n            }\r\n            // if no before error, fakes rename \"before -> before\"\r\n            else if (!beforeError) {\r\n                ret.set(words[0], words[0]);\r\n            }\r\n            // if no after error, fakes rename \"\"\" -> before\", where empty string has undefined range\r\n            else if (!afterError) {\r\n                ret.set(IndexedString.empty(), words[0]);\r\n            }\r\n            // if both errors, adds nothing\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Expectations: original names in projection pair (original -> new) are subset of the source schema,\r\n     * new names with rest of the source schema contain no duplicity\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n        const changes: ISToISMap = this.parseChanges(true);\r\n        const source: Relation = this.subtree.getResult();\r\n        // check whether all columns to rename are in source relation\r\n        changes.forEach((value, key) => {\r\n             if (source.getColumnNames().indexOf(key.toString()) === -1) {\r\n                 throw ErrorFactory.semanticError(language().semanticErrors.renameNode_absentOriginalColumn,\r\n                     key.getRange(), key.toString());\r\n             }\r\n        });\r\n        // rename of relational schema\r\n        const result: Relation = new Relation(source.getName() + \"<...>\");\r\n        const toChange: Map<string, SupportedColumnType> = new Map<string, SupportedColumnType>();\r\n        // in first loop adds unchanged columns only\r\n        source.forEachColumn((type, name) => {\r\n            if (changes.has(name)) {\r\n                toChange.set(name, type);\r\n            }\r\n            else {\r\n                result.addColumn(name, type);\r\n            }\r\n        });\r\n        // in second loop adds changed columns\r\n        toChange.forEach((type, name) => {\r\n            // @ts-ignore (changes must contain 'name' key now)\r\n            if (!result.addColumn(changes.get(name).toString(), type)) {\r\n                const newName = changes.get(name);\r\n                throw ErrorFactory.semanticError(language().semanticErrors.renameNode_changeToDuplicit,\r\n                    this.rename.getRange(), newName ? newName.toString() : \"\");\r\n            }\r\n        });\r\n        // rename of relation rows\r\n        source.getRows().forEach(row => {\r\n            const newRow: Row = new Row(result.getColumns());\r\n            row.getValues().forEach((value, name) => {\r\n                const returned = changes.get(name);\r\n                if (typeof returned === \"undefined\") {\r\n                    newRow.addValue(name, value);\r\n                }\r\n                else {\r\n                    newRow.addValue(returned.toString(), value);\r\n                }\r\n            });\r\n            result.addRow(newRow);\r\n        });\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: original names in projection pair (original -> new) are subset of the source schema,\r\n     * new names with rest of the source schema contain no duplicity\r\n     * Returned schema: if the cursor is not after the arrow '->' returns\r\n     * (source schema minus originals) union (news whose originals were in source schema),\r\n     * otherwise returns empty array (does not whisper to what the user should rename)\r\n     * Second possible approach would be to return (source schema minus originals) union (news) - less strict.\r\n     */\r\n    public fakeEval(cursorIndex: number) {\r\n        const source = this.subtree.fakeEval(cursorIndex);\r\n        // checks whether the cursor is in this rename block\r\n        let whispers = source.whispers;\r\n        if (this.stringRange !== undefined && this.stringRange.start < cursorIndex && cursorIndex <= this.stringRange.end) {\r\n            whispers = source.result.getColumnNames();\r\n        }\r\n        // adds errors from current expression\r\n        const errors = source.errors;\r\n        const changes: ISToISMap = this.parseChanges(false, errors);\r\n        // creates relational schema - \"(source minus to-rename) union (renamed existing in source)\"\r\n        const result: Relation = new Relation(source.result.getName() + \"<...>\");\r\n        // in first loop adds source columns which are not in changes.keys\r\n        source.result.forEachColumn((type, name) => {\r\n            if (!changes.has(name)) {\r\n                result.addColumn(name, type);\r\n            }\r\n        });\r\n        // in second loop adds changes.values whose changes.keys are in source\r\n        const absent: IndexedString[] = [];\r\n        const duplicit: IndexedString[] = [];\r\n        changes.forEach((after, before) => {\r\n            const beforeStr = before.toString();\r\n            const afterStr = after.toString();\r\n            if (!source.result.hasColumn(beforeStr) && !before.isEmpty()) {\r\n                absent.push(before);\r\n            }\r\n            // @ts-ignore source must have beforeStr now\r\n            else if(!result.addColumn(afterStr, source.result.getColumns().get(beforeStr))) {\r\n                duplicit.push(after);\r\n            }\r\n        });\r\n        absent.forEach(column => {\r\n            errors.push(ErrorFactory.semanticError(language().semanticErrors.renameNode_absentOriginalColumn,\r\n                column.getRange(), column.toString()));\r\n        });\r\n        duplicit.forEach(column => {\r\n            errors.push(ErrorFactory.semanticError(language().semanticErrors.renameNode_changeToDuplicit,\r\n                column.getRange(), column.toString()));\r\n        });\r\n        return {result, whispers, errors};\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return this.subtree.printInLine() + this.getOperationSymbol();\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        return language().operations.rename;\r\n    }\r\n\r\n    public getOperationSymbol(): string {\r\n        return this.rename.replace(/\\s+/g, ' ');\r\n    }\r\n}","import Row from \"../relation/row\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\n\r\n/**\r\n * Abstract class for value-evaluating nodes producing new values.\r\n */\r\nexport abstract class VETreeNode {\r\n\r\n    /**\r\n     * Evaluates this value-evaluating tree.\r\n     *\r\n     * @param source row with values to be used to reference to\r\n     * @return evaluated value and its type\r\n     */\r\n    public abstract eval(source: Row): { value: ColumnContent, type: SupportedColumnType | \"null\" };\r\n\r\n    /**\r\n     * @return string representation of the value-evaluating tree\r\n     */\r\n    public abstract toString(): string;\r\n}","import Row from \"../relation/row\";\r\nimport {VETreeNode} from \"./veTreeNode\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\nimport {ErrorFactory} from \"../error/errorFactory\";\r\nimport {IndexedString} from \"../types/indexedString\";\r\nimport {language} from \"../language/language\";\r\n\r\n/**\r\n * Types of LogicalOperator class.\r\n */\r\nenum LogicalOperatorType {\r\n    and,\r\n    or,\r\n    not\r\n}\r\n\r\n/**\r\n * Logical operator chains boolean values and produces new ones.\r\n */\r\nexport class LogicalOperator extends VETreeNode {\r\n\r\n    /**\r\n     * Creates an 'and' logical operator.\r\n     *\r\n     * @param operator String representing an 'and' in input (used to printing)\r\n     * @param left Left subtree evaluating to a boolean value\r\n     * @param right Right subtree evaluating to a boolean value\r\n     */\r\n    public static and(operator: IndexedString, left: VETreeNode, right: VETreeNode): LogicalOperator {\r\n        return new LogicalOperator(LogicalOperatorType.and, operator, left, right);\r\n    }\r\n\r\n    /**\r\n     * Creates an 'or' logical operator.\r\n     *\r\n     * @param operator String representing an 'or' in input (used to printing)\r\n     * @param left Left subtree evaluating to a boolean value\r\n     * @param right Right subtree evaluating to a boolean value\r\n     */\r\n    public static or(operator: IndexedString, left: VETreeNode, right: VETreeNode): LogicalOperator {\r\n        return new LogicalOperator(LogicalOperatorType.or, operator, left, right);\r\n    }\r\n\r\n    /**\r\n     * Creates a 'not' logical operator.\r\n     *\r\n     * @param operator String representing a 'not' in input (used to printing)\r\n     * @param subtree Subtree evaluating to a boolean value\r\n     */\r\n    public static not(operator: IndexedString, subtree: VETreeNode): LogicalOperator {\r\n        return new LogicalOperator(LogicalOperatorType.not, operator, subtree);\r\n    }\r\n\r\n    private constructor(private readonly type: LogicalOperatorType, private readonly operator: IndexedString,\r\n                        private readonly left: VETreeNode, private readonly right?: VETreeNode) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Evaluates recursively subtrees and transforms their boolean results into a new boolean.\r\n     * If any subtree evaluates to string or number, throws error.\r\n     *\r\n     * @param source row with actual values of columns recursively passed to leaf reference nodes\r\n     * @return boolean comparing left and right subtrees' values\r\n     */\r\n    public eval(source: Row): { value: boolean, type: \"boolean\" } {\r\n\r\n        const leftResult: { value: ColumnContent, type: SupportedColumnType | \"null\" } = this.left.eval(source);\r\n        if (leftResult.type !== \"boolean\") {\r\n            throw ErrorFactory.syntaxError(language().syntaxErrors.logicalOperator_leftInputNotBoolean,\r\n                this.operator.getRange(), this.operator.toString(), leftResult.type);\r\n        }\r\n\r\n        if (this.type === LogicalOperatorType.not) {\r\n            if (leftResult.value === null) {\r\n                return { value: false, type: \"boolean\" };\r\n            }\r\n            return { value: !leftResult.value, type: \"boolean\" };\r\n        }\r\n        else {\r\n            // @ts-ignore (in and/or operations right subtree must exist)\r\n            const rightResult: { value: ColumnContent, type: SupportedColumnType | \"null\" } = this.right.eval(source);\r\n            if (rightResult.type !== \"boolean\") {\r\n                throw ErrorFactory.syntaxError(language().syntaxErrors.logicalOperator_rightInputNotBoolean,\r\n                    this.operator.getRange(), this.operator.toString(), rightResult.type);\r\n            }\r\n\r\n            if (this.type === LogicalOperatorType.and) {\r\n                if (leftResult.value === null || rightResult.value === null) {\r\n                    return { value: false, type: \"boolean\" };\r\n                }\r\n                // @ts-ignore (they must be both booleans now)\r\n                return { value: leftResult.value && rightResult.value, type: \"boolean\" };\r\n            }\r\n            else /* if (this.type === LogicalOperatorType.or)*/ {\r\n                if (leftResult.value === null && rightResult.value === null) {\r\n                    return { value: false, type: \"boolean\" };\r\n                }\r\n                if (leftResult.value === null) {\r\n                    // @ts-ignore (it must be boolean now)\r\n                    return { value: rightResult.value, type: \"boolean\" };\r\n                }\r\n                if (rightResult.value === null) {\r\n                    // @ts-ignore (it must be boolean now)\r\n                    return { value: leftResult.value, type: \"boolean\" };\r\n                }\r\n                // @ts-ignore (they must be both booleans now)\r\n                return { value: leftResult.value || rightResult.value, type: \"boolean\" };\r\n            }\r\n        }\r\n    }\r\n\r\n    public toString(): string {\r\n        if (this.type === LogicalOperatorType.not) {\r\n            return this.operator.toString() + \"(\" + this.left.toString() + \")\";\r\n        }\r\n        // @ts-ignore (in and, or operations right subtree must exist)\r\n        return \"(\" + this.left.toString() + \" \" + this.operator.toString() + \" \" + this.right.toString() + \")\";\r\n    }\r\n}","import Row from \"../relation/row\";\r\nimport {VETreeNode} from \"./veTreeNode\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\nimport {ErrorFactory} from \"../error/errorFactory\";\r\nimport {language} from \"../language/language\";\r\nimport {StartEndPair} from \"../types/startEndPair\";\r\n\r\n/**\r\n * Types of ComputingOperator class.\r\n */\r\nenum ComputingOperatorType {\r\n    plus = \"+\",\r\n    minus = \"-\",\r\n    multiplication = \"*\",\r\n    division = \"/\"\r\n}\r\n\r\n/**\r\n * Comparing operator takes two number values and returns a new computed number.\r\n */\r\nexport class ComputingOperator extends VETreeNode {\r\n\r\n    /**\r\n     * Creates an addition (+) computing operator.\r\n     *\r\n     * @param left Left subtree evaluating to a number value\r\n     * @param right Right subtree evaluating to a number value\r\n     * @param range Range of the operator in the input string to highlight errors\r\n     */\r\n    public static add(left: VETreeNode, right: VETreeNode, range: StartEndPair | undefined): ComputingOperator {\r\n        return new ComputingOperator(ComputingOperatorType.plus, left, right, range);\r\n    }\r\n\r\n    /**\r\n     * Creates a deduction (-) computing operator.\r\n     *\r\n     * @param left Left subtree evaluating to a number value\r\n     * @param right Right subtree evaluating to a number value\r\n     * @param range Range of the operator in the input string to highlight errors\r\n     */\r\n    public static deduct(left: VETreeNode, right: VETreeNode, range: StartEndPair | undefined): ComputingOperator {\r\n        return new ComputingOperator(ComputingOperatorType.minus, left, right, range);\r\n    }\r\n\r\n    /**\r\n     * Creates a multiplication (*) computing operator.\r\n     *\r\n     * @param left Left subtree evaluating to a number value\r\n     * @param right Right subtree evaluating to a number value\r\n     * @param range Range of the operator in the input string to highlight errors\r\n     */\r\n    public static multiply(left: VETreeNode, right: VETreeNode, range: StartEndPair | undefined): ComputingOperator {\r\n        return new ComputingOperator(ComputingOperatorType.multiplication, left, right, range);\r\n    }\r\n\r\n    /**\r\n     * Creates a division (/) computing operator.\r\n     *\r\n     * @param left Left subtree evaluating to a number value\r\n     * @param right Right subtree evaluating to a number value\r\n     * @param range Range of the operator in the input string to highlight errors\r\n     */\r\n    public static divide(left: VETreeNode, right: VETreeNode, range: StartEndPair | undefined): ComputingOperator {\r\n        return new ComputingOperator(ComputingOperatorType.division, left, right, range);\r\n    }\r\n\r\n    private constructor(private readonly type: ComputingOperatorType, private readonly left: VETreeNode,\r\n                        private readonly right: VETreeNode, private readonly range: StartEndPair | undefined) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Evaluates recursively subtrees and transforms their number results into a new number.\r\n     * If any subtree evaluates to string or boolean, throws error.\r\n     * If any subtree evaluates to null, returns null.\r\n     *\r\n     * @param source row with actual values of columns recursively passed to leaf reference nodes\r\n     * @return number produced from subtrees with given operation, or null if any subtree returned null\r\n     */\r\n    public eval(source: Row): { value: number | null, type: \"number\" } {\r\n        const leftResult: { value: ColumnContent, type: SupportedColumnType | \"null\" } = this.left.eval(source);\r\n        const rightResult: { value: ColumnContent, type: SupportedColumnType | \"null\" } = this.right.eval(source);\r\n\r\n        if (leftResult.type !== \"number\" || rightResult.type !== \"number\") {\r\n            throw ErrorFactory.syntaxError(language().syntaxErrors.computingOperator_inputTypesNotNumbers, this.range,\r\n                this.type, leftResult.type, rightResult.type);\r\n        }\r\n\r\n        if (leftResult.value === null || rightResult.value === null) {\r\n            return { value: null, type: \"number\" };\r\n        }\r\n\r\n        switch (this.type) {\r\n            case ComputingOperatorType.plus:\r\n                // @ts-ignore (ensured by first if)\r\n                return { value: leftResult.value + rightResult.value, type: \"number\" };\r\n            case ComputingOperatorType.minus:\r\n                // @ts-ignore (ensured by first if)\r\n                return { value: leftResult.value - rightResult.value, type: \"number\" };\r\n            case ComputingOperatorType.multiplication:\r\n                // @ts-ignore (ensured by first if)\r\n                return { value: leftResult.value * rightResult.value, type: \"number\" };\r\n            case ComputingOperatorType.division:\r\n                // @ts-ignore (ensured by first if)\r\n                return { value: leftResult.value / rightResult.value, type: \"number\" };\r\n        }\r\n    }\r\n\r\n    public toString(): string {\r\n        return \"(\" + this.left.toString() + \" \" + this.type + \" \" + this.right.toString() + \")\";\r\n    }\r\n}","import Row from \"../relation/row\";\r\nimport {VETreeNode} from \"./veTreeNode\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\n\r\n/**\r\n * Class storing literal value of number, string or null type.\r\n */\r\nexport class LiteralValue extends VETreeNode {\r\n\r\n    /**\r\n     * Creates a literal storing given value.\r\n     *\r\n     * @param value value to be returned by eval(...) function\r\n     * @param type type of the literal value\r\n     */\r\n    public constructor(private readonly value: ColumnContent, private readonly type: SupportedColumnType | \"null\") {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Returns stored value.\r\n     *\r\n     * @param source row with actual values of columns (note: not used in literals)\r\n     * @return stored value and its type\r\n     */\r\n    public eval(source: Row): { value: ColumnContent, type: SupportedColumnType | \"null\" } {\r\n        return { value: this.value, type: this.type };\r\n    }\r\n\r\n    public toString(): string {\r\n        if (this.value === null) {\r\n            return \"null\";\r\n        }\r\n        return this.value.toString();\r\n    }\r\n}","import Row from \"../relation/row\";\r\nimport {VETreeNode} from \"./veTreeNode\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\nimport {ErrorFactory} from \"../error/errorFactory\";\r\nimport {IndexedString} from \"../types/indexedString\";\r\nimport {language} from \"../language/language\";\r\n\r\n/**\r\n * Class storing reference to a column.\r\n */\r\nexport class ReferenceValue extends VETreeNode {\r\n\r\n    /**\r\n     * Creates a reference to the given column.\r\n     *\r\n     * @param columnName name of the column whose value is returned by eval(...) function\r\n     */\r\n    public constructor(private readonly columnName: IndexedString) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Returns value (expected to be string, number, or boolean) of the referenced column from given source row.\r\n     *\r\n     * @param source row with actual values of columns\r\n     * @return referenced value and its type\r\n     */\r\n    public eval(source: Row): { value: ColumnContent, type: SupportedColumnType } {\r\n        const value: ColumnContent | undefined = source.getValue(this.columnName.toString());\r\n        const type: SupportedColumnType | undefined = source.getType(this.columnName.toString());\r\n        if (value === undefined || type === undefined) {\r\n            throw ErrorFactory.semanticError(language().semanticErrors.referenceValue_absentColumn,\r\n                this.columnName.getRange(), this.columnName.toString(), [...source.getColumnNames()].join(', '));\r\n        }\r\n        return { value: value, type: type };\r\n    }\r\n\r\n    public toString(): string {\r\n        return this.columnName.toString();\r\n    }\r\n}","import {ComparingOperatorType} from \"../vetree/comparingOperator\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\nimport {IndexedString} from \"../types/indexedString\";\r\nimport {StartEndPair} from \"../types/startEndPair\";\r\n\r\n/**\r\n * Precedence value for all token types.\r\n */\r\nconst precedenceNot: number = 50;\r\nconst precedenceMulDiv: number = 30;\r\nconst precedencePlusMinus: number = 25;\r\nconst precedenceComparison: number = 20;\r\nconst precedenceAnd: number = 10;\r\nconst precedenceOr: number = 5;\r\n\r\n/**\r\n * Tokens used for parsing of string expression to BooleanEvaluating tree.\r\n */\r\nexport abstract class ValueToken {\r\n    protected constructor(public readonly str: IndexedString) {}\r\n\r\n    /**\r\n     * Gets token start and end index in the text (if the token has IndexedString representation) or undefined.\r\n     */\r\n    public getRange(): StartEndPair | undefined {\r\n        return this.str.getRange();\r\n    }\r\n}\r\n\r\nexport abstract class OperatorToken extends ValueToken {\r\n    protected constructor(str: IndexedString, readonly precedence: number) {\r\n        super(str);\r\n    }\r\n}\r\n\r\nexport class LogicalNotToken extends OperatorToken {\r\n    constructor(operator: IndexedString) {\r\n        super(operator, precedenceNot);\r\n    }\r\n}\r\n\r\nexport class LogicalAndToken extends OperatorToken {\r\n    constructor(operator: IndexedString) {\r\n        super(operator, precedenceAnd);\r\n    }\r\n}\r\n\r\nexport class LogicalOrToken extends OperatorToken {\r\n    constructor(operator: IndexedString) {\r\n        super(operator, precedenceOr);\r\n    }\r\n}\r\n\r\nexport class ComputingMultiplicationToken extends OperatorToken {\r\n    constructor(operator: IndexedString) {\r\n        super(operator, precedenceMulDiv);\r\n    }\r\n}\r\n\r\nexport class ComputingDivisionToken extends OperatorToken {\r\n    constructor(operator: IndexedString) {\r\n        super(operator, precedenceMulDiv);\r\n    }\r\n}\r\n\r\nexport class ComputingPlusToken extends OperatorToken {\r\n    constructor(operator: IndexedString) {\r\n        super(operator, precedencePlusMinus);\r\n    }\r\n}\r\n\r\nexport class ComputingMinusToken extends OperatorToken {\r\n    constructor(operator: IndexedString) {\r\n        super(operator, precedencePlusMinus);\r\n    }\r\n}\r\n\r\nexport class ComparingToken extends OperatorToken {\r\n    constructor(readonly type: ComparingOperatorType, operator: IndexedString) {\r\n        super(operator, precedenceComparison);\r\n    }\r\n}\r\n\r\nexport abstract class ParenthesisToken extends ValueToken {\r\n    protected constructor(operator: IndexedString) {\r\n        super(operator);\r\n    }\r\n}\r\n\r\nexport class OpeningParentheses extends ParenthesisToken {\r\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\r\n    constructor(operator: IndexedString) {\r\n        super(operator);\r\n    }\r\n}\r\n\r\nexport class ClosingParentheses extends ParenthesisToken {\r\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\r\n    constructor(operator: IndexedString) {\r\n        super(operator);\r\n    }\r\n}\r\n\r\nexport class LiteralToken extends ValueToken {\r\n    constructor(str: IndexedString, readonly value: ColumnContent, readonly type: SupportedColumnType | \"null\") {\r\n        super(str);\r\n    }\r\n}\r\n\r\nexport class ReferenceToken extends ValueToken {\r\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\r\n    constructor(columnName: IndexedString) {\r\n        super(columnName);\r\n    }\r\n}","import StringUtils from \"../utils/stringUtils\";\r\nimport {ComparingOperator, ComparingOperatorType} from \"../vetree/comparingOperator\";\r\nimport {LogicalOperator} from \"../vetree/logicalOperator\";\r\nimport {LiteralValue} from \"../vetree/literalValue\";\r\nimport {ReferenceValue} from \"../vetree/referenceValue\";\r\nimport {ComputingOperator} from \"../vetree/computingOperator\";\r\nimport {\r\n    ClosingParentheses,\r\n    ComparingToken,\r\n    ComputingDivisionToken,\r\n    ComputingMinusToken,\r\n    ComputingMultiplicationToken,\r\n    ComputingPlusToken,\r\n    LiteralToken,\r\n    LogicalAndToken,\r\n    LogicalNotToken,\r\n    LogicalOrToken,\r\n    OpeningParentheses,\r\n    OperatorToken,\r\n    ParenthesisToken,\r\n    ReferenceToken,\r\n    ValueToken\r\n} from \"./valueTokens\"\r\nimport {VETreeNode} from \"../vetree/veTreeNode\";\r\nimport {IndexedString} from \"../types/indexedString\";\r\nimport IndexedStringUtils from \"../utils/indexedStringUtils\";\r\nimport ErrorWithTextRange, {insertRangeIfUndefined} from \"../error/errorWithTextRange\";\r\nimport {ErrorFactory} from \"../error/errorFactory\";\r\nimport RASyntaxError from \"../error/raSyntaxError\";\r\nimport {language} from \"../language/language\";\r\n\r\n/**\r\n * StringUtils of string infix boolean and algebraic expression to value-evaluating tree.\r\n */\r\nexport default class ValueParser {\r\n\r\n    /**\r\n     * Parses given string infix boolean and algebraic expression into a value-evaluating tree and returns the tree.\r\n     * Uses Shunting-yard algorithm (first, it transforms the string into reverse polish notation).\r\n     * Supported expressions:\r\n     * - logical: and (&&, &), or (||, |), not (!, ~)\r\n     * - computing: addition (+), deduction (-), multiplication (*), division (/)\r\n     * - comparing: equal (==, =), non-equal (!=, <>), less (<), more (>), less-or-equal (<=), more-or-equal (>=)\r\n     * - literals: numbers (1, 5.02, etc.), strings (\"String\", \"With inner \\\" symbol\", etc.), nulls (null),\r\n     * booleans (true, false)\r\n     * - column references (ColumnNameAsStringWithoutQuotes, Id, etc.)\r\n     *\r\n     * @param str infix boolean and algebraic expression to be parsed\r\n     * @param nullValuesSupport whether null values are supported\r\n     * @return VETreeNode tree (its root)\r\n     */\r\n    public static parse(str: IndexedString, nullValuesSupport: boolean): VETreeNode {\r\n        let tokens: ValueToken[] = ValueParser.parseTokens(str, nullValuesSupport, true);\r\n        this.assertValidInfixTokens(tokens, true);\r\n        tokens = this.simplify(tokens);\r\n        try {\r\n            const rpn: ValueToken[] = ValueParser.toRPN(tokens);\r\n            return ValueParser.rpnToVETree(rpn);\r\n        }\r\n        catch (err) {\r\n            throw insertRangeIfUndefined(err, str.getRange());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses given string infix boolean and algebraic expression and returns errors in it.\r\n     * For supported operations see ValueParser.parse().\r\n     *\r\n     * @param str infix boolean and algebraic expression to be parsed\r\n     * @param nullValuesSupport whether null values are supported\r\n     * @param columns\r\n     */\r\n    public static fakeParse(str: IndexedString, nullValuesSupport: boolean, columns: string[]): ErrorWithTextRange[] {\r\n        const errors: ErrorWithTextRange[] = [];\r\n        let tokens: ValueToken[] = ValueParser.parseTokens(str, nullValuesSupport, false, errors);\r\n        tokens.forEach(token => {\r\n            if (token instanceof ReferenceToken && columns.indexOf(token.str.toString()) === -1) {\r\n                errors.push(ErrorFactory.semanticError(language().semanticErrors.referenceValue_absentColumn,\r\n                    token.str.getRange(), token.str.toString(), columns.join(', ')));\r\n            }\r\n        })\r\n        this.assertValidInfixTokens(tokens, false, errors);\r\n        return errors;\r\n    }\r\n\r\n    /**\r\n     * Parses given string infix boolean and algebraic expression into an array of Tokens.\r\n     * Tokens are returned infix (in order parsed from string).\r\n     * If doThrow is true, found errors are thrown. Otherwise, they are added in errors array and ignored.\r\n     *\r\n     * @param str infix boolean and algebraic expression to be parsed\r\n     * @param nullValuesSupport whether null values are supported\r\n     * @param doThrow true if errors should be thrown\r\n     * @param errors array for storing not thrown errors\r\n     * @return infix array of parsed Tokens\r\n     */\r\n    public static parseTokens(str: IndexedString, nullValuesSupport: boolean, doThrow: boolean,\r\n                              errors: ErrorWithTextRange[] = []): ValueToken[] {\r\n        const handleError = (error: RASyntaxError) => {\r\n            if (doThrow) {\r\n                throw error;\r\n            }\r\n            else {\r\n                errors.push(error);\r\n            }\r\n        }\r\n        let rest: IndexedString = str.trim();\r\n        if (rest.isEmpty()) {\r\n            handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_emptyInput, undefined));\r\n        }\r\n        const tokens: ValueToken[] = [];\r\n        while (!rest.isEmpty()) {\r\n            // PARENTHESES\r\n            if (rest.startsWith('(')) {\r\n                tokens.push(new OpeningParentheses(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            else if (rest.startsWith(')')) {\r\n                tokens.push(new ClosingParentheses(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            // COMPUTING OPERATORS\r\n            else if (rest.startsWith('+')) {\r\n                tokens.push(new ComputingPlusToken(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            else if (rest.startsWith('-')) {\r\n                tokens.push(new ComputingMinusToken(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            else if (rest.startsWith('*')) {\r\n                tokens.push(new ComputingMultiplicationToken(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            else if (rest.startsWith('/')) {\r\n                tokens.push(new ComputingDivisionToken(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            // COMPARING OPERATORS\r\n            else if (rest.startsWith('==')) {\r\n                tokens.push(new ComparingToken(ComparingOperatorType.equal, rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n            }\r\n            else if (rest.startsWith('=')) {     // NOTE: needs to be after '==' check\r\n                tokens.push(new ComparingToken(ComparingOperatorType.equal, rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            else if (rest.startsWith('!=')) {\r\n                tokens.push(new ComparingToken(ComparingOperatorType.nonEqual, rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n            }\r\n            else if (rest.startsWith('<>')) {\r\n                tokens.push(new ComparingToken(ComparingOperatorType.nonEqual, rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n            }\r\n            else if (rest.startsWith('<=')) {\r\n                tokens.push(new ComparingToken(ComparingOperatorType.lessOrEqual, rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n            }\r\n            else if (rest.startsWith('>=')) {\r\n                tokens.push(new ComparingToken(ComparingOperatorType.moreOrEqual, rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n            }\r\n            else if (rest.startsWith('<')) {\r\n                tokens.push(new ComparingToken(ComparingOperatorType.less, rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            else if (rest.startsWith('>')) {\r\n                tokens.push(new ComparingToken(ComparingOperatorType.more, rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            // LOGICAL OPERATORS\r\n            else if (rest.startsWith('!') || rest.startsWith('~')\r\n                || rest.startsWith('\\u00ac')) { // NOTE: needs to be after '!=' check\r\n                tokens.push(new LogicalNotToken(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            else if (rest.startsWith('&&')) {\r\n                tokens.push(new LogicalAndToken(rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n            }\r\n            else if (rest.startsWith('&') || rest.startsWith('\\u2227')) { // NOTE: needs to be after '&&' check\r\n                tokens.push(new LogicalAndToken(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            else if (rest.startsWith('||')) {\r\n                tokens.push(new LogicalOrToken(rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n            }\r\n            else if (rest.startsWith('|') || rest.startsWith('\\u2228')) { // NOTE: needs to be after '||' check\r\n                tokens.push(new LogicalOrToken(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            // LITERALS\r\n            else if (rest.startsWith('\"')) {\r\n                const split = IndexedStringUtils.nextQuotedString(rest);\r\n                if (split.error !== undefined) {\r\n                    handleError(split.error);\r\n                }\r\n                const end = split.first.length() > 1 ? -1 : undefined;\r\n                const str = split.first.slice(1, end);\r\n                tokens.push(new LiteralToken(str, str.toString(), \"string\"));\r\n                rest = split.second;\r\n            }\r\n            else if (StringUtils.isDigit(rest.charAt(0))) {\r\n                let split = IndexedStringUtils.nextNumber(rest);\r\n                tokens.push(new LiteralToken(split.first, Number(split.first.toString()), \"number\"));\r\n                rest = split.second;\r\n            }\r\n            else if (rest.startsWith('null')) {\r\n                if (!nullValuesSupport) {\r\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_unsupportedNull,\r\n                        rest.slice(0, 4).getRange()));\r\n                }\r\n                tokens.push(new LiteralToken(rest.slice(0, 4), null, \"null\"));\r\n                rest = rest.slice(4);\r\n            }\r\n            else if (rest.startsWith('true') || rest.startsWith('True') || rest.startsWith('TRUE')) {\r\n                tokens.push(new LiteralToken(rest.slice(0, 4), true, \"boolean\"));\r\n                rest = rest.slice(4);\r\n            }\r\n            else if (rest.startsWith('false') || rest.startsWith('False') || rest.startsWith('FALSE')) {\r\n                tokens.push(new LiteralToken(rest.slice(0, 5), false, \"boolean\"));\r\n                rest = rest.slice(5);\r\n            }\r\n            // COLUMN REFERENCE\r\n            else if (StringUtils.isLetter(rest.charAt(0)) || rest.charAt(0) === '_') {\r\n                let split = IndexedStringUtils.nextName(rest);\r\n                tokens.push(new ReferenceToken(split.first));\r\n                rest = split.second;\r\n            }\r\n            // UNEXPECTED PART\r\n            else {\r\n                const split = IndexedStringUtils.nextNonWhitespacePart(rest);\r\n                handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_unexpectedPart,\r\n                    split.first.getRange(), split.first.toString()));\r\n                rest = rest.slice(split.first.length());\r\n            }\r\n            rest = rest.trim();\r\n        }\r\n        return tokens;\r\n    }\r\n\r\n    /**\r\n     * It checks whether all adjacent pairs of tokens are possible and if the array start and end are valid\r\n     * (e.i., it starts with '(', literal, column reference or '!' and it ends with ')', literal or column reference).\r\n     * If doThrow is true, found errors are thrown. Otherwise, they are added in errors array and ignored.\r\n     */\r\n    public static assertValidInfixTokens(tokens: ValueToken[], doThrow: boolean, errors: ErrorWithTextRange[] = []) {\r\n        if (tokens.length === 0) {\r\n            return;\r\n        }\r\n        \r\n        const handleError = (error: RASyntaxError) => {\r\n            if (doThrow) {\r\n                throw error;\r\n            }\r\n            else {\r\n                errors.push(error);\r\n            }\r\n        }\r\n        \r\n        // checks start of an array: it must start with '(', literal, reference or '!'\r\n        // it cannot start with binary operator or ')'\r\n        if ((tokens[0] instanceof ClosingParentheses) || ((tokens[0] instanceof OperatorToken) && !(tokens[0] instanceof LogicalNotToken))) {\r\n            handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_invalidStart,\r\n                tokens[0].getRange(), tokens[0].str.toString()));\r\n        }\r\n        // checks end of an array: it must end with ')', literal or reference\r\n        // it cannot end with operator or '('\r\n        if ((tokens[tokens.length - 1] instanceof OpeningParentheses) || (tokens[tokens.length - 1] instanceof OperatorToken)) {\r\n            handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_invalidEnd,\r\n                tokens[tokens.length - 1].getRange(), tokens[tokens.length - 1].str.toString()));\r\n        }\r\n        // checks adjacent pairs of tokens\r\n        let i2: number = 1;\r\n        while (i2 < tokens.length) {\r\n            const token1: ValueToken = tokens[i2 - 1];\r\n            const token2: ValueToken = tokens[i2];\r\n            ++i2;\r\n\r\n            // valid predecessors: operator or '('\r\n            // invalid predecessors: literal, reference or ')'\r\n            if (token2 instanceof LiteralToken) {\r\n                if (token1 instanceof LiteralToken) {\r\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_literalAfterLiteral,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof ReferenceToken) {\r\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_literalAfterReference,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof ClosingParentheses) {\r\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_literalAfterClosing,\r\n                        token2.getRange(), token2.str.toString()));\r\n                }\r\n            }\r\n            // valid predecessors: operator or '('\r\n            // invalid predecessors: literal, reference or ')'\r\n            else if (token2 instanceof ReferenceToken) {\r\n                if (token1 instanceof LiteralToken) {\r\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_referenceAfterLiteral,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof ReferenceToken) {\r\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_referenceAfterReference,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof ClosingParentheses) {\r\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_referenceAfterClosing,\r\n                        token2.getRange(), token2.str.toString()));\r\n                }\r\n            }\r\n            // valid predecessors: operator or '('\r\n            // invalid predecessors: literal, reference or ')'\r\n            else if (token2 instanceof LogicalNotToken) {\r\n                if (token1 instanceof LiteralToken) {\r\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_notAfterLiteral,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof ReferenceToken) {\r\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_notAfterReference,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof ClosingParentheses) {\r\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_notAfterClosing,\r\n                        token2.getRange(), token2.str.toString()));\r\n                }\r\n            }\r\n            // valid predecessors: literal, reference or ')'\r\n            // invalid predecessors: operator or '('\r\n            else if (token2 instanceof OperatorToken /* only binary (without LogicalNotToken) */ ) {\r\n                if (token1 instanceof OperatorToken) {\r\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_binaryAfterOperator,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof OpeningParentheses) {\r\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_binaryAfterOpening,\r\n                        token2.getRange(), token2.str.toString()));\r\n                }\r\n            }\r\n            // valid predecessors: operator or '('\r\n            // invalid predecessors: literal, reference or ')'\r\n            else if (token2 instanceof OpeningParentheses) {\r\n                if (token1 instanceof LiteralToken) {\r\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_openingAfterLiteral,\r\n                        token2.getRange(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof ReferenceToken) {\r\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_openingAfterReference,\r\n                        token2.getRange(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof ClosingParentheses) {\r\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_openingAfterClosing,\r\n                        token2.getRange()));\r\n                }\r\n            }\r\n            // valid predecessors: literal or reference\r\n            // invalid predecessors: operator, '(' or ')'\r\n            else if (token2 instanceof ClosingParentheses) {\r\n                if (token1 instanceof OperatorToken) {\r\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_closingAfterOperator,\r\n                        token2.getRange(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof OpeningParentheses) {\r\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_closingAfterOpening,\r\n                        token2.getRange()));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Simplifies given token array in infix form. That means all groups of LogicalNotTokens ('!') are reduced to 1 or 0\r\n     * tokens (\"!\" => \"!\", \"!!\" => \"\", \"!!!\" => \"!\", \"!!!!\" => \"\", ...).\r\n     *\r\n     * @param tokens tokens to simplify\r\n     */\r\n    public static simplify(tokens: ValueToken[]): ValueToken[] {\r\n        const notIndexes: number[] = [];\r\n        const indexesToRemove: Set<number> = new Set<number>();\r\n        // finds indexes in tokens where '!'s are\r\n        tokens.forEach((token, i) => {\r\n            if (token instanceof LogicalNotToken) {\r\n                notIndexes.push(i);\r\n            }\r\n        });\r\n        for (let i = 1; i < notIndexes.length; ++i) {\r\n            // if there is \"x - 1\" and \"x\" next to each other, adds them to remove\r\n            if (notIndexes[i - 1] + 1 === notIndexes[i]) {\r\n                indexesToRemove.add(notIndexes[i - 1]);\r\n                indexesToRemove.add(notIndexes[i]);\r\n                notIndexes[i] = NaN; // sets to NaN to not remove possible third '!' in a row\r\n            }\r\n        }\r\n        if (indexesToRemove.size === 0) {\r\n            return tokens;\r\n        }\r\n        return tokens.filter((t, i) => !indexesToRemove.has(i));\r\n    }\r\n\r\n    /**\r\n     * Transforms given infix boolean and algebraic expression into postfix (reverse polish) form.\r\n     *\r\n     * @param tokens infix boolean and algebraic expression as Token array\r\n     * @return postfix (reverse polish) form of given array\r\n     */\r\n    public static toRPN(tokens: ValueToken[]): ValueToken[] {\r\n        const rpnQueue: ValueToken[] = [];\r\n        const operatorsStack: Array<OperatorToken | ParenthesisToken> = [];\r\n        tokens.forEach(token => {\r\n            if (token instanceof LiteralToken || token instanceof ReferenceToken) {\r\n                rpnQueue.push(token);\r\n            }\r\n            else if (token instanceof OperatorToken) {\r\n                while (operatorsStack.length > 0 && operatorsStack[operatorsStack.length - 1] instanceof OperatorToken) {\r\n                    // @ts-ignore (token must be of OperatorToken class)\r\n                    let other: OperatorToken = operatorsStack[operatorsStack.length - 1];\r\n                    // all used operators have left associativity\r\n                    if (token.precedence <= other.precedence) {\r\n                        // @ts-ignore (token must be present)\r\n                        rpnQueue.push(operatorsStack.pop());\r\n                    }\r\n                    else {\r\n                        break;\r\n                    }\r\n                }\r\n                operatorsStack.push(token);\r\n            }\r\n            else if (token instanceof OpeningParentheses) {\r\n                operatorsStack.push(token);\r\n            }\r\n            else if (token instanceof ClosingParentheses) {\r\n                while (true) {\r\n                    if (operatorsStack.length === 0) {\r\n                        throw ErrorFactory.syntaxError(language().syntaxErrors.valueParser_missingOpeningParenthesis,\r\n                            undefined);\r\n                    }\r\n                    if (operatorsStack[operatorsStack.length - 1] instanceof OpeningParentheses) {\r\n                        operatorsStack.pop();\r\n                        break;\r\n                    }\r\n                    // @ts-ignore (token must be present)\r\n                    rpnQueue.push(operatorsStack.pop());\r\n                }\r\n            }\r\n        });\r\n        while (operatorsStack.length > 0) {\r\n            // @ts-ignore (token must be present)\r\n            const curToken: ValueToken = operatorsStack.pop();\r\n            if (curToken instanceof OpeningParentheses) {\r\n                throw ErrorFactory.syntaxError(language().syntaxErrors.valueParser_missingClosingParenthesis,\r\n                    undefined);\r\n            }\r\n            else {\r\n                rpnQueue.push(curToken);\r\n            }\r\n        }\r\n        return rpnQueue;\r\n    }\r\n\r\n    /**\r\n     * Creates a value-evaluating tree from the given array of tokens in reverse polish form.\r\n     * Wraps recursive function rpnToVETreeRecursive(tokens), when not all tokens are used, throws error.\r\n     *\r\n     * @param tokens value-evaluating expression in reverse polish form\r\n     * @return VETreeNode tree (its root)\r\n     */\r\n    public static rpnToVETree(tokens: ValueToken[]): VETreeNode {\r\n        const ret: VETreeNode = this.rpnToVETreeRecursive(tokens);\r\n        // not all tokens were used\r\n        if (tokens.length > 0) {\r\n            throw ErrorFactory.syntaxError(language().syntaxErrors.valueParser_invalidExpression, undefined);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Creates a value-evaluating tree from the given array of tokens in reverse polish form.\r\n     *\r\n     * @param tokens value-evaluating expression in reverse polish form\r\n     * @return VETreeNode tree (its root)\r\n     */\r\n    public static rpnToVETreeRecursive(tokens: ValueToken[]): VETreeNode {\r\n        if (tokens.length === 0) {\r\n            throw ErrorFactory.syntaxError(language().syntaxErrors.valueParser_invalidExpression, undefined);\r\n        }\r\n        // @ts-ignore (there must be a token)\r\n        const token: ValueToken = tokens.pop();\r\n        if (token instanceof LogicalNotToken) {\r\n            const subtree: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            return LogicalOperator.not(token.str, subtree);\r\n        }\r\n        if (token instanceof LogicalAndToken) {\r\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            return LogicalOperator.and(token.str, left, right);\r\n        }\r\n        if (token instanceof LogicalOrToken) {\r\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            return LogicalOperator.or(token.str, left, right);\r\n        }\r\n        if (token instanceof ComparingToken) {\r\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            return new ComparingOperator(token.type, token.str, left, right);\r\n        }\r\n        if (token instanceof LiteralToken) {\r\n            return new LiteralValue(token.value, token.type);\r\n        }\r\n        if (token instanceof ReferenceToken) {\r\n            return new ReferenceValue(token.str);\r\n        }\r\n        if (token instanceof ComputingPlusToken) {\r\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            return ComputingOperator.add(left, right, token.getRange());\r\n        }\r\n        if (token instanceof ComputingMinusToken) {\r\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            return ComputingOperator.deduct(left, right, token.getRange());\r\n        }\r\n        if (token instanceof ComputingMultiplicationToken) {\r\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            return ComputingOperator.multiply(left, right, token.getRange());\r\n        }\r\n        if (token instanceof ComputingDivisionToken) {\r\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            return ComputingOperator.divide(left, right, token.getRange());\r\n        }\r\n        // should never happen\r\n        throw ErrorFactory.codeError(language().codeErrors.valueParser_unexpectedToken, JSON.stringify(token));\r\n    }\r\n}","import RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\n\r\n/**\r\n * Classes extending binary node.\r\n */\r\nexport type BinaryNodeClass = \"left antijoin\" | \"right antijoin\" | \"cartesian product\" | \"division\" | \"natural join\"\r\n    | \"left outer join\" | \"right outer join\" | \"full outer join\" | \"left semijoin\" | \"right semijoin\" | \"union\"\r\n    | \"intersection\" | \"difference\" | \"theta join\" | \"left theta semijoin\" | \"right theta semijoin\";\r\n\r\n/**\r\n * Abstract node of the relational algebra syntactic tree with two subtrees.\r\n */\r\nexport default abstract class BinaryNode extends RATreeNode {\r\n\r\n    protected leftSubtree: RATreeNode;\r\n    protected rightSubtree: RATreeNode;\r\n\r\n    protected constructor(left: RATreeNode, right: RATreeNode) {\r\n        super();\r\n        this.leftSubtree = left;\r\n        this.rightSubtree = right;\r\n    }\r\n\r\n    public getLeftSubtree(): RATreeNode {\r\n        return this.leftSubtree;\r\n    }\r\n\r\n    public getRightSubtree(): RATreeNode {\r\n        return this.rightSubtree;\r\n    }\r\n\r\n    /**\r\n     * Fake evaluates left and right subtrees of the current not-parametrized binary node.\r\n     * If not, returns new simple faked schema with empty \"\" name:\r\n     * - type = union: returns union of source schemas\r\n     * - type = left: returns left source schema\r\n     * - type = right: returns right source schema\r\n     */\r\n    protected fakeEvalBinary(cursorIndex: number, type: \"union\" | \"left\" | \"right\"):\r\n        {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} {\r\n        // evaluates the subtrees\r\n        const left = this.leftSubtree.fakeEval(cursorIndex);\r\n        const right = this.rightSubtree.fakeEval(cursorIndex);\r\n        // creates return relation\r\n        const result: Relation = new Relation(\"\");\r\n        if (type === \"left\" || type === \"union\") {\r\n            left.result.forEachColumn((type, name) => result.addColumn(name, type));\r\n        }\r\n        if (type === \"right\" || type === \"union\") {\r\n            right.result.forEachColumn((type, name) => result.addColumn(name, type));\r\n        }\r\n        left.errors.push(...right.errors);\r\n        return {\r\n            result,\r\n            whispers: left.whispers.length !== 0 ? left.whispers : right.whispers,\r\n            errors: left.errors\r\n        };\r\n    }\r\n}","import RATreeNode from \"./raTreeNode\";\r\nimport UnaryNode from \"./unaryNode\";\r\nimport BinaryNode from \"./binaryNode\";\r\nimport {IndexedString} from \"../types/indexedString\";\r\nimport {StartEndPair} from \"../types/startEndPair\";\r\n\r\n/**\r\n * Finds the root in the given tree with the given index with respect to depth first search. Root has index 0.\r\n *\r\n * @param root root of the searched tree\r\n * @param index index to be found\r\n * @return found root with given index or null if not found\r\n */\r\nexport function depthSearch(root: RATreeNode, index: number): RATreeNode | null {\r\n    let i: number = 0;\r\n    const findIndexInTree = (node: RATreeNode): RATreeNode | null => {\r\n        // wanted index found\r\n        if (i === index) {\r\n            return node;\r\n        }\r\n        i++;\r\n        if (node instanceof UnaryNode) {\r\n            return findIndexInTree(node.getSubtree());\r\n        }\r\n        if (node instanceof BinaryNode) {\r\n            const leftSearch = findIndexInTree(node.getLeftSubtree());\r\n            if (leftSearch === null) {\r\n                return findIndexInTree(node.getRightSubtree());\r\n            }\r\n            return leftSearch;\r\n        }\r\n        // end of the branch without the result\r\n        return null;\r\n    }\r\n    return findIndexInTree(root);\r\n}\r\n\r\n/**\r\n * Computes depth of the tree. One node has depth 0.\r\n *\r\n * @param root root of the tree to compute the depth for\r\n * @return tree depth\r\n */\r\nexport function getTreeDepth(root: RATreeNode): number {\r\n    if (root instanceof BinaryNode) {\r\n        const left: number = getTreeDepth(root.getLeftSubtree());\r\n        const right: number = getTreeDepth(root.getRightSubtree());\r\n        return Math.max(left, right) + 1;\r\n    }\r\n    if (root instanceof UnaryNode) {\r\n        return getTreeDepth(root.getSubtree()) + 1;\r\n    }\r\n    return 0;\r\n}\r\n\r\n/**\r\n * Returns true, if the given cursor position is in the given range, it is not inside quotes, and the character at the\r\n * cursor position is present (i.e., was not removed as comment).\r\n * Note: given range is expected to be computed from given string.\r\n */\r\nexport function isInRangeAndNotInQuotes(cursor: number, range: StartEndPair | undefined, str: IndexedString): boolean {\r\n    if (range !== undefined && range.start < cursor && cursor <= range.end) {\r\n        const len = range.end - range.start;\r\n        const s = str.toString();\r\n        const cursorIndexInStr = cursor - range.start;\r\n        let insideQuotes: boolean = false;\r\n        let backslashes: number = 0;\r\n        for (let i = 0; i < len; ++i) {\r\n            const curChar = s.charAt(i);\r\n            // quotes found\r\n            if (curChar === '\"' && (backslashes % 2) === 0) {\r\n                insideQuotes = !insideQuotes;\r\n            }\r\n            if (insideQuotes && curChar === '\\\\') {\r\n                ++backslashes;\r\n            }\r\n            else {\r\n                backslashes = 0;\r\n            }\r\n            if (i === cursorIndexInStr - 1) {\r\n                // when the cursor was reached, returns true, if it is not in quotes and the position is present (was not removed as comment)\r\n                return !insideQuotes && str.getChars().some(c => c.index === cursor - 1);\r\n            }\r\n        }\r\n        console.warn(\"isInRangeAndNotInQuotes outside range\");\r\n    }\r\n    return false;\r\n}","import BinaryNode from \"./binaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport Row from \"../relation/row\";\r\nimport {language} from \"../language/language\";\r\n\r\n/**\r\n * Types of antijoin node.\r\n */\r\nexport enum AntijoinType {\r\n    left = \"\\u22b3\",\r\n    right = \"\\u22b2\"\r\n}\r\n\r\n/**\r\n * Antijoin node of the relational algebra syntactic tree.\r\n */\r\nexport default class AntijoinNode extends BinaryNode {\r\n\r\n    private readonly type: AntijoinType;\r\n\r\n    public constructor(operator: AntijoinType, leftSubtree: RATreeNode, rightSubtree: RATreeNode) {\r\n        super(leftSubtree, rightSubtree);\r\n        this.type = operator;\r\n    }\r\n\r\n    /**\r\n     * Expectations on source schemas: none\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n        const leftSource: Relation = this.leftSubtree.getResult();\r\n        const rightSource: Relation = this.rightSubtree.getResult();\r\n        // intersection of columns in left and right subtree\r\n        const commonColumns: string[] = leftSource.getColumnNames().filter(lc => rightSource.hasColumn(lc));\r\n        let rowsToKeep: Row[];   // rows from the subtree, which have to be kept in result\r\n        let rowsToHelp: Row[];\r\n        // change of relational schema\r\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + this.type + rightSource.getName() + \")\");\r\n        if (this.type === AntijoinType.left) {\r\n            leftSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n            rowsToKeep = leftSource.getRows();\r\n            rowsToHelp = rightSource.getRows();\r\n        }\r\n        else {\r\n            rightSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n            rowsToKeep = rightSource.getRows();\r\n            rowsToHelp = leftSource.getRows();\r\n        }\r\n        // join of relation rows\r\n        rowsToKeep.forEach(keptRow => {\r\n            let someMatch: boolean = rowsToHelp.some(helpRow => {\r\n                // if all common columns match, the row should not be added\r\n                return commonColumns.every(c => keptRow.getValue(c) === helpRow.getValue(c));\r\n            });\r\n            if (!someMatch) {\r\n                let newRow: Row = new Row(result.getColumns());\r\n                keptRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                result.addRow(newRow);\r\n            }\r\n        });\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: none\r\n     * Returned schema: left/right source schema (for left/right antijoin)\r\n     */\r\n    public fakeEval(cursorIndex: number) {\r\n        const type = this.type === AntijoinType.left ? \"left\" : \"right\";\r\n        return this.fakeEvalBinary(cursorIndex, type);\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return \"(\" + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + \")\";\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        const lang = language().operations;\r\n        return this.type === AntijoinType.left ? lang.leftAntijoin : lang.rightAntijoin;\r\n    }\r\n\r\n    public getOperationSymbol(): string {\r\n        return this.type;\r\n    }\r\n}","import UnaryNode from \"./unaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport {VETreeNode} from \"../vetree/veTreeNode\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\nimport {IndexedString} from \"../types/indexedString\";\r\nimport ValueParser from \"../expression/valueParser\";\r\nimport {ErrorFactory} from \"../error/errorFactory\";\r\nimport ErrorWithTextRange, {insertRangeIfUndefined} from \"../error/errorWithTextRange\";\r\nimport {isInRangeAndNotInQuotes} from \"./raTreeTools\";\r\nimport {language} from \"../language/language\";\r\nimport {StartEndPair} from \"../types/startEndPair\";\r\n\r\n/**\r\n * Selection node of the relational algebra syntactic tree.\r\n */\r\nexport default class SelectionNode extends UnaryNode {\r\n\r\n    private readonly selection: IndexedString;\r\n    private readonly stringRange: StartEndPair | undefined;\r\n    private readonly nullValuesSupport: boolean;\r\n\r\n    /**\r\n     * Expects the selection string to start with '(' and end with ')'.\r\n     *\r\n     * @param selection\r\n     * @param subtree\r\n     * @param nullValuesSupport\r\n     */\r\n    public constructor(selection: IndexedString, subtree: RATreeNode, nullValuesSupport: boolean) {\r\n        super(subtree);\r\n        this.selection = selection;\r\n        this.stringRange = selection.getRange();\r\n        this.nullValuesSupport = nullValuesSupport;\r\n    }\r\n\r\n    /**\r\n     * Expectations: condition is valid expression which evaluates to boolean\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n\r\n        let boolExpr: VETreeNode;\r\n        try {\r\n            boolExpr = ValueParser.parse(this.selection.slice(1, -1), this.nullValuesSupport);\r\n        }\r\n        catch (e) {\r\n            throw insertRangeIfUndefined(e, this.stringRange);\r\n        }\r\n\r\n        const source: Relation = this.subtree.getResult();\r\n        const result: Relation = new Relation(source.name + \"(...)\");\r\n        source.forEachColumn((type, name) => result.addColumn(name, type));\r\n\r\n        source.getRows().forEach(row => {\r\n            let bool: { value: ColumnContent, type: SupportedColumnType | \"null\" } = boolExpr.eval(row);\r\n            if (bool.type !== \"boolean\") {\r\n                throw ErrorFactory.syntaxError(language().syntaxErrors.selectionNode_resultNotBoolean,\r\n                    this.stringRange, this.selection.replace(/\\s+/g, \" \"), bool.type);\r\n            }\r\n            if (bool.value) {\r\n                result.addRow(row);\r\n            }\r\n        });\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: columns names used in the condition exists in source schema\r\n     * Returned schema: source schema\r\n     * Usage of absent column names does not affect returned schema.\r\n     */\r\n    public fakeEval(cursorIndex: number): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} {\r\n        let {result, whispers, errors} = this.subtree.fakeEval(cursorIndex);\r\n        const newResult = new Relation(result.getName() + \"(...)\");\r\n        result.forEachColumn((type, name) => {\r\n            newResult.addColumn(name, type);\r\n        });\r\n        result = newResult;\r\n        // checks whether the cursor is in this selection block (and not in the string) - saves current available columns\r\n        if (isInRangeAndNotInQuotes(cursorIndex, this.stringRange, this.selection)) {\r\n            whispers = result.getColumnNames();\r\n        }\r\n        // checks empty selection input\r\n        if (this.selection.toString().slice(1, -1).trim().length  === 0) {\r\n            errors.push(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_emptyInput, this.stringRange));\r\n        }\r\n        // adds errors from current expression\r\n        else {\r\n            errors.push(...ValueParser.fakeParse(this.selection.slice(1, -1), this.nullValuesSupport, result.getColumnNames()));\r\n        }\r\n        // result schema is the same as the source\r\n        return {result, whispers, errors};\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return this.subtree.printInLine() + this.getOperationSymbol();\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        return language().operations.selection;\r\n    }\r\n\r\n    public getOperationSymbol(): string {\r\n        return this.selection.replace(/\\s+/g, ' ');\r\n    }\r\n}","import BinaryNode from \"./binaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport Row from \"../relation/row\";\r\nimport {language} from \"../language/language\";\r\n\r\n/**\r\n * Types of outer join node.\r\n */\r\nexport enum OuterJoinType {\r\n    left = \"*L*\",\r\n    right = \"*R*\",\r\n    full = \"*F*\"\r\n}\r\n\r\n/**\r\n * Outer join node of the relational algebra syntactic tree.\r\n */\r\nexport default class OuterJoinNode extends BinaryNode {\r\n\r\n    private readonly type: OuterJoinType;\r\n\r\n    public constructor(operator: OuterJoinType, leftSubtree: RATreeNode, rightSubtree: RATreeNode) {\r\n        super(leftSubtree, rightSubtree);\r\n        this.type = operator;\r\n    }\r\n\r\n    /**\r\n     * Expectations on source schemas: none\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n        const leftSource: Relation = this.leftSubtree.getResult();\r\n        const rightSource: Relation = this.rightSubtree.getResult();\r\n        // change of relational schema\r\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + this.type + rightSource.getName() + \")\");\r\n        leftSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n        rightSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n        // join of relation rows\r\n        const leftRows: Row[] = leftSource.getRows();\r\n        const rightRows: Row[] = rightSource.getRows();\r\n        // intersection of columns in left and right subtree\r\n        const commonColumns: string[] = leftSource.getColumnNames().filter(lc => rightSource.hasColumn(lc));\r\n        // adds naturally joined rows\r\n        leftRows.forEach(leftRow => {\r\n            rightRows.forEach(rightRow => {\r\n                // if all common columns have the same value\r\n                if (commonColumns.every(c => leftRow.getValue(c) === rightRow.getValue(c))) {\r\n                    let newRow: Row = new Row(result.getColumns());\r\n                    leftRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                    rightRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                    result.addRow(newRow);\r\n                }\r\n            });\r\n        });\r\n        // adds left source rows with right null values\r\n        if (this.type === OuterJoinType.left || this.type === OuterJoinType.full) {\r\n            leftRows.forEach(leftRow => {\r\n                let someMatch: boolean = rightRows.some(rightRow => {\r\n                    // if all common columns match, the row should not be added\r\n                    return commonColumns.every(c => leftRow.getValue(c) === rightRow.getValue(c));\r\n                });\r\n                if (!someMatch) {\r\n                    let newRow: Row = new Row(result.getColumns());\r\n                    leftRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                    result.addRow(newRow);\r\n                }\r\n            });\r\n        }\r\n        // adds right source rows with left null values\r\n        if (this.type === OuterJoinType.right || this.type === OuterJoinType.full) {\r\n            rightRows.forEach(rightRow => {\r\n                let someMatch: boolean = leftRows.some(leftRow => {\r\n                    // if all common columns match, the row should not be added\r\n                    return commonColumns.every(c => leftRow.getValue(c) === rightRow.getValue(c));\r\n                });\r\n                if (!someMatch) {\r\n                    let newRow: Row = new Row(result.getColumns());\r\n                    rightRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                    result.addRow(newRow);\r\n                }\r\n            });\r\n        }\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: none\r\n     * Returned schema: union of source schemas (in all cases - full/left/right)\r\n     */\r\n    public fakeEval(cursorIndex: number) {\r\n        return this.fakeEvalBinary(cursorIndex, \"union\");\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return \"(\" + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + \")\";\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        const lang = language().operations;\r\n        if (this.type === OuterJoinType.left) {\r\n            return lang.leftOuterJoin;\r\n        }\r\n        else if (this.type === OuterJoinType.right) {\r\n            return lang.rightOuterJoin;\r\n        }\r\n        else {\r\n            return lang.fullOuterJoin;\r\n        }\r\n    }\r\n\r\n    public getOperationSymbol(): string {\r\n        return this.type;\r\n    }\r\n}","import BinaryNode from \"./binaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport Row from \"../relation/row\";\r\nimport {ErrorFactory} from \"../error/errorFactory\";\r\nimport {language} from \"../language/language\";\r\nimport {StartEndPair} from \"../types/startEndPair\";\r\n\r\n/**\r\n * Cartesian product node of the relational algebra syntactic tree.\r\n */\r\nexport default class CartesianProductNode extends BinaryNode {\r\n\r\n    public constructor(leftSubtree: RATreeNode, rightSubtree: RATreeNode, private stringRange: StartEndPair | undefined) {\r\n        super(leftSubtree, rightSubtree);\r\n    }\r\n\r\n    /**\r\n     * Expectations on source schemas: disjointness\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n        const leftSource: Relation = this.leftSubtree.getResult();\r\n        const rightSource: Relation = this.rightSubtree.getResult();\r\n        // join of relational schema\r\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + \"\\u2a2f\" + rightSource.getName() + \")\");\r\n        leftSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n        rightSource.forEachColumn((type, name) => {\r\n            if (!result.addColumn(name, type)) {\r\n                throw ErrorFactory.semanticError(language().semanticErrors.binaryNode_commonColumns,\r\n                    this.stringRange, \"cartesian product\", name);\r\n            }\r\n        });\r\n        // join of relation rows\r\n        leftSource.getRows().forEach(leftRow => {\r\n            rightSource.getRows().forEach(rightRow => {\r\n                let newRow: Row = new Row(result.getColumns());\r\n                leftRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                rightRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                result.addRow(newRow);\r\n            });\r\n        });\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: disjointness\r\n     * Returned schema: union of source schemas\r\n     * Returned fake schema is not affected when disjointness is not held\r\n     */\r\n    public fakeEval(cursorIndex: number) {\r\n        // evaluates the subtrees\r\n        const left = this.leftSubtree.fakeEval(cursorIndex);\r\n        const right = this.rightSubtree.fakeEval(cursorIndex);\r\n        // creates return relation\r\n        const result: Relation = new Relation(\"\");\r\n        left.result.forEachColumn((type, name) => result.addColumn(name, type));\r\n        right.result.forEachColumn((type, name) => result.addColumn(name, type));\r\n        // checks errors\r\n        left.errors.push(...right.errors);\r\n        const commonColumns: string[] = [];\r\n        left.result.getColumnNames().forEach(leftColumn => {\r\n            if (right.result.hasColumn(leftColumn)) {\r\n                commonColumns.push(leftColumn);\r\n            }\r\n        });\r\n        if (commonColumns.length > 0) {\r\n            left.errors.push(ErrorFactory.semanticError(language().semanticErrors.binaryNode_commonColumns,\r\n                this.stringRange, \"cartesian product\", commonColumns.join('\", \"')));\r\n        }\r\n        return {\r\n            result,\r\n            whispers: left.whispers.length !== 0 ? left.whispers : right.whispers,\r\n            errors: left.errors\r\n        };\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return \"(\" + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + \")\";\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        return language().operations.cartesianProduct;\r\n    }\r\n\r\n    public getOperationSymbol(): string {\r\n        return \"⨯\";\r\n    }\r\n}","import BinaryNode from \"./binaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport Row from \"../relation/row\";\r\nimport {SupportedColumnType} from \"../relation/columnType\";\r\nimport {ErrorFactory} from \"../error/errorFactory\";\r\nimport {language} from \"../language/language\";\r\nimport {StartEndPair} from \"../types/startEndPair\";\r\n\r\n/**\r\n * Division node of the relational algebra syntactic tree.\r\n */\r\nexport default class DivisionNode extends BinaryNode {\r\n\r\n    public constructor(leftSubtree: RATreeNode, rightSubtree: RATreeNode, private stringRange: StartEndPair | undefined) {\r\n        super(leftSubtree, rightSubtree);\r\n    }\r\n\r\n    /**\r\n     * Expectations on source schemas: right source schema is a proper subset of left source schema\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n        const leftSource: Relation = this.leftSubtree.getResult();\r\n        const rightSource: Relation = this.rightSubtree.getResult();\r\n        const leftColumns: Map<string, SupportedColumnType> = leftSource.getColumns();\r\n        const rightColumns: Map<string, SupportedColumnType> = rightSource.getColumns();\r\n\r\n        if (![...rightColumns].every(value => leftColumns.has(value[0]) && leftColumns.get(value[0]) === value[1])) {\r\n            throw ErrorFactory.semanticError(language().semanticErrors.divisionNode_rightColumnsNotSubset,\r\n                this.stringRange, rightSource.getSchemaString(), leftSource.getSchemaString());\r\n        }\r\n\r\n        // difference of columns in left and right subtree\r\n        const resultColumns: Map<string, SupportedColumnType> = new Map<string, SupportedColumnType>();\r\n        leftColumns.forEach((type, name) => {\r\n           if (!rightColumns.has(name)) {\r\n               resultColumns.set(name, type);\r\n           }\r\n        });\r\n\r\n        if (resultColumns.size === 0) {\r\n            throw ErrorFactory.semanticError(language().semanticErrors.divisionNode_rightColumnsNotProperSubset,\r\n                this.stringRange, rightSource.getNamesSchemaString(), leftSource.getNamesSchemaString());\r\n        }\r\n\r\n        // join of relational schema\r\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + \"\\u00f7\" + rightSource.getName() + \")\");\r\n        resultColumns.forEach((type, name) => result.addColumn(name, type));\r\n        // filter relation rows\r\n        const leftRows: Row[] = leftSource.getRows();\r\n        const rightRows: Row[] = rightSource.getRows();\r\n        leftRows.forEach(leftRow => {\r\n           if (rightRows.every(rightRow => {\r\n               // creates a row with left row's extra columns and right row's common columns\r\n               let testRow: Row = new Row(leftColumns);\r\n               // left row's extra columns\r\n               // @ts-ignore ('name' must be present in left row)\r\n               resultColumns.forEach((type, name) => testRow.addValue(name, leftRow.getValue(name)));\r\n               // right row's common columns\r\n               rightRow.getValues().forEach((type, name) => testRow.addValue(name, type));\r\n               // tests if the created row exists in left relation\r\n               return [...leftRows].some(lr => lr.equals(testRow));\r\n           })) {\r\n               let newRow: Row = new Row(result.getColumns());\r\n               // @ts-ignore ('name' must be present in left row)\r\n               resultColumns.forEach((value, name) => newRow.addValue(name, leftRow.getValue(name)));\r\n               result.addRow(newRow);\r\n           }\r\n        });\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: right source schema is a proper subset of left source schema\r\n     * Returned schema: left source schema minus right source schema\r\n     * Returned fake schema may be empty (right source schema may contain all left source columns).\r\n     */\r\n    public fakeEval(cursorIndex: number) {\r\n        const left = this.leftSubtree.fakeEval(cursorIndex);\r\n        const right = this.rightSubtree.fakeEval(cursorIndex);\r\n        const leftColumns = left.result.getColumns();\r\n        const rightColumns = right.result.getColumns();\r\n        // creates relation schema - \"left columns minus right columns\"\r\n        const resultColumns = new Map([...leftColumns.entries()].filter(([key, _]) => !rightColumns.has(key)));\r\n        const result = new Relation(\"(\" + left.result.getName() + \"\\u00f7\" + right.result.getName() + \")\");\r\n        resultColumns.forEach((type, name) => result.addColumn(name, type));\r\n        // checks errors in schema\r\n        const errors = left.errors;\r\n        errors.push(...right.errors);\r\n        if (![...rightColumns].every(value => leftColumns.has(value[0]) && leftColumns.get(value[0]) === value[1])\r\n            && left.result.getName() !== \"\") {\r\n            errors.push(ErrorFactory.semanticError(language().semanticErrors.divisionNode_rightColumnsNotSubset,\r\n                this.stringRange, right.result.getSchemaString(), left.result.getSchemaString()));\r\n        }\r\n        else if (resultColumns.size === 0 && left.result.getName() !== \"\") {\r\n            errors.push(ErrorFactory.semanticError(language().semanticErrors.divisionNode_rightColumnsNotProperSubset,\r\n                this.stringRange, right.result.getNamesSchemaString(), left.result.getNamesSchemaString()));\r\n        }\r\n        return {\r\n            result,\r\n            whispers: left.whispers.length !== 0 ? left.whispers : right.whispers,\r\n            errors: left.errors\r\n        };\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return \"(\" + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + \")\";\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        return language().operations.division;\r\n    }\r\n\r\n    public getOperationSymbol(): string {\r\n        return \"÷\";\r\n    }\r\n}","import BinaryNode from \"./binaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport Row from \"../relation/row\";\r\nimport {language} from \"../language/language\";\r\n\r\n/**\r\n * Types of natural join node.\r\n */\r\nexport enum NaturalJoinType {\r\n    natural = \"*\",\r\n    leftSemi = \"<*\",\r\n    rightSemi = \"*>\"\r\n}\r\n\r\n/**\r\n * Natural join or semi join node of the relational algebra syntactic tree.\r\n */\r\nexport default class NaturalJoinNode extends BinaryNode {\r\n\r\n    private readonly type: NaturalJoinType;\r\n\r\n    public constructor(operator: NaturalJoinType, leftSubtree: RATreeNode, rightSubtree: RATreeNode) {\r\n        super(leftSubtree, rightSubtree);\r\n        this.type = operator;\r\n    }\r\n\r\n    /**\r\n     * Expectations on source schemas: none\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n        const leftSource: Relation = this.leftSubtree.getResult();\r\n        const rightSource: Relation = this.rightSubtree.getResult();\r\n        // intersection of columns in left and right subtree\r\n        const commonColumns: string[] = leftSource.getColumnNames().filter(lc => rightSource.hasColumn(lc));\r\n        // change of relational schema\r\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + this.type + rightSource.getName() + \")\");\r\n        if (this.type === NaturalJoinType.leftSemi || this.type === NaturalJoinType.natural) {\r\n            leftSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n        }\r\n        if (this.type === NaturalJoinType.rightSemi || this.type === NaturalJoinType.natural) {\r\n            rightSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n        }\r\n        // join of relation rows\r\n        leftSource.getRows().forEach(leftRow => {\r\n            rightSource.getRows().forEach(rightRow => {\r\n                // if all common columns have the same value\r\n                if ([...commonColumns].every(c => leftRow.getValue(c) === rightRow.getValue(c))) {\r\n                    let newRow: Row = new Row(result.getColumns());\r\n                    if (this.type === NaturalJoinType.leftSemi || this.type === NaturalJoinType.natural) {\r\n                        leftRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                    }\r\n                    if (this.type === NaturalJoinType.rightSemi || this.type === NaturalJoinType.natural) {\r\n                        rightRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                    }\r\n                    result.addRow(newRow);\r\n                }\r\n            });\r\n        });\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: none\r\n     * Returned schema: left/right/both source schema (for left-semijoin/right-semijoin/natural join)\r\n     */\r\n    public fakeEval(cursorIndex: number) {\r\n        let type: \"union\" | \"left\" | \"right\" = \"union\";\r\n        if (this.type === NaturalJoinType.leftSemi) {\r\n            type = \"left\";\r\n        }\r\n        else if (this.type === NaturalJoinType.rightSemi) {\r\n            type = \"right\";\r\n        }\r\n        return this.fakeEvalBinary(cursorIndex, type);\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return \"(\" + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + \")\";\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        const lang = language().operations;\r\n        if (this.type === NaturalJoinType.leftSemi) {\r\n            return lang.leftSemiJoin;\r\n        }\r\n        else if (this.type === NaturalJoinType.rightSemi) {\r\n            return lang.rightSemiJoin;\r\n        }\r\n        else {\r\n            return lang.naturalJoin;\r\n        }\r\n    }\r\n\r\n    public getOperationSymbol(): string {\r\n        return \"*\";\r\n    }\r\n\r\n    public getType(): NaturalJoinType {\r\n        return this.type;\r\n    }\r\n}","import BinaryNode from \"./binaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport Row from \"../relation/row\";\r\nimport { isEqual } from \"lodash\";\r\nimport {ErrorFactory} from \"../error/errorFactory\";\r\nimport {language} from \"../language/language\";\r\nimport {StartEndPair} from \"../types/startEndPair\";\r\n\r\n/**\r\n * Types of set operation node.\r\n */\r\nexport enum SetOperationType {\r\n    union = \"\\u222a\",\r\n    intersection = \"\\u2229\",\r\n    difference = \"\\\\\"\r\n}\r\n\r\n/**\r\n * Set operation node of the relational algebra syntactic tree.\r\n */\r\nexport default class SetOperationNode extends BinaryNode {\r\n\r\n    private readonly type: SetOperationType;\r\n\r\n    public constructor(operator: SetOperationType, leftSubtree: RATreeNode, rightSubtree: RATreeNode,\r\n                       private stringRange: StartEndPair | undefined) {\r\n        super(leftSubtree, rightSubtree);\r\n        this.type = operator;\r\n    }\r\n\r\n    /**\r\n     * Expectations on source schemas: equality\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n        const leftSource: Relation = this.leftSubtree.getResult();\r\n        const rightSource: Relation = this.rightSubtree.getResult();\r\n\r\n        if (!isEqual(leftSource.getColumns(), rightSource.getColumns())) {\r\n            let typeStr: string = this.getOperationName().toLowerCase();\r\n            throw ErrorFactory.semanticError(language().semanticErrors.setOperationNode_notEqualColumns,\r\n                this.stringRange, leftSource.getSchemaString(), rightSource.getSchemaString(), typeStr);\r\n        }\r\n        // copy of relational schema\r\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + this.type + rightSource.getName() + \")\");\r\n        leftSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n        // change of relation rows\r\n        let resultRows: Row[];\r\n        const leftRows: Row[] = leftSource.getRows();\r\n        const rightRows: Row[] = rightSource.getRows();\r\n        if (this.type === SetOperationType.union) {\r\n            resultRows = [...leftRows, ...rightRows];\r\n        }\r\n        else if (this.type === SetOperationType.intersection) {\r\n            resultRows = [...leftRows].filter(lr => [...rightRows].some(rr => lr.equals(rr)));\r\n        }\r\n        else /* this.type === SetOperationType.difference */ {\r\n            resultRows = [...leftRows].filter(lr => ![...rightRows].some(rr => lr.equals(rr)));\r\n        }\r\n        resultRows.forEach(row => result.addRow(row));\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: equality\r\n     * Returned schema: intersection of source schemas\r\n     * Returned schema may be empty (when there is no common column in sources).\r\n     * Second possible approach would be to return union of source schemas (less strict).\r\n     */\r\n    public fakeEval(cursorIndex: number) {\r\n        const left = this.leftSubtree.fakeEval(cursorIndex);\r\n        const right = this.rightSubtree.fakeEval(cursorIndex);\r\n        // join of relational schema - \"left intersection right\"\r\n        const result: Relation = new Relation(\"(\" + left.result.getName() + this.type + right.result.getName() + \")\");\r\n        left.result.forEachColumn((type, name) => {\r\n            if (right.result.hasColumn(name)) {\r\n                result.addColumn(name, type);\r\n            }\r\n        });\r\n        // checks errors in schema\r\n        const errors = left.errors;\r\n        errors.push(...right.errors);\r\n        if (!isEqual(left.result.getColumns(), right.result.getColumns()) && left.result.getName() !== \"\" && right.result.getName() !== \"\") {\r\n            let typeStr: string = this.getOperationName().toLowerCase();\r\n            errors.push(ErrorFactory.semanticError(language().semanticErrors.setOperationNode_notEqualColumns,\r\n                this.stringRange, left.result.getSchemaString(), right.result.getSchemaString(), typeStr));\r\n        }\r\n        return {\r\n            result,\r\n            whispers: left.whispers.length !== 0 ? left.whispers : right.whispers,\r\n            errors: left.errors\r\n        };\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return \"(\" + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + \")\";\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        const lang = language().operations;\r\n        if (this.type === SetOperationType.union) {\r\n            return lang.union;\r\n        }\r\n        else if (this.type === SetOperationType.intersection) {\r\n            return lang.intersection;\r\n        }\r\n        else {\r\n            return lang.difference;\r\n        }\r\n    }\r\n\r\n    public getOperationSymbol(): string {\r\n        return this.type;\r\n    }\r\n}","import BinaryNode from \"./binaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport Row from \"../relation/row\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\nimport {VETreeNode} from \"../vetree/veTreeNode\";\r\nimport {IndexedString} from \"../types/indexedString\";\r\nimport ValueParser from \"../expression/valueParser\";\r\nimport {ErrorFactory} from \"../error/errorFactory\";\r\nimport {insertRangeIfUndefined} from \"../error/errorWithTextRange\";\r\nimport {isInRangeAndNotInQuotes} from \"./raTreeTools\";\r\nimport {language} from \"../language/language\";\r\nimport {StartEndPair} from \"../types/startEndPair\";\r\n\r\n/**\r\n * Types of theta join node.\r\n */\r\nexport enum ThetaJoinType {\r\n    full = \"[]\",\r\n    left = \"<]\",\r\n    right = \"[>\"\r\n}\r\n\r\n/**\r\n * Theta join or theta semijoin node of the relational algebra syntactic tree.\r\n */\r\nexport default class ThetaJoinNode extends BinaryNode {\r\n\r\n    private readonly type: ThetaJoinType;\r\n    private readonly condition: IndexedString;\r\n    private readonly stringRange: StartEndPair | undefined;\r\n    private readonly nullValuesSupport: boolean;\r\n\r\n    /**\r\n     * Expects the condition string to start with '<' and end with ']' or start with '[' and end with '>'.\r\n     */\r\n    public constructor(type: ThetaJoinType, condition: IndexedString,\r\n                       leftSubtree: RATreeNode, rightSubtree: RATreeNode, nullValuesSupport: boolean) {\r\n        super(leftSubtree, rightSubtree);\r\n        this.condition = condition;\r\n        this.stringRange = condition.getRange();\r\n        this.nullValuesSupport = nullValuesSupport;\r\n        this.type = type;\r\n    }\r\n\r\n    /**\r\n     * Expectations on source schemas: disjointness\r\n     * Other expectations: condition is valid expression which evaluates to boolean\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n\r\n        let boolExpr: VETreeNode;\r\n        try {\r\n            boolExpr = ValueParser.parse(this.condition.slice(1, -1), this.nullValuesSupport);   // slices brackets out\r\n        }\r\n        catch (e) {\r\n            throw insertRangeIfUndefined(e, this.stringRange);\r\n        }\r\n\r\n        const leftSource: Relation = this.leftSubtree.getResult();\r\n        const rightSource: Relation = this.rightSubtree.getResult();\r\n\r\n        leftSource.getColumnNames().forEach(leftColumn => {\r\n            if (rightSource.hasColumn(leftColumn)) {\r\n                throw ErrorFactory.semanticError(language().semanticErrors.binaryNode_commonColumns, this.stringRange,\r\n                    this.getOperationName().toLowerCase(), leftColumn);\r\n            }\r\n        });\r\n        // change of relational schema\r\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + this.type.charAt(0) + \"...\" + this.type.charAt(1) + rightSource.getName() + \")\");\r\n        if (this.type === ThetaJoinType.left || this.type === ThetaJoinType.full) {\r\n            leftSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n        }\r\n        if (this.type === ThetaJoinType.right || this.type === ThetaJoinType.full) {\r\n            rightSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n        }\r\n        // combine columns of both source relations to use it in testing row\r\n        const bothSourceColumns: Map<string, SupportedColumnType> = new Map<string, SupportedColumnType>(leftSource.getColumns());\r\n        rightSource.forEachColumn((type, name) => bothSourceColumns.set(name, type));\r\n\r\n        leftSource.getRows().forEach(leftRow => {\r\n            rightSource.getRows().forEach(rightRow => {\r\n                const testRow: Row = new Row(bothSourceColumns);\r\n                leftRow.getValues().forEach((value, name) => testRow.addValue(name, value));\r\n                rightRow.getValues().forEach((value, name) => testRow.addValue(name, value));\r\n                // checks whether the combined row from both relations' columns satisfies the condition\r\n                let booleanResult: { value: ColumnContent, type: SupportedColumnType | \"null\" } = boolExpr.eval(testRow);\r\n                if (booleanResult.type !== \"boolean\") {\r\n                    throw ErrorFactory.syntaxError(language().syntaxErrors.thetaJoinNode_resultNotBoolean,\r\n                        this.stringRange, this.condition.replace(/\\s+/g, \" \"), booleanResult.type);\r\n                }\r\n                if (booleanResult.value) {\r\n                    const newRow: Row = new Row(result.getColumns());\r\n                    if (this.type === ThetaJoinType.left || this.type === ThetaJoinType.full) {\r\n                        leftRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                    }\r\n                    if (this.type === ThetaJoinType.right || this.type === ThetaJoinType.full) {\r\n                        rightRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                    }\r\n                    result.addRow(newRow);\r\n                }\r\n            });\r\n        });\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: disjointness\r\n     * Returned schema: left/right/both source schema (for left/right/full semijoin)\r\n     * Returned fake schema is not affected when disjointness is not held\r\n     */\r\n    public fakeEval(cursorIndex: number) {\r\n        const left = this.leftSubtree.fakeEval(cursorIndex);\r\n        const right = this.rightSubtree.fakeEval(cursorIndex);\r\n        const sourceColumns: string[] = [];\r\n        sourceColumns.push(...left.result.getColumnNames());\r\n        sourceColumns.push(...right.result.getColumnNames());\r\n        // creates return relation\r\n        const result: Relation = new Relation(\"\");\r\n        if (this.type === ThetaJoinType.left || this.type === ThetaJoinType.full) {\r\n            left.result.forEachColumn((type, name) => result.addColumn(name, type));\r\n        }\r\n        if (this.type === ThetaJoinType.right || this.type === ThetaJoinType.full) {\r\n            right.result.forEachColumn((type, name) => result.addColumn(name, type));\r\n        }\r\n        // checks whether the cursor is in this condition block (and not in the string) - saves current available columns\r\n        let whispers = left.whispers.length !== 0 ? left.whispers : right.whispers;\r\n        if (isInRangeAndNotInQuotes(cursorIndex, this.stringRange, this.condition)) {\r\n            whispers = sourceColumns;\r\n        }\r\n        // adds errors from current expression\r\n        const errors = left.errors;\r\n        errors.push(...right.errors);\r\n        const commonColumns: string[] = [];\r\n        left.result.getColumnNames().forEach(leftColumn => {\r\n            if (right.result.hasColumn(leftColumn)) {\r\n                commonColumns.push(leftColumn);\r\n            }\r\n        });\r\n        if (commonColumns.length > 0 && this.stringRange !== undefined) {\r\n            errors.push(ErrorFactory.semanticError(language().semanticErrors.binaryNode_commonColumns,\r\n                {start: this.stringRange.start, end: this.stringRange.start},   // highlight only opening bracket\r\n                this.getOperationName().toLowerCase(), commonColumns.join('\", \"')));\r\n        }\r\n        // checks empty condition input\r\n        if (this.condition.toString().slice(1, -1).trim().length  === 0) {\r\n            errors.push(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_emptyInput, this.stringRange));\r\n        }\r\n        else {\r\n            errors.push(...ValueParser.fakeParse(this.condition.slice(1, -1), this.nullValuesSupport, sourceColumns));\r\n        }\r\n        return {result, whispers, errors};\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return \"(\" + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + \")\";\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        const lang = language().operations;\r\n        if (this.type === ThetaJoinType.left) {\r\n            return lang.leftThetaSemiJoin;\r\n        }\r\n        else if (this.type === ThetaJoinType.right) {\r\n            return lang.rightThetaSemiJoin;\r\n        }\r\n        else {\r\n            return lang.thetaJoin;\r\n        }\r\n    }\r\n\r\n    public getOperationSymbol(): string {\r\n        return this.condition.replace(/\\s+/g, ' ');\r\n    }\r\n\r\n    public getType(): ThetaJoinType {\r\n        return this.type;\r\n    }\r\n}","import Relation from \"../relation/relation\";\r\nimport {ErrorFactory} from \"../error/errorFactory\";\r\nimport {\r\n    BinaryOperatorToken,\r\n    ClosingParenthesis,\r\n    ExprToken,\r\n    OpeningParenthesis,\r\n    ParenthesisToken,\r\n    RelationToken,\r\n    UnaryOperatorToken\r\n} from \"./exprTokens\";\r\nimport StringUtils from \"../utils/stringUtils\";\r\nimport CodeError from \"../error/codeError\";\r\nimport RATreeNode from \"../ratree/raTreeNode\";\r\nimport RelationNode from \"../ratree/relationNode\";\r\nimport {\r\n    IndexedString\r\n} from \"../types/indexedString\";\r\nimport IndexedStringUtils from \"../utils/indexedStringUtils\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\nimport RATreeFactory from \"../ratree/raTreeFactory\";\r\nimport {language} from \"../language/language\";\r\nimport {StartEndPair} from \"../types/startEndPair\";\r\n\r\n/**\r\n * Assertion types for assertValidInfixTokens function.\r\n */\r\nenum AssertType {\r\n    NOT_THROW,\r\n    THROW_STRICT,\r\n    THROW_NOT_STRICT\r\n}\r\n\r\n/**\r\n * StringUtils of relational algebra expressions. Provides parsing function parse(String expr) and additional\r\n * helping functions and predicates. Uses IndexedString to describe error ranges in thrown errors.\r\n */\r\nexport class ExprParser {\r\n\r\n    /**\r\n     * Creates a parser with given source relations.\r\n     *\r\n     * @param relations Map with relations' names as keys and relation themselves as values used as source for leave nodes\r\n     * @param nullValuesSupport whether to support null values\r\n     */\r\n    public constructor(readonly relations: Map<string, Relation>, readonly nullValuesSupport: boolean) {}\r\n\r\n    /**\r\n     * Parses given relational algebra expression 'expr' and returns tree of RA operations.\r\n     * Expression is expected to respect following constraints:\r\n     * - all relation's and column's names contain letters, numbers and underscores only\r\n     * - all relation's and column's names start with a letter\r\n     * - used operations must be in a practical notation and be well-structured\r\n     * - comment begins with '//' and ends with newline\r\n     *\r\n     * Supported operations are:\r\n     * - projection of columns: Relation[projectedColumn1, ...]\r\n     * - selection of rows: Relation(condition)\r\n     * - rename of columns: Relation<oldName -> newName, ...>\r\n     * - cartesian product: A \\u2a2f B\r\n     * - natural join: A * B\r\n     * - theta join: A [condition] B\r\n     * - left and right semijoin: A <* B and A *> B\r\n     * - left and right antijoin: A \\u22b3 B and A \\u22b2 B\r\n     * - left and right theta semijoin: A <condition] B and A [condition> B\r\n     * - division: A \\u00f7 B\r\n     * - left, right and full outer join: A *L* B, A *R* B and A *F* B\r\n     * - union, intersection and difference: A \\u222a B, A \\u2229 B and A \\ B\r\n     *\r\n     * See ValueParser for condition constraints.\r\n     *\r\n     * @param expr relational algebra expression in expected format\r\n     * @return tree structure of 'expr'\r\n     */\r\n    public parse(expr: string): RATreeNode {\r\n        const {str, err} = IndexedStringUtils.deleteAllComments(IndexedString.new(expr));\r\n        if (err !== undefined) {\r\n            throw err;\r\n        }\r\n        const tokens: ExprToken[] = this.parseTokens(str);\r\n        if (tokens.length === 0) {\r\n            throw ErrorFactory.syntaxError(language().syntaxErrors.exprParser_emptyStringGiven, undefined);\r\n        }\r\n        this.assertValidInfixTokens(tokens, AssertType.THROW_STRICT);\r\n        const rpn: ExprToken[] = this.toRPN(tokens);\r\n        return this.rpnToRATree(rpn, true);\r\n    }\r\n\r\n    /**\r\n     * Parses given expression and finds words to whisper for the given cursorIndex.\r\n     * If the cursor is located next to any RA operator, returns list of all defined relation names.\r\n     * If the cursor is located inside any RA operator, which uses relation columns, returns list of available column\r\n     * names at given place.\r\n     * If a parsing error occurs, it is faked to work or ignored and reported in returning errors array.\r\n     */\r\n    public fakeParse(expr: string, cursorIndex: number):\r\n      {whispers: string[], errors: ErrorWithTextRange[], parentheses: StartEndPair[]} {\r\n        if (expr.trim() === \"\") {\r\n            return {whispers: [...this.relations.keys()], errors: [], parentheses: []};\r\n        }\r\n        const {str, err} = IndexedStringUtils.deleteAllComments(IndexedString.new(expr));\r\n        const {whispers, tokens, errors, parentheses} = this.fakeParseTokens(str, cursorIndex);\r\n        if (err !== undefined) {\r\n            errors.push(err);\r\n        }\r\n        // prevent errors in creation of RPN\r\n        if (tokens.length === 0) {\r\n            return {whispers: whispers, errors: errors, parentheses: parentheses};\r\n        }\r\n        // fakes found errors to valid parse\r\n        this.assertValidInfixTokens(tokens, AssertType.NOT_THROW, errors);\r\n        const rpn: ExprToken[] = this.toRPN(tokens);\r\n        const raTree: RATreeNode = this.rpnToRATree(rpn, false, errors);\r\n        // tries to find whispers inside RA operations with parameters\r\n        const innerResult: {whispers: string[], errors: ErrorWithTextRange[]} = raTree.fakeEval(cursorIndex);\r\n        errors.push(...innerResult.errors);\r\n        // if there are whispers from inner operators, returns them\r\n        if (innerResult.whispers.length > 0) {\r\n            return {whispers: innerResult.whispers, errors: errors, parentheses: parentheses};\r\n        }\r\n        // otherwise returns outer whispers (or empty array if no were found)\r\n        return {whispers: whispers, errors: errors, parentheses: parentheses};\r\n    }\r\n\r\n    /**\r\n     * Given expression string is expected to be without comment lines and not empty.\r\n     *\r\n     * @param expr IndexedString to parse the expression from\r\n     * @param selectionExpected true if next part \"(...)\" should be treated as a selection = last part\r\n     * was a relation or an unary operator (default false)\r\n     */\r\n    public parseTokens(expr: IndexedString, selectionExpected: boolean = false): ExprToken[] {\r\n        let tokens: ExprToken[] = [];\r\n        // alternative solution in case of finding \"[...]\"\r\n        let alternativeTokens: ExprToken[] = [];\r\n        let rest: IndexedString = expr.trim();\r\n\r\n        while (!rest.isEmpty()) {\r\n            // '(' can be a selection or a parentheses\r\n            if (rest.startsWith(\"(\")) {\r\n                const split = IndexedStringUtils.nextBorderedPart(rest, '(', ')');\r\n                // whole \"(...)\" part pushed as selection\r\n                if (selectionExpected) {\r\n                    tokens.push(UnaryOperatorToken.selection(split.first));\r\n                }\r\n                // inner of \"(...)\" part parsed as parentheses structure\r\n                else {\r\n                    tokens.push(new OpeningParenthesis(split.first.slice(0, 1)));\r\n                    tokens.push(...this.parseTokens(split.first.slice(1, -1)));\r\n                    tokens.push(new ClosingParenthesis(split.first.slice(-1)));\r\n                    selectionExpected = true;\r\n                }\r\n                rest = split.second;\r\n            }\r\n            // '[' can be a projection, theta join, or right theta semi join\r\n            else if (rest.startsWith(\"[\")) {\r\n                const split = IndexedStringUtils.nextBorderedPart(rest, '[', ']>');\r\n                // right theta semijoin found\r\n                if (split.first.endsWith('>')) {\r\n                    tokens.push(BinaryOperatorToken.rightThetaSemijoin(split.first));\r\n                    selectionExpected = false;\r\n                    rest = split.second;\r\n                }\r\n                // the expression cannot end with a theta join (right source expected)\r\n                else if (split.second.isEmpty()) {\r\n                    tokens.push(UnaryOperatorToken.projection(split.first));\r\n                    break;\r\n                }\r\n                // it is no known yet whether it is a projection or a theta join, recursively tries both possibilities\r\n                else {\r\n                    let errorAlternative: Error | undefined;\r\n                    let error: Error | undefined;\r\n\r\n                    // 1: treat as Theta join (it must copy tokens first)\r\n                    try {\r\n                        alternativeTokens.push(...tokens);\r\n                        alternativeTokens.push(BinaryOperatorToken.thetaJoin(split.first));\r\n                        alternativeTokens.push(...this.parseTokens(split.second, false));\r\n                    }\r\n                    catch (err) {\r\n                        if (err instanceof CodeError) {\r\n                            throw err;\r\n                        }\r\n                        errorAlternative = err;\r\n                    }\r\n\r\n                    // 2: treat as Projection\r\n                    try {\r\n                        tokens.push(UnaryOperatorToken.projection(split.first));\r\n                        tokens.push(...this.parseTokens(split.second, true));\r\n                    }\r\n                    catch (err) {\r\n                        if (err instanceof CodeError) {\r\n                            throw err;\r\n                        }\r\n                        error = err;\r\n                    }\r\n\r\n                    // both branches have error - reports it to user\r\n                    if (errorAlternative !== undefined && error !== undefined) {\r\n                        // when errors were the same, throws one of them\r\n                        if (errorAlternative.message === error.message) {\r\n                            throw error;\r\n                        }\r\n                        // when errors were different, joins them\r\n                        throw ErrorFactory.syntaxError(language().syntaxErrors.exprParser_bothBranchesError,\r\n                            undefined, split.first.toString(), error.message, errorAlternative.message);\r\n                    }\r\n                    // does not use alternative tokens after error\r\n                    if (errorAlternative !== undefined) {\r\n                        alternativeTokens = [];\r\n                    }\r\n                    // uses alternative tokens after error in second branch\r\n                    if (error !== undefined) {\r\n                        tokens = alternativeTokens;\r\n                        alternativeTokens = [];\r\n                    }\r\n                    // breaks the while - the rest was parsed recursively\r\n                    break;\r\n                }\r\n            }\r\n            // BINARY OPERATORS\r\n            else if (rest.startsWith(\"*F*\") || rest.startsWith(\"*L*\") || rest.startsWith(\"*R*\")) {\r\n                if (!this.nullValuesSupport) {\r\n                    let errorRange: StartEndPair | undefined = undefined;\r\n                    if (!isNaN(rest.getFirstIndex())) {\r\n                        errorRange = {start: rest.getFirstIndex(), end: rest.getFirstIndex() + 2};\r\n                    }\r\n                    throw ErrorFactory.syntaxError(language().syntaxErrors.exprParser_outerJoinWhenNullNotSupported,\r\n                        errorRange, \"*F*\");\r\n                }\r\n                if (rest.startsWith(\"*F\")) {\r\n                    tokens.push(BinaryOperatorToken.fullOuterJoin(rest.slice(0, 3)));\r\n                }\r\n                else if (rest.startsWith(\"*L\")) {\r\n                    tokens.push(BinaryOperatorToken.leftOuterJoin(rest.slice(0, 3)));\r\n                }\r\n                else {\r\n                    tokens.push(BinaryOperatorToken.rightOuterJoin(rest.slice(0, 3)));\r\n                }\r\n                rest = rest.slice(3);\r\n                selectionExpected = false;\r\n            }\r\n            else if (rest.startsWith(\"<*\")) {\r\n                tokens.push(BinaryOperatorToken.leftSemijoin(rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n                selectionExpected = false;\r\n            }\r\n            else if (rest.startsWith(\"*>\")) {\r\n                tokens.push(BinaryOperatorToken.rightSemijoin(rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n                selectionExpected = false;\r\n            }\r\n            else if (rest.startsWith(\"*\")) {\r\n                tokens.push(BinaryOperatorToken.naturalJoin(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n                selectionExpected = false;\r\n            }\r\n            else if (rest.startsWith(\"\\u2a2f\")) {\r\n                tokens.push(BinaryOperatorToken.cartesianProduct(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n                selectionExpected = false;\r\n            }\r\n            else if (rest.startsWith(\"\\u222a\")) {\r\n                tokens.push(BinaryOperatorToken.union(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n                selectionExpected = false;\r\n            }\r\n            else if (rest.startsWith(\"\\u2229\")) {\r\n                tokens.push(BinaryOperatorToken.intersection(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n                selectionExpected = false;\r\n            }\r\n            else if (rest.startsWith(\"\\\\\")) {\r\n                tokens.push(BinaryOperatorToken.difference(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n                selectionExpected = false;\r\n            }\r\n            else if (rest.startsWith(\"\\u22b3\")) {\r\n                tokens.push(BinaryOperatorToken.leftAntijoin(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n                selectionExpected = false;\r\n            }\r\n            else if (rest.startsWith(\"\\u22b2\")) {\r\n                tokens.push(BinaryOperatorToken.rightAntijoin(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n                selectionExpected = false;\r\n            }\r\n            else if (rest.startsWith(\"\\u00f7\")) {\r\n                tokens.push(BinaryOperatorToken.division(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n                selectionExpected = false;\r\n            }\r\n            // '<' can be a rename or left theta semi join - this \"if\" must be after <* and *>\r\n            else if (rest.startsWith('<')) {\r\n                const split = IndexedStringUtils.nextBorderedPart(rest, '<', '>]', '-');\r\n                if (split.first.endsWith('>')) {\r\n                    tokens.push(UnaryOperatorToken.rename(split.first));\r\n                    selectionExpected = true;\r\n                }\r\n                else {\r\n                    tokens.push(BinaryOperatorToken.leftThetaSemijoin(split.first));\r\n                    selectionExpected = false;\r\n                }\r\n                rest = split.second;\r\n            }\r\n            // RELATION REFERENCE\r\n            else if (StringUtils.isLetter(rest.charAt(0)) || rest.charAt(0) === '_') {\r\n                const split = IndexedStringUtils.nextName(rest);\r\n                tokens.push(new RelationToken(split.first));\r\n                rest = split.second;\r\n                selectionExpected = true;\r\n            }\r\n            // UNEXPECTED PART\r\n            else {\r\n                const split = IndexedStringUtils.nextNonWhitespacePart(rest);\r\n                throw ErrorFactory.syntaxError(language().syntaxErrors.exprParser_unexpectedPart,\r\n                    split.first.getRange(), split.first.toString());\r\n            }\r\n            rest = rest.trim();\r\n        }\r\n        // checks whether alternative tokens are valid when used\r\n        if (alternativeTokens.length > 0) {\r\n            try {\r\n                // assert not strict validity (because this can be in nested recursion call where some rules are not held)\r\n                this.assertValidInfixTokens(alternativeTokens, AssertType.THROW_NOT_STRICT, []);\r\n                // if error not thrown, returns alternative tokens\r\n                return alternativeTokens;\r\n            }\r\n            catch (ignored) {}\r\n        }\r\n        // when alternative tokens are not set or valid, returns tokens\r\n        return tokens;\r\n    }\r\n\r\n    /**\r\n     * Parses given expression to ExprToken array. While parsing, it tries to find cursor index and returns whispers.\r\n     * Parsing errors are not thrown but stored in errors array.\r\n     *\r\n     * @param expr IndexedString to parse the expression from\r\n     * @param cursorIndex\r\n     * @param selectionExpected true if next part \"(...)\" should be treated as a selection = last part\r\n     * was a relation or an unary operator (default false)\r\n     */\r\n    public fakeParseTokens(expr: IndexedString, cursorIndex: number, selectionExpected: boolean = false):\r\n        { tokens: ExprToken[], whispers: string[], errors: ErrorWithTextRange[], parentheses: StartEndPair[] } {\r\n        let whispers: string[] = [];\r\n        let tokens: ExprToken[] = [];\r\n        let errors: ErrorWithTextRange[] = [];\r\n        let parentheses: StartEndPair[] = [];\r\n\r\n        // adds new pair of parentheses from margins of the given string\r\n        const pushParentheses = (str: IndexedString) => {\r\n            parentheses.push({start: str.getFirstIndex(), end: str.getLastIndex()});\r\n        }\r\n\r\n        let rest: IndexedString = expr;\r\n        while (!rest.isEmpty()) {\r\n            // checks whether the cursor was reached\r\n            const restStartIndex: number = rest.getFirstIndex();\r\n            if (restStartIndex === cursorIndex) {\r\n                whispers = [...this.relations.keys()];\r\n            }\r\n\r\n            // '(' can be a selection or a parentheses\r\n            if (rest.startsWith(\"(\")) {\r\n                let split: {first: IndexedString, second: IndexedString};\r\n                try {\r\n                    split = IndexedStringUtils.nextBorderedPart(rest, '(', ')');\r\n                }\r\n                // catches error from nextBorderedPart\r\n                catch (err) {\r\n                    // saves error\r\n                    if (err instanceof ErrorWithTextRange) {\r\n                        errors.push(err);\r\n                    }\r\n\r\n                    if (selectionExpected) {\r\n                        // it fakes the unclosed expression part as a selection operator\r\n                        tokens.push(UnaryOperatorToken.selection(rest.concat(IndexedString.new(')', rest.getLastIndex() + 1))));\r\n                    }\r\n                    else {\r\n                        // checks whether the cursor was reached after the opening parentheses\r\n                        if (restStartIndex === cursorIndex - 1) {\r\n                            whispers = [...this.relations.keys()];\r\n                        }\r\n\r\n                        // it fakes the unclosed expression as nested expression in parentheses\r\n                        tokens.push(new OpeningParenthesis(rest.slice(0, 1)));\r\n                        // parses inner part between parentheses\r\n                        const recursiveReturn = this.fakeParseTokens(rest.slice(1), cursorIndex);\r\n                        errors.push(...recursiveReturn.errors);\r\n                        whispers.push(...recursiveReturn.whispers);\r\n                        tokens.push(...recursiveReturn.tokens);\r\n                        parentheses.push(...recursiveReturn.parentheses);\r\n                        // gives invalid index (NaN for not reporting errors with this imaginary parentheses\r\n                        tokens.push(new ClosingParenthesis(IndexedString.new(')', NaN)));\r\n                    }\r\n                    // breaks the while cycle because rest was parsed recursively\r\n                    break;\r\n                }\r\n\r\n                // saves parentheses\r\n                pushParentheses(split.first);\r\n\r\n                // whole \"(...)\" part pushed as selection\r\n                if (selectionExpected) {\r\n                    tokens.push(UnaryOperatorToken.selection(split.first));\r\n                }\r\n                // inner of \"(...)\" part parsed as parentheses structure\r\n                else {\r\n                    tokens.push(new OpeningParenthesis(split.first.slice(0, 1)));\r\n                    const recursiveReturn = this.fakeParseTokens(split.first.slice(1, -1), cursorIndex);\r\n                    errors.push(...recursiveReturn.errors);\r\n                    whispers.push(...recursiveReturn.whispers);\r\n                    tokens.push(...recursiveReturn.tokens);\r\n                    parentheses.push(...recursiveReturn.parentheses);\r\n                    tokens.push(new ClosingParenthesis(split.first.slice(-1)));\r\n                    selectionExpected = true;\r\n                }\r\n                rest = split.second;\r\n            }\r\n            // '[' can be a projection, theta join, or right theta semi join\r\n            else if (rest.startsWith(\"[\")) {\r\n                let split: {first: IndexedString, second: IndexedString};\r\n                let error: boolean = false;\r\n                try {\r\n                    split = IndexedStringUtils.nextBorderedPart(rest, '[', ']>');\r\n                }\r\n                // catches error from nextBorderedPart\r\n                catch (err) {\r\n                    error = true;\r\n                    // saves error\r\n                    if (err instanceof ErrorWithTextRange) {\r\n                        errors.push(err);\r\n                    }\r\n                    // it fakes the unclosed expression part as a projection operator\r\n                    split = {first: rest.concat(IndexedString.new(']', rest.getLastIndex() + 1)), second: IndexedString.empty()};\r\n                }\r\n\r\n                // saves parentheses\r\n                pushParentheses(split.first);\r\n\r\n                // checks whether the cursor was reached\r\n                if (!error && split.first.getLastIndex() === cursorIndex - 1) {\r\n                    whispers = [...this.relations.keys()];\r\n                }\r\n\r\n                // right theta semijoin found \"[...>\"\r\n                if (split.first.endsWith('>')) {\r\n                    tokens.push(BinaryOperatorToken.rightThetaSemijoin(split.first));\r\n                    selectionExpected = false;\r\n                    rest = split.second;\r\n                }\r\n                // if the next part contains any character from =<>+/*&|~\"()! it cannot be a valid Projection\r\n                else if (split.first.containsAny('=<>+/*&|~\"()!')) {\r\n                    tokens.push(BinaryOperatorToken.thetaJoin(split.first));\r\n                    selectionExpected = false;\r\n                    rest = split.second;\r\n                }\r\n                // else suppose it is a projection\r\n                else {\r\n                    tokens.push(UnaryOperatorToken.projection(split.first));\r\n                    selectionExpected = true;\r\n                    rest = split.second;\r\n                }\r\n            }\r\n            // BINARY OPERATORS\r\n            else if (rest.startsWith(\"*F*\") || rest.startsWith(\"*L*\") || rest.startsWith(\"*R*\")) {\r\n                const operator: IndexedString = rest.slice(0, 3);\r\n                // checks whether the cursor was reached\r\n                if (operator.getLastIndex() === cursorIndex - 1) {\r\n                    whispers = [...this.relations.keys()];\r\n                }\r\n\r\n                if (rest.startsWith(\"*F\")) {\r\n                    tokens.push(BinaryOperatorToken.fullOuterJoin(operator));\r\n                }\r\n                else if (rest.startsWith(\"*L\")) {\r\n                    tokens.push(BinaryOperatorToken.leftOuterJoin(operator));\r\n                }\r\n                else {\r\n                    tokens.push(BinaryOperatorToken.rightOuterJoin(operator));\r\n                }\r\n                rest = rest.slice(3);\r\n                selectionExpected = false;\r\n            }\r\n            // operators of 2 characters\r\n            else if (rest.startsWith(\"<*\") || rest.startsWith(\"*>\")) {\r\n                const operator: IndexedString = rest.slice(0, 2);\r\n                // checks whether the cursor was reached\r\n                if (operator.getLastIndex() === cursorIndex - 1) {\r\n                    whispers = [...this.relations.keys()];\r\n                }\r\n\r\n                if (rest.startsWith(\"<*\")) {\r\n                    tokens.push(BinaryOperatorToken.leftSemijoin(operator));\r\n                }\r\n                else {\r\n                    tokens.push(BinaryOperatorToken.rightSemijoin(operator));\r\n                }\r\n                rest = rest.slice(2);\r\n                selectionExpected = false;\r\n            }\r\n            // operators of 1 character\r\n            else if (\"*\\u2a2f\\u222a\\u2229\\\\\\u22b3\\u22b2\\u00f7\".indexOf(rest.charAt(0)) > -1) {\r\n                const operator: IndexedString = rest.slice(0, 1);\r\n                // checks whether the cursor was reached\r\n                if (operator.getLastIndex() === cursorIndex - 1) {\r\n                    whispers = [...this.relations.keys()];\r\n                }\r\n\r\n                if (rest.startsWith(\"*\")) {\r\n                    tokens.push(BinaryOperatorToken.naturalJoin(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\u2a2f\")) {\r\n                    tokens.push(BinaryOperatorToken.cartesianProduct(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\u222a\")) {\r\n                    tokens.push(BinaryOperatorToken.union(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\u2229\")) {\r\n                    tokens.push(BinaryOperatorToken.intersection(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\\\\")) {\r\n                    tokens.push(BinaryOperatorToken.difference(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\u22b3\")) {\r\n                    tokens.push(BinaryOperatorToken.leftAntijoin(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\u22b2\")) {\r\n                    tokens.push(BinaryOperatorToken.rightAntijoin(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\u00f7\")) {\r\n                    tokens.push(BinaryOperatorToken.division(operator));\r\n                }\r\n                rest = rest.slice(1);\r\n                selectionExpected = false;\r\n            }\r\n            // '<' can be a rename or left theta semi join - this \"if\" must be after <*\r\n            else if (rest.startsWith('<')) {\r\n                try {\r\n                    const split = IndexedStringUtils.nextBorderedPart(rest, '<', '>]', '-');\r\n                    // saves parentheses\r\n                    pushParentheses(split.first);\r\n                    // checks whether the cursor was reached\r\n                    if (split.first.getLastIndex() === cursorIndex - 1) {\r\n                        whispers = [...this.relations.keys()];\r\n                    }\r\n                    // found rename\r\n                    if (split.first.endsWith('>')) {\r\n                        tokens.push(UnaryOperatorToken.rename(split.first));\r\n                        selectionExpected = true;\r\n                    }\r\n                    // found left theta semi join\r\n                    else {\r\n                        tokens.push(BinaryOperatorToken.leftThetaSemijoin(split.first));\r\n                        selectionExpected = false;\r\n                    }\r\n                    rest = split.second;\r\n                }\r\n                // catches error from nextBorderedPart\r\n                catch (e) {\r\n                    // it fakes the unclosed expression part as a rename operator\r\n                    tokens.push(UnaryOperatorToken.rename(rest.concat(IndexedString.new('>', rest.getLastIndex() + 1))));\r\n                    // breaks the while cycle as all was used\r\n                    break;\r\n                }\r\n            }\r\n            // RELATION REFERENCE\r\n            else if (StringUtils.isLetter(rest.charAt(0)) || rest.charAt(0) === '_') {\r\n                const split = IndexedStringUtils.nextName(rest);\r\n\r\n                // checks whether the cursor was reached in the relation reference string\r\n                if (split.first.getFirstIndex() <= cursorIndex - 1 && cursorIndex - 1 <= split.first.getLastIndex()) {\r\n                    whispers = [...this.relations.keys()];\r\n                }\r\n\r\n                tokens.push(new RelationToken(split.first));\r\n                rest = split.second;\r\n                selectionExpected = true;\r\n            }\r\n            // WHITE SPACE\r\n            else if (rest.charAt(0).match(/\\s/)) {\r\n                let i = 0;\r\n                while (i < rest.length() && rest.charAt(i).match(/\\s/)) {\r\n                    if (rest.indexAt(i) === cursorIndex - 1) {\r\n                        whispers = [...this.relations.keys()];\r\n                    }\r\n                    ++i;\r\n                }\r\n                rest = rest.slice(i);\r\n            }\r\n            // UNEXPECTED PART\r\n            else {\r\n                const split = IndexedStringUtils.nextNonWhitespacePart(rest);\r\n                errors.push(ErrorFactory.syntaxError(language().syntaxErrors.exprParser_unexpectedPart,\r\n                    split.first.getRange(), split.first.toString()));\r\n                // tries to skip first unexpected character\r\n                rest = rest.slice(split.first.length());\r\n            }\r\n        }\r\n        return { tokens, whispers, errors, parentheses };\r\n    }\r\n\r\n    /**\r\n     * Checks the validity of the given infix token array.\r\n     * If the type is THROW_STRICT or THROW_NOT_STRICT, it throws found errors. Strict version checks the first\r\n     * token in the array, not strict version does not. In both throw version is the errors parameter ignored.\r\n     * If the type is NOT_THROW, it adds fake tokens if the array is not valid.\r\n     * Fake tokens are relations with empty name \"\", or natural joins \"*\", their error ranges are undefined.\r\n     * All faked errors are reported pushed in given errors array.\r\n     * Expects validly nested parentheses: yes \"(()())\", no \")()\", \")(\". Expects not empty array.\r\n     *\r\n     * @param tokens token array to check\r\n     * @param type type of the assertion\r\n     * @param errors array for pushing faked errors for NOT_THROW type\r\n     */\r\n    public assertValidInfixTokens(tokens: ExprToken[], type: AssertType, errors: ErrorWithTextRange[] = []): void {\r\n        /**\r\n         * Handles the error described by given error code, params and range. If doThrow is true, throws the described\r\n         * error. Otherwise, fakes it by inserting a new token at given index. The token is binary (natural join) if\r\n         * missing is \"binary\", otherwise, it is a relation with empty name.\r\n         */\r\n        const handleError = (index: number, missing: \"binary\" | \"relation\",\r\n                             msg: string[], range: StartEndPair | undefined, ...params: string[]) => {\r\n            const error = ErrorFactory.syntaxError(msg, range, ...params);\r\n            if (type !== AssertType.NOT_THROW) {\r\n                throw error;\r\n            }\r\n            else if (missing === \"binary\") {\r\n                errors.push(error);\r\n                tokens.splice(index, 0, BinaryOperatorToken.naturalJoin(IndexedString.new(\"*\")));\r\n            }\r\n            else {\r\n                errors.push(error);\r\n                tokens.splice(index, 0, new RelationToken(IndexedString.new(\"\")));\r\n            }\r\n        }\r\n\r\n        if (type !== AssertType.THROW_NOT_STRICT) {\r\n            // checks start of an array: it must start with '(' or relation\r\n            if (tokens[0] instanceof UnaryOperatorToken || tokens[0] instanceof BinaryOperatorToken || tokens[0] instanceof ClosingParenthesis) {\r\n                handleError(0, \"relation\", language().syntaxErrors.exprParser_invalidStart,\r\n                    tokens[0].getRange(), tokens[0].str.toString());\r\n            }\r\n        }\r\n\r\n        // checks end of an array: it must end with ')', relation or an unary operator\r\n        if (tokens[tokens.length - 1] instanceof OpeningParenthesis || tokens[tokens.length - 1] instanceof BinaryOperatorToken) {\r\n            handleError(tokens.length, \"relation\", language().syntaxErrors.exprParser_invalidEnd,\r\n                tokens[tokens.length - 1].getRange(), tokens[tokens.length - 1].str.toString());\r\n        }\r\n\r\n        // checks adjacent pairs of tokens\r\n        let i2: number = 1;\r\n        while (i2 < tokens.length) {\r\n            const token1: ExprToken = tokens[i2 - 1];\r\n            const token2: ExprToken = tokens[i2];\r\n\r\n            // valid predecessors: binary operator or '('\r\n            if (token2 instanceof RelationToken) {\r\n                if (token1 instanceof RelationToken) {\r\n                    handleError(i2, \"binary\", language().syntaxErrors.exprParser_relationAfterRelation,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString());\r\n                }\r\n                if (token1 instanceof UnaryOperatorToken) {\r\n                    handleError(i2, \"binary\", language().syntaxErrors.exprParser_relationAfterUnary,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString());\r\n                }\r\n                if (token1 instanceof ClosingParenthesis) {\r\n                    handleError(i2, \"binary\", language().syntaxErrors.exprParser_relationAfterClosing,\r\n                        token2.getRange(), token2.str.toString());\r\n                }\r\n            }\r\n            // valid predecessors: relation, unary operator or ')'\r\n            else if (token2 instanceof UnaryOperatorToken) {\r\n                if (token1 instanceof BinaryOperatorToken) {\r\n                    handleError(i2, \"relation\", language().syntaxErrors.exprParser_unaryAfterBinary,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString());\r\n                }\r\n                if (token1 instanceof OpeningParenthesis) {\r\n                    handleError(i2, \"relation\", language().syntaxErrors.exprParser_unaryAfterOpening,\r\n                        token2.getRange(), token2.str.toString());\r\n                }\r\n            }\r\n            // valid predecessors: relation, unary operator or ')'\r\n            else if (token2 instanceof BinaryOperatorToken) {\r\n                if (token1 instanceof BinaryOperatorToken) {\r\n                    handleError(i2, \"relation\", language().syntaxErrors.exprParser_binaryAfterBinary,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString());\r\n                }\r\n                if (token1 instanceof OpeningParenthesis) {\r\n                    handleError(i2, \"relation\", language().syntaxErrors.exprParser_binaryAfterOpening,\r\n                        token2.getRange(), token2.str.toString());\r\n                }\r\n            }\r\n            // valid predecessors: binary operator or '('\r\n            else if (token2 instanceof OpeningParenthesis) {\r\n                if (token1 instanceof RelationToken) {\r\n                    handleError(i2, \"binary\", language().syntaxErrors.exprParser_openingAfterRelation,\r\n                        token2.getRange(), token1.str.toString());\r\n                }\r\n                if (token1 instanceof UnaryOperatorToken) {\r\n                    handleError(i2, \"binary\", language().syntaxErrors.exprParser_openingAfterUnary,\r\n                        token2.getRange(), token1.str.toString());\r\n                }\r\n                if (token1 instanceof ClosingParenthesis) {\r\n                    handleError(i2, \"binary\", language().syntaxErrors.exprParser_openingAfterClosing,\r\n                        token2.getRange());\r\n                }\r\n            }\r\n            // valid predecessors: relation, unary operator or ')'\r\n            else if (token2 instanceof ClosingParenthesis) {\r\n                if (token1 instanceof BinaryOperatorToken) {\r\n                    handleError(i2, \"relation\", language().syntaxErrors.exprParser_closingAfterBinary,\r\n                        token2.getRange(), token1.str.toString());\r\n                }\r\n                if (token1 instanceof OpeningParenthesis) {\r\n                    handleError(i2, \"relation\", language().syntaxErrors.exprParser_closingAfterOpening,\r\n                        token2.getRange());\r\n                }\r\n            }\r\n            else {\r\n                throw ErrorFactory.codeError(language().codeErrors.exprParser_unexpectedToken, JSON.stringify(token2));\r\n            }\r\n            ++i2;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transforms given infix relation algebra expression into postfix (reverse polish) form.\r\n     * Throws error when invalid parentheses structure is given.\r\n     *\r\n     * @param tokens infix relational algebra expression as Token array\r\n     * @return postfix (reverse polish) form of given array\r\n     */\r\n    public toRPN(tokens: ExprToken[]): ExprToken[] {\r\n        const rpnQueue: ExprToken[] = [];\r\n        const operatorsStack: Array<BinaryOperatorToken | ParenthesisToken> = [];\r\n        tokens.forEach(token => {\r\n            if (token instanceof RelationToken || token instanceof UnaryOperatorToken) {\r\n                rpnQueue.push(token);\r\n            }\r\n            else if (token instanceof BinaryOperatorToken) {\r\n                while (operatorsStack.length > 0 && operatorsStack[operatorsStack.length - 1] instanceof BinaryOperatorToken) {\r\n                    // @ts-ignore (token must be of BinaryOperatorToken class)\r\n                    let other: BinaryOperatorToken = operatorsStack[operatorsStack.length - 1];\r\n                    // all used operators have left associativity\r\n                    if (token.precedence <= other.precedence) {\r\n                        // @ts-ignore (token must be present)\r\n                        rpnQueue.push(operatorsStack.pop());\r\n                    }\r\n                    else {\r\n                        break;\r\n                    }\r\n                }\r\n                operatorsStack.push(token);\r\n            }\r\n            else if (token instanceof OpeningParenthesis) {\r\n                operatorsStack.push(token);\r\n            }\r\n            else if (token instanceof ClosingParenthesis) {\r\n                while (true) {\r\n                    if (operatorsStack.length === 0) {\r\n                        throw ErrorFactory.syntaxError(language().syntaxErrors.exprParser_invalidParentheses,\r\n                            undefined);\r\n                    }\r\n                    if (operatorsStack[operatorsStack.length - 1] instanceof OpeningParenthesis) {\r\n                        operatorsStack.pop();\r\n                        break;\r\n                    }\r\n                    // @ts-ignore (token must be present)\r\n                    rpnQueue.push(operatorsStack.pop());\r\n                }\r\n            }\r\n        });\r\n        while (operatorsStack.length > 0) {\r\n            // @ts-ignore (token must be present)\r\n            const curToken: ExprToken = operatorsStack.pop();\r\n            if (curToken instanceof OpeningParenthesis) {\r\n                throw ErrorFactory.syntaxError(language().syntaxErrors.exprParser_invalidParentheses,\r\n                    undefined);\r\n            }\r\n            else {\r\n                rpnQueue.push(curToken);\r\n            }\r\n        }\r\n        return rpnQueue;\r\n    }\r\n\r\n    /**\r\n     * Creates a RA expression evaluating tree from the given array of tokens in reverse polish form.\r\n     * Wraps recursive function rpnToRATreeRecursive(tokens).\r\n     * Possible errors:\r\n     * - not all tokens were used (invalid RPN structure was given, should not happen if the previous infix structure\r\n     * was asserted/faked) - if doThrow = false, returns a RelationNode with an empty relation\r\n     * - reference to a relation which does not exist found - if doThrow = false, replaces it with an empty relation\r\n     *\r\n     * @param tokens value-evaluating expression in reverse polish form\r\n     * @param doThrow if true and an error occurs, throws an error, if false and an error occurs, fakes it and does\r\n     * not throw\r\n     * @param errors\r\n     * @return RATreeNode tree (its root)\r\n     */\r\n    public rpnToRATree(tokens: ExprToken[], doThrow: boolean, errors: ErrorWithTextRange[] = []): RATreeNode {\r\n        const ret: RATreeNode = this.rpnToRATreeRecursive(tokens, doThrow, errors);\r\n        // not all tokens were used\r\n        if (tokens.length > 0) {\r\n            if (doThrow) {\r\n                throw ErrorFactory.syntaxError(language().syntaxErrors.exprParser_invalidExpression, undefined);\r\n            }\r\n            else {\r\n                return new RelationNode(new Relation(\"\"));\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    public rpnToRATreeRecursive(tokens: ExprToken[], doThrow: boolean, errors: ErrorWithTextRange[]): RATreeNode {\r\n        if (tokens.length === 0) {\r\n            throw ErrorFactory.syntaxError(language().syntaxErrors.exprParser_invalidExpression, undefined);\r\n        }\r\n        // @ts-ignore (there must be a token)\r\n        const token: ExprToken = tokens.pop();\r\n        // RELATION REFERENCE\r\n        if (token instanceof RelationToken) {\r\n            const relation: Relation | undefined = this.relations.get(token.str.toString());\r\n            // when the relation does not exist, throws or fakes it with an empty relation\r\n            if (relation === undefined) {\r\n                const error = ErrorFactory.semanticError(language().semanticErrors.exprParser_relationNotDefined,\r\n                    token.getRange(), token.str.toString());\r\n                if (doThrow) {\r\n                    throw error;\r\n                }\r\n                else {\r\n                    errors.push(error);\r\n                    return new RelationNode(new Relation(\"\"));\r\n                }\r\n            }\r\n            return new RelationNode(relation);\r\n        }\r\n        // UNARY OPERATORS\r\n        if (token instanceof UnaryOperatorToken) {\r\n            const subtree: RATreeNode = this.rpnToRATreeRecursive(tokens, doThrow, errors);\r\n            return RATreeFactory.createUnary(token.type, subtree, this.nullValuesSupport, token.str);\r\n        }\r\n        // BINARY OPERATORS\r\n        if (token instanceof BinaryOperatorToken) {\r\n            const right: RATreeNode = this.rpnToRATreeRecursive(tokens, doThrow, errors);\r\n            const left: RATreeNode = this.rpnToRATreeRecursive(tokens, doThrow, errors);\r\n            return RATreeFactory.createBinary(token.type, left, right, this.nullValuesSupport, token.str);\r\n        }\r\n        // should never happen\r\n        throw ErrorFactory.codeError(language().codeErrors.exprParser_unexpectedToken, JSON.stringify(token));\r\n    }\r\n}\r\n","import RATreeNode from \"./raTreeNode\";\r\nimport ProjectionNode from \"./projectionNode\";\r\nimport RenameNode from \"./renameNode\";\r\nimport SelectionNode from \"./selectionNode\";\r\nimport UnaryNode, {UnaryNodeClass} from \"./unaryNode\";\r\nimport AntijoinNode, {AntijoinType} from \"./antijoinNode\";\r\nimport CartesianProductNode from \"./cartesianProductNode\";\r\nimport DivisionNode from \"./divisionNode\";\r\nimport OuterJoinNode, {OuterJoinType} from \"./outerJoinNode\";\r\nimport NaturalJoinNode, {NaturalJoinType} from \"./naturalJoinNode\";\r\nimport SetOperationNode, {SetOperationType} from \"./setOperationNode\";\r\nimport BinaryNode, {BinaryNodeClass} from \"./binaryNode\";\r\nimport {IndexedString} from \"../types/indexedString\";\r\nimport ThetaJoinNode, {ThetaJoinType} from \"./thetaJoinNode\";\r\n\r\n/**\r\n * Factory for creating unary and binary nodes of given class.\r\n */\r\nexport default class RATreeFactory {\r\n\r\n    /**\r\n     * Creates new unary node of given class.\r\n     *\r\n     * @param unaryClass wanted class\r\n     * @param subtree source subtree for a node\r\n     * @param nullValuesSupport whether null values are supported\r\n     * @param expr expression used to specify node's behavior\r\n     */\r\n    public static createUnary(unaryClass: UnaryNodeClass, subtree: RATreeNode,\r\n                              nullValuesSupport: boolean, expr: IndexedString): UnaryNode {\r\n        switch (unaryClass) {\r\n            case \"projection\":\r\n                return new ProjectionNode(expr, subtree);\r\n            case \"rename\":\r\n                return new RenameNode(expr, subtree);\r\n            case \"selection\":\r\n                return new SelectionNode(expr, subtree, nullValuesSupport);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates new binary node of given class.\r\n     *\r\n     * @param binaryClass wanted class\r\n     * @param left left source subtree for a node\r\n     * @param right right source subtree for a node\r\n     * @param nullValuesSupport whether null values are supported\r\n     * @param expr expression used to specify node's behavior\r\n     */\r\n    public static createBinary(binaryClass: BinaryNodeClass, left: RATreeNode, right: RATreeNode,\r\n                               nullValuesSupport: boolean, expr: IndexedString): BinaryNode {\r\n        switch (binaryClass) {\r\n            case \"left antijoin\":\r\n                return new AntijoinNode(AntijoinType.left, left, right);\r\n            case \"right antijoin\":\r\n                return new AntijoinNode(AntijoinType.right, left, right);\r\n            case \"cartesian product\":\r\n                return new CartesianProductNode(left, right, expr.getRange());\r\n            case \"division\":\r\n                return new DivisionNode(left, right, expr.getRange());\r\n            case \"natural join\":\r\n                return new NaturalJoinNode(NaturalJoinType.natural, left, right);\r\n            case \"left outer join\":\r\n                return new OuterJoinNode(OuterJoinType.left, left, right);\r\n            case \"right outer join\":\r\n                return new OuterJoinNode(OuterJoinType.right, left, right);\r\n            case \"full outer join\":\r\n                return new OuterJoinNode(OuterJoinType.full, left, right);\r\n            case \"left semijoin\":\r\n                return new NaturalJoinNode(NaturalJoinType.leftSemi, left, right);\r\n            case \"right semijoin\":\r\n                return new NaturalJoinNode(NaturalJoinType.rightSemi, left, right);\r\n            case \"union\":\r\n                return new SetOperationNode(SetOperationType.union, left, right, expr.getRange());\r\n            case \"intersection\":\r\n                return new SetOperationNode(SetOperationType.intersection, left, right, expr.getRange());\r\n            case \"difference\":\r\n                return new SetOperationNode(SetOperationType.difference, left, right, expr.getRange());\r\n            case \"theta join\":\r\n                return new ThetaJoinNode(ThetaJoinType.full, expr, left, right, nullValuesSupport);\r\n            case \"left theta semijoin\":\r\n                return new ThetaJoinNode(ThetaJoinType.left, expr, left, right, nullValuesSupport);\r\n            case \"right theta semijoin\":\r\n                return new ThetaJoinNode(ThetaJoinType.right, expr, left, right, nullValuesSupport);\r\n        }\r\n    }\r\n}","import React from \"react\";\r\n\r\ninterface TextInputProps {\r\n    // initial value for the input\r\n    value: string,\r\n    // text on the submit button\r\n    buttonText: string,\r\n    // handler of input submit\r\n    onSubmit: (text: string) => void,\r\n    // function which returns true for forbidden inputs which cannot be submitted\r\n    forbidden: (text: string) => boolean,\r\n\r\n    // id of the input\r\n    id: string\r\n}\r\n\r\ninterface TextInputState {\r\n    value: string,\r\n    buttonDisable: boolean\r\n}\r\n\r\n/**\r\n * Basic text input with submit button (without label). The input cannot be submit if the current value is forbidden.\r\n * All inserted tabulators are replaced by 4 spaces.\r\n */\r\nexport class TextInput extends React.Component<TextInputProps, TextInputState> {\r\n\r\n    private readonly inputRef: React.RefObject<HTMLInputElement>;\r\n\r\n    constructor(props: TextInputProps) {\r\n        super(props);\r\n        this.state = {\r\n            value: this.props.value,\r\n            buttonDisable: this.props.forbidden(this.props.value)\r\n        }\r\n        this.inputRef = React.createRef();\r\n    }\r\n\r\n    componentDidUpdate(prevProps: Readonly<TextInputProps>) {\r\n        if (prevProps.value !== this.props.value) {\r\n            this.setState({value: this.props.value});\r\n        }\r\n    }\r\n\r\n    private handleChange = (value: string): void => {\r\n        value = value.replace(/\\t/g, \"    \");\r\n        const disable: boolean = this.props.forbidden(value);\r\n        this.setState({\r\n            value: value,\r\n            buttonDisable: disable\r\n        });\r\n    }\r\n\r\n    private handleKeyDown = (event: React.KeyboardEvent<HTMLInputElement>): void => {\r\n        if (event.key === \"Enter\") {\r\n            if (!this.state.buttonDisable) {\r\n                this.handleSubmit();\r\n            }\r\n        }\r\n        else if (event.key === \"Escape\" || event.key === \"Esc\") {\r\n            if (this.inputRef.current !== null) {\r\n                this.inputRef.current.blur();\r\n            }\r\n        }\r\n    }\r\n\r\n    private handleSubmit = (): void => {\r\n        this.props.onSubmit(this.state.value);\r\n    }\r\n\r\n    public render() {\r\n        return (\r\n            <>\r\n                <input\r\n                    ref={this.inputRef}\r\n                    type='text'\r\n                    id={this.props.id}\r\n                    spellCheck={false}\r\n                    autoComplete={\"off\"}\r\n                    value={this.state.value}\r\n                    onChange={event => this.handleChange(event.target.value)}\r\n                    onKeyDown={this.handleKeyDown}\r\n                    className={'text-input'}\r\n                />\r\n                <button\r\n                    onClick={this.handleSubmit}\r\n                    disabled={this.state.buttonDisable}\r\n                >{this.props.buttonText}</button>\r\n            </>\r\n        );\r\n    }\r\n}","import \"./css/messageBox.css\"\r\n\r\n// @ts-ignore\r\nconst cssConstants: CSSStyleDeclaration = getComputedStyle(document.querySelector(':root'));\r\nconst boxMargin: number = Number(cssConstants.getPropertyValue('--message-box-margin-num'));\r\n\r\nexport class MessageBox {\r\n\r\n    private static readonly hideTimeout: number = 5000;\r\n\r\n    private static box: HTMLDivElement = MessageBox.init();\r\n    private static hideIntervalId: NodeJS.Timeout;\r\n\r\n    private static init(): HTMLDivElement {\r\n        const box = document.createElement(\"div\");\r\n        box.classList.add(\"message-box\");\r\n        box.style.visibility = \"hidden\";\r\n        box.onmouseenter = () => {\r\n            MessageBox.clearHideTimeout();\r\n        }\r\n        box.onmouseleave = () => {\r\n            MessageBox.setHideTimeout();\r\n        }\r\n\r\n        const paragraph = document.createElement(\"p\");\r\n        box.appendChild(paragraph);\r\n\r\n        const button = document.createElement(\"button\");\r\n        button.innerText = \"\\u2716\";\r\n        button.onclick = () => {\r\n            MessageBox.hideBox();\r\n        }\r\n        box.appendChild(button);\r\n\r\n        window.addEventListener('resize', () => {\r\n            MessageBox.moveBox();\r\n        });\r\n\r\n        document.body.appendChild(box);\r\n        return box;\r\n    }\r\n\r\n    private static setHideTimeout = () => {\r\n        // clears previous hide interval\r\n        MessageBox.clearHideTimeout();\r\n        MessageBox.hideIntervalId = setTimeout(MessageBox.hideBox, MessageBox.hideTimeout);\r\n    }\r\n\r\n    private static clearHideTimeout = () => {\r\n        clearTimeout(MessageBox.hideIntervalId);\r\n    }\r\n\r\n    private static hideBox = () => {\r\n        MessageBox.box.style.visibility = \"hidden\";\r\n    }\r\n\r\n    private static moveBox = () => {\r\n        if (MessageBox.box.style.visibility === \"visible\") {\r\n            MessageBox.box.style.width = (document.body.clientWidth - 2 * boxMargin) + \"px\";\r\n        }\r\n    }\r\n\r\n    private static display(msg: string, error: boolean): void {\r\n        const box = MessageBox.box;\r\n        // @ts-ignore - first element is paragraph\r\n        box.firstElementChild.innerText = msg;\r\n        box.style.visibility = \"visible\";\r\n        box.classList.toggle(\"message-box-message\", !error);\r\n        box.classList.toggle(\"message-box-error\", error);\r\n        MessageBox.moveBox();\r\n        MessageBox.setHideTimeout();\r\n    }\r\n\r\n    /**\r\n     * Displays given message in a message box fixed on the page bottom.\r\n     */\r\n    public static message(msg: string): void {\r\n        MessageBox.display(msg, false);\r\n    }\r\n\r\n    /**\r\n     * Displays given error in a message box fixed on the page bottom.\r\n     */\r\n    public static error(msg: string): void {\r\n        MessageBox.display(msg, true);\r\n    }\r\n}","import React from \"react\";\r\nimport \"./css/expressionSection.css\"\r\nimport Relation from \"../relation/relation\";\r\nimport {TooltipButton} from \"./tooltipButton\";\r\nimport RASyntaxError from \"../error/raSyntaxError\";\r\nimport RASemanticError from \"../error/raSemanticError\";\r\nimport {XTextArea} from \"./xTextArea\";\r\nimport {ExprParser} from \"../expression/exprParser\";\r\nimport {getStartOfWordBeforeIndex, sortWhispers} from \"../utils/whisperUtils\";\r\nimport {Expression} from \"../expression/expression\";\r\nimport {TextInput} from \"./textInput\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\nimport RATreeNode from \"../ratree/raTreeNode\";\r\nimport {MessageBox} from \"./messageBox\";\r\nimport {LanguageDef} from \"../language/language\";\r\nimport {StartEndPair} from \"../types/startEndPair\";\r\n\r\ninterface ExpressionSectionProps {\r\n    // available expressions\r\n    expressions: Expression[],\r\n    // index of the current selected expression in the expression list\r\n    currentExpressionIndex: number,\r\n\r\n    // loaded relations user as sources for expression evaluation\r\n    relations: Map<string, Relation>,\r\n\r\n    // handler of selecting different expression as current\r\n    onSelectDifferentExpression: (newIndex: number) => void,\r\n    // handler of moving an expression on a new position using drag and drop\r\n    onDragExpression: (from: number, to: number) => void,\r\n    // handler of creating the new expression\r\n    onNewExpression: () => void,\r\n    // handler of deleting the current expression\r\n    onDeleteExpression: (onDone: () => void) => void,\r\n    // handler of saving the expressions\r\n    onExportExpressions: (onDone: (msg: string) => void) => void,\r\n    // handler of loading the expressions\r\n    onImportExpressions: (onDone: (msg: string) => void) => void,\r\n\r\n    // handler of change in the current selected expression\r\n    onChange: (name: string, text: string) => void,\r\n    // handler of evaluation, it accepts the parsed tree from the expression text\r\n    onEval: (tree: RATreeNode) => void,\r\n    // handler of unexpected errors\r\n    onUnexpectedError: (e: Error) => void,\r\n\r\n    // whether to support null values\r\n    nullValuesSupport: boolean,\r\n    // true if dark theme should be applied\r\n    darkTheme: boolean,\r\n    // current application language\r\n    language: LanguageDef\r\n}\r\n\r\ninterface ExpressionSectionState {\r\n    sectionClicked: boolean,\r\n    whispers: string[],\r\n    errors: {start: number, end: number, msg: string}[],\r\n    parentheses: StartEndPair[],\r\n    cursorIndex: number\r\n}\r\n\r\n/**\r\n * Section to edit, manage, and eval relational algebra expressions.\r\n */\r\nexport class ExpressionSection extends React.Component<ExpressionSectionProps, ExpressionSectionState> {\r\n\r\n    // reference to child textarea element\r\n    private readonly textAreaRef: React.RefObject<XTextArea>;\r\n    // timestamp of last expression text change\r\n    private lastChange: number = 0;\r\n    // timestamp of last display of whispers and errors\r\n    private lastWhisperAndErrorsUpdate: number = 0;\r\n    // update rate of whispers and errors (in ms)\r\n    private readonly whispersAndErrorsUpdateRate: number = 400;\r\n\r\n    constructor(props: ExpressionSectionProps) {\r\n        super(props);\r\n        this.state = {\r\n            sectionClicked: false,\r\n            whispers: [],\r\n            errors: [],\r\n            parentheses: [],\r\n            cursorIndex: 0\r\n        }\r\n        this.textAreaRef = React.createRef<XTextArea>();\r\n        setInterval(() => this.updateWhispersAndErrors(), this.whispersAndErrorsUpdateRate);\r\n    }\r\n\r\n    /**\r\n     * Updates displayed errors and parentheses pairs in the text area input.\r\n     */\r\n    public updateErrorsAndParentheses = () => {\r\n        const text = this.getCurExpr().text;\r\n        const exprParser: ExprParser = new ExprParser(this.props.relations, this.props.nullValuesSupport);\r\n        const { errors, parentheses } = exprParser.fakeParse(text, this.state.cursorIndex);\r\n        this.setState({\r\n            errors: errors.filter(err => err.range !== undefined && !isNaN(err.range.start) && !isNaN(err.range.end))\r\n                // @ts-ignore\r\n                .map(err => {return {start: err.range.start, end: err.range.end + 1, msg: err.message}}),\r\n            parentheses: parentheses.filter(p => !isNaN(p.start) && !isNaN(p.end))\r\n        });\r\n    }\r\n\r\n    private getCurExpr(): Expression {\r\n        return this.props.expressions[this.props.currentExpressionIndex];\r\n    }\r\n\r\n    private handleSelectDifferentExpression(index: number): void {\r\n        this.props.onSelectDifferentExpression(index);\r\n    }\r\n\r\n    private evalExpr = (): void => {\r\n        try {\r\n            const exprParser: ExprParser = new ExprParser(this.props.relations, this.props.nullValuesSupport);\r\n            const tree = exprParser.parse(this.props.expressions[this.props.currentExpressionIndex].text);\r\n            tree.eval();\r\n            this.setState({errors: []});\r\n            this.props.onEval(tree);\r\n        }\r\n        catch (err) {\r\n            if (err instanceof ErrorWithTextRange) {\r\n                if (err.range !== undefined) {\r\n                    // change end to also highlight the last char\r\n                    err.range.end += 1;\r\n                    this.setState(state => {\r\n                        const errorRanges = state.errors;\r\n                        // does not push duplicate error range\r\n                        if (errorRanges.every(er => er.start !== err.range.start || er.end !== err.range.end)) {\r\n                            errorRanges.push({...err.range, msg: err.message});\r\n                        }\r\n                        return {errors: errorRanges}\r\n                    });\r\n                }\r\n            }\r\n            this.showError(err);\r\n        }\r\n    }\r\n\r\n    private newExpression = (): void => {\r\n        this.props.onNewExpression();\r\n    }\r\n\r\n    private deleteExpression = (): void => {\r\n        this.props.onDeleteExpression(this.updateErrorsAndParentheses);\r\n    }\r\n\r\n    private exportExpressions = (): void => {\r\n        this.props.onExportExpressions(MessageBox.message);\r\n    }\r\n\r\n    private importExpressions = (): void => {\r\n        this.props.onImportExpressions((msg) => {\r\n            MessageBox.message(msg);\r\n            this.updateErrorsAndParentheses();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds given special string into RA expression at the current cursor position.\r\n     *\r\n     * @param str string to be added\r\n     * @param shift move of the cursor from added string end position (to the beginning)\r\n     */\r\n    private addSpecialString = (str: string, shift: number): void => {\r\n        // @ts-ignore\r\n        const {start, end} = this.textAreaRef.current.getSelection();\r\n        const firstPart: string = this.getCurExpr().text.substring(0, start);\r\n        const secondPart: string = this.getCurExpr().text.substring(end);\r\n        const newPosition: number = firstPart.length + str.length - shift;\r\n        const newStr: string = firstPart + str + secondPart;\r\n        // updates text in textarea\r\n        this.handleExprChange(newStr, newPosition, () => {\r\n            // @ts-ignore - moves cursor to expected position\r\n            this.textAreaRef.current.setSelection(newPosition);\r\n            // @ts-ignore\r\n            this.textAreaRef.current.focus();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handles change of expression text. Updates text and notifies the parent.\r\n     *\r\n     * @param text\r\n     * @param cursorIndex\r\n     * @param onDone callback after updating the state\r\n     */\r\n    private handleExprChange = (text: string, cursorIndex: number, onDone: () => void = () => {}): void => {\r\n        this.props.onChange(this.getCurExpr().name, text);  // must be called before setState for proper functionality of XTextArea\r\n        this.setState({cursorIndex: cursorIndex}, onDone);\r\n        this.lastChange = Date.now();\r\n    }\r\n\r\n    /**\r\n     * Handles input with Ctrl key pressed from textarea.\r\n     */\r\n    private handleCtrlInput = (ev: KeyboardEvent): void => {\r\n        if (ev.key === \"Enter\") {\r\n            this.evalExpr();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Shows current whispers and errors, if the text area is focused and there was a text change after last update.\r\n     */\r\n    private updateWhispersAndErrors = () => {\r\n        const textArea = this.textAreaRef.current;\r\n        if (textArea !== null && textArea.isFocused() && this.lastChange > this.lastWhisperAndErrorsUpdate) {\r\n            const text = this.getCurExpr().text;\r\n            const exprParser: ExprParser = new ExprParser(this.props.relations, this.props.nullValuesSupport);\r\n            const fakeParseResult = exprParser.fakeParse(text, this.state.cursorIndex);\r\n            const wordBeforeCursor: string = text.slice(getStartOfWordBeforeIndex(text, this.state.cursorIndex), this.state.cursorIndex);\r\n            const whispers = sortWhispers(fakeParseResult.whispers, wordBeforeCursor);\r\n            this.setState({\r\n                whispers: whispers,\r\n                errors: fakeParseResult.errors.filter(err => err.range !== undefined && !isNaN(err.range.start) && !isNaN(err.range.end))\r\n                    // @ts-ignore\r\n                    .map(err => {return {start: err.range.start, end: err.range.end + 1, msg: err.message}}),\r\n                parentheses: fakeParseResult.parentheses.filter(p => !isNaN(p.start) && !isNaN(p.end))\r\n            });\r\n            this.lastWhisperAndErrorsUpdate = Date.now();\r\n        }\r\n    }\r\n\r\n    private handleExprNameChange = (name: string) => {\r\n        this.props.onChange(name, this.getCurExpr().text);\r\n    }\r\n\r\n    /**\r\n     * Handles and shows the given error. If the error is not of RASyntaxError or RASemanticError class, it is passed\r\n     * to the parent as unexpected error.\r\n     *\r\n     * @param err the error to handle\r\n     */\r\n    private showError = (err: Error) => {\r\n        // common user's errors\r\n        if (err instanceof RASyntaxError || err instanceof RASemanticError) {\r\n            MessageBox.error(err.message);\r\n        }\r\n        else {\r\n            this.props.onUnexpectedError(err);\r\n            MessageBox.error(\"UNEXPECTED ERROR: \" + err.message + \"\\n\" +\r\n                \"Please, help us and report your last actions, thank you!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Requests expressions move when the drag ends.\r\n     */\r\n    // @ts-ignore\r\n    private handleDragDrop = (e: DragEvent<HTMLDivElement>, i: number) => {\r\n        const from = Number(e.dataTransfer.getData(\"text/plain\"));\r\n        if (!isNaN(from)) {\r\n            this.props.onDragExpression(from, i);\r\n        }\r\n    }\r\n\r\n    public render() {\r\n        const lang = this.props.language.expressionSection;\r\n        const ops = this.props.language.operations;\r\n\r\n        const createExprMenuButtons = () => {\r\n            return this.props.expressions.map((expr, i) => {\r\n                const className: string = (this.props.currentExpressionIndex === i ? \"button-clicked\" : \"\");\r\n                return (<button\r\n                    key={i}\r\n                    onClick={() => this.handleSelectDifferentExpression(i)}\r\n                    className={className}\r\n                    draggable={true}\r\n                    onDragStart={e => e.dataTransfer.setData(\"text/plain\", String(i))}\r\n                    onDragOver={e => e.preventDefault()}\r\n                    onDrop={e => this.handleDragDrop(e, i)}\r\n                >{expr.name}</button>);\r\n            });\r\n        }\r\n\r\n        const createButton = (text: string, onClick: () => void, tooltip: string, style?: React.CSSProperties) => {\r\n            return (<TooltipButton\r\n                key={text}\r\n                text={text}\r\n                onClick={onClick}\r\n                style={style}\r\n                tooltip={tooltip}\r\n            />);\r\n        }\r\n\r\n        const createOpButton = (key: string, char: string, text: string, tooltip: string, shift: number, style: React.CSSProperties = {}) => {\r\n            return (<TooltipButton\r\n                key={key}\r\n                text={text}\r\n                onClick={() => this.addSpecialString(char, shift)}\r\n                tooltip={tooltip}\r\n                style={style}\r\n            />);\r\n        }\r\n        const buttonGroupMargin = {marginRight: \"10px\"};\r\n\r\n        return (\r\n            <section className=\"page-section\">\r\n                <header>\r\n                    <h2>{lang.expressionSectionHeader}</h2>\r\n                    {createButton(lang.importButton, this.importExpressions, lang.importButtonTooltip)}\r\n                    {createButton(lang.exportButton, this.exportExpressions, lang.exportButtonTooltip)}\r\n                </header>\r\n\r\n                <menu className=\"page-section-tab-menu\">\r\n                    {createExprMenuButtons()}\r\n                    <button onClick={this.newExpression}\r\n                        style={{minWidth: \"0\", marginLeft: \"10px\", padding: \"2px 6px 1px 6px\"}}>\r\n                        <strong>+</strong>\r\n                    </button>\r\n                </menu>\r\n\r\n                <XTextArea\r\n                    ref={this.textAreaRef}\r\n                    id=\"expression-section-textarea\"\r\n                    text={this.getCurExpr().text}\r\n                    placeholder={lang.expressionTextareaPlaceholder}\r\n                    errors={this.state.errors}\r\n                    whispers={this.state.whispers}\r\n                    parentheses={this.state.parentheses}\r\n\r\n                    onChange={this.handleExprChange}\r\n                    onCtrlInput={this.handleCtrlInput}\r\n\r\n                    darkTheme={this.props.darkTheme}\r\n                />\r\n\r\n                <menu className=\"expressions-operators-menu\">\r\n                    {createOpButton(\"unary_a\", \"()\", \"()\", ops.selection, 1)}\r\n                    {createOpButton(\"unary_b\", \"[]\", \"[]\", ops.projection, 1)}\r\n                    {createOpButton(\"unary_c\", \"< -> >\", \"<>\", ops.rename, 5, buttonGroupMargin)}\r\n\r\n                    {createOpButton(\"set_a\", \"\\u222a\", \"\\u222a\", ops.union, 0)}\r\n                    {createOpButton(\"set_b\", \"\\u2229\", \"\\u2229\", ops.intersection, 0)}\r\n                    {createOpButton(\"set_c\", \"\\\\\", \"\\\\\", ops.difference, 0, buttonGroupMargin)}\r\n\r\n                    {createOpButton(\"inner_a\", \"*\", \"*\", ops.naturalJoin, 0)}\r\n                    {createOpButton(\"inner_b\", \"\\u2a2f\", \"\\u2a2f\", ops.cartesianProduct, 0)}\r\n                    {createOpButton(\"inner_c\", \"<*\", \"<*\", ops.leftSemiJoin, 0)}\r\n                    {createOpButton(\"inner_d\", \"*>\", \"*>\", ops.rightSemiJoin, 0)}\r\n                    {createOpButton(\"inner_e\", \"\\u22b3\", \"\\u22b3\", ops.leftAntijoin, 0)}\r\n                    {createOpButton(\"inner_f\", \"\\u22b2\", \"\\u22b2\", ops.rightAntijoin, 0)}\r\n                    {createOpButton(\"inner_g\", \"[]\", \"[]\", ops.thetaJoin, 1)}\r\n                    {createOpButton(\"inner_h\", \"<]\", \"<]\", ops.leftThetaSemiJoin, 1)}\r\n                    {createOpButton(\"inner_i\", \"[>\", \"[>\", ops.rightThetaSemiJoin, 1, buttonGroupMargin)}\r\n\r\n                    {this.props.nullValuesSupport && createOpButton(\"outer_a\", \"*F*\", \"*F*\", ops.fullOuterJoin, 0)}\r\n                    {this.props.nullValuesSupport && createOpButton(\"outer_b\", \"*L*\", \"*L*\", ops.leftOuterJoin, 0)}\r\n                    {this.props.nullValuesSupport && createOpButton(\"outer_c\", \"*R*\", \"*R*\", ops.rightOuterJoin, 0, buttonGroupMargin)}\r\n\r\n                    {createOpButton(\"division\", \"\\u00f7\", \"\\u00f7\", ops.division, 0, buttonGroupMargin)}\r\n\r\n                    {createOpButton(\"line_comment\", \"//\", \"//\", lang.lineComment, 0)}\r\n                    {createOpButton(\"block_comment\", \"/**/\", \"/*\", lang.blockComment, 2)}\r\n                </menu>\r\n\r\n                <menu className=\"page-section-management-menu\">\r\n                    <TooltipButton\r\n                        text={lang.evaluateButton}\r\n                        onClick={this.evalExpr}\r\n                        className={\"action-button\"}\r\n                        style={{marginRight: \"40px\"}}\r\n                        tooltip={lang.evaluateButtonTooltip}\r\n                    />\r\n                    <TextInput\r\n                        value={this.getCurExpr().name}\r\n                        buttonText={lang.renameButton}\r\n                        onSubmit={this.handleExprNameChange}\r\n                        forbidden={() => false}\r\n                        id=\"expression-name-input\"\r\n                    />\r\n                    {createButton(lang.deleteButton, this.deleteExpression, lang.deleteButtonTooltip)}\r\n                </menu>\r\n            </section>\r\n        );\r\n    }\r\n}","import React from \"react\";\r\nimport Relation from \"../relation/relation\";\r\nimport './css/resultRelationTable.css'\r\nimport Row from \"../relation/row\";\r\n\r\ninterface RelationTableProps {\r\n    // relation to be shown\r\n    relation: Relation\r\n}\r\n\r\ninterface RelationTableState {\r\n    // index of the column which is used to order the table (or -1 if none is used)\r\n    orderBy: number,\r\n    // 1 = ascending, -1 = descending\r\n    orderDir: number\r\n}\r\n\r\n/**\r\n * Table which shows given relation. The relation cannot be edited\r\n * Rows can be ordered by column values when the column header is clicked.\r\n * When the same column header is clicked for the second time, the order direction is changed (asc, des, asc, des, ...).\r\n */\r\nexport class ResultRelationTable extends React.Component<RelationTableProps, RelationTableState> {\r\n\r\n    constructor(props: RelationTableProps) {\r\n        super(props);\r\n        this.state = {\r\n            orderBy: -1,\r\n            orderDir: 1\r\n        }\r\n    }\r\n\r\n    componentDidUpdate(prevProps: Readonly<RelationTableProps>, prevState: Readonly<RelationTableState>, snapshot?: any) {\r\n        if (prevProps.relation !== this.props.relation) {\r\n            this.setState({\r\n                orderDir: 1,\r\n                orderBy: -1\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates ordering column or direction. If the given orderBy index is already selected, switches ASC/DESC order.\r\n     * Otherwise, sets ASC ordering by new orderBy column index.\r\n     */\r\n    private updateOrderBy(orderBy: number): void {\r\n        this.setState(state => {\r\n            if (state.orderBy === orderBy) {\r\n                return {\r\n                    orderDir: -state.orderDir,\r\n                    orderBy: orderBy\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    orderDir: 1,\r\n                    orderBy: orderBy\r\n                };\r\n            }\r\n        });\r\n    }\r\n\r\n    private getOrderByText = (): string => {\r\n        return this.state.orderDir === 1 ? \" ▼\" : \" ▲\";\r\n    }\r\n\r\n    /**\r\n     * Creates a header row for a table (with given column names).\r\n     *\r\n     * @param columns\r\n     */\r\n    private createHeaderRow(columns: string[]) {\r\n        return (\r\n            <tr>\r\n                <td className=\"row-number-td\"/>\r\n                {columns.map((columnName, index) => {\r\n                    const text: string = this.state.orderBy === index ?\r\n                        (columnName + this.getOrderByText()) : columnName;\r\n                    return <th key={index} onClick={() => this.updateOrderBy(index)}>{text}</th>\r\n                })}\r\n            </tr>\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates rows for a table. If there is no row in a resultRelation, returns one cell \"<<NO ROWS>>\".\r\n     *\r\n     * @param columns\r\n     */\r\n    private createRows(columns: string[]) {\r\n        // creates default row if no exists\r\n        if (this.props.relation.getRowsCount() === 0) {\r\n            return (\r\n                <tr key='1'>\r\n                    <td className=\"row-number-td\"/>\r\n                    <td key='1' colSpan={columns.length}>{'<<NO ROWS>>'}</td>\r\n                </tr>\r\n            );\r\n        }\r\n        const rows: Row[] = this.props.relation.getRows();\r\n        // sorts rows if orderBy is given (null values are after other values)\r\n        if (this.state.orderBy > -1 && this.state.orderBy < columns.length) {\r\n            const sortCol: string = columns[this.state.orderBy];\r\n            // @ts-ignore cannot be undefined\r\n            const type: \"string\" | \"number\" | \"boolean\" = rows[0].getType(sortCol);\r\n            if (type === \"number\") {\r\n                rows.sort((a, b) => {\r\n                    // @ts-ignore\r\n                    let aValue: number | null = a.getValue(sortCol);\r\n                    // @ts-ignore\r\n                    let bValue: number | null = b.getValue(sortCol);\r\n                    // a is null\r\n                    if (aValue === null && bValue !== null) {\r\n                        return this.state.orderDir * Number.MAX_SAFE_INTEGER;\r\n                    }\r\n                    // b is null\r\n                    if (aValue !== null && bValue === null) {\r\n                        return this.state.orderDir * Number.MIN_SAFE_INTEGER;\r\n                    }\r\n                    // no is null - compares as numbers\r\n                    if (aValue !== null && bValue !== null) {\r\n                        // @ts-ignore\r\n                        return this.state.orderDir * (a.getValue(sortCol) - b.getValue(sortCol));\r\n                    }\r\n                    // both are null\r\n                    return 0;\r\n                });\r\n            }\r\n            else {\r\n                rows.sort((a, b) => {\r\n                    // @ts-ignore\r\n                    let aValue: string | boolean | null = a.getValue(sortCol);\r\n                    // @ts-ignore\r\n                    let bValue: string | boolean | null = b.getValue(sortCol);\r\n                    // a is null\r\n                    if (aValue === null && bValue !== null) {\r\n                        return this.state.orderDir * Number.MAX_SAFE_INTEGER;\r\n                    }\r\n                    // b is null\r\n                    if (aValue !== null && bValue === null) {\r\n                        return this.state.orderDir * Number.MIN_SAFE_INTEGER;\r\n                    }\r\n                    // no is null - compares as strings\r\n                    if (aValue !== null && bValue !== null) {\r\n                        return this.state.orderDir * String(a.getValue(sortCol)).localeCompare(String(b.getValue(sortCol)));\r\n                    }\r\n                    // both are null\r\n                    return 0;\r\n                });\r\n            }\r\n        }\r\n        // creates all rows if any\r\n        return rows.map((row, index) => (\r\n            <tr key={index}>\r\n                <td className=\"row-number-td\">{index + 1}</td>\r\n                {row.getOrderedPrintValues(columns).map((value, index) => (\r\n                    <td key={index}>{value}</td>\r\n                ))}\r\n            </tr>\r\n        ));\r\n    }\r\n\r\n    render(){\r\n        // creates header row\r\n        const columns: string[] = this.props.relation.getColumnNames();\r\n        const headerRow = this.createHeaderRow(columns);\r\n        const rows = this.createRows(columns);\r\n\r\n        return (\r\n            <div className=\"result-table-container scrollbar-container\">\r\n                <table className=\"result-table\">\r\n                    <thead>\r\n                    {headerRow}\r\n                    </thead>\r\n                    <tbody>\r\n                    {rows}\r\n                    </tbody>\r\n                </table>\r\n            </div>\r\n        );\r\n    }\r\n}","import React from \"react\";\r\nimport { Group } from '@visx/group';\r\nimport { hierarchy, Tree } from '@visx/hierarchy';\r\nimport { HierarchyPointNode, HierarchyPointLink } from '@visx/hierarchy/lib/types';\r\nimport { LinkVertical } from '@visx/shape';\r\nimport ParentSize from \"@visx/responsive/lib/components/ParentSize\";\r\nimport {useTooltip} from '@visx/tooltip';\r\nimport './css/evaluationTree.css';\r\nimport RATreeNode from \"../ratree/raTreeNode\";\r\nimport UnaryNode from \"../ratree/unaryNode\";\r\nimport BinaryNode from \"../ratree/binaryNode\";\r\nimport {getTreeDepth} from \"../ratree/raTreeTools\";\r\nimport {computeFontSizeInPx} from \"../utils/fontUtils\";\r\n\r\nexport const evalTreeSVGId: string = \"eval-tree-svg\";\r\n\r\ninterface EvaluationTreeProps {\r\n    // root of the evaluation tree to be displayed\r\n    tree: RATreeNode,\r\n    // index of the current selected node (with respect to depth first search)\r\n    selected: number,\r\n    // handler of click on nodes, it receives the index of the clicked node (with respect to depth first search)\r\n    onClick: (index: number) => void,\r\n    // true if dark theme should be applied\r\n    darkTheme: boolean\r\n}\r\n\r\n/**\r\n * Component displaying an evaluation tree. The tree is interactive and handles clicking on the nodes.\r\n */\r\nexport class EvaluationTree extends React.Component<EvaluationTreeProps, {}> {\r\n    render() {\r\n        return (\r\n            <ParentSize>{({ width }) =>\r\n                <TreeComponent\r\n                    raTree={this.props.tree}\r\n                    selected={this.props.selected}\r\n                    width={width}\r\n                    onClick={this.props.onClick}\r\n                    darkTheme={this.props.darkTheme}\r\n                />}\r\n            </ParentSize>\r\n        );\r\n    }\r\n}\r\n\r\n// @ts-ignore\r\nconst cssConstants: CSSStyleDeclaration = getComputedStyle(document.querySelector(':root'));\r\n\r\nconst fontSize: string = cssConstants.getPropertyValue('--eval-tree-font-size');\r\nconst fontFamily: string = cssConstants.getPropertyValue('--eval-tree-font-family');\r\nconst {fontWidth, fontHeight} = computeFontSizeInPx(fontFamily, fontSize);\r\nconst nodePaddingX2: number = 24;\r\nconst nodeHeight = 2 * fontHeight + nodePaddingX2;\r\nconst maxNodeTextLength = 30;\r\n\r\nconst backgroundColorLight = cssConstants.getPropertyValue('--light-color-a');\r\nconst backgroundColorDark = cssConstants.getPropertyValue('--dark-color-a');\r\nconst textColorLight = cssConstants.getPropertyValue('--text-color-light');\r\nconst textColorDark = cssConstants.getPropertyValue('--text-color-dark');\r\nconst selectedNodeColorLight = cssConstants.getPropertyValue('--light-color-c');\r\nconst unselectedNodeColorLight = cssConstants.getPropertyValue('--light-color-b');\r\nconst selectedNodeColorDark = cssConstants.getPropertyValue('--dark-color-d');\r\nconst unselectedNodeColorDark = cssConstants.getPropertyValue('--dark-color-c');\r\n\r\ninterface DisplayTreeNode {\r\n    title: string;\r\n    symbol: string,\r\n    index: number;\r\n    children?: this[];\r\n}\r\n\r\n/**\r\n * Creates a DisplayTreeNode tree from the given RATreeNode tree.\r\n *\r\n * @param tree RATreeNode tree to parse to DisplayTreeNode tree\r\n * @return parsed DisplayTreeNode tree\r\n */\r\nfunction parseTreeForDisplay(tree: RATreeNode): DisplayTreeNode {\r\n    let indexes = 0;\r\n    function parseTreeForDisplayHelper(node: RATreeNode): DisplayTreeNode {\r\n        let symbol: string = node.getOperationSymbol();\r\n        if (symbol.length > maxNodeTextLength) {\r\n            symbol = symbol.slice(0, maxNodeTextLength - 4) + \"...\" + symbol.charAt(symbol.length - 1);\r\n        }\r\n\r\n        if (node instanceof UnaryNode) {\r\n            return {\r\n                title: node.getOperationName(),\r\n                symbol: symbol,\r\n                index: indexes++,\r\n                children: [\r\n                    parseTreeForDisplayHelper(node.getSubtree())\r\n                ]\r\n            }\r\n        }\r\n        else if (node instanceof BinaryNode) {\r\n            return {\r\n                title: node.getOperationName(),\r\n                symbol: symbol,\r\n                index: indexes++,\r\n                children: [\r\n                    parseTreeForDisplayHelper(node.getLeftSubtree()),\r\n                    parseTreeForDisplayHelper(node.getRightSubtree())\r\n                ]\r\n            }\r\n        }\r\n        else /* (tree instanceof RelationNode) */ {\r\n            return {\r\n                title: node.getOperationName(),\r\n                symbol: symbol,\r\n                index: indexes++\r\n            };\r\n        }\r\n    }\r\n    return parseTreeForDisplayHelper(tree);\r\n}\r\n\r\n/**\r\n * Component representing individual nodes of the displayed tree.\r\n *\r\n * Props:\r\n * - node: HierarchyPointNode<DisplayTreeNode>: node to be displayed wrapped as visx HierarchyPointNode.\r\n * - selected: boolean: boolean whether the given node is currently selected by the user\r\n * - onClick: (index: number) => void: handler of click on the node, it receives the index of the node (with\r\n * respect to depth first search)\r\n */\r\nfunction TreeNodeComponent({ node, selected, onClick, darkTheme }:\r\n                               { node: HierarchyPointNode<DisplayTreeNode>, selected: boolean, onClick: (index: number) => void, darkTheme: boolean }): JSX.Element {\r\n    const {\r\n        tooltipOpen, // true when mouse is over\r\n        showTooltip,\r\n        hideTooltip\r\n    } = useTooltip();\r\n\r\n    const handleMouseOver = () => {\r\n        showTooltip({ tooltipLeft: 0, tooltipTop: 0 });\r\n    };\r\n\r\n    // computes node width with respect to the text length and asserts it wider than taller\r\n    let nodeWidth = Math.max(node.data.title.length, node.data.symbol.length) * fontWidth + nodePaddingX2;\r\n    if (nodeWidth < nodeHeight) {\r\n        nodeWidth = nodeHeight;\r\n    }\r\n\r\n    return (\r\n        // top=y, left=x for vertical layout; top=x, left=y for horizontal layout\r\n        <Group top={node.y} left={node.x}>\r\n            <rect\r\n                height={nodeHeight} width={nodeWidth}\r\n                y={-nodeHeight / 2} x={-nodeWidth / 2} rx={5}\r\n                fill={darkTheme ?\r\n                    (selected ? selectedNodeColorDark : (tooltipOpen ? selectedNodeColorDark : unselectedNodeColorDark)) :\r\n                    (selected ? selectedNodeColorLight : (tooltipOpen ? selectedNodeColorLight : unselectedNodeColorLight))}\r\n                onClick={() => {\r\n                    onClick(node.data.index);\r\n                }}\r\n                cursor=\"pointer\"\r\n                onMouseOver={handleMouseOver}\r\n                onMouseOut={hideTooltip}\r\n            />\r\n            <text\r\n                y=\"-4px\"\r\n                dy=\".2em\"\r\n                fontSize={fontSize}\r\n                fontFamily={fontFamily}\r\n                textAnchor=\"middle\"\r\n                style={{ pointerEvents: \"none\"}}\r\n                fill={darkTheme ? textColorDark : textColorLight}\r\n            >\r\n                {node.data.symbol === \"\" ?\r\n                    <tspan x=\"0\" dy=\".5em\">{node.data.title}</tspan> :\r\n                    (<>\r\n                        <tspan x=\"0\" dy=\"0\">{node.data.title}</tspan>\r\n                        <tspan x=\"0\" dy=\"1.2em\">{node.data.symbol}</tspan>\r\n                    </>)}\r\n            </text>\r\n        </Group>\r\n    );\r\n}\r\n\r\n/**\r\n * Internal component for displaying the evaluation tree. It uses visx Tree component.\r\n *\r\n * Props:\r\n * - tree: RATreeNode: root of the evaluation tree to be displayed\r\n * - selected: number: index of the current selected node (with respect to depth first search)\r\n * - width: number: width of the parent container\r\n * - onClick: (index: number) => void: handler of click on nodes, it receives the index of the clicked node (with\r\n * respect to depth first search)\r\n */\r\nfunction TreeComponent({raTree, selected, width, onClick, darkTheme}:\r\n                           {raTree: RATreeNode, selected: number, width: number, onClick: (index: number) => void, darkTheme: boolean}): JSX.Element | null {\r\n    const treeDepth: number = getTreeDepth(raTree);\r\n    // height = \"nodes height\" + \"gaps between nodes\" + \"margin up and under\"\r\n    const height = (treeDepth + 1) * nodeHeight + treeDepth * nodeHeight / 2 + nodeHeight;\r\n    const margin = { top: nodeHeight, left: 0 / 2, right: 0 / 2, bottom: nodeHeight };\r\n    const yMax = height - margin.top - margin.bottom;\r\n    const xMax = width - margin.left - margin.right;\r\n\r\n    const tree: DisplayTreeNode = parseTreeForDisplay(raTree);\r\n    const data = hierarchy<DisplayTreeNode>(tree);\r\n\r\n    return width < 10 ? null : (\r\n        <svg id=\"eval-tree-svg\" width={width} height={height}>\r\n            <rect width={width} height={height} rx={14} fill={darkTheme ? backgroundColorDark : backgroundColorLight} />\r\n            <Tree<DisplayTreeNode> root={data} size={[xMax, yMax]}>\r\n                {tree => (\r\n                    <Group top={margin.top} left={margin.left}>\r\n                        {tree.links().map((link, i) => (\r\n                            <LinkVertical<HierarchyPointLink<DisplayTreeNode>, HierarchyPointNode<DisplayTreeNode>>\r\n                                key={`cluster-link-${i}`}\r\n                                data={link}\r\n                                stroke={darkTheme ? textColorDark : textColorLight}\r\n                                strokeWidth=\"1\"\r\n                                strokeOpacity={1}\r\n                                fill=\"none\"\r\n                            />\r\n                        ))}\r\n                        {tree.descendants().map((node) => (\r\n                            <TreeNodeComponent\r\n                                key={`node-${node.data.index}`}\r\n                                node={node}\r\n                                selected={node.data.index === selected}\r\n                                onClick={onClick}\r\n                                darkTheme={darkTheme}\r\n                            />\r\n                        ))}\r\n                    </Group>\r\n                )}\r\n            </Tree>\r\n        </svg>\r\n    );\r\n}","export interface File {\r\n    name: string,\r\n    text: string | null\r\n}\r\n\r\n/**\r\n * FileDialog for loading files to the application.\r\n */\r\nexport class FileDialog {\r\n\r\n    /**\r\n     * Loads asynchronously a textual content from one file selected by the user in the file browser.\r\n     *\r\n     * @param accept comma-separated list of extensions for filter (default are all extensions)\r\n     */\r\n    public static openFile(accept: string = \"*\"): Promise<File> {\r\n        return new Promise<File>(resolve => {\r\n            let element = document.createElement('div');\r\n            element.innerHTML = `<input type=\"file\" accept=${accept}>`;\r\n            let fileInput = element.firstChild;\r\n            // @ts-ignore\r\n            fileInput.addEventListener('change', function() {\r\n                // @ts-ignore\r\n                let file = fileInput.files[0];\r\n                let reader = new FileReader();\r\n                reader.onload = function() {\r\n                    // @ts-ignore\r\n                    resolve({name: file.name, text: reader.result});\r\n                };\r\n                reader.readAsText(file);\r\n            });\r\n            // @ts-ignore\r\n            fileInput.click();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Asynchronously loads textual content from multiple files selected by the user in the file browser.\r\n     *\r\n     * @param accept comma-separated list of extensions for filter (default are all extensions)\r\n     */\r\n    public static openFiles(accept: string = \"*\"): Promise<File[]> {\r\n        return new Promise<File[]>(resolve => {\r\n            FileDialog.openFilesHelper(resolve, accept);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Loads textual content from multiple files selected by the user in the file browser.\r\n     * Multiple file input handling inspired by xaedes on https://stackoverflow.com/a/13975217.\r\n     *\r\n     * @param resolve - function called when the loading is done, it should accept an array of file information\r\n     * {name: string, text: string | null}[] where name contains the filename and text contains the content of the file.\r\n     * @param accept comma-separated list of extensions for filter\r\n     */\r\n    private static openFilesHelper(resolve: (files: File[]) => void, accept: string): void {\r\n        let element = document.createElement('div');\r\n        element.innerHTML = `<input type=\"file\" accept=${accept} multiple>`;\r\n        // @ts-ignore\r\n        let fileInput: HTMLInputElement = element.firstChild;\r\n        const fileInfo: {name: string, text: string | null}[] = [];\r\n        fileInput.addEventListener('change', function() {\r\n            // @ts-ignore\r\n            const files: FileList = fileInput.files;\r\n            function readFile(index: number) {\r\n                if (index === files.length) {\r\n                    return resolve(fileInfo);\r\n                }\r\n                const file = files[index];\r\n                const reader = new FileReader();\r\n                reader.onload = function(e) {\r\n                    // @ts-ignore\r\n                    fileInfo.push({name: file.name, text: e.target.result});\r\n                    readFile(index+1);\r\n                    console.log('File ' + (index+1) + '/' + files.length + ' loaded');\r\n                }\r\n                reader.readAsText(file);\r\n            }\r\n            readFile(0);\r\n        });\r\n        fileInput.click();\r\n    }\r\n}\r\n","/**\r\n * Wrapper of JavaScript Map object to provide usage of object {row: number | \"name\", column: number} as a key for\r\n * string values.\r\n */\r\nexport class NNToSMap {\r\n    private map: Map<string, string> = new Map<string, string>();\r\n\r\n    public get(row: number | \"name\", column: number): string | undefined {\r\n        return this.map.get(row + \":\" + column);\r\n    }\r\n\r\n    public set(row: number | \"name\", column: number, value: string): void {\r\n        this.map.set(row + \":\" + column, value);\r\n    }\r\n\r\n    public delete(row: number | \"name\", column: number): boolean {\r\n        return this.map.delete(row + \":\" + column);\r\n    }\r\n\r\n    public clear(): void {\r\n        this.map.clear();\r\n    }\r\n\r\n    public size(): number {\r\n        return this.map.size;\r\n    }\r\n\r\n    public forEach(f: (value: string, row: number | \"name\", column: number, index?: number) => void): void {\r\n        [...this.map.entries()]\r\n            .map((entry) => {return {value: entry[1], key: NNToSMap.parseKey(entry[0])}})\r\n            .forEach((entry, index) => f(entry.value, entry.key.row, entry.key.column, index));\r\n    }\r\n\r\n    private static parseKey(key: string): {row: number | \"name\", column: number} {\r\n        const split = key.split(':');\r\n        return {row: Number(split[0]), column: Number(split[1])};\r\n    }\r\n}","import {isSupportedColumnType, SupportedColumnType} from \"./columnType\";\r\nimport StringUtils from \"../utils/stringUtils\";\r\nimport {NNToSMap} from \"../types/nnToSMap\";\r\nimport Relation from \"./relation\";\r\nimport Row from \"./row\";\r\nimport {isForbiddenColumnName} from \"../utils/keywords\";\r\nimport {language} from \"../language/language\";\r\n\r\n/**\r\n * Plain object representation of the stored relation.\r\n */\r\nexport interface StoredRelationData {\r\n    name: string;\r\n    columnNames: string[];\r\n    columnTypes: SupportedColumnType[];\r\n    rows: string[][];\r\n    columnCount: number;\r\n    rowCount: number;\r\n}\r\n\r\n/**\r\n * Creates a copy of the given stored relation data.\r\n */\r\nexport function copyStoredRelationData(data: StoredRelationData): StoredRelationData {\r\n    return {\r\n        name: data.name,\r\n        columnNames: [...data.columnNames],\r\n        columnTypes: [...data.columnTypes],\r\n        rows: data.rows.map(row => [...row]),\r\n        columnCount: data.columnCount,\r\n        rowCount: data.rowCount\r\n    }\r\n}\r\n\r\n/**\r\n * String representation of the relation for its storing. The relation may happen to be in inconsistent state.\r\n */\r\nexport class StoredRelation {\r\n\r\n    /**\r\n     * Creates a new stored relation with given name, one column and no rows.\r\n     */\r\n    static new(name: string, nullValuesSupport: boolean): StoredRelation {\r\n        return new StoredRelation(name, [\"Column1\"], [\"number\"], [], nullValuesSupport);\r\n    }\r\n\r\n    /**\r\n     * Creates a new stored relation from given plain relation object. If the object is not a valid StoredRelationData,\r\n     * throws error.\r\n     */\r\n    static fromData(data: any, nullValuesSupport: boolean): StoredRelation {\r\n        if (isStoredRelationData(data)) {\r\n            const d: StoredRelationData = data as StoredRelationData;\r\n            return new StoredRelation(d.name, d.columnNames, d.columnTypes, d.rows, nullValuesSupport);\r\n        }\r\n        throw new Error(\"Given object is not a valid relation.\");\r\n    }\r\n\r\n    /**\r\n     * Creates a new stored relation from given full relation representation.\r\n     */\r\n    static fromRelation(name: string, relation: Relation, nullValuesSupport: boolean): StoredRelation {\r\n        const columnNames: string[] = [];\r\n        const columnTypes: SupportedColumnType[] = [];\r\n        relation.getColumns().forEach((type, name) => {\r\n            columnNames.push(name);\r\n            columnTypes.push(type);\r\n        });\r\n        const rows: string[][] = relation.getRows().map(row => {\r\n            return row.getOrderedPrintValues(columnNames);\r\n        });\r\n        return new StoredRelation(name, columnNames, columnTypes, rows, nullValuesSupport);\r\n    }\r\n\r\n    /**\r\n     * Creates a new relation with the same name, columns, rows a null values support.\r\n     */\r\n    static copy(relation: StoredRelation): StoredRelation {\r\n        const name = relation.name;\r\n        const columnNames = [...relation.columnNames];\r\n        const columnTypes = [...relation.columnTypes];\r\n        const rows = relation.rows.map(row => [...row]);\r\n        const nullValuesSupport = relation.nullValuesSupport;\r\n        return new StoredRelation(name, columnNames, columnTypes, rows, nullValuesSupport);\r\n    }\r\n\r\n    /**\r\n     * Returns formatted string representation of StoredRelation or StoredRelationData.\r\n     */\r\n    static format(rel: StoredRelation | StoredRelationData): string {\r\n        // finds longest inputs in each column\r\n        const longest = rel.columnNames.map(n => n.length);\r\n        rel.columnTypes.forEach((t, i) => {\r\n            if (longest[i] < t.length) {\r\n                longest[i] = t.length;\r\n            }\r\n        });\r\n        rel.rows.forEach(r => {\r\n            r.forEach((d, i) => {\r\n                if (longest[i] < d.length) {\r\n                    longest[i] = d.length;\r\n                }\r\n            });\r\n        });\r\n        // function for end-padding strings with spaces\r\n        const pad = (ss: string[]) => ss.map((s, i) => s.padEnd(longest[i], \" \")).join(' | ');\r\n        return pad(rel.columnNames) + '\\n' +\r\n            pad(rel.columnTypes) + '\\n' +\r\n            longest.map(n => \"-\".repeat(n)).join(\"-+-\") + '\\n' +\r\n            rel.rows.map(r => pad(r)).join('\\n') + '\\n\\n';\r\n    }\r\n\r\n    private name: string;\r\n    columnNames: string[];\r\n    columnTypes: SupportedColumnType[];\r\n    rows: string[][];\r\n    private columnCount: number;\r\n    private rowCount: number;\r\n    private readonly errors: NNToSMap;\r\n    private nullValuesSupport: boolean;\r\n    private actual: boolean;\r\n    private revertState: StoredRelationData;\r\n\r\n    /**\r\n     * Creates new relation with given name, one default column and no rows.\r\n     */\r\n    constructor(name: string, columnNames: string[], columnTypes: SupportedColumnType[],\r\n                        rows: string[][], nullValuesSupport: boolean) {\r\n        this.name = name;\r\n        this.columnNames = columnNames;\r\n        this.columnTypes = columnTypes;\r\n        this.rows = rows;\r\n        this.columnCount = columnNames.length;\r\n        this.rowCount = rows.length;\r\n        this.errors = new NNToSMap();\r\n        this.nullValuesSupport = nullValuesSupport;\r\n        this.actual = false;\r\n        this.revertState = this.toDataObject();\r\n        this.recomputeErrors();\r\n    }\r\n\r\n    /**\r\n     * Checks all possible errors in the relation.\r\n     */\r\n    public recomputeErrors(): void {\r\n        this.errors.clear();\r\n        this.checkColumnNames();\r\n        for (let c = 0; c < this.columnCount; ++c) {\r\n            [...new Array(this.rowCount).keys()].forEach(r => this.checkRowInput(c, r));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks whether the column name on given index is valid and not duplicit and updates error map.\r\n     */\r\n    private checkColumnNames(): void {\r\n        const lang = language().relationErrors;\r\n        for (let columnIndex = 0; columnIndex < this.columnCount; ++columnIndex) {\r\n            const columnName: string = this.columnNames[columnIndex].trim();\r\n            if (columnName === \"\") {\r\n                this.errors.set(\"name\", columnIndex, lang.emptyColumn);\r\n                continue;\r\n            }\r\n            const nameCount: number = this.columnNames.reduce((agg, name) => {\r\n                return (name === columnName) ? (agg + 1) : agg;\r\n            }, 0);\r\n            if (nameCount > 1) {\r\n                this.errors.set(\"name\", columnIndex, lang.duplicitColumn);\r\n                continue;\r\n            }\r\n            if (isForbiddenColumnName(columnName)) {\r\n                this.errors.set(\"name\", columnIndex, lang.keywordColumn);\r\n                continue;\r\n            }\r\n            if (!StringUtils.isName(columnName)) {\r\n                this.errors.set(\"name\", columnIndex, lang.invalidColumn);\r\n                continue;\r\n            }\r\n            this.errors.delete(\"name\", columnIndex);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks whether the row input on given index is valid and updates error map.\r\n     */\r\n    private checkRowInput(columnIndex: number, rowIndex: number): void {\r\n        const lang = language().relationErrors;\r\n        this.errors.delete(rowIndex, columnIndex);\r\n        const input: string = this.rows[rowIndex][columnIndex].trim();\r\n        // empty input = null\r\n        if (input === \"\" || input === \"null\") {\r\n            if (!this.nullValuesSupport) {\r\n                this.errors.set(rowIndex, columnIndex, lang.unsupportedNull);\r\n            }\r\n        }\r\n        else if (this.columnTypes[columnIndex] === \"number\") {\r\n            if (!StringUtils.isNumber(input.replace(/\\s/g, \"\"))) {\r\n                this.errors.set(rowIndex, columnIndex, lang.invalidNumber);\r\n            }\r\n        }\r\n        else if (this.columnTypes[columnIndex] === \"boolean\") {\r\n            const lower = input.toLowerCase();\r\n            if (lower !== \"true\" && lower !== \"t\" && lower !== \"false\" && lower !== \"f\") {\r\n                this.errors.set(rowIndex, columnIndex, lang.invalidBoolean);\r\n            }\r\n        }\r\n        /* STRING COLUMNS CANNOT BE INVALID */\r\n    }\r\n\r\n    /**\r\n     * Checks whether all row inputs on given column index are valid and updates error map.\r\n     */\r\n    private checkColumnTypes(columnIndex: number): void {\r\n        this.rows.forEach((_, i) => this.checkRowInput(columnIndex, i));\r\n    }\r\n\r\n    /**\r\n     * Creates a relation with full schema.\r\n     * WARNING: It expects that there are no errors in the stored relation before call.\r\n     */\r\n    public createRelation(): Relation {\r\n        const relation: Relation = new Relation(this.name);\r\n        for (let c = 0; c < this.columnCount; ++c) {\r\n            relation.addColumn(this.columnNames[c], this.columnTypes[c]);\r\n        }\r\n        this.rows.forEach(rowInput => {\r\n            const row: Row = new Row(relation.getColumns());\r\n            rowInput.forEach((input, c) => {\r\n                input = input.trim();\r\n                if (input === \"\" || input === \"null\") {\r\n                    row.addValue(this.columnNames[c], null);\r\n                }\r\n                else if (this.columnTypes[c] === \"string\") {\r\n                    // changes input representation to expected in inner relations\r\n                    // replaces all used '\\' by two '\\\\' and all used '\"' by '\\\"'\r\n                    input = input.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"');\r\n                    row.addValue(this.columnNames[c], input);\r\n                }\r\n                else if (this.columnTypes[c] === \"number\") {\r\n                    row.addValue(this.columnNames[c], Number(input.replace(/\\s/g, \"\")));\r\n                }\r\n                else /* this.columnTypes[c] === \"boolean\" */ {\r\n                    const lower = input.toLowerCase();\r\n                    row.addValue(this.columnNames[c], lower === \"t\" || lower === \"true\");\r\n                }\r\n            });\r\n            relation.addRow(row);\r\n        });\r\n        relation.finishSchema();\r\n        return relation;\r\n    }\r\n\r\n    /**\r\n     * Creates plain object representation of the stored relation.\r\n     */\r\n    public toDataObject(): StoredRelationData {\r\n        return {\r\n            name: this.name,\r\n            columnNames: [...this.columnNames],\r\n            columnTypes: [...this.columnTypes],\r\n            rows: this.rows.map(row => [...row]),\r\n            columnCount: this.columnCount,\r\n            rowCount: this.rowCount\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns map \"row/column => error\". Numeric row keys are for relation rows, row key \"name\" is for column name row.\r\n     */\r\n    public getErrors(): NNToSMap {\r\n        return this.errors;\r\n    }\r\n\r\n    /**\r\n     * Returns true if there are no errors in the relation.\r\n     */\r\n    public isValid(): boolean {\r\n        return this.errors.size() === 0;\r\n    }\r\n\r\n    /**\r\n     * Sets null values support to check null errors in the relation.\r\n     */\r\n    public setNullValuesSupport(nullValuesSupport: boolean): void {\r\n        if (nullValuesSupport !== this.nullValuesSupport) {\r\n            this.nullValuesSupport = nullValuesSupport;\r\n            this.recomputeErrors();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a new column with default name \"Column n\", default type \"number\", and empty inputs \"\" in all rows.\r\n     */\r\n    public addNewColumn(): void {\r\n        let i = (this.columnNames.length + 1);\r\n        let name = \"Column\" + i;\r\n        while (this.columnNames.indexOf(name) > -1) {\r\n            name = \"Column\" + ++i;\r\n        }\r\n        this.columnNames.push(name);\r\n        this.columnTypes.push(\"number\");\r\n        if (this.nullValuesSupport) {\r\n            this.rows.forEach(r => r.push(\"\"));\r\n        }\r\n        else {\r\n            this.rows.forEach(r => r.push(\"0\"));\r\n        }\r\n        ++this.columnCount;\r\n        this.checkColumnNames();\r\n        this.actual = false;\r\n    }\r\n\r\n    /**\r\n     * Adds a new row with empty inputs \"\" in all columns.\r\n     */\r\n    public addNewRow(): void {\r\n        if (this.nullValuesSupport) {\r\n            this.rows.push([...new Array(this.columnCount).keys()].map(_ => \"\"));\r\n        }\r\n        else {\r\n            this.rows.push([...new Array(this.columnCount).keys()].map(i => {\r\n                if (this.columnTypes[i] === \"number\") {\r\n                    return \"0\";\r\n                }\r\n                else if (this.columnTypes[i] === \"boolean\") {\r\n                    return \"false\";\r\n                }\r\n                return '\"\"';\r\n            }));\r\n        }\r\n        ++this.rowCount;\r\n        this.actual = false;\r\n    }\r\n\r\n    /**\r\n     * Deletes a column with the given index. If the last column was deleted, removes all rows and creates\r\n     * new default column.\r\n     *\r\n     * @param columnIndex\r\n     */\r\n    public deleteColumn(columnIndex: number): void {\r\n        this.columnNames.splice(columnIndex, 1);\r\n        this.columnTypes.splice(columnIndex, 1);\r\n        this.rows.forEach(row => row.splice(columnIndex, 1));\r\n        --this.columnCount;\r\n        // if last column was deleted, removes all rows and creates new default column\r\n        if (this.columnCount === 0) {\r\n            this.rows = [];\r\n            this.addNewColumn();\r\n        }\r\n        this.errors.forEach((value, row, column) => {\r\n            // removes errors for given row\r\n            if (column === columnIndex) {\r\n                this.errors.delete(row, column);\r\n            }\r\n            // updates row index for errors in rows under deleted one\r\n            else if (column > columnIndex) {\r\n                this.errors.delete(row, column);\r\n                this.errors.set(row, column, value);\r\n            }\r\n        });\r\n        this.actual = false;\r\n    }\r\n\r\n    /**\r\n     * Deletes a row with given index.\r\n     *\r\n     * @param rowIndex\r\n     */\r\n    public deleteRow(rowIndex: number): void {\r\n        this.rows.splice(rowIndex, 1);\r\n        --this.rowCount;\r\n        this.errors.forEach((value, row, column) => {\r\n            // removes errors for given row\r\n            if (row === rowIndex) {\r\n                this.errors.delete(row, column);\r\n            }\r\n            // updates row index for errors in rows under deleted one\r\n            else if (typeof row === \"number\" && row > rowIndex) {\r\n                this.errors.delete(row, column);\r\n                this.errors.set(row - 1, column, value);\r\n            }\r\n        });\r\n        this.actual = false;\r\n    }\r\n\r\n    public getRowCount(): number {\r\n        return this.rowCount;\r\n    }\r\n\r\n    public getColumnCount(): number {\r\n        return this.columnCount;\r\n    }\r\n\r\n    public setName(name: string): void {\r\n        this.name = name;\r\n        this.actual = false;\r\n    }\r\n\r\n    public getName(): string {\r\n        return this.name;\r\n    }\r\n\r\n    public getColumnNames(): string[] {\r\n        return this.columnNames;\r\n    }\r\n\r\n    public setColumnName(columnName: string, columnIndex: number): void {\r\n        this.columnNames[columnIndex] = columnName;\r\n        this.checkColumnNames();\r\n        this.actual = false;\r\n    }\r\n\r\n    public getColumnTypes(): SupportedColumnType[] {\r\n        return this.columnTypes;\r\n    }\r\n\r\n    public setColumnType(columnType: SupportedColumnType, columnIndex: number): void {\r\n        this.columnTypes[columnIndex] = columnType;\r\n        this.checkColumnTypes(columnIndex);\r\n        this.actual = false;\r\n    }\r\n\r\n    public getRows(): string[][] {\r\n        return this.rows;\r\n    }\r\n\r\n    public setRowInput(input: string, rowIndex: number, columnIndex: number): void {\r\n        this.rows[rowIndex][columnIndex] = input;\r\n        this.checkRowInput(columnIndex, rowIndex);\r\n        this.actual = false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if no changes were made after last setActual(true) call.\r\n     * The StoredRelation is created with isActual() = false.\r\n     */\r\n    public isActual(): boolean {\r\n        return this.actual;\r\n    }\r\n\r\n    /**\r\n     * Sets current StoredRelation state as actual. Any change sets the state as not actual automatically.\r\n     * If it is set to actual, the current state is saved as the revert state.\r\n     */\r\n    public setActual(actual: boolean): void {\r\n        this.actual = actual;\r\n        if (actual) {\r\n            this.revertState = this.toDataObject();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns name of the saved relation state to revert or empty string.\r\n     */\r\n    public getRevertName(): string {\r\n        if (this.revertState !== undefined) {\r\n            return this.revertState.name;\r\n        }\r\n        else {\r\n            return \"\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reverts the current relation to its last loaded state (if any exists, call canRevert() to check).\r\n     * The relation is set as not actual, null values support and saved revert state is not reverted.\r\n     */\r\n    public revert(): void {\r\n        if (this.revertState !== undefined) {\r\n            this.name = this.revertState.name;\r\n            this.columnNames = [...this.revertState.columnNames];\r\n            this.columnTypes = [...this.revertState.columnTypes];\r\n            this.rows = this.revertState.rows.map(row => [...row]);\r\n            this.columnCount = this.revertState.columnCount;\r\n            this.rowCount = this.revertState.rowCount;\r\n            this.actual = false;\r\n            this.recomputeErrors();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Returns true if the relation relation object has at least one column, and all rows has the same length.\r\n */\r\nexport function isStoredRelationData(obj: any): boolean {\r\n    if (typeof obj !== \"object\") {\r\n        return false;\r\n    }\r\n    if (!(\"name\" in obj) || typeof obj.name !== \"string\") {\r\n        return false;\r\n    }\r\n    if (!(\"columnCount\" in obj) || typeof obj.columnCount !== \"number\" || obj.columnCount < 1) {\r\n        return false;\r\n    }\r\n    if (!(\"rowCount\" in obj) || typeof obj.rowCount !== \"number\") {\r\n        return false;\r\n    }\r\n    if (!(\"columnNames\" in obj) || !Array.isArray(obj.columnNames) || obj.columnNames.length !== obj.columnCount ||\r\n        obj.columnNames.some((o: any) => typeof o !== \"string\")) {\r\n        return false;\r\n    }\r\n    if (!(\"columnTypes\" in obj) || !Array.isArray(obj.columnTypes) || obj.columnTypes.length !== obj.columnCount ||\r\n        obj.columnTypes.some((o: any) => !isSupportedColumnType(o))) {\r\n        return false;\r\n    }\r\n    return (\"rows\" in obj && Array.isArray(obj.rows) && obj.rows.every((o: any) => {\r\n        return Array.isArray(o) && o.length === obj.columnCount && o.every((d: any) => typeof d === \"string\");\r\n    }));\r\n}","/**\r\n * Specifies supported column types in the application. When changed, update the keywords.ts file.\r\n */\r\n\r\n/**\r\n * Supported string names of types of columns for a relational schema.\r\n */\r\nexport type SupportedColumnType = \"string\" | \"number\" | \"boolean\";\r\n\r\n/**\r\n * Possible types of the content of columns (null values included).\r\n */\r\nexport type ColumnContent = string | number | boolean | null;\r\n\r\n/**\r\n * Returns true if the given obj is string with value SupportedColumnType value.\r\n */\r\nexport function isSupportedColumnType(obj: any): boolean {\r\n    if (typeof obj !== \"string\") {\r\n        return false;\r\n    }\r\n    return obj === \"string\" || obj === \"number\" || obj === \"boolean\";\r\n}","import {FileDialog} from \"../utils/fileDialog\";\r\nimport {\r\n    CsvValueSeparator,\r\n    findValueSeparator\r\n} from \"../types/csvSupport\";\r\nimport {StoredRelation} from \"./storedRelation\";\r\nimport {SupportedColumnType} from \"./columnType\";\r\nimport {saveAs} from \"file-saver\";\r\nimport JSZip from \"jszip\";\r\nimport StringUtils from \"../utils/stringUtils\";\r\n\r\n/**\r\n * Class for loading and saving relation definitions.\r\n */\r\nexport class RelationStoreManager {\r\n\r\n    /**\r\n     * Loads textual relation representations from multiple csv files selected by the user. If the csv does not have\r\n     * valid stricture, it is skipped. Loaded csv are parsed to StoredRelations and returned in a promise.\r\n     *\r\n     * @param nullValuesSupport null values support to set in created StoredRelations\r\n     */\r\n    public static load(nullValuesSupport: boolean): Promise<{relations: StoredRelation[], skipped: number}> {\r\n        return new Promise<{relations: StoredRelation[], skipped: number}>(resolve => {\r\n            FileDialog.openFiles(\".csv\").then(files => {\r\n                let relations: StoredRelation[] = [];\r\n                let skipped: number = 0;\r\n                files.forEach(file => {\r\n                    if (file.name.match(/\\.csv$/)) {\r\n                        try {\r\n                            relations.push(this.csvToRelation(RelationStoreManager.createValidName(file.name.slice(0, -4)),\r\n                                file.text, nullValuesSupport));\r\n                        }\r\n                        catch (err) {\r\n                            console.log('File ' + file.name + ' skipped for bad format of csv');\r\n                            skipped += 1;\r\n                        }\r\n                    }\r\n                    else {\r\n                        console.log('Unsupported filetype: ' + file.name);\r\n                        skipped += 1;\r\n                    }\r\n                });\r\n                resolve({relations: relations, skipped: skipped});\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Saves given relations into csv files (in one csv file each relation). Uses given value separator.\r\n     *\r\n     * @param relations map of the relations to be saved\r\n     * @param filename name of the downloaded file (without .zip/.csv extension)\r\n     * @param valueSeparator the separator of values\r\n     */\r\n    public static save(relations: StoredRelation[], filename: string, valueSeparator: CsvValueSeparator): void {\r\n        if (relations.length === 0) {\r\n            return;\r\n        }\r\n        if (relations.length === 1) {\r\n            const blob = new Blob([this.relationToCsv(relations[0], valueSeparator)], {type: \"text/plain;charset=utf-8\"});\r\n            saveAs(blob, relations[0].getName() + '.csv');\r\n            return;\r\n        }\r\n        const zip: JSZip = JSZip();\r\n        relations.forEach(relation => {\r\n            zip.file(relation.getName() + '.csv', this.relationToCsv(relation, valueSeparator));\r\n        });\r\n        zip.generateAsync({type: \"blob\"}).then(content => {\r\n            saveAs(content, filename + \".zip\");\r\n        }).catch(err => {\r\n            throw err;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Parses a StoredRelation from given csv text. If the text is invalid, throws error.\r\n     *\r\n     * @param name name of the relation\r\n     * @param text csv content to parse a relation from\r\n     * @param nullValuesSupport null values support to set in created StoredRelation\r\n     */\r\n    private static csvToRelation(name: string, text: string | null, nullValuesSupport: boolean): StoredRelation {\r\n        if (text === null || text === \"\") {\r\n            console.log(\"null or empty string read from file \" + name);\r\n            throw Error();\r\n        }\r\n\r\n        text = text.trim().replace(/\\r\\n/g, '\\n')\r\n            .replace(/\\r/g, '\\n').replace(/\\t/g, \"    \");\r\n\r\n        const lines: string[] = text.split('\\n');\r\n\r\n        if (lines.length < 2) {\r\n            console.log(\"file \" + name + \" has only one line\");\r\n            throw Error();  // at least two lines are expected (names and types)\r\n        }\r\n\r\n        lines[0] = lines[0].replace(/\\s/g, '');\r\n        lines[1] = lines[1].replace(/\\s/g, '');\r\n\r\n        let separator = findValueSeparator(lines[1]);\r\n        // if no separator is found, only one column is expected - sets separator to not defined value to unify the\r\n        // following process\r\n        if (separator === undefined) {\r\n            separator = ';';\r\n        }\r\n\r\n        const columnNames: string[] = lines[0].split(separator);\r\n        const columnTypes: SupportedColumnType[] = lines[1].split(separator).map(str => {\r\n            const lower = str.toLowerCase();\r\n            if (lower === \"string\" || lower === \"str\" || lower === \"s\") {\r\n                return \"string\";\r\n            }\r\n            else if (lower === \"number\" || lower === \"num\" || lower === \"n\") {\r\n                return \"number\";\r\n            }\r\n            return \"boolean\";\r\n        });\r\n        const rows: string[][] = lines.slice(2).map(line => {\r\n            const row: string[] = []\r\n            line = line.trim();\r\n            while (true) {\r\n                // @ts-ignore - separator cannot be undefined now\r\n                const split = RelationStoreManager.nextRowInput(line, separator);\r\n                row.push(split.input);\r\n                if (split.rest === undefined) {\r\n                    break;\r\n                }\r\n                line = split.rest;\r\n            }\r\n            return row;\r\n        });\r\n\r\n        // all rows must have equal column count\r\n        const columnCount = columnNames.length;\r\n        if (columnTypes.length !== columnCount || rows.some(row => row.length !== columnCount)) {\r\n            console.log(\"rows in file \" + name + \" do not have the same number of columns\");\r\n            throw new Error();\r\n        }\r\n\r\n        return new StoredRelation(name, columnNames, columnTypes, rows, nullValuesSupport);\r\n    }\r\n\r\n    /**\r\n     * Removes invalid characters for name. If the filtered name is empty, returns string \"relation\".\r\n     */\r\n    private static createValidName(name: string): string {\r\n        name = name.split('').filter(char => StringUtils.isNameChar(char)).join('');\r\n        if (name === \"\") {\r\n            return \"relation\";\r\n        }\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * Returns next part of the line before separator. Separators in string literals are ignored.\r\n     */\r\n    private static nextRowInput(line: string, separator: string): {input: string, rest: string | undefined} {\r\n        let inString = false;\r\n        let backslashes = 0;\r\n        let i = 0;\r\n        while (i < line.length) {\r\n            const char = line.charAt(i);\r\n            // separator found not in the string literal\r\n            if (!inString && char === separator) {\r\n                return {input: line.slice(0, i), rest: line.slice(i + 1)};\r\n            }\r\n            // next backslash found in a row\r\n            if (char === '\\\\') {\r\n                ++backslashes;\r\n            }\r\n            // resets backslashes in a row\r\n            else {\r\n                backslashes = 0;\r\n            }\r\n            // not escaped quotes found\r\n            if (char === '\"' && (backslashes % 2) === 0) {\r\n                inString = !inString;\r\n            }\r\n            ++i;\r\n        }\r\n        return {input: line, rest: undefined}\r\n    }\r\n\r\n    /**\r\n     * Creates a csv representation for the given relation.\r\n     */\r\n    private static relationToCsv(relation: StoredRelation, valueSeparator: CsvValueSeparator): string {\r\n        const names: string = relation.getColumnNames().join(valueSeparator);\r\n        const types: string = relation.getColumnTypes().join(valueSeparator);\r\n        const rows: string[] = relation.getRows().map(row => row.join(valueSeparator));\r\n        return [names, types, ...rows].join('\\n');\r\n    }\r\n}","/**\r\n * Two possible CSV value separators: comma (,) and semicolon (;).\r\n */\r\nexport type CsvValueSeparator = \",\" | \";\";\r\n\r\nexport function findValueSeparator(str: string): string | undefined {\r\n    for (let i = 0; i < str.length; ++i) {\r\n        const char: string = str.charAt(i);\r\n        if (char === \",\") {\r\n            return \",\";\r\n        }\r\n        if (char === \";\") {\r\n            return \";\";\r\n        }\r\n    }\r\n    return undefined;\r\n}","import React from \"react\";\r\n// @ts-ignore - type declaration is not needed for its short usage\r\nimport downloadSVG from \"export-svg-with-styles\";\r\nimport Relation from \"../relation/relation\";\r\nimport {ResultRelationTable} from \"./resultRelationTable\";\r\nimport {TooltipButton} from \"./tooltipButton\";\r\nimport RATreeNode from \"../ratree/raTreeNode\";\r\nimport {CsvValueSeparator} from \"../types/csvSupport\";\r\nimport {evalTreeSVGId, EvaluationTree} from \"./evaluationTree\";\r\nimport {depthSearch} from \"../ratree/raTreeTools\";\r\nimport {ErrorFactory} from \"../error/errorFactory\";\r\nimport {RelationStoreManager} from \"../relation/relationStoreManager\";\r\nimport {StoredRelation} from \"../relation/storedRelation\";\r\nimport \"./css/resultSection.css\"\r\nimport {language, LanguageDef} from \"../language/language\";\r\n\r\ninterface ResultSectionProps {\r\n    // the root of the current evaluation tree to display\r\n    evaluationTreeRoot: RATreeNode,\r\n    // name of the evaluated expression\r\n    expressionName: string,\r\n\r\n    // handler of adding the given relation to defined relations\r\n    onAddResult: (relation: Relation) => void,\r\n\r\n    // handler of unexpected errors\r\n    onUnexpectedError: (e: Error) => void,\r\n\r\n    // current selected value separator in csv files\r\n    csvValueSeparator: CsvValueSeparator\r\n    // true if dark theme should be applied\r\n    darkTheme: boolean,\r\n    // current application language\r\n    language: LanguageDef\r\n}\r\n\r\ninterface ResultSectionState {\r\n    selectedIndex: number\r\n}\r\n\r\n/**\r\n * Section to show the evaluation result. It contains a table with a result and text input and buttons to save it.\r\n * The component is hidden if given resultRelation is null.\r\n */\r\nexport class ResultSection extends React.Component<ResultSectionProps, ResultSectionState> {\r\n\r\n    // reference to this section element\r\n    private readonly sectionRef: React.RefObject<HTMLDivElement>;\r\n\r\n    constructor(props: ResultSectionProps) {\r\n        super(props);\r\n        this.state = {\r\n            selectedIndex: 0\r\n        }\r\n        this.sectionRef = React.createRef<HTMLDivElement>();\r\n    }\r\n\r\n    componentDidUpdate(prevProps: Readonly<ResultSectionProps>) {\r\n        if (prevProps.evaluationTreeRoot !== this.props.evaluationTreeRoot) {\r\n            this.setState({selectedIndex: 0});\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the result relation for the current selected node.\r\n     */\r\n    private getCurrentRelation = (): Relation | null => {\r\n        let currentNode: RATreeNode | null = depthSearch(this.props.evaluationTreeRoot, this.state.selectedIndex);\r\n        if (currentNode === null) {\r\n            currentNode = depthSearch(this.props.evaluationTreeRoot, 0);\r\n            if (currentNode === null) {\r\n                this.props.onUnexpectedError(ErrorFactory.codeError(language().codeErrors.resultSection_nodeIndexNotFound));\r\n                return null;\r\n            }\r\n        }\r\n        try {\r\n            return currentNode.getResult();\r\n        }\r\n        catch (err) {\r\n            // errors should be handled in expression section\r\n            this.props.onUnexpectedError(ErrorFactory.codeError(language().codeErrors.resultSection_evalError, err.message));\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private handleSelectedNodeChange = (index: number): void => {\r\n        this.setState({selectedIndex: index});\r\n    }\r\n\r\n    /**\r\n     * Saves the displayed evaluation tree as png picture.\r\n     */\r\n    private exportEvalTreeAsPng = (): void => {\r\n        const svg = document.getElementById(evalTreeSVGId);\r\n        if (svg !== null) {\r\n            const rect = svg.getBoundingClientRect();\r\n            const options = {\r\n                width: rect.width * 3,\r\n                height: rect.height * 3,\r\n                svg: svg,\r\n                filename: this.props.expressionName + \" - evaluation tree.png\"\r\n            }\r\n            downloadSVG(options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Saves the current selected relation to a file.\r\n     */\r\n    private exportRelation = (): void => {\r\n        if (this.getCurrentRelation() === null) {\r\n            this.props.onUnexpectedError(ErrorFactory.codeError(language().codeErrors.resultSection_nullRelationToSave));\r\n            return;\r\n        }\r\n        try {\r\n            RelationStoreManager.save(\r\n                [StoredRelation.fromRelation(\"rachel_result\", this.getCurrentRelation() as Relation, true)],\r\n                \"rachel_result\", this.props.csvValueSeparator);\r\n        }\r\n        catch (err) {\r\n            console.warn(\"Saving error: \" + err, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Passes the current selected relation with the given name to the parent.\r\n     */\r\n    private addRelation = (): void => {\r\n        if (this.getCurrentRelation() === null) {\r\n            this.props.onUnexpectedError(\r\n                ErrorFactory.codeError(language().codeErrors.resultSection_nullRelationToAdd)\r\n            );\r\n            return;\r\n        }\r\n        // @ts-ignore\r\n        this.props.onAddResult(this.getCurrentRelation());\r\n    }\r\n\r\n    render() {\r\n        const relation = this.getCurrentRelation();\r\n        // does not show null result\r\n        if (relation === null) {\r\n            return null;\r\n        }\r\n        const lang = this.props.language.resultSection;\r\n\r\n        const relationType: string = this.state.selectedIndex === 0 ? lang.resultRelationTitle : lang.intermediateRelationTitle;\r\n        const selectedNode: RATreeNode | null = depthSearch(this.props.evaluationTreeRoot, this.state.selectedIndex);\r\n        const tableTitle: string | null = selectedNode === null ? null : selectedNode.printInLine();\r\n\r\n        return (\r\n            <section\r\n                ref={this.sectionRef}\r\n                className=\"page-section result-section\">\r\n                <header>\r\n                    <h2>{lang.resultSectionHeader}</h2>\r\n                    <TooltipButton\r\n                        text={lang.exportEvalTreeButton}\r\n                        onClick={this.exportEvalTreeAsPng}\r\n                        tooltip={lang.exportEvalTreeButtonTooltip}\r\n                    />\r\n                </header>\r\n\r\n                <p className=\"upper-p\">\r\n                    <strong>{lang.evalTreeTitle + ' ' + this.props.evaluationTreeRoot.printInLine() + ':'}</strong>\r\n                </p>\r\n\r\n                <EvaluationTree\r\n                    tree={this.props.evaluationTreeRoot}\r\n                    selected={this.state.selectedIndex}\r\n                    onClick={this.handleSelectedNodeChange}\r\n                    darkTheme={this.props.darkTheme}\r\n                />\r\n\r\n                <p className=\"lower-p\"><strong>{relationType} {tableTitle}:</strong></p>\r\n\r\n                <menu className=\"page-section-tab-menu\">\r\n                    <TooltipButton\r\n                        text={lang.addButton}\r\n                        onClick={this.addRelation}\r\n                        tooltip={lang.addButtonTooltip}\r\n                    />\r\n                    <TooltipButton\r\n                        text={lang.exportRelationButton}\r\n                        onClick={this.exportRelation}\r\n                        tooltip={lang.exportRelationButtonTooltip}\r\n                    />\r\n                </menu>\r\n\r\n                <ResultRelationTable relation={relation} />\r\n            </section>\r\n        );\r\n    }\r\n}","import {FileDialog} from \"../utils/fileDialog\";\r\nimport {saveAs} from \"file-saver\";\r\nimport {Expression} from \"./expression\";\r\n\r\n/**\r\n * Promised relation in ExpressionStoreManager.load() function. Contains:\r\n * - expressions: Expression[] - successfully parsed expressions\r\n * - skippedExpressions: number - number of skipped expressions (from successfully loaded files)\r\n * - loadedFiles: number - number of successfully loaded files\r\n * - skippedFiles: number - number of skipped files (not .txt, null loaded...)\r\n */\r\nexport interface ExpressionLoadData {\r\n    expressions: Expression[],\r\n    skippedExpressions: number,\r\n    loadedFiles: number,\r\n    skippedFiles: number\r\n}\r\n\r\n/**\r\n * Class for loading and saving expressions.\r\n */\r\nexport class ExpressionStoreManager {\r\n\r\n    /**\r\n     * Loads expressions from multiple textual files selected by the user. Each file can contain multiple expressions,\r\n     * split by '\\n###\\n'. When different line separator is used (\\r, \\r\\n), it is replaced by \\n before return.\r\n     * All tabulators are replaces by 4 spaces.\r\n     */\r\n    public static load(): Promise<ExpressionLoadData> {\r\n        return new Promise<ExpressionLoadData>(resolve => {\r\n            FileDialog.openFiles(\".txt\").then(files =>{\r\n                let expressions: Expression[] = [];\r\n                let skippedExpressions: number = 0;\r\n                let loadedFiles: number = 0;\r\n                let skippedFiles: number = 0;\r\n                files.forEach(file => {\r\n                    if (file.text === null) {\r\n                        console.log('Null read from file ' + file.name);\r\n                        skippedFiles += 1;\r\n                    }\r\n                    else if (file.name.match(/\\.txt$/)) {\r\n                        // replaces line separators to expected '\\n' and tabulators to four spaces\r\n                        file.text = file.text.replace(/\\r\\n/g, '\\n')\r\n                            .replace(/\\r/g, '\\n').replace(/\\t/g, \"    \");\r\n                        // prepends newline for first expected splitting of the first expression\r\n                        ('\\n'.concat(file.text)).split('\\n### ').forEach(part => {\r\n                            try {\r\n                                if (part.trim().length !== 0) {\r\n                                    expressions.push(this.splitExpressionNameAndText(part));\r\n                                }\r\n                            }\r\n                            catch (err) {\r\n                                skippedExpressions += 1;\r\n                            }\r\n                        });\r\n                        loadedFiles += 1;\r\n                    }\r\n                    else {\r\n                        console.log('Unsupported filetype: ' + file.name);\r\n                        skippedFiles += 1;\r\n                    }\r\n                });\r\n                resolve({expressions, skippedExpressions, loadedFiles, skippedFiles});\r\n            });\r\n        });\r\n    }\r\n\r\n    private static splitExpressionNameAndText(expr: string): Expression {\r\n        const firstNewLineIndex: number = expr.indexOf('\\n');\r\n        if (firstNewLineIndex === -1) {\r\n            console.log(\"Expression does not contain first name line.\");\r\n            throw Error();\r\n        }\r\n        const firstRow: string = expr.slice(0, firstNewLineIndex).trim();\r\n        if (!firstRow.endsWith(' ###')) {\r\n            console.log(\"Expression does not contain name between hashes.\");\r\n            throw Error();\r\n        }\r\n        const name: string = firstRow.slice(0, -4);\r\n        const text: string = expr.slice(firstNewLineIndex).trim();\r\n        return {name: name, text: text};\r\n    }\r\n\r\n    /**\r\n     * Saves given expressions to a textual file. Each expression starts with \"### Expression name ###\\n\" line.\r\n     *\r\n     * @param expressions array of expressions to be saved\r\n     * @param filename name of the downloaded file (without extension)\r\n     */\r\n    public static save(expressions: Expression[], filename: string): void {\r\n        const textContent: string = expressions.map(e => {\r\n            return \"### \" + e.name + \" ###\\n\\n\" + e.text;\r\n        }).join('\\n\\n');\r\n        const blob = new Blob([textContent], {type: \"text/plain;charset=utf-8\"});\r\n        saveAs(blob, filename + '.txt');\r\n    }\r\n}","import {Project} from \"./project\";\r\n\r\nexport interface ProjectSample {\r\n    name: string,\r\n    project: Project\r\n}\r\n\r\nconst samples: ProjectSample[] = [\r\n    // english sample\r\n    {\r\n        name: \"Cars and Owners (EN)\",\r\n        project: {\r\n            relations: [\r\n                {\r\n                    name: \"Car\",\r\n                    columnNames: [\"Id\", \"Owner\", \"Color\", \"Electric\", \"Weight\"],\r\n                    columnTypes: [\"number\", \"number\", \"string\", \"boolean\", \"number\"],\r\n                    rows: [\r\n                        ['1', '1', 'Blue', 'True', '1000'],\r\n                        ['2', '1', 'Green', 'false', '1 200'],\r\n                        ['3', '2', 'Blue', 'F', '850.42'],\r\n                        ['4', '3', 'Black', 't', '1 111.111 111']\r\n                    ],\r\n                    columnCount: 5,\r\n                    rowCount: 4\r\n                },\r\n                {\r\n                    name: \"Owner\",\r\n                    columnNames: [\"Id\", \"Name\"],\r\n                    columnTypes: [\"number\", \"string\"],\r\n                    rows: [\r\n                        ['1', 'George Smith'],\r\n                        ['2', 'Adam \"Driver /\\\\\" Jackson'],\r\n                        ['3', 'Michael Trueman'],\r\n                        ['Fix errors', 'before loading'],\r\n                        ['Or delete', 'invalid rows']\r\n                    ],\r\n                    columnCount: 2,\r\n                    rowCount: 3\r\n                }\r\n            ],\r\n            expressions: [\r\n                {\r\n                    name: \"Relation only\",\r\n                    text:\r\n                        \"// You can use comments until the line end after '//'\\n\" +\r\n                        \"// You must load relations before using them in expressions\\n\" +\r\n                        \"\\n\" +\r\n                        \"Car\\n\" +\r\n                        \"\\n\" +\r\n                        \"// After evaluation, you will see the evaluation tree\\n\" +\r\n                        \"// and the result relation at the bottom of the page\\n\" +\r\n                        \"\"\r\n                },\r\n                {\r\n                    name: \"Unary operator\",\r\n                    text:\r\n                        \"// Unary operator comes after the source relation\\n\" +\r\n                        \"// If the relation is still not defined, go check its definition\\n\" +\r\n                        \"// This expression returns all owners with id 1\\n\" +\r\n                        \"\\n\" +\r\n                        \"Owner(Id = 1)\\n\" +\r\n                        \"\"\r\n                },\r\n                {\r\n                    name: \"Binary operator\",\r\n                    text:\r\n                        \"// Binary operator comes between source relations\\n\" +\r\n                        \"// This expression returns natural join of cars and owners\\n\" +\r\n                        \"\\n\" +\r\n                        \"Car*Owner\\n\" +\r\n                        \"\"\r\n                },\r\n                {\r\n                    name: \"Escapes\",\r\n                    text:\r\n                        \"// Strings in expressions are enclosed in quotes\\n\" +\r\n                        \"// To use quotes inside a string, you must escape them by a backslash '\\\\\\\"'\\n\" +\r\n                        \"// To use backslash inside a string, you must escape it with second one '\\\\\\\\'\\n\" +\r\n                        \"\\n\" +\r\n                        'Owner(Name == \"Adam \\\\\"Driver /\\\\\\\\\\\\\" Jackson\")\\n' +\r\n                        '\\n' +\r\n                        '// This does not work: Owner(Name == \"Adam \"Driver /\\\\\" Jackson\")\\n' +\r\n                        \"\"\r\n                },\r\n                {\r\n                    name: \"Example\",\r\n                    text:\r\n                        \"// Errors are highlighted by red underline - hover mouse over it to see details\\n\" +\r\n                        \"// While typing, Rachel shows you available relations or columns\\n\" +\r\n                        \"// (if relations are loaded in the application)\\n\" +\r\n                        \"// Try to write a query for: all cars' ids and their owners' names\\n\" +\r\n                        \"\\n\" +\r\n                        \"TODO...\\n\" +\r\n                        \"\"\r\n                },\r\n                {\r\n                    name: \"Example result\",\r\n                    text:\r\n                        \"// One possible expression is like this...\\n\" +\r\n                        \"\\n\" +\r\n                        \"(\\n\" +\r\n                        \"  Car\\n\" +\r\n                        \"  *\\n\" +\r\n                        \"  Owner< Id -> Owner >\\n\" +\r\n                        \")[Id, Name]\\n\" +\r\n                        \"\\n\" +\r\n                        \"// For more detailed manual click 'About' button in the page header\\n\" +\r\n                        \"\"\r\n                }\r\n            ],\r\n            nullValuesSupport: true\r\n        }\r\n    },\r\n    // czech sample\r\n    {\r\n        name: \"Auta a Majitelé (CS)\",\r\n        project: {\r\n            relations: [\r\n                {\r\n                    name: \"Auto\",\r\n                    columnNames: [\"Id\", \"Majitel\", \"Barva\", \"Elektro\", \"Váha\"],\r\n                    columnTypes: [\"number\", \"number\", \"string\", \"boolean\", \"number\"],\r\n                    rows: [\r\n                        ['1', '1', 'Modrá', 'True', '1000'],\r\n                        ['2', '1', 'Zelená', 'false', '1 200'],\r\n                        ['3', '2', 'Modrá', 'F', '850.42'],\r\n                        ['4', '3', 'Černá', 't', '1 111.111 111']\r\n                    ],\r\n                    columnCount: 5,\r\n                    rowCount: 4\r\n                },\r\n                {\r\n                    name: \"Majitel\",\r\n                    columnNames: [\"Id\", \"Jméno\"],\r\n                    columnTypes: [\"number\", \"string\"],\r\n                    rows: [\r\n                        ['1', 'Pepa Mrázek'],\r\n                        ['2', 'Adam \"Závodník /\\\\\" Horváth'],\r\n                        ['3', 'Michael Dvořák'],\r\n                        ['Před nahráním', 'oprav chyby'],\r\n                        ['Nebo odstraň', 'chybné řádky']\r\n                    ],\r\n                    columnCount: 2,\r\n                    rowCount: 3\r\n                }\r\n            ],\r\n            expressions: [\r\n                {\r\n                    name: \"Pouze relace\",\r\n                    text:\r\n                        \"// Můžeš používat komentáře po '//'\\n\" +\r\n                        \"// Před použitím relací ve výrazech je musíš nahrát\\n\" +\r\n                        \"\\n\" +\r\n                        \"Auto\\n\" +\r\n                        \"\\n\" +\r\n                        \"// Po vyhodnocení uvidíš evaluační strom\\n\" +\r\n                        \"// a výslednou relaci dole na stránce\\n\" +\r\n                        \"\"\r\n                },\r\n                {\r\n                    name: \"Unární operátor\",\r\n                    text:\r\n                        \"// Unární operátory se píší za vstupní relaci\\n\" +\r\n                        \"// Pokud je tato relace stále nedefinovaná, zkontroluj její definici\\n\" +\r\n                        \"// Tento dotaz vrátí všechny majitele s id = 1\\n\" +\r\n                        \"\\n\" +\r\n                        \"Majitel(Id = 1)\\n\" +\r\n                        \"\"\r\n                },\r\n                {\r\n                    name: \"Binární operátor\",\r\n                    text:\r\n                        \"// Binární operátory se píší mezi vstupní relace\\n\" +\r\n                        \"// Tento výraz vrátí přirozené spojení aut a majitelů\\n\" +\r\n                        \"\\n\" +\r\n                        \"Auto*Majitel\\n\" +\r\n                        \"\"\r\n                },\r\n                {\r\n                    name: \"Escapes\",\r\n                    text:\r\n                        \"// Textové řetězce ve výrazech musí být mezi uvozovkami\\n\" +\r\n                        \"// Pro použití uvozovek v řetězci před ně musíš napsat zpětné lomítko '\\\\\\\"'\\n\" +\r\n                        \"// Pro použití zpětného lomítka před něj musíš napsat druhé '\\\\\\\\'\\n\" +\r\n                        \"\\n\" +\r\n                        'Majitel(Jméno == \"Adam \\\\\"Závodník /\\\\\\\\\\\\\" Horváth\")\\n' +\r\n                        '\\n' +\r\n                        '// Toto by nefungovalo: Majitel(Jméno == \"Adam \"Závodník /\\\\\" Horváth\")\\n' +\r\n                        \"\"\r\n                },\r\n                {\r\n                    name: \"Příklad\",\r\n                    text:\r\n                        \"// Chyby jsou zvýrazněni červeným podtržením - přejeď na ně myší pro detaily\\n\" +\r\n                        \"// Při psaní ti Rachel nabízí dostupné relace nebo sloupce\\n\" +\r\n                        \"// (pokud jsou relace nahrané v aplikace)\\n\" +\r\n                        \"// Zkus napsat dotaz pro: id všech aut a jména jejich majitelů\\n\" +\r\n                        \"\\n\" +\r\n                        \"TODO...\\n\" +\r\n                        \"\"\r\n                },\r\n                {\r\n                    name: \"Výsledek příkladu\",\r\n                    text:\r\n                        \"// Jedno možné řešení je toto...\\n\" +\r\n                        \"\\n\" +\r\n                        \"(\\n\" +\r\n                        \"  Auto\\n\" +\r\n                        \"  *\\n\" +\r\n                        \"  Majitel< Id -> Majitel >\\n\" +\r\n                        \")[Id, Jméno]\\n\" +\r\n                        \"\\n\" +\r\n                        \"// Pro více informací navštiv manuál přes odkaz 'O aplikaci' v horním menu\\n\" +\r\n                        \"\"\r\n                }\r\n            ],\r\n            nullValuesSupport: true\r\n        }\r\n    }\r\n];\r\n\r\n/**\r\n * Returns prepared project samples.\r\n */\r\nexport function getSamples(): ProjectSample[] {\r\n    return samples;\r\n}","import React from \"react\";\r\nimport {CsvValueSeparator} from \"../types/csvSupport\";\r\nimport {allSupportedLanguages, LanguageDef, SupportedLanguage} from \"../language/language\";\r\nimport \"./css/managementSection.css\"\r\nimport {getSamples} from \"../project/samples\";\r\nimport {Project} from \"../project/project\";\r\n\r\ninterface ManagementSectionProps {\r\n    // handler of batch processing\r\n    onBatch: () => void,\r\n\r\n    // handler of project loading\r\n    onLoadProject: () => void,\r\n    // handler of project saving\r\n    onSaveProject: () => void,\r\n\r\n    // handler of loading the selected sample project\r\n    onLoadSample: (sample: Project) => void,\r\n\r\n    // current selected value separator in csv files\r\n    csvValueSeparator: CsvValueSeparator,\r\n    // current selected language of the application\r\n    language: LanguageDef,\r\n    // current selected null values support\r\n    nullValuesSupport: boolean,\r\n    // true if dark theme should be applied\r\n    darkTheme: boolean,\r\n\r\n    // handler of change of the current selected value separator in csv files\r\n    onCsvValueSeparatorChange: (csvValueSeparator: CsvValueSeparator) => void,\r\n    // handler of change of the current selected language of the application\r\n    onLanguageChange: (language: SupportedLanguage) => void,\r\n    // handler of change of the current selected null values support\r\n    onNullValuesSupportChange: (nullValuesSupport: boolean) => void,\r\n    // handler of change of the current selected theme\r\n    onDarkModeChange: (darkTheme: boolean) => void\r\n}\r\n\r\ninterface ManagementSectionState {\r\n    sectionClicked: boolean\r\n}\r\n\r\n/**\r\n * Section to manage batch processing, importing/exporting the project, and settings.\r\n */\r\nexport class ManagementSection extends React.Component<ManagementSectionProps, ManagementSectionState> {\r\n\r\n    constructor(props: ManagementSectionProps) {\r\n        super(props);\r\n        this.state = {\r\n            sectionClicked: false\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const lang = this.props.language.managementSection;\r\n\r\n        const createBatchButton = () => {\r\n            return (<button onClick={this.props.onBatch}>{lang.batchButton}</button>);\r\n        }\r\n        const createLoadProjectButton = () => {\r\n            return (<button onClick={this.props.onLoadProject} >{lang.loadButton}</button>);\r\n        }\r\n        const createSaveProjectButton = () => {\r\n            return (<button onClick={this.props.onSaveProject} >{lang.saveButton}</button>);\r\n        }\r\n        const createSettingsButton = () => {\r\n            const settingsMenu = (\r\n                <ul className=\"list-menu\">\r\n                    <li>\r\n                        <span>{lang.settingsNullValues}:</span>\r\n                        <input\r\n                            type=\"radio\"\r\n                            name=\"null_values_support\"\r\n                            value=\"allowed\"\r\n                            id=\"null_values_support_allowed\"\r\n                            checked={this.props.nullValuesSupport}\r\n                            onChange={() => this.props.onNullValuesSupportChange(true)} />\r\n                        <label htmlFor=\"null_values_support_allowed\">{lang.settingsNullValuesAllowed}</label>\r\n                        <input\r\n                            type=\"radio\"\r\n                            name=\"null_values_support\"\r\n                            value=\"forbidden\"\r\n                            id=\"null_values_support_forbid\"\r\n                            checked={!this.props.nullValuesSupport}\r\n                            onChange={() => this.props.onNullValuesSupportChange(false)} />\r\n                        <label htmlFor=\"null_values_support_forbid\">{lang.settingsNullValuesForbidden}</label>\r\n                    </li>\r\n                    <li>\r\n                        <span>{lang.settingsCSVSeparator}:</span>\r\n                        <input\r\n                            type=\"radio\"\r\n                            name=\"value_separator\"\r\n                            value=\"semicolon\"\r\n                            id=\"value_separator_semi\"\r\n                            checked={this.props.csvValueSeparator === \";\"}\r\n                            onChange={() => this.props.onCsvValueSeparatorChange(\";\")}/>\r\n                        <label htmlFor=\"value_separator_semi\">{lang.settingsCSVSeparatorSemicolon}</label>\r\n                        <input\r\n                            type=\"radio\"\r\n                            name=\"value_separator\"\r\n                            value=\"comma\"\r\n                            id=\"value_separator_comma\"\r\n                            checked={this.props.csvValueSeparator === \",\"}\r\n                            onChange={() => this.props.onCsvValueSeparatorChange(\",\")}/>\r\n                        <label htmlFor=\"value_separator_comma\">{lang.settingsCSVSeparatorComma}</label>\r\n                    </li>\r\n                    <li>\r\n                        <span>{lang.settingsTheme}:</span>\r\n                        <input\r\n                            type=\"radio\"\r\n                            name=\"dark_mode\"\r\n                            value=\"on\"\r\n                            id=\"dark_mode_on\"\r\n                            checked={!this.props.darkTheme}\r\n                            onChange={() => this.props.onDarkModeChange(false)} />\r\n                        <label htmlFor=\"dark_mode_on\">{lang.settingsThemeLight}</label>\r\n                        <input\r\n                            type=\"radio\"\r\n                            name=\"dark_mode\"\r\n                            value=\"off\"\r\n                            id=\"dark_mode_off\"\r\n                            checked={this.props.darkTheme}\r\n                            onChange={() => this.props.onDarkModeChange(true)} />\r\n                        <label htmlFor=\"dark_mode_off\">{lang.settingsThemeDark}</label>\r\n                    </li>\r\n                    <li>\r\n                        <span>{lang.settingsLanguage}:</span>\r\n                        {allSupportedLanguages.map(lang => {\r\n                            return (<div key={lang} style={{display: \"inline\"}}>\r\n                                <input\r\n                                    type=\"radio\"\r\n                                    name=\"language\"\r\n                                    value={lang}\r\n                                    id={\"language_\" + lang}\r\n                                    checked={this.props.language.abbr === lang}\r\n                                    onChange={() => this.props.onLanguageChange(lang)} />\r\n                                <label htmlFor={\"language_\" + lang}>{lang}</label>\r\n                            </div>)\r\n                        })}\r\n                    </li>\r\n                </ul>\r\n            );\r\n            return (<div className={\"button-like\"}>{lang.settingsButton}{settingsMenu}</div>);\r\n        }\r\n        const createSamplesButton = () => {\r\n            const samplesMenu = (\r\n            <ul className=\"list-menu\">\r\n                {lang.samplesMenuTitle}\r\n                {getSamples().map((sample, i) => {\r\n                    return (\r\n                        <li key={i}>\r\n                            <button onClick={() => this.props.onLoadSample(sample.project)}>{sample.name}</button>\r\n                        </li>\r\n                    );\r\n                })}\r\n            </ul>\r\n            );\r\n            return (<div className={\"button-like\"} >{lang.samplesButton}{samplesMenu}</div>);\r\n        }\r\n        const createAboutButton = () => {\r\n            return (\r\n                <a  href=\"https://github.com/kotliluk/rachel\"\r\n                    target=\"_blank\"\r\n                    rel=\"noreferrer\"\r\n                    className={\"button-like\"}\r\n                >{lang.aboutButton}</a>\r\n            );\r\n        }\r\n\r\n        return (\r\n            <header className=\"management-section\">\r\n                <h1>RACHEL</h1>\r\n                {createBatchButton()}\r\n                {createLoadProjectButton()}\r\n                {createSaveProjectButton()}\r\n                {createSamplesButton()}\r\n                {createSettingsButton()}\r\n                {createAboutButton()}\r\n            </header>\r\n        );\r\n    }\r\n}","import {copyExpression, Expression, isExpression} from \"../expression/expression\";\r\nimport {copyStoredRelationData, isStoredRelationData, StoredRelationData} from \"../relation/storedRelation\";\r\n\r\n/**\r\n * Project interface to store information about project relations and expressions relation.\r\n * Does not store custom settings about saving file types etc.\r\n */\r\nexport interface Project {\r\n    relations: StoredRelationData[],\r\n    expressions: Expression[],\r\n    nullValuesSupport: boolean\r\n}\r\n\r\n/**\r\n * Checks whether the given value is Project (i.e., has all required fields of required types).\r\n *\r\n * @param obj value to be checked\r\n * @return \"OK\" string if the given obj is Project or string description of found error in the structure\r\n */\r\nexport function isProjectObject(obj: any): string {\r\n    if (typeof obj !== \"object\") {\r\n        return 'The file cannot be parsed to an object.';\r\n    }\r\n    if (!(\"relations\" in obj) || !Array.isArray(obj.relations) || obj.relations.length === 0 ||\r\n        obj.relations.some((o: any) => !isStoredRelationData(o))) {\r\n        return 'The file must contain the field \"relations: StoredRelationData[]\" of length at least one';\r\n    }\r\n    if (!(\"expressions\" in obj) || !Array.isArray(obj.expressions) || obj.expressions.length === 0 ||\r\n        obj.expressions.some((o: any) => !isExpression(o))) {\r\n        return 'The file must contain the field \"expressions: Expression[]\" of length at least one';\r\n    }\r\n    if (!(\"nullValuesSupport\" in obj) || typeof obj.nullValuesSupport !== \"boolean\") {\r\n        return 'The file must contain the field \"nullValuesSupport: boolean\"';\r\n    }\r\n    return 'OK';\r\n}\r\n\r\n/**\r\n * Creates a copy of the given project.\r\n */\r\nexport function copyProject(proj: Project): Project {\r\n    return {\r\n        relations: proj.relations.map(rel => copyStoredRelationData(rel)),\r\n        expressions: proj.expressions.map(expr => copyExpression(expr)),\r\n        nullValuesSupport: proj.nullValuesSupport\r\n    }\r\n}","/**\r\n * Representation of named RA expression.\r\n */\r\nexport interface Expression {\r\n    name: string,\r\n    text: string\r\n}\r\n\r\n/**\r\n * Checks whether the given obj is an Expression.\r\n *\r\n * @param obj\r\n */\r\nexport function isExpression(obj: any): boolean {\r\n    if (typeof obj !== \"object\") {\r\n        return false;\r\n    }\r\n    return (\"name\" in obj) && (typeof obj.name === \"string\") && (\"text\" in obj) && (typeof obj.text === \"string\");\r\n}\r\n\r\n/**\r\n * Creates a copy of the given expression.\r\n */\r\nexport function copyExpression(exp: Expression): Expression {\r\n    return {name: exp.name, text: exp.text};\r\n}","import {isProjectObject, Project} from \"./project\";\r\nimport {FileDialog} from \"../utils/fileDialog\";\r\nimport {saveAs} from \"file-saver\";\r\n\r\n/**\r\n * Class for loading and saving project relations and expressions relation.\r\n */\r\nexport class ProjectStoreManager {\r\n\r\n    /**\r\n     * Loads asynchronously the project from a .rachel (JSON) file selected by the user.\r\n     * The file must contain the representation of the project object: {\r\n     * relations: StoredRelationData[],\r\n     * expressionTexts: string[],\r\n     * nullValuesSupport: boolean\r\n     * }.\r\n     * Returned string values always use '\\n' as line separator.\r\n     */\r\n    public static load(): Promise<Project> {\r\n        return new Promise<Project>((resolve, reject) => {\r\n            FileDialog.openFile(\".rachel\").then(file => {\r\n                if (file.text === null) {\r\n                    reject(\"Reading of the content of the file \" + file.name + \" failed.\");\r\n                }\r\n                else if (file.name.match(/\\.rachel$/)) {\r\n                    // replaces line separators to expected '\\n'\r\n                    file.text = file.text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n')\r\n                        .replace(/\\t/g, \"    \");\r\n                    let obj = JSON.parse(file.text);\r\n                    const result: string = isProjectObject(obj);\r\n                    if (result === \"OK\") {\r\n                        const project: Project = obj;\r\n                        resolve(project);\r\n                    }\r\n                    else {\r\n                        reject(\"Invalid structure of the JSON file. \" + result)\r\n                    }\r\n                }\r\n                else {\r\n                    reject(\"Please select a JSON file to load a project relation from.\");\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Saves the given Project into the .rachel (JSON) file.\r\n     *\r\n     * @param project the Project object with all project relation\r\n     * @param filename name of the downloaded file (without extension)\r\n     */\r\n    public static save(project: Project, filename: string): void {\r\n        const blob = new Blob([JSON.stringify(project)], {type: \"text/plain;charset=utf-8\"});\r\n        saveAs(blob, filename + '.rachel');\r\n    }\r\n}","import {FileDialog} from \"../utils/fileDialog\";\r\nimport JSZip from \"jszip\";\r\nimport {saveAs} from \"file-saver\";\r\nimport Relation from \"../relation/relation\";\r\nimport RATreeNode from \"../ratree/raTreeNode\";\r\nimport UnaryNode from \"../ratree/unaryNode\";\r\nimport ProjectionNode from \"../ratree/projectionNode\";\r\nimport RenameNode from \"../ratree/renameNode\";\r\nimport SelectionNode from \"../ratree/selectionNode\";\r\nimport BinaryNode from \"../ratree/binaryNode\";\r\nimport AntijoinNode from \"../ratree/antijoinNode\";\r\nimport CartesianProductNode from \"../ratree/cartesianProductNode\";\r\nimport DivisionNode from \"../ratree/divisionNode\";\r\nimport OuterJoinNode from \"../ratree/outerJoinNode\";\r\nimport NaturalJoinNode, {NaturalJoinType} from \"../ratree/naturalJoinNode\";\r\nimport SetOperationNode from \"../ratree/setOperationNode\";\r\nimport {formatDate} from \"../utils/dateUtils\";\r\nimport ThetaJoinNode, {ThetaJoinType} from \"../ratree/thetaJoinNode\";\r\nimport {isProjectObject, Project} from \"../project/project\";\r\nimport {ExprParser} from \"../expression/exprParser\";\r\nimport {StoredRelation, StoredRelationData} from \"../relation/storedRelation\";\r\nimport {Expression} from \"../expression/expression\";\r\nimport {MessageBox} from \"../components/messageBox\";\r\n\r\n/**\r\n * Class for processing multiple input .txt files with expressions.\r\n */\r\nexport class BatchProcessor {\r\n\r\n    /**\r\n     * Opens file dialog and processes files selected by the user. For each .rachel file creates a textual evaluation\r\n     * report. Files are expected to contain valid project data. Returns promise with string message about process.\r\n     */\r\n    public static process(filename: string): void {\r\n        FileDialog.openFiles(\".rachel\").then(files => {\r\n            console.log(files.length + ' files loaded to BatchProcessor');\r\n            console.time(\"Batch duration\");\r\n\r\n            let reports: {name: string, text: string}[] = [];\r\n            let processed: number = 0;\r\n            let skipped: number = 0;\r\n\r\n            /**\r\n             * Processes a file on the given index and calls the processing of the next file.\r\n             * If all files were processed, calls downloadReports().\r\n             */\r\n            const processNext = (i: number) => {\r\n                if (i >= files.length) {\r\n                    return downloadReports();\r\n                }\r\n                const file = files[i];\r\n                if (file.text === null) {\r\n                    reports.push({\r\n                        name: file.name + '-eval-report.txt',\r\n                        text: \"ERROR: Source file cannot be loaded.\"\r\n                    });\r\n                    skipped += 1;\r\n                    console.warn('Null read from ' + file.name);\r\n                }\r\n                else if (file.name.match(/\\.rachel$/)) {\r\n                    // @ts-ignore - file.text cannot be null now\r\n                    reports.push(BatchProcessor.processFile(file));\r\n                    processed += 1;\r\n                }\r\n                else {\r\n                    reports.push({\r\n                        name: file.name + '-eval-report.txt',\r\n                        text: \"ERROR: Source file is not a .rachel file, but: \" + file.name\r\n                    });\r\n                    skipped += 1;\r\n                    console.warn('Unsupported filetype: ' + file.name);\r\n                }\r\n                MessageBox.message(\"Batch in progress... \" + (processed + skipped) + \"/\" + files.length);\r\n                setTimeout(() => processNext(i + 1), 0);\r\n            }\r\n\r\n            /**\r\n             * Downloads created reports.\r\n             */\r\n            const downloadReports = () => {\r\n                const zip: JSZip = JSZip();\r\n                reports.forEach(report => {\r\n                    zip.file(report.name, report.text);\r\n                })\r\n                zip.generateAsync({type: \"blob\"}).then(content => {\r\n                    saveAs(content, filename + \".zip\");\r\n                    console.log(\"Batch finished: \" + processed + \" files processed, \" + skipped + \" skipped.\");\r\n                    MessageBox.message(\"Batch finished: \" + processed + \" files processed, \" + skipped + \" skipped.\");\r\n                }).catch(err => {\r\n                    MessageBox.error(\"Batch results saving error: \" + err.message);\r\n                });\r\n                console.timeEnd(\"Batch duration\");\r\n            }\r\n\r\n            processNext(0);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Tries to parse Project object from given file.text. If successful, parses relations in the project, evaluates\r\n     * expressions in the project and generates textual report: header (see reportHeader()),\r\n     * formatted relations (see formatRelations()) and formatted expressions (see processExpression()).\r\n     */\r\n    private static processFile = (file: {name: string, text: string}): {name: string, text: string} => {\r\n        const project: Project = JSON.parse(file.text);\r\n        const status = isProjectObject(project);\r\n        if (status !== \"OK\") {\r\n            return {name: file.name.slice(0, -4) + '-eval-report.txt', text: \"Invalid JSON file: \" + status};\r\n        }\r\n        const relations: Map<string, Relation> = BatchProcessor.parseRelations(project.relations, project.nullValuesSupport);\r\n        const exprParser: ExprParser = new ExprParser(relations, project.nullValuesSupport);\r\n\r\n        const exprCount: number = project.expressions.length;\r\n        const reports = project.expressions.map(e => BatchProcessor.processExpression(e, exprParser));\r\n        const ops: OperationsCount = addOperations(...reports.map(r => r.counts));\r\n        const errors: number = reports.reduce((agg, report) => agg + report.error, 0);\r\n\r\n        return {\r\n            name: file.name.slice(0, -7) + '-eval-report.txt',\r\n            text: BatchProcessor.reportHeader(exprCount, errors, ops, project.nullValuesSupport) +\r\n                  BatchProcessor.formatRelations(project.relations) +\r\n                  sectionLine + \"\\n\\nQUERIES (\" + exprCount + \")\\n\\n\" +\r\n                  reports.map(r => r.text).join('')\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Creates full Relation representation for given StoredRelationData array.\r\n     */\r\n    private static parseRelations(storedData: StoredRelationData[], nullValuesSupport: boolean): Map<string, Relation> {\r\n        const map: Map<string, Relation> = new Map();\r\n        storedData.forEach(data => {\r\n            try {\r\n                const storedRelation: StoredRelation = StoredRelation.fromData(data, nullValuesSupport);\r\n                if (storedRelation.isValid()) {\r\n                    map.set(storedRelation.getName(), storedRelation.createRelation());\r\n                }\r\n            }\r\n            catch (ignored) { }\r\n        })\r\n        return map;\r\n    }\r\n\r\n    /**\r\n     * Processes given expression in context of given parser. Returns formatted expression and its result (or error),\r\n     * count of used RA operations and 0/1 error indicator.\r\n     */\r\n    private static processExpression = (expr: Expression, parser: ExprParser): {text: string, counts: OperationsCount, error: number} => {\r\n        try {\r\n            const evaluationTree = parser.parse(expr.text);\r\n            const counts: OperationsCount = operationsOfTree(evaluationTree);\r\n            const relation: Relation = evaluationTree.getResult();\r\n            return {\r\n                text: contentLine + '\\n' + expr.name + '\\n\\n' + expr.text + '\\n\\n' + relation.contentString() + '\\n\\n\\n',\r\n                counts: counts,\r\n                error: 0\r\n            };\r\n        }\r\n        catch (err) {\r\n            return {\r\n                text: contentLine + '\\n' + expr.name + '\\n\\n' + expr.text + '\\n\\nERROR: ' + err.message + '\\n\\n\\n',\r\n                counts: zeroOperations(),\r\n                error: 1\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates the header of the report. The header contains the time of the report, count of expressions and errors,\r\n     * count of used operations and null values support info.\r\n     *\r\n     * @param expressions count of expressions\r\n     * @param errors count of errors\r\n     * @param operations count of operations\r\n     * @param nullValuesSupport\r\n     */\r\n    private static reportHeader = (expressions: number, errors: number, operations: OperationsCount, nullValuesSupport: boolean): string => {\r\n        const total: number = totalOperations(operations);\r\n        const binary: number = binaryOperations(operations);\r\n        const unary: number = unaryOperations(operations);\r\n        return sectionLine + '\\n\\nRachel project report from ' + formatDate(new Date()) + '\\n\\n' + sectionLine + '\\n\\n' +\r\n            'Expressions: ' + expressions + '    Errors: ' + errors + '\\n\\n' +\r\n            'Used operations (' + total + ' in total: ' + binary + ' binary, ' + unary + ' unary):\\n' +\r\n            '    Selection: ' + operations.selection + '\\n' +\r\n            '    Projection: ' + operations.projection + '\\n' +\r\n            '    Rename: ' + operations.rename + '\\n\\n' +\r\n            '    Set Operations: ' + operations.setOperation + '\\n\\n' +\r\n            '    Natural join: ' + operations.natural + '\\n' +\r\n            '    Cartesian product: ' + operations.cartesian + '\\n' +\r\n            '    Semijoin: ' + operations.semijoin + '\\n' +\r\n            '    Antijoin: ' + operations.antijoin + '\\n' +\r\n            '    Theta Join: ' + operations.thetaJoin + '\\n' +\r\n            '    Theta Semijoin: ' + operations.thetaSemijoin + '\\n\\n' +\r\n            '    Outer Join: ' + operations.outerJoin + '\\n\\n' +\r\n            '    Division: ' + operations.division + '\\n\\n' +\r\n            (nullValuesSupport ? 'Null values ALLOWED.\\n\\n' : 'Null values FORBIDDEN.\\n\\n');\r\n    }\r\n\r\n    /**\r\n     * Returns formatted string for given StoredRelationsData array.\r\n     */\r\n    private static formatRelations = (storedData: StoredRelationData[]): string => {\r\n        const inlines = storedData.map(data => {\r\n            return data.name + \"(\" + data.columnNames.join(\", \") + \")\\n\"\r\n        }).join('');\r\n        return sectionLine + \"\\n\\nTABLES (\" + storedData.length + \")\\n\\n\" + inlines + \"\\n\" +\r\n            storedData.map(data => contentLine + \"\\n\" + data.name + '\\n\\n' + StoredRelation.format(data)).join('');\r\n    }\r\n}\r\n\r\nconst sectionLine: string = \"################################################################################\";\r\nconst contentLine: string = \"--------------------------------------------------------------------------------\";\r\n\r\n/**\r\n * Counts of all supported relational algebra operations.\r\n */\r\ninterface OperationsCount {\r\n    antijoin: number,\r\n    cartesian: number,\r\n    division: number,\r\n    natural: number,\r\n    outerJoin: number,\r\n    projection: number,\r\n    rename: number,\r\n    selection: number,\r\n    semijoin: number,\r\n    setOperation: number,\r\n    thetaJoin: number,\r\n    thetaSemijoin: number,\r\n}\r\n\r\n/**\r\n * @return zero count of all operations\r\n */\r\nfunction zeroOperations(): OperationsCount {\r\n    return addOperations();\r\n}\r\n\r\n/**\r\n * @return adds given OperationsCounts together\r\n */\r\nfunction addOperations(...counts: OperationsCount[]): OperationsCount {\r\n    return {\r\n        antijoin: counts.reduce((agg, count) => agg + count.antijoin, 0),\r\n        cartesian: counts.reduce((agg, count) => agg + count.cartesian, 0),\r\n        division: counts.reduce((agg, count) => agg + count.division, 0),\r\n        natural: counts.reduce((agg, count) => agg + count.natural, 0),\r\n        outerJoin: counts.reduce((agg, count) => agg + count.outerJoin, 0),\r\n        projection: counts.reduce((agg, count) => agg + count.projection, 0),\r\n        rename: counts.reduce((agg, count) => agg + count.rename, 0),\r\n        selection: counts.reduce((agg, count) => agg + count.selection, 0),\r\n        semijoin: counts.reduce((agg, count) => agg + count.semijoin, 0),\r\n        setOperation: counts.reduce((agg, count) => agg + count.setOperation, 0),\r\n        thetaJoin: counts.reduce((agg, count) => agg + count.thetaJoin, 0),\r\n        thetaSemijoin: counts.reduce((agg, count) => agg + count.thetaSemijoin, 0),\r\n    }\r\n}\r\n\r\n/**\r\n * @return sum of all operation counts\r\n */\r\nfunction totalOperations(o: OperationsCount): number {\r\n    return binaryOperations(o) + unaryOperations(o);\r\n}\r\n\r\n/**\r\n * @return sum of all binary operation counts\r\n */\r\nfunction binaryOperations(o: OperationsCount): number {\r\n    return o.antijoin + o.cartesian + o.division + o.natural + o.outerJoin + o.semijoin + o.setOperation + o.thetaJoin + o.thetaSemijoin;\r\n}\r\n\r\n/**\r\n * @return sum of all unary operation counts\r\n */\r\nfunction unaryOperations(o: OperationsCount): number {\r\n    return o.projection + o.rename + o.selection;\r\n}\r\n\r\n/**\r\n * @return counts all operations used in the given tree.\r\n */\r\nfunction operationsOfTree(tree: RATreeNode): OperationsCount {\r\n    if (tree instanceof UnaryNode) {\r\n        return addOperations(operationOfUnaryNode(tree), operationsOfTree(tree.getSubtree()));\r\n    }\r\n    if (tree instanceof BinaryNode) {\r\n        return addOperations(operationOfBinaryNode(tree), operationsOfTree(tree.getLeftSubtree()), operationsOfTree(tree.getRightSubtree()));\r\n    }\r\n    // no subtree - relation node\r\n    return zeroOperations();\r\n}\r\n\r\n/**\r\n * @return OperationsCount with one given unary operation count set to 1, other 0\r\n */\r\nfunction operationOfUnaryNode(node: UnaryNode): OperationsCount {\r\n    let ret: OperationsCount = zeroOperations();\r\n    if (node instanceof ProjectionNode) {\r\n        ret.projection = 1;\r\n        return ret;\r\n    }\r\n    if (node instanceof RenameNode) {\r\n        ret.rename = 1;\r\n        return ret;\r\n    }\r\n    if (node instanceof SelectionNode) {\r\n        ret.selection = 1;\r\n        return ret;\r\n    }\r\n    return ret;\r\n}\r\n\r\n/**\r\n * @return OperationsCount with one given binary operation count set to 1, other 0\r\n */\r\nfunction operationOfBinaryNode(node: BinaryNode): OperationsCount {\r\n    let ret: OperationsCount = zeroOperations();\r\n    if (node instanceof AntijoinNode) {\r\n        ret.antijoin = 1;\r\n        return ret;\r\n    }\r\n    if (node instanceof CartesianProductNode) {\r\n        ret.cartesian = 1;\r\n        return ret;\r\n    }\r\n    if (node instanceof DivisionNode) {\r\n        ret.division = 1;\r\n        return ret;\r\n    }\r\n    if (node instanceof OuterJoinNode) {\r\n        ret.outerJoin = 1;\r\n        return ret;\r\n    }\r\n    if (node instanceof NaturalJoinNode) {\r\n        if (node.getType() === NaturalJoinType.natural) {\r\n            ret.natural = 1;\r\n        }\r\n        else {\r\n            ret.semijoin = 1;\r\n        }\r\n        return ret;\r\n    }\r\n    if (node instanceof SetOperationNode) {\r\n        ret.setOperation = 1;\r\n        return ret;\r\n    }\r\n    if (node instanceof ThetaJoinNode) {\r\n        if (node.getType() === ThetaJoinType.full) {\r\n            ret.thetaJoin = 1;\r\n        }\r\n        else {\r\n            ret.thetaSemijoin = 1;\r\n        }\r\n        return ret;\r\n    }\r\n    return ret;\r\n}","/**\r\n * Formats given date to: dd.mm.yyyy hh:mm.\r\n *\r\n * @param date date to format\r\n */\r\nexport function formatDate(date: Date): string {\r\n    return String(date.getDate()).padStart(2, '0') + '.' + String(date.getMonth() + 1).padStart(2, '0') + '.' +\r\n        String(date.getFullYear()) + ' ' +\r\n        String(date.getHours()).padStart(2, '0') + ':' + String(date.getMinutes()).padStart(2, '0');\r\n}","import React from \"react\";\r\nimport './css/editRelationTable.css';\r\nimport {StoredRelation} from \"../relation/storedRelation\";\r\nimport {SupportedColumnType} from \"../relation/columnType\";\r\nimport {NNToSMap} from \"../types/nnToSMap\";\r\n\r\ninterface EditRelationTableProps {\r\n    // storing representation of the relation to be edited\r\n    relation: StoredRelation,\r\n\r\n    // handler of column name change\r\n    onColumnNameChange: (columnName: string, columnIndex: number) => void,\r\n    // handler of column type change\r\n    onColumnTypeChange: (columnType: SupportedColumnType, columnIndex: number) => void,\r\n    // handler of row input change\r\n    onRowInputChange: (input: string, columnIndex: number, rowIndex: number) => void,\r\n    // handler of adding new row\r\n    onNewRow: (onDone: () => void) => void,\r\n    // handler of adding new column\r\n    onNewColumn: (onDone: () => void) => void,\r\n    // handler of deleting the row of given index\r\n    onDeleteRow: (rowIndex: number) => void,\r\n    // handler of deleting the column of given index\r\n    onDeleteColumn: (columnIndex: number) => void,\r\n\r\n    // handler of input with Ctrl key\r\n    onCtrlInput: (ev: React.KeyboardEvent) => void\r\n}\r\n\r\ninterface EditRelationTableState {\r\n    selectedColumn: number | undefined,\r\n    selectedRow: \"names\" | \"types\" | number | undefined\r\n}\r\n\r\n// @ts-ignore\r\nconst cssConstants: CSSStyleDeclaration = getComputedStyle(document.querySelector(':root'));\r\nconst cellPaddingSides: number = Number(cssConstants.getPropertyValue('--cell-padding-sides-num'));\r\nconst inputMarginSides: number = Number(cssConstants.getPropertyValue('--input-margin-sides-num'));\r\n\r\n/**\r\n * Table for editing a relation relation. It supports adding new columns and rows and editing all relation (column names,\r\n * column types and row inputs).\r\n */\r\nexport default class EditRelationTable extends React.Component<EditRelationTableProps, EditRelationTableState> {\r\n\r\n    private readonly containerRef: React.RefObject<HTMLDivElement>;\r\n    // reference to the head row with columns names\r\n    private readonly tableHeadRowRef: React.RefObject<HTMLTableRowElement>;\r\n    // width of cells in head (with deducted padding) to set proper inputs width to not resize the table\r\n    private columnWidths: number[] = [];\r\n\r\n    constructor(props: EditRelationTableProps) {\r\n        super(props);\r\n        this.state = {\r\n            selectedColumn: undefined,\r\n            selectedRow: undefined\r\n        }\r\n        this.containerRef = React.createRef<HTMLDivElement>();\r\n        this.tableHeadRowRef = React.createRef<HTMLTableRowElement>();\r\n    }\r\n\r\n    componentDidMount() {\r\n        // clicking in the window blurs the selected input (if clicked into a cell, event propagation is stopped to not blur\r\n        window.addEventListener('click', () => {\r\n            this.setSelectedInput(undefined, undefined);\r\n        });\r\n        this.componentDidUpdate();\r\n    }\r\n\r\n    componentDidUpdate() {\r\n        const headRow = this.tableHeadRowRef.current;\r\n        if (headRow !== null) {\r\n            // cells without the first (line number) and last (add column button)\r\n            const cells = [...headRow.cells].slice(1, -1);\r\n            this.columnWidths = cells.map(cell => cell.clientWidth - 2 * (cellPaddingSides + inputMarginSides));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Changes column width if the resized input element does not fit in it anymore.\r\n     */\r\n    private handleInputResize = (inputElement: EventTarget & HTMLInputElement, column: number) => {\r\n        // handles larger width\r\n        if (inputElement.scrollWidth > this.columnWidths[column]) {\r\n            this.columnWidths[column] = inputElement.scrollWidth;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns error of the relation to edit.\r\n     */\r\n    private getErrors = (): NNToSMap => {\r\n        return this.props.relation.getErrors();\r\n    }\r\n\r\n    /**\r\n     * Sets selected input column and row to given values.\r\n     */\r\n    private setSelectedInput = (column: number | undefined, row: \"names\" | \"types\" | number | undefined): void => {\r\n        this.setState({\r\n            selectedColumn: column,\r\n            selectedRow: row\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Moves selected input to right if it is defined and not in the last column.\r\n     */\r\n    private moveSelectedInputRight = (): void => {\r\n        const selectedColumn = this.state.selectedColumn;\r\n        const selectedRow = this.state.selectedRow;\r\n        if (selectedColumn !== undefined && selectedRow !== undefined) {\r\n            // if not last column was selected\r\n            if (selectedColumn < this.props.relation.getColumnCount() - 1) {\r\n                this.setState({selectedColumn: selectedColumn + 1});\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves selected input to left if it is defined and not in the first column.\r\n     */\r\n    private moveSelectedInputLeft = (): void => {\r\n        const selectedColumn = this.state.selectedColumn;\r\n        const selectedRow = this.state.selectedRow;\r\n        if (selectedColumn !== undefined && selectedRow !== undefined) {\r\n            // if not first column was selected\r\n            if (selectedColumn > 0) {\r\n                this.setState({selectedColumn: selectedColumn - 1});\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves selected input up if it is defined and not in the first row.\r\n     */\r\n    private moveSelectedInputUp = (): void => {\r\n        const selectedColumn = this.state.selectedColumn;\r\n        const selectedRow = this.state.selectedRow;\r\n        if (selectedColumn !== undefined && selectedRow !== undefined) {\r\n            // if not first row was selected\r\n            if (typeof selectedRow === \"number\") {\r\n                if (selectedRow === 0) {\r\n                    this.setState({selectedRow: \"names\"});\r\n                }\r\n                else {\r\n                    this.setState({selectedRow: selectedRow - 1});\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves selected input down if it is defined and not in the last row.\r\n     */\r\n    private moveSelectedInputDown = (): void => {\r\n        const selectedColumn = this.state.selectedColumn;\r\n        const selectedRow = this.state.selectedRow;\r\n        if (selectedColumn !== undefined && selectedRow !== undefined) {\r\n            if (selectedRow === \"names\" && this.props.relation.getRowCount() > 0) {\r\n                this.setState({selectedRow: 0});\r\n            }\r\n            // if not last row was selected\r\n            if (typeof selectedRow === \"number\" && selectedRow < this.props.relation.getRowCount() - 1) {\r\n                this.setState({selectedRow: selectedRow + 1});\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Catches key inputs with special effects in tht table.\r\n     */\r\n    private handleKeyDown = (event: React.KeyboardEvent): void => {\r\n        if (event.key === \"Enter\" || event.key === \"Esc\" || event.key === \"Escape\") {\r\n            this.setSelectedInput(undefined, undefined);\r\n        }\r\n        else if (event.key === \"Tab\" || (event.ctrlKey && event.key === \"ArrowRight\")) {\r\n            this.moveSelectedInputRight();\r\n            event.preventDefault();\r\n        }\r\n        else if (event.ctrlKey && event.key === \"ArrowLeft\") {\r\n            this.moveSelectedInputLeft();\r\n            event.preventDefault();\r\n        }\r\n        else if (event.ctrlKey && event.key === \"ArrowUp\") {\r\n            this.moveSelectedInputUp();\r\n            event.preventDefault();\r\n        }\r\n        else if (event.ctrlKey && event.key === \"ArrowDown\") {\r\n            this.moveSelectedInputDown();\r\n            event.preventDefault();\r\n        }\r\n        if (event.ctrlKey) {\r\n            this.props.onCtrlInput(event);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Passes the change of the column name, column type or row input to the parent element.\r\n     * When row = \"types\", it is expected that value is of SupportedColumnType type.\r\n     * Tabulators are replaced by 4 spaces.\r\n     */\r\n    private handleChange = (value: string, column: number, row: \"names\" | \"types\" | number): void => {\r\n        value = value.replace(/\\t/g, \"    \");\r\n        if (row === \"names\") {\r\n            this.props.onColumnNameChange(value, column);\r\n        }\r\n        else if (row === \"types\") {\r\n            // @ts-ignore - should be ensured before method call\r\n            this.props.onColumnTypeChange(value, column);\r\n        }\r\n        else {\r\n            this.props.onRowInputChange(value, column, row);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a new column to the relation and scrolls to it.\r\n     */\r\n    private handleNewColumn = (): void => {\r\n        this.props.onNewColumn(() => {\r\n            // @ts-ignore\r\n            this.containerRef.current.scrollTo(this.containerRef.current.clientWidth, this.containerRef.current.scrollTop)\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds a new row to the relation and scrolls to it.\r\n     */\r\n    private handleNewRow = (): void => {\r\n        this.props.onNewRow(() => {\r\n            // @ts-ignore\r\n            this.containerRef.current.scrollTo(this.containerRef.current.scrollLeft, this.containerRef.current.clientHeight)\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deletes the column at given index.\r\n     */\r\n    private handleDeleteColumn = (column: number): void => {\r\n        this.props.onDeleteColumn(column);\r\n    }\r\n\r\n    /**\r\n     * Deletes the row at given index.\r\n     */\r\n    private handleDeleteRow = (row: number): void => {\r\n        this.props.onDeleteRow(row);\r\n    }\r\n\r\n    /**\r\n     * Creates a text input bind to handling change of given column and row.\r\n     */\r\n    private createInput = (value: string, column: number, row: \"names\" | \"types\" | number) => {\r\n        return (\r\n            <input\r\n                type='text'\r\n                className={'text-input'}\r\n                spellCheck={false}\r\n                value={value}\r\n                onChange={(e) => {\r\n                    this.handleChange(e.target.value, column, row);\r\n                    this.handleInputResize(e.target, column);\r\n                }}\r\n                autoFocus={true}\r\n                style={{width: this.columnWidths[column] + \"px\"}}\r\n            />\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Creates a tooltip with given text.\r\n     */\r\n    private createTooltip(text: string, style?: React.CSSProperties) {\r\n        return (<span className={\"tooltip\"} style={style}>{text}</span>)\r\n    }\r\n\r\n    /**\r\n     * Creates a button for deleting rows or columns.\r\n     */\r\n    private createDeleteButton = (callback: () => void) => {\r\n        return (<button className=\"delete-row-or-column-button\" onClick={callback}>&#10006;</button>);\r\n    }\r\n\r\n    /**\r\n     * Creates content of the first row of the table with column names.\r\n     * If the table is editable, additional blank column is added for \"add column\" button in next rows.\r\n     */\r\n    private createNamesRow() {\r\n        const rowData = this.props.relation.getColumnNames().map((columnName, columnIndex) => {\r\n            let content: string | JSX.Element = columnName;\r\n            if (this.state.selectedColumn === columnIndex && this.state.selectedRow === \"names\") {\r\n                content = this.createInput(columnName, columnIndex, \"names\");\r\n            }\r\n            let span: null | JSX.Element = null;\r\n            let className: string = \"name-th\";\r\n            const error = this.getErrors().get(\"name\", columnIndex);\r\n            if (error !== undefined) {\r\n                span = this.createTooltip(error, {top: \"90%\", bottom: \"auto\"});\r\n                className += \" error-input\";\r\n            }\r\n            return (\r\n                <th key={columnIndex}\r\n                    className={className}\r\n                    onClick={ev => {\r\n                        this.setSelectedInput(columnIndex, \"names\");\r\n                        ev.stopPropagation();\r\n                    }}\r\n                >{content}{span}</th>\r\n            )});\r\n        // pushes \"add column\" button in last column\r\n        rowData.push(\r\n            <td key='add-column'\r\n                rowSpan={2}\r\n                style={{width: \"24px\", border: \"none\", padding: \"1px\"}}>\r\n                <button onClick={this.handleNewColumn}\r\n                    style={{width: \"100%\", height: \"100%\"}}><strong>+</strong></button>\r\n            </td>);\r\n        return (\r\n            <><td className=\"row-number-td\"/>{rowData}</>\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates content of the second row of the table with column types.\r\n     * If the table is editable, \"add column\" button is added in the last column with row span to the end of the table.\r\n     */\r\n    private createTypesRow() {\r\n        const rowData = this.props.relation.getColumnTypes().map((columnType, columnIndex) => {\r\n            const content = (\r\n                <select value={columnType}\r\n                    onChange={(e) => this.handleChange(e.target.value, columnIndex, \"types\")}>\r\n                    <option>number</option>\r\n                    <option>string</option>\r\n                    <option>boolean</option>\r\n                </select>\r\n            );\r\n            return (\r\n                <th key={columnIndex}\r\n                    className=\"type-th\"\r\n                >{content}{this.createDeleteButton(() => this.handleDeleteColumn(columnIndex))}</th>\r\n            )});\r\n        return (\r\n            <><td className=\"row-number-td\"/>{rowData}</>\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a data rows of the table.\r\n     */\r\n    private createRows() {\r\n        // creates default row if no exists\r\n        if (this.props.relation.getRows().length === 0) {\r\n            return null;\r\n        }\r\n        const rows: string[][] = this.props.relation.getRows();\r\n        // creates all rows if any\r\n        return rows.map((row, rowIndex) => (\r\n            <tr key={rowIndex}>\r\n                <td className=\"row-number-td\">\r\n                    {rowIndex + 1}\r\n                    {this.createDeleteButton(() => this.handleDeleteRow(rowIndex))}\r\n                </td>\r\n                {row.map((value, columnIndex) => {\r\n                    let content: string | JSX.Element = value;\r\n                    if (this.state.selectedColumn === columnIndex && this.state.selectedRow === rowIndex) {\r\n                        content = this.createInput(value, columnIndex, rowIndex);\r\n                    }\r\n                    let span: null | JSX.Element = null;\r\n                    let className: string = \"\";\r\n                    const error = this.getErrors().get(rowIndex, columnIndex);\r\n                    if (error !== undefined) {\r\n                        span = this.createTooltip(error);\r\n                        className = \"error-input\";\r\n                    }\r\n                    return (\r\n                        <td key={columnIndex}\r\n                            className={className}\r\n                            onClick={ev => {\r\n                                this.setSelectedInput(columnIndex, rowIndex);\r\n                                ev.stopPropagation();\r\n                            }}\r\n                        >{content}{span}</td>\r\n                    )})}\r\n            </tr>\r\n        ));\r\n    }\r\n\r\n    /**\r\n     * Creates the last row of the table with button for adding rows.\r\n     */\r\n    private createAddRow() {\r\n        return (\r\n            <tr key='add-row'>\r\n                <td key='add-row-column'\r\n                    className=\"add-row-td\">\r\n                    <button onClick={this.handleNewRow}><strong>+</strong></button>\r\n                </td>\r\n            </tr>\r\n        );\r\n    }\r\n\r\n    public render() {\r\n        let divClassName: string = \"edit-table-container scrollbar-container\";\r\n        let tableClassName: string = \"edit-table\";\r\n\r\n        return (\r\n            <div\r\n                className={divClassName}\r\n                ref={this.containerRef}\r\n                onKeyDown={this.handleKeyDown}>\r\n                <table className={tableClassName}>\r\n                    <thead>\r\n                        <tr ref={this.tableHeadRowRef}>{this.createNamesRow()}</tr>\r\n                        <tr>{this.createTypesRow()}</tr>\r\n                    </thead>\r\n                    <tbody>\r\n                        {this.createRows()}\r\n                        {this.createAddRow()}\r\n                    </tbody>\r\n                </table>\r\n            </div>\r\n        );\r\n    }\r\n}","import React from \"react\";\r\nimport Relation from \"../relation/relation\";\r\nimport {TooltipButton} from \"./tooltipButton\";\r\nimport {SupportedColumnType} from \"../relation/columnType\";\r\nimport EditRelationTable from \"./editRelationTable\";\r\nimport {StoredRelation} from \"../relation/storedRelation\";\r\nimport {TextInput} from \"./textInput\";\r\nimport {isForbiddenRelationName} from \"../utils/keywords\";\r\nimport StringUtils from \"../utils/stringUtils\";\r\nimport {MessageBox} from \"./messageBox\";\r\nimport {LanguageDef} from \"../language/language\";\r\n\r\ninterface RelationsSectionProps {\r\n    // all stored relations\r\n    storedRelations: StoredRelation[],\r\n    // index of the current selected relation\r\n    storedRelationIndex: number,\r\n\r\n    // all currently loaded relations in the application\r\n    loadedRelations: Relation[],\r\n\r\n    // handler of change of the name of the current selected relation\r\n    onRelationNameChange: (newName: string) => void,\r\n    // handler of change of the name of the column at given index in the current selected relation\r\n    onColumnNameChange: (columnName: string, columnIndex: number) => void,\r\n    // handler of change of the type of the column at given index in the current selected relation\r\n    onColumnTypeChange: (columnType: SupportedColumnType, columnIndex: number) => void,\r\n    // handler of change of the row input at given column/row index in the current selected relation\r\n    onRowInputChange: (input: string, columnIndex: number, rowIndex: number) => void,\r\n    // handler of adding a new row in the current selected relation\r\n    onNewRow: (onDone: () => void) => void,\r\n    // handler of adding a new column in the current selected relation\r\n    onNewColumn: (onDone: () => void) => void,\r\n    // handler of deleting the row on given index\r\n    onDeleteRow: (rowIndex: number) => void,\r\n    // handler of deleting the column on given index\r\n    onDeleteColumn: (columnIndex: number) => void,\r\n\r\n    // handler of selecting a different relation as current\r\n    onSelectDifferentRelation: (newIndex: number) => void,\r\n    // handler of moving a relation on a new position using drag and drop\r\n    onDragRelation: (from: number, to: number) => void,\r\n    // handler of creating a new relation\r\n    onNewRelation: () => void,\r\n    // handler of loading the current selected relation into the application\r\n    onLoadRelation: (onDone: (msg: string) => void) => void,\r\n    // handler of deleting the current stored relation\r\n    onDeleteStoredRelation: () => void,\r\n\r\n    onRevertRelation: () => void,\r\n\r\n    // handler of loading all valid relations into the application\r\n    onLoadAllRelations: (onDone: (msg: string) => void) => void,\r\n    // handler of deleting the loaded relations\r\n    onRemoveLoadedRelations: (onDone: (msg: string) => void) => void,\r\n    // handler of saving the stored relations into the files\r\n    onExportRelations: (onDone: (msg: string) => void) => void,\r\n    // handler of loading new relations from files\r\n    onImportRelations: (onDone: (msg: string) => void) => void,\r\n\r\n    // whether to support null values\r\n    nullValuesSupport: boolean,\r\n    // current application language\r\n    language: LanguageDef\r\n}\r\n\r\ninterface RelationsSectionState {\r\n    sectionClicked: boolean\r\n}\r\n\r\n/**\r\n * Section to type the RA expression. It contains textarea for relations definition and control buttons.\r\n */\r\nexport class RelationsSection extends React.Component<RelationsSectionProps, RelationsSectionState> {\r\n\r\n    constructor(props: RelationsSectionProps) {\r\n        super(props);\r\n        this.state = {\r\n            sectionClicked: false\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns selected stored relation.\r\n     */\r\n    private getCurRel = (): StoredRelation => {\r\n        return this.props.storedRelations[this.props.storedRelationIndex];\r\n    }\r\n\r\n    /**\r\n     * Passes change to the parent element if isShowingStored = true. Otherwise, changes the state.loadedRelationIndex.\r\n     */\r\n    private handleSelectDifferentRelation(index: number): void {\r\n        this.props.onSelectDifferentRelation(index);\r\n    }\r\n\r\n    /**\r\n     * Passes change of the relation name to the parent element.\r\n     */\r\n    private handleRelationNameChange = (name: string) => {\r\n        this.props.onRelationNameChange(name);\r\n    }\r\n\r\n    /**\r\n     * Loads the selected relation to the application if there are no errors in it. Otherwise, displays a message to user.\r\n     */\r\n    private loadRelation = () => {\r\n        if (this.getCurRel().isValid()) {\r\n            this.props.onLoadRelation(MessageBox.message);\r\n        }\r\n        else {\r\n            MessageBox.error(\"Cannot use the invalid relation. Check errors and try again.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Passes the load all relations call to the parent.\r\n     */\r\n    private loadAllRelations = () => {\r\n        this.props.onLoadAllRelations(MessageBox.message);\r\n    }\r\n\r\n    /**\r\n     * Passes the export stored relations call to the parent.\r\n     */\r\n    private exportRelations = () => {\r\n        this.props.onExportRelations(MessageBox.message);\r\n    }\r\n\r\n    /**\r\n     * Passes the import stored relations call to the parent.\r\n     */\r\n    private importRelations = () => {\r\n        this.props.onImportRelations(MessageBox.message);\r\n    }\r\n\r\n    /**\r\n     * Passes the call to delete current selected stored relation.\r\n     */\r\n    private deleteRelation = () => {\r\n        this.props.onDeleteStoredRelation();\r\n    }\r\n\r\n    private revertRelation = () => {\r\n        this.props.onRevertRelation();\r\n    }\r\n\r\n    /**\r\n     * Passes the create new stored relation call to the parent.\r\n     */\r\n    private newRelation = () => {\r\n        this.props.onNewRelation();\r\n    }\r\n\r\n    /**\r\n     * Passes the remove loaded relations call to the parent.\r\n     */\r\n    private removeLoadedRelations = () => {\r\n        this.props.onRemoveLoadedRelations(MessageBox.message);\r\n    }\r\n\r\n    /**\r\n     * Handles input with Ctrl key pressed from relation table.\r\n     */\r\n    private handleCtrlInput = (event: React.KeyboardEvent) => {\r\n        if (event.key === \"Enter\") {\r\n            this.loadRelation();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates menu buttons. Buttons for relations with errors are highlighted.\r\n     */\r\n    private createRelationMenuButtons = () => {\r\n        return this.props.storedRelations.map((rel, i) => {\r\n            const className: string = (this.props.storedRelationIndex === i ? \"button-clicked\" : \"\");\r\n            const actuality: string = rel.isActual() ? \"\" : \"*\";\r\n            const style = rel.isValid() ? {} : {border: \"2px solid #fd3030\"};\r\n            return (\r\n                <button\r\n                    key={i}\r\n                    onClick={() => this.handleSelectDifferentRelation(i)}\r\n                    className={className}\r\n                    style={style}\r\n                    draggable={true}\r\n                    onDragStart={e => e.dataTransfer.setData(\"text/plain\", String(i))}\r\n                    onDragOver={e => e.preventDefault()}\r\n                    onDrop={e => this.handleDragDrop(e, i)}\r\n                >{actuality + rel.getName()}</button>\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Requests relation move when the drag ends.\r\n     */\r\n    // @ts-ignore\r\n    private handleDragDrop = (e: DragEvent<HTMLDivElement>, i: number) => {\r\n        const from = Number(e.dataTransfer.getData(\"text/plain\"));\r\n        if (!isNaN(from)) {\r\n            this.props.onDragRelation(from, i);\r\n        }\r\n    }\r\n\r\n    public render() {\r\n        const lang = this.props.language.relationSection;\r\n\r\n        const createButton = (text: string, onClick: () => void, tooltip: string, style?: React.CSSProperties) => {\r\n            return (<TooltipButton\r\n                key={text}\r\n                text={text}\r\n                onClick={onClick}\r\n                style={style}\r\n                tooltip={tooltip}\r\n            />);\r\n        }\r\n\r\n        // the relation cannot be renamed to forbidden relation names and other currently used relation names\r\n        const forbiddenRelationNames: string[] = this.props.storedRelations\r\n            .filter((sr, i) => i !== this.props.storedRelationIndex)\r\n            .map(sr => sr.getName());\r\n        const forbiddenNamesFunction = (text: string): boolean => {\r\n            if (forbiddenRelationNames.indexOf(text) > -1) {\r\n                return true;\r\n            }\r\n            return !StringUtils.isName(text) || isForbiddenRelationName(text);\r\n        }\r\n\r\n        return (\r\n            <section className=\"page-section\">\r\n                <header>\r\n                    <h2>{lang.relationSectionHeader}</h2>\r\n                    {createButton(lang.loadAllButton, this.loadAllRelations, lang.loadAllButtonTooltip)}\r\n                    {createButton(lang.removeLoadedButton, this.removeLoadedRelations, lang.removeLoadedButtonTooltip)}\r\n                    {createButton(lang.importButton, this.importRelations, lang.importButtonTooltip)}\r\n                    {createButton(lang.exportButton, this.exportRelations, lang.exportButtonTooltip)}\r\n                </header>\r\n\r\n                <menu className=\"page-section-tab-menu\">\r\n                    {this.createRelationMenuButtons()}\r\n                    <button onClick={this.newRelation}\r\n                        style={{minWidth: \"0\", marginLeft: \"10px\", padding: \"2px 6px 1px 6px\"}}>\r\n                        <strong>+</strong>\r\n                    </button>\r\n                </menu>\r\n\r\n                <EditRelationTable\r\n                    relation={this.getCurRel()}\r\n\r\n                    onColumnNameChange={this.props.onColumnNameChange}\r\n                    onColumnTypeChange={this.props.onColumnTypeChange}\r\n                    onRowInputChange={this.props.onRowInputChange}\r\n                    onNewRow={this.props.onNewRow}\r\n                    onNewColumn={this.props.onNewColumn}\r\n                    onDeleteRow={this.props.onDeleteRow}\r\n                    onDeleteColumn={this.props.onDeleteColumn}\r\n\r\n                    onCtrlInput={this.handleCtrlInput}\r\n                />\r\n\r\n                <menu className=\"page-section-management-menu\">\r\n                    <TooltipButton\r\n                        text={lang.loadButton}\r\n                        onClick={this.loadRelation}\r\n                        className={\"action-button\"}\r\n                        style={{marginRight: \"40px\"}}\r\n                        tooltip={lang.loadButtonTooltip}\r\n                    />\r\n                    <TextInput\r\n                        value={this.getCurRel().getName()}\r\n                        buttonText={lang.renameButton}\r\n                        onSubmit={this.handleRelationNameChange}\r\n                        forbidden={forbiddenNamesFunction}\r\n                        id=\"relation-name-input\"\r\n                    />\r\n                    {createButton(lang.deleteButton, this.deleteRelation, lang.deleteButtonTooltip)}\r\n                    {createButton(lang.revertButton, this.revertRelation,\r\n                        lang.revertButtonTooltip + \" (\" + this.getCurRel().getRevertName() + \")\")}\r\n                </menu>\r\n            </section>\r\n        );\r\n    }\r\n}","interface SendData {\r\n    access_token: string,\r\n    subject: string,\r\n    text: string\r\n}\r\n\r\n/**\r\n * Class for sending emails. Powered by https://postmail.invotes.com/.\r\n * TypeScript version of JavaScript Copy & Paste Example from PostMail webpage.\r\n */\r\nexport class Mail {\r\n\r\n    /**\r\n     * Creates a mailer with given Mail access token.\r\n     *\r\n     * @param accessToken token which specifies Mail receiver of mails\r\n     */\r\n    constructor(readonly accessToken: string) {}\r\n\r\n    /**\r\n     * Sends given subject and body of the email to the Mail receiver.\r\n     *\r\n     * @param subject subject of the mail\r\n     * @param body body of the mail\r\n     */\r\n    public send(subject: string, body: string): void {\r\n        const data_js: SendData = {\r\n            access_token: this.accessToken,\r\n            subject: subject,\r\n            text: body\r\n        };\r\n\r\n        const request = new XMLHttpRequest();\r\n        request.onreadystatechange = function() {\r\n            if (request.readyState === 4 && request.status === 200) {\r\n            } else if(request.readyState === 4) {\r\n                console.log(\"failed creating XMLHttpRequest in Mail.send: \" + request.response);\r\n            }\r\n        };\r\n\r\n        let params = Mail.toParams(data_js);\r\n        request.open(\"POST\", \"https://postmail.invotes.com/send\", true);\r\n        request.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\r\n        request.send(params);\r\n    }\r\n\r\n    private static toParams(data: SendData): string {\r\n        return encodeURIComponent(\"access_token\") + \"=\" + encodeURIComponent(data.access_token) + \"&\" +\r\n            encodeURIComponent(\"subject\") + \"=\" + encodeURIComponent(data.subject) + \"&\" +\r\n                encodeURIComponent(\"text\") + \"=\" + encodeURIComponent(data.text);\r\n    }\r\n}","import React, {Component} from 'react';\r\nimport Relation from '../relation/relation';\r\nimport RATreeNode from \"../ratree/raTreeNode\";\r\nimport {ExpressionSection} from \"./expressionSection\";\r\nimport {ResultSection} from \"./resultSection\";\r\nimport {ExpressionStoreManager} from \"../expression/expressionStoreManager\";\r\nimport {ManagementSection} from \"./managementSection\";\r\nimport {CsvValueSeparator} from \"../types/csvSupport\";\r\nimport {ProjectStoreManager} from \"../project/projectStoreManager\";\r\nimport {language, LanguageDef, SupportedLanguage} from \"../language/language\";\r\nimport {LocalStorage} from \"../utils/localStorage\";\r\nimport {BatchProcessor} from \"../batch/batchProcessor\";\r\nimport {Expression} from \"../expression/expression\";\r\nimport {RelationsSection} from \"./relationsSection\";\r\nimport {StoredRelation} from \"../relation/storedRelation\";\r\nimport {SupportedColumnType} from \"../relation/columnType\";\r\nimport {RelationStoreManager} from \"../relation/relationStoreManager\";\r\nimport {Mail} from \"../utils/mail\";\r\nimport {copyProject, Project} from \"../project/project\";\r\nimport {getSamples} from \"../project/samples\";\r\n\r\ninterface MainScreenProps {}\r\n\r\ninterface MainScreenState {\r\n    samples: { name: string, project: Project }[],\r\n\r\n    loadedRelations: Map<string, Relation>,\r\n    storedRelations: StoredRelation[],\r\n    selectedRelation: number,\r\n\r\n    expressions: Expression[],\r\n    selectedExpression: number,\r\n\r\n    evaluationTreeRoot: RATreeNode | null,\r\n    evaluatedExpressionName: string,\r\n\r\n    nullValuesSupport: boolean,\r\n    csvValueSeparator: CsvValueSeparator,\r\n    language: LanguageDef,\r\n    darkTheme: boolean\r\n}\r\n\r\n/**\r\n * Main component of Rachel web page. It wraps all page sections and passes messages between them.\r\n */\r\nexport default class MainScreen extends Component<MainScreenProps, MainScreenState> {\r\n\r\n    private readonly expressionSectionRef: React.RefObject<ExpressionSection>;\r\n\r\n    constructor(props: MainScreenProps) {\r\n        super(props);\r\n\r\n        // sets body template by settings from local storage\r\n        document.body.classList.toggle('body-dark', LocalStorage.getDarkMode());\r\n        document.body.classList.toggle('body-light', !LocalStorage.getDarkMode());\r\n\r\n        const initRelationData = {\r\n            name: \"Relation\",\r\n            columnNames: [\"Column1\", \"Column2\", \"Column3\"],\r\n            columnTypes: [\"number\", \"string\", \"boolean\"],\r\n            rows: [\r\n                ['', '', '']\r\n            ],\r\n            columnCount: 3,\r\n            rowCount: 1\r\n        };\r\n\r\n        this.state = {\r\n            samples: getSamples(),\r\n\r\n            loadedRelations: new Map<string, Relation>(),\r\n            storedRelations: [ StoredRelation.fromData(initRelationData, true) ],\r\n            selectedRelation: 0,\r\n\r\n            expressions: [ {name: \"Expression 1\", text: \"\"} ],\r\n            selectedExpression: 0,\r\n\r\n            evaluationTreeRoot: null,\r\n            evaluatedExpressionName: \"\",\r\n\r\n            nullValuesSupport: true,\r\n            csvValueSeparator: LocalStorage.getCsvValueSeparator(),\r\n            language: language(),\r\n            darkTheme: LocalStorage.getDarkMode()\r\n        }\r\n        this.expressionSectionRef = React.createRef();\r\n    }\r\n\r\n    /**\r\n     * Reports an error to the author of the application via email.\r\n     *\r\n     * @param err unexpected error\r\n     */\r\n    private reportUnexpectedError = (err: Error): void => {\r\n        const postMail: Mail = new Mail(\"5uog26ex8q9qu7sqib8ea0qd\");\r\n        let body: string = \"Unexpected error \" + err.name + \" in Rachel application.\" +\r\n            \"\\n\\nMessage:\\n\" + err.message +\r\n            \"\\n\\nDate:\\n\" + new Date().toString() +\r\n            \"\\n\\nStack trace:\\n\" + err.stack +\r\n\r\n            \"\\n\\nLoaded relations: ----------------------------\\n\" +\r\n            [...this.state.loadedRelations.values()].map(relation => {\r\n                return relation.getName() + \"\\n\" + relation.contentString();\r\n            }).join(\"\\n\\n\") +\r\n\r\n            \"\\n\\nStored relations: ----------------------------\" +\r\n            \"\\nSelected relation (1-index): \" + (this.state.selectedRelation + 1) + \"\\n\\n\" +\r\n            this.state.storedRelations.map(rel => StoredRelation.format(rel)).join(\"\\n\\n\") +\r\n\r\n            \"\\n\\nExpressions: ----------------------------\" +\r\n            \"\\nSelected expression (1-index): \" + (this.state.selectedExpression + 1) + \"\\n\\n\" +\r\n            this.state.expressions.map(expr => expr.text).join(\"\\n\\n###\\n\\n\") +\r\n\r\n            \"\\n\\nEvaluation tree:\\n\" + this.state.evaluationTreeRoot?.printInLine() +\r\n\r\n            \"\\n\\nOther state: ----------------------------\" +\r\n            \"\\ncsvValueSeparator: \" + this.state.csvValueSeparator +\r\n            \"\\nlanguage:          \" + this.state.language +\r\n            \"\\nnullValuesSupport: \" + this.state.nullValuesSupport +\r\n            \"\\ndarkTheme:         \" + this.state.darkTheme;\r\n\r\n        postMail.send(\"Rachel application unexpected error\", body);\r\n        console.error('Unexpected error: ' + err.stack);\r\n    }\r\n\r\n    /**\r\n     * Overwrites the current project data with the given one.\r\n     *\r\n     * @param project\r\n     */\r\n    private loadProject = (project: Project): void => {\r\n        this.setState({\r\n            loadedRelations: new Map<string, Relation>(),\r\n            storedRelations: project.relations.map(r => StoredRelation.fromData(r, project.nullValuesSupport)),\r\n            selectedRelation: 0,\r\n            expressions: project.expressions,\r\n            nullValuesSupport: project.nullValuesSupport,\r\n            selectedExpression: 0,\r\n            evaluationTreeRoot: null,\r\n            evaluatedExpressionName: \"\"\r\n        }, () => {\r\n            console.log(\"Project loaded.\");\r\n            this.updateExpressionsErrors();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds number after the given name if it already exists in stored relation.\r\n     */\r\n    private ensureUniqueRelationName = (name: string): string => {\r\n        if (this.state.storedRelations.map(sr => sr.getName()).indexOf(name) > -1) {\r\n            for (let i = 2; true; ++i) {\r\n                if (this.state.storedRelations.map(sr => sr.getName()).indexOf(name + i) === -1) {\r\n                    name += i;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return name;\r\n    }\r\n\r\n    /****************************************** MANAGEMENT SECTION HANDLERS ******************************************/\r\n\r\n    /**\r\n     * Processes multiple selected files with expressions by the user and saves the reports of the evaluation in textual\r\n     * files.\r\n     */\r\n    private handleBatch = () => {\r\n        BatchProcessor.process('rachel-eval-results');\r\n    }\r\n\r\n    /**\r\n     * Opens a file dialog and lets the user choose a .rachel (JSON) file with project to load.\r\n     */\r\n    private handleLoadProject = (): void => {\r\n        ProjectStoreManager.load().then(this.loadProject).catch(console.warn);\r\n    }\r\n\r\n    /**\r\n     * Saves the project relation to the .rachel (JSON) file.\r\n     */\r\n    private handleSaveProject = (): void => {\r\n        try {\r\n            ProjectStoreManager.save({\r\n                relations: this.state.storedRelations.map(sr => sr.toDataObject()),\r\n                expressions: this.state.expressions,\r\n                nullValuesSupport: this.state.nullValuesSupport\r\n                }, \"project\");\r\n            console.log(\"Project saved.\");\r\n        }\r\n        catch (err) {\r\n            console.warn(\"Project saving failed: \" + err.message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles loading a sample project.\r\n     */\r\n    private handleLoadSampleProject = (sample: Project): void => {\r\n        this.loadProject(copyProject(sample));\r\n    }\r\n\r\n    /**\r\n     * Changes the support of the null values in relations.\r\n     *\r\n     * @param nullValuesSupport new support of the null values in relations\r\n     */\r\n    private handleNullValuesSupportChange = (nullValuesSupport: boolean): void => {\r\n        this.state.storedRelations.forEach(sr => sr.setNullValuesSupport(nullValuesSupport));\r\n        // null values change can change validity of the relations, therefore set as not actual\r\n        this.setState({nullValuesSupport: nullValuesSupport}, this.updateExpressionsErrors);\r\n    }\r\n\r\n    /**\r\n     * Changes the value separator used in generated CSV files.\r\n     *\r\n     * @param csvValueSeparator new value separator used in generated CSV files\r\n     */\r\n    private handleCsvValueSeparatorChange = (csvValueSeparator: CsvValueSeparator): void => {\r\n        LocalStorage.setCsvValueSeparator(csvValueSeparator);\r\n        this.setState({csvValueSeparator: csvValueSeparator});\r\n    }\r\n\r\n    /**\r\n     * Changes the language of the application.\r\n     *\r\n     * @param lang new language of the application\r\n     */\r\n    private handleLanguageChange = (lang: SupportedLanguage): void => {\r\n        LocalStorage.setLanguage(lang);\r\n        // updates language of errors in stored relations\r\n        this.state.storedRelations.forEach(r => r.recomputeErrors());\r\n        this.setState({language: language()});\r\n    }\r\n\r\n    /**\r\n     * Changes the dark/light mode of the application.\r\n     *\r\n     * @param darkTheme true if dark theme is on\r\n     */\r\n    private handleDarkModeChange = (darkTheme: boolean) => {\r\n        LocalStorage.setDarkMode(darkTheme);\r\n        this.setState({darkTheme: darkTheme});\r\n        document.body.classList.toggle( 'body-dark', darkTheme);\r\n        document.body.classList.toggle( 'body-light', !darkTheme);\r\n    }\r\n\r\n    /******************************************* RELATION SECTION HANDLERS *******************************************/\r\n\r\n    private handleRelationNameChange = (name: string): void => {\r\n        this.setState(state => {\r\n            const storedRelations = state.storedRelations;\r\n            storedRelations[this.state.selectedRelation].setName(name);\r\n            return {storedRelations: storedRelations};\r\n        });\r\n    }\r\n\r\n    private handleRelationColumnNameChange = (columnName: string, columnIndex: number): void => {\r\n        this.setState(state => {\r\n            const storedRelations = state.storedRelations;\r\n            storedRelations[this.state.selectedRelation].setColumnName(columnName, columnIndex);\r\n            return {storedRelations: storedRelations};\r\n        });\r\n    }\r\n\r\n    private handleRelationColumnTypeChange = (columnType: SupportedColumnType, columnIndex: number): void => {\r\n        this.setState(state => {\r\n            const storedRelations = state.storedRelations;\r\n            storedRelations[this.state.selectedRelation].setColumnType(columnType, columnIndex);\r\n            return {storedRelations: storedRelations};\r\n        });\r\n    }\r\n\r\n    private handleRelationRowInputChange = (input: string, columnIndex: number, rowIndex: number): void => {\r\n        this.setState(state => {\r\n            const storedRelations = state.storedRelations;\r\n            storedRelations[this.state.selectedRelation].setRowInput(input, rowIndex, columnIndex);\r\n            return {storedRelations: storedRelations};\r\n        });\r\n    }\r\n\r\n    private handleRelationNewRow = (onDone: () => void): void => {\r\n        this.state.storedRelations[this.state.selectedRelation].addNewRow();\r\n        // forces update\r\n        this.setState({}, onDone);\r\n    }\r\n\r\n    private handleRelationNewColumn = (onDone: () => void): void => {\r\n        this.state.storedRelations[this.state.selectedRelation].addNewColumn();\r\n        // forces update\r\n        this.setState({}, onDone);\r\n    }\r\n\r\n    private handleRelationDeleteRow = (rowIndex: number): void => {\r\n        this.state.storedRelations[this.state.selectedRelation].deleteRow(rowIndex);\r\n        // forces update\r\n        this.setState({});\r\n    }\r\n\r\n    private handleRelationDeleteColumn = (columnIndex: number): void => {\r\n        this.state.storedRelations[this.state.selectedRelation].deleteColumn(columnIndex);\r\n        // forces update\r\n        this.setState({});\r\n    }\r\n\r\n    /**\r\n     * Selects a new relation from the relations list as the current one.\r\n     */\r\n    private handleSelectDifferentRelation = (newIndex: number): void => {\r\n        this.setState({selectedRelation: newIndex});\r\n    }\r\n\r\n    /**\r\n     * Moves a relation from the given \"from\" index to the given \"to\" index.\r\n     */\r\n    private handleDragRelation = (from: number, to: number): void => {\r\n        // dragging left\r\n        if (from > to) {\r\n            const before = this.state.storedRelations.slice(0, to);\r\n            const moved = this.state.storedRelations.slice(to, from);\r\n            const fromValue = this.state.storedRelations[from];\r\n            const after = this.state.storedRelations.slice(from + 1);\r\n            const newArray = [...before, fromValue, ...moved, ...after];\r\n            this.setState({storedRelations: newArray, selectedRelation: to});\r\n        }\r\n        // dragging right\r\n        else if (from < to) {\r\n            const before = this.state.storedRelations.slice(0, from);\r\n            const fromValue = this.state.storedRelations[from];\r\n            const moved = this.state.storedRelations.slice(from + 1, to + 1);\r\n            const after = this.state.storedRelations.slice(to + 1);\r\n            const newArray = [...before, ...moved, fromValue, ...after];\r\n            this.setState({storedRelations: newArray, selectedRelation: to});\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new empty relation and adds it in the relation list.\r\n     */\r\n    private handleCreateNewRelation = (): void => {\r\n        // inserts a new empty relation in the array\r\n        const newIndex: number = this.state.selectedRelation + 1;\r\n        let name: string = this.ensureUniqueRelationName(\"NewRelation\");\r\n        this.state.storedRelations.splice(newIndex, 0, StoredRelation.new(name, this.state.nullValuesSupport));\r\n        this.setState({selectedRelation: newIndex});\r\n    }\r\n\r\n    /**\r\n     * Deletes the current relation from the relations list (or clears it if it is the last relation in the list).\r\n     */\r\n    private handleDeleteRelation = (): void => {\r\n        // if there is the last relation, only clears it\r\n        if (this.state.storedRelations.length === 1) {\r\n            this.setState({storedRelations: [StoredRelation.new(\"Relation\", this.state.nullValuesSupport)]});\r\n            return;\r\n        }\r\n        const selected: number = this.state.selectedRelation;\r\n        this.state.storedRelations.splice(selected, 1);\r\n        if (selected === this.state.storedRelations.length) {\r\n            this.setState({selectedRelation: selected - 1}, this.updateExpressionsErrors);\r\n        }\r\n        else {\r\n            // forces update\r\n            this.setState({}, this.updateExpressionsErrors);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reverts the current selected stored relation to its last loaded state.\r\n     */\r\n    private handleRevertRelation = (): void => {\r\n        this.setState(state => {\r\n            const storedRelations = state.storedRelations;\r\n            storedRelations[this.state.selectedRelation].revert();\r\n            return {storedRelations};\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Removes all relations loaded in the application.\r\n     */\r\n    private handleRemoveLoadedRelations = (onDone: (msg: string) => void): void => {\r\n        const lang = this.state.language.userMessages;\r\n        const previous = this.state.loadedRelations.size;\r\n        this.state.loadedRelations.clear();\r\n        this.state.storedRelations.forEach(sr => sr.setActual(false));\r\n        onDone(previous + lang.deleteLoadedRelations);\r\n        // forces update\r\n        this.setState({}, this.updateExpressionsErrors);\r\n    }\r\n\r\n    /**\r\n     * Saves the relations list in a textual file.\r\n     *\r\n     * @param onDone\r\n     */\r\n    private handleExportRelations = (onDone: (msg: string) => void): void => {\r\n        const lang = this.state.language.userMessages;\r\n        try {\r\n            RelationStoreManager.save(this.state.storedRelations, \"relations\", this.state.csvValueSeparator);\r\n            onDone(this.state.storedRelations.length + lang.relationsExportOK);\r\n        }\r\n        catch (err) {\r\n            onDone(lang.relationsExportErr + err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads the relations list from the textual file selected by the user.\r\n     *\r\n     * @param onDone\r\n     */\r\n    private handleImportRelations = (onDone: (msg: string) => void): void => {\r\n        const lang = this.state.language.userMessages;\r\n        RelationStoreManager.load(this.state.nullValuesSupport).then(info => {\r\n            const countBefore: number = this.state.storedRelations.length;\r\n            // loads relations to application\r\n            info.relations.forEach(relation => {\r\n                const name = this.ensureUniqueRelationName(relation.getName());\r\n                relation.setName(name);\r\n                this.state.storedRelations.push(relation);\r\n            });\r\n            if (info.relations.length > 0) {\r\n                // shows first loaded relation\r\n                this.setState({selectedRelation: countBefore});\r\n            }\r\n            onDone(info.relations.length + lang.relationsImport[0] + info.skipped + lang.relationsImport[1])\r\n        });\r\n    }\r\n\r\n    private handleLoadRelation = (onDone: (msg: string) => void): void => {\r\n        const lang = this.state.language.userMessages;\r\n        const currRelation: StoredRelation = this.state.storedRelations[this.state.selectedRelation];\r\n        currRelation.setActual(true);\r\n        this.state.loadedRelations.set(currRelation.getName(), currRelation.createRelation());\r\n        const msgPart2: string = this.state.loadedRelations.size === 0 ? lang.loadedRelationsTotalNo :\r\n            this.state.loadedRelations.size + lang.loadedRelationsTotalSome + [...this.state.loadedRelations.keys()].join(', ') + \".\";\r\n        onDone(lang.loadRelationNew + \"\\n\" + msgPart2);\r\n        // forces update\r\n        this.setState({}, this.updateExpressionsErrors);\r\n    }\r\n\r\n    private handleLoadAllRelations = (onDone: (msg: string) => void): void => {\r\n        const lang = this.state.language.userMessages;\r\n        let loaded: number = 0;\r\n        let skipped: number = 0;\r\n        this.state.storedRelations.forEach(sr => {\r\n            if (sr.isValid()) {\r\n                sr.setActual(true);\r\n                this.state.loadedRelations.set(sr.getName(), sr.createRelation());\r\n                ++loaded;\r\n            }\r\n            else {\r\n                ++skipped;\r\n            }\r\n        });\r\n        const msgPart2: string = this.state.loadedRelations.size === 0 ? lang.loadedRelationsTotalNo :\r\n            this.state.loadedRelations.size + lang.loadedRelationsTotalSome + [...this.state.loadedRelations.keys()].join(', ') + \".\";\r\n        onDone(loaded + lang.loadAllRelationsNew[0] + skipped + lang.loadAllRelationsNew[1] + \"\\n\" + msgPart2);\r\n        // forces update\r\n        this.setState({}, this.updateExpressionsErrors);\r\n    }\r\n\r\n    /****************************************** EXPRESSION SECTION HANDLERS ******************************************/\r\n\r\n    private updateExpressionsErrors = (): void => {\r\n        const expressionSection = this.expressionSectionRef.current;\r\n        if (expressionSection !== null) {\r\n            expressionSection.updateErrorsAndParentheses();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Saves evaluation tree for the evaluated RA expression.\r\n     */\r\n    private handleExprEval = (tree: RATreeNode): void => {\r\n        this.setState({\r\n            evaluationTreeRoot: tree,\r\n            evaluatedExpressionName: this.state.expressions[this.state.selectedExpression].name\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates the text of the current expression and sets it as not actual.\r\n     */\r\n    private handleExprTextChange = (name: string, text: string): void => {\r\n        this.setState(state => {\r\n            let expressions: Expression[] = state.expressions;\r\n            expressions[state.selectedExpression] = {name: name, text: text};\r\n            return { expressions: expressions }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Selects a new expression from the expression list as the current one.\r\n     */\r\n    private handleSelectDifferentExpression = (newIndex: number): void => {\r\n        this.setState({ selectedExpression: newIndex }, this.updateExpressionsErrors);\r\n    }\r\n\r\n    /**\r\n     * Moves a expression from the given \"from\" index to the given \"to\" index.\r\n     */\r\n    private handleDragExpression = (from: number, to: number): void => {\r\n        // dragging left\r\n        if (from > to) {\r\n            const before = this.state.expressions.slice(0, to);\r\n            const moved = this.state.expressions.slice(to, from);\r\n            const fromValue = this.state.expressions[from];\r\n            const after = this.state.expressions.slice(from + 1);\r\n            const newArray = [...before, fromValue, ...moved, ...after];\r\n            this.setState({expressions: newArray, selectedExpression: to});\r\n        }\r\n        // dragging right\r\n        else if (from < to) {\r\n            const before = this.state.expressions.slice(0, from);\r\n            const fromValue = this.state.expressions[from];\r\n            const moved = this.state.expressions.slice(from + 1, to + 1);\r\n            const after = this.state.expressions.slice(to + 1);\r\n            const newArray = [...before, ...moved, fromValue, ...after];\r\n            this.setState({expressions: newArray, selectedExpression: to});\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new empty expression and adds it in the expression list.\r\n     */\r\n    private handleCreateNewExpression = (): void => {\r\n        // inserts a new empty expression in the array\r\n        const newIndex: number = this.state.selectedExpression + 1;\r\n        this.state.expressions.splice(newIndex, 0, {name: \"New expression\", text: \"\"});\r\n        this.setState({selectedExpression: newIndex});\r\n    }\r\n\r\n    /**\r\n     * Deletes the current expression from the expression list (or clears it if it is the last expression in the list).\r\n     */\r\n    private handleDeleteExpression = (onDone: () => void): void => {\r\n        // if there is the last expression, only clears it\r\n        if (this.state.expressions.length === 1) {\r\n            return this.handleExprTextChange(\"Expression 1\", \"\");\r\n        }\r\n        const selected: number = this.state.selectedExpression;\r\n        this.state.expressions.splice(selected, 1);\r\n        if (selected === this.state.expressions.length) {\r\n            this.setState({selectedExpression: selected - 1}, onDone);\r\n        }\r\n        else {\r\n            // forces update\r\n            this.setState({}, onDone);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Saves the expression list in a textual file.\r\n     *\r\n     * @param onDone\r\n     */\r\n    private handleExportExpressions = (onDone: (msg: string) => void): void => {\r\n        const lang = this.state.language.userMessages;\r\n        try {\r\n            ExpressionStoreManager.save(this.state.expressions, 'expressions');\r\n            onDone(lang.expressionsExportOK);\r\n        }\r\n        catch (err) {\r\n            onDone(lang.expressionsExportErr + err.message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads the expression list from the textual file selected by the user.\r\n     *\r\n     * @param onDone\r\n     */\r\n    private handleImportExpressions = (onDone: (msg: string) => void): void => {\r\n        const lang = this.state.language.userMessages;\r\n        ExpressionStoreManager.load().then(info => {\r\n            this.state.expressions.push(...info.expressions);\r\n            this.setState({});\r\n            onDone(info.expressions.length + lang.expressionsImport[0] + info.loadedFiles + lang.expressionsImport[1] +\r\n                + info.skippedExpressions + lang.expressionsImport[2] + info.skippedFiles + lang.expressionsImport[3]);\r\n        });\r\n    }\r\n\r\n    /******************************************** RESULT SECTION HANDLERS ********************************************/\r\n\r\n    /**\r\n     * Adds the given relation to defined relations.\r\n     *\r\n     * @return message and its color (red for errors, black for information)\r\n     */\r\n    private addResultRelation = (relation: Relation): void => {\r\n        const name = this.ensureUniqueRelationName(\"Evaluated\");\r\n        const storedRelation = StoredRelation.fromRelation(name, relation, this.state.nullValuesSupport);\r\n        this.state.storedRelations.push(storedRelation);\r\n        this.setState({selectedRelation: this.state.storedRelations.length - 1});\r\n    }\r\n\r\n    /***************************************************** RENDER *****************************************************/\r\n\r\n    public render() {\r\n        let resultSection = null;\r\n        if (this.state.evaluationTreeRoot !== null) {\r\n            resultSection = (\r\n                <ResultSection\r\n                    evaluationTreeRoot={this.state.evaluationTreeRoot}\r\n                    expressionName={this.state.evaluatedExpressionName}\r\n\r\n                    onAddResult={this.addResultRelation}\r\n                    onUnexpectedError={this.reportUnexpectedError}\r\n\r\n                    csvValueSeparator={this.state.csvValueSeparator}\r\n                    darkTheme={this.state.darkTheme}\r\n                    language={this.state.language}\r\n                />\r\n            );\r\n        }\r\n\r\n        return (\r\n            <main>\r\n                <ManagementSection\r\n                    onBatch={this.handleBatch}\r\n                    onLoadProject={this.handleLoadProject}\r\n                    onSaveProject={this.handleSaveProject}\r\n                    onLoadSample={this.handleLoadSampleProject}\r\n\r\n                    csvValueSeparator={this.state.csvValueSeparator}\r\n                    language={this.state.language}\r\n                    nullValuesSupport={this.state.nullValuesSupport}\r\n                    darkTheme={this.state.darkTheme}\r\n\r\n                    onCsvValueSeparatorChange={this.handleCsvValueSeparatorChange}\r\n                    onLanguageChange={this.handleLanguageChange}\r\n                    onNullValuesSupportChange={this.handleNullValuesSupportChange}\r\n                    onDarkModeChange={this.handleDarkModeChange}\r\n                />\r\n\r\n                <RelationsSection\r\n                    storedRelations={this.state.storedRelations}\r\n                    storedRelationIndex={this.state.selectedRelation}\r\n\r\n                    loadedRelations={[...this.state.loadedRelations.values()]}\r\n\r\n                    onRelationNameChange={this.handleRelationNameChange}\r\n                    onColumnNameChange={this.handleRelationColumnNameChange}\r\n                    onColumnTypeChange={this.handleRelationColumnTypeChange}\r\n                    onRowInputChange={this.handleRelationRowInputChange}\r\n                    onNewRow={this.handleRelationNewRow}\r\n                    onNewColumn={this.handleRelationNewColumn}\r\n                    onDeleteRow={this.handleRelationDeleteRow}\r\n                    onDeleteColumn={this.handleRelationDeleteColumn}\r\n\r\n                    onSelectDifferentRelation={this.handleSelectDifferentRelation}\r\n                    onDragRelation={this.handleDragRelation}\r\n                    onNewRelation={this.handleCreateNewRelation}\r\n                    onLoadRelation={this.handleLoadRelation}\r\n                    onDeleteStoredRelation={this.handleDeleteRelation}\r\n                    onRevertRelation={this.handleRevertRelation}\r\n\r\n                    onLoadAllRelations={this.handleLoadAllRelations}\r\n                    onRemoveLoadedRelations={this.handleRemoveLoadedRelations}\r\n                    onExportRelations={this.handleExportRelations}\r\n                    onImportRelations={this.handleImportRelations}\r\n\r\n                    nullValuesSupport={this.state.nullValuesSupport}\r\n                    language={this.state.language}\r\n                />\r\n\r\n                <ExpressionSection\r\n                    ref={this.expressionSectionRef}\r\n\r\n                    expressions={this.state.expressions}\r\n                    currentExpressionIndex={this.state.selectedExpression}\r\n                    relations={this.state.loadedRelations}\r\n\r\n                    onChange={this.handleExprTextChange}\r\n                    onEval={this.handleExprEval}\r\n\r\n                    onSelectDifferentExpression={this.handleSelectDifferentExpression}\r\n                    onDragExpression={this.handleDragExpression}\r\n                    onNewExpression={this.handleCreateNewExpression}\r\n                    onDeleteExpression={this.handleDeleteExpression}\r\n                    onExportExpressions={this.handleExportExpressions}\r\n                    onImportExpressions={this.handleImportExpressions}\r\n\r\n                    onUnexpectedError={this.reportUnexpectedError}\r\n                    nullValuesSupport={this.state.nullValuesSupport}\r\n                    darkTheme={this.state.darkTheme}\r\n                    language={this.state.language}\r\n                />\r\n\r\n                {resultSection}\r\n            </main>\r\n        );\r\n    }\r\n}","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport * as serviceWorker from './serviceWorker';\r\nimport MainScreen from \"./components/mainScreen\";\r\n\r\n/**\r\n * @license The software is Licensed under the MIT License\r\n *\r\n * Copyright (c) Lukáš Kotlík\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\r\n * documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\r\n * to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions\r\n * of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO\r\n * THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\r\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n * ********* Used, Licensed third party code: *********\r\n *\r\n * JSZIP - Create, read and edit .zip files with Javascript\r\n * Version: 3.5.0\r\n * https://github.com/Stuk/jszip\r\n * MIT License - Copyright (c) 2009-2016 Stuart Knightley, David Duponchel, Franz Buchinger, António Afonso\r\n *\r\n * visx - visualization components\r\n * visx/group - version: 1.0.0\r\n * visx/hierarchy - version: 1.0.0\r\n * visx/shape - version: 1.4.0\r\n * visx/responsive - version: 1.3.0\r\n * visx/tooltip - version: 1.3.0\r\n * https://github.com/airbnb/visx\r\n * MIT License - Copyright (c) 2017-2018 Harrison Shoff\r\n *\r\n * export-svg-with-styles - Turn your SVGs to PNGs\r\n * Version: 0.0.4\r\n * https://www.npmjs.com/package/export-svg-with-styles\r\n * MIT License - Copyright (c) 2019 Mathew Leland\r\n *\r\n * FileSaver.js - An HTML5 saveAs() FileSaver implementation\r\n * Version: 2.0.5\r\n * https://github.com/eligrey/FileSaver.js\r\n * MIT License - Copyright (c) 2016 Eli Grey\r\n *\r\n * Lodash - A modern JavaScript utility library delivering modularity, performance, & extras.\r\n * Version: 4.17.20\r\n * https://github.com/lodash/lodash\r\n * MIT License - Copyright JS Foundation and other contributors <https://js.foundation/>\r\n * Based on Underscore.js, copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors <http://underscorejs.org/>\r\n * This software consists of voluntary contributions made by many individuals. For exact contribution history, see the revision history available at https://github.com/lodash/lodash\r\n *\r\n * React - A declarative, efficient, and flexible JavaScript library for building user interfaces.\r\n * Version: 16.13.1\r\n * https://github.com/facebook/react\r\n * MIT License - Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * Jest - Delightful JavaScript Testing.\r\n * Version: 26.6.0\r\n * https://github.com/facebook/jest\r\n * MIT License - Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * create-react-app - Set up a modern web app by running one command.\r\n * Version: 3.4.1\r\n * https://github.com/facebook/create-react-app\r\n * MIT License - Copyright (c) 2013-present, Facebook, Inc.\r\n *\r\n * TypeScript - TypeScript is a superset of JavaScript that compiles to clean JavaScript output.\r\n * Version: 3.7.5\r\n * https://github.com/microsoft/TypeScript\r\n * Apache License 2.0\r\n *\r\n * ********* Used, not Licensed, free to use code and services: *********\r\n *\r\n * PostMail - Send email from JavaScript or static HTML without backend code\r\n * https://postmail.invotes.com/\r\n */\r\nReactDOM.render(\r\n    <React.StrictMode>\r\n        <MainScreen/>\r\n    </React.StrictMode>,\r\n    document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.register();\r\n"],"sourceRoot":""}
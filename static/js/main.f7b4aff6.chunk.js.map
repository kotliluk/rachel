{"version":3,"sources":["serviceWorker.ts","components/tooltipButton.tsx","error/errorWithTextRange.ts","error/raSyntaxError.ts","error/raSemanticError.ts","tools/font.ts","tools/whisper.ts","components/xTextArea.tsx","tools/math.ts","error/errorFactory.ts","relation/relation.ts","error/codeError.ts","tools/parser.ts","tools/parserIndexed.ts","tools/indexedString.ts","expression/exprTokens.ts","ratree/raTreeNode.ts","ratree/relationNode.ts","ratree/unaryNode.ts","relation/row.ts","tools/keywords.ts","vetree/comparingOperator.ts","ratree/projectionNode.ts","tools/issToISSMap.ts","ratree/renameNode.ts","vetree/veTreeNode.ts","vetree/logicalOperator.ts","vetree/computingOperator.ts","vetree/literalValue.ts","vetree/referenceValue.ts","expression/valueTokens.ts","expression/valueParser.ts","ratree/binaryNode.ts","ratree/raTreeTools.ts","ratree/antijoinNode.ts","ratree/selectionNode.ts","ratree/outerJoinNode.ts","ratree/cartesianProductNode.ts","ratree/divisionNode.ts","ratree/naturalJoinNode.ts","ratree/setOperationNode.ts","ratree/thetaJoinNode.ts","expression/exprParser.ts","ratree/raTreeFactory.ts","components/textInput.tsx","components/messageBox.ts","components/expressionSection.tsx","components/resultRelationTable.tsx","components/evaluationTree.tsx","tools/fileDialog.ts","tools/rcToStringMap.ts","relation/storedRelation.ts","relation/columnType.ts","relation/relationStoreManager.ts","tools/csvSupport.ts","components/resultSection.tsx","expression/expressionStoreManager.ts","project/samples.ts","components/managementSection.tsx","project/project.ts","expression/expression.ts","project/projectStoreManager.ts","tools/localStorage.ts","tools/supportedLanguage.ts","tools/batchProcessor.ts","tools/date.ts","components/editRelationTable.tsx","components/relationsSection.tsx","tools/postMail.ts","components/mainScreen.tsx","index.tsx"],"names":["isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","console","log","onUpdate","onSuccess","catch","error","TooltipButton","className","this","props","onClick","style","text","tooltipClassName","tooltipStyle","tooltip","React","Component","ErrorWithTextRange","msg","range","Error","insertRangeIfUndefined","err","undefined","RASyntaxError","captureStackTrace","name","RASemanticError","computeFontSizeInPx","fontFamily","fontSize","div","document","createElement","setAttribute","innerText","documentElement","appendChild","divWidth","clientWidth","divHeight","clientHeight","remove","fontWidth","length","fontHeight","getStartOfWordBeforeIndex","str","index","prefixText","slice","i","charAt","cssConstants","getComputedStyle","querySelector","getPropertyValue","lineHeight","Number","numsBackgroundLight","numsBackgroundDark","numsColorLight","numsColorDark","XTextArea","reactDiv","createRef","textarea","start","selectionStart","end","selectionEnd","setSelectionRange","activeElement","id","focus","getElementById","table","classList","add","tr","td1","td2","ta","mouseIsDown","placeholder","value","canvas","width","canvasWidth","canvasLines","whisperDiv","isShown","selectedIndex","changeSelected","indexDiff","setSelected","newIndex","n","m","childElementCount","children","getSelectedWhisper","paintLineNumbers","darkTheme","height","ctx","getContext","fillStyle","fillRect","scrollHeight","font","linesCount","fillText","e","update","lines","createWhisper","whispers","hideWhisper","innerHTML","forEach","whisper","onclick","event","stopPropagation","ondblclick","insertCurrentSelectedWhisper","onChange","notAutoShowWhisper","moveWhisper","cursorLineAndColumn","getPositionLineAndColumn","cursorDistanceFromTATotalTop","line","cursorDistanceFromTATotalLeft","column","yPos","scrollTop","xPos","scrollLeft","getBoundingClientRect","y","innerHeight","currWhisper","beforeAdd","afterAdd","newCursorPos","errorDivs","moveErrors","highlight","startLine","rangeLength","startColumn","x","innerWidth","messageSpan","updateErrors","ranges","pushHighlight","parentElement","push","createHighlightDiv","getLineLength","addEventListener","onscroll","onmousedown","onmouseup","onmousemove","oninput","ev","target","onkeydown","key","preventDefault","ctrlKey","cursor","onCtrlInput","errors","prevProps","ref","position","textBeforeCursor","lastNewLine","lastIndexOf","newLinesFound","lineStart","lineEnd","newEvent","MouseEvent","type","dispatchEvent","span","CodeErrorCodes","SemanticErrorCodes","SyntaxErrorCodes","Relation","columns","Map","columnNames","rows","finishedSchema","hasColumn","hasFinishedSchema","set","some","cn","f","row","isEqual","getTypes","finishSchema","finish","r","equals","map","s","join","get","getOrderedPrintValues","other","Set","CodeError","codeErrMsgEng","resultSection_getCurrentRelation_nodeIndexNotFound","resultSection_getCurrentRelation_evalError","resultSection_saveResultRelation_nullRelationToSave","resultSection_handleAddRelation_nullRelationToAdd","row_getOrderedValues_absentColumn","valueParser_rpnToVETreeRecursive_unexpectedToken","exprParser_isValidSequence_unexpectedToken","exprParser_rpnToVETreeRecursive_unexpectedToken","exprParser_parseTokensForWhisper_thetaJoinBranchError","exprParser_parseTokensForWhisper_projectionBranchError","semanticErrMsgEng","exprParser_parse_relationNotDefined","binaryNode_eval_commonColumnsInSources","setOperationNode_eval_notEqualColumnsInSources","divisionNode_eval_rightColumnsNotSubsetOfLeft","divisionNode_eval_rightColumnsNotProperSubsetOfLeft","renameNode_eval_absentOriginalColumn","renameNode_eval_changeToDuplicitName","projectionNode_eval_absentColumn","referenceValue_eval_absentColumn","syntaxErrMsgEng","exprParser_parse_emptyStringGiven","exprParser_parseTokens_outerJoinWhenNullNotSupported","exprParser_parseTokens_unexpectedPart","exprParser_parseTokens_bothBranchesError","exprParser_rpnToVETree_invalidExpression","exprParser_assertValidInfixTokens_invalidParentheses","exprParser_assertValidInfixTokens_invalidStart","exprParser_assertValidInfixTokens_invalidEnd","exprParser_assertValidInfixTokens_relationAfterRelation","exprParser_assertValidInfixTokens_relationAfterUnary","exprParser_assertValidInfixTokens_relationAfterClosing","exprParser_assertValidInfixTokens_unaryAfterBinary","exprParser_assertValidInfixTokens_unaryAfterOpening","exprParser_assertValidInfixTokens_binaryAfterBinary","exprParser_assertValidInfixTokens_binaryAfterOpening","exprParser_assertValidInfixTokens_openingAfterRelation","exprParser_assertValidInfixTokens_openingAfterUnary","exprParser_assertValidInfixTokens_openingAfterClosing","exprParser_assertValidInfixTokens_closingAfterBinary","exprParser_assertValidInfixTokens_closingAfterOpening","valueParser_parseTokens_emptyInput","valueParser_parseTokens_unsupportedNull","valueParser_parseTokens_unexpectedPart","valueParser_toRPN_missingOpeningParenthesis","valueParser_toRPN_missingClosingParenthesis","valueParser_rpnToVETree_invalidExpression","valueParser_rpnToVETree_invalidStart","valueParser_rpnToVETree_invalidEnd","valueParser_rpnToVETree_literalAfterLiteral","valueParser_rpnToVETree_literalAfterReference","valueParser_rpnToVETree_literalAfterClosing","valueParser_rpnToVETree_referenceAfterLiteral","valueParser_rpnToVETree_referenceAfterReference","valueParser_rpnToVETree_referenceAfterClosing","valueParser_rpnToVETree_notAfterLiteral","valueParser_rpnToVETree_notAfterReference","valueParser_rpnToVETree_notAfterClosing","valueParser_rpnToVETree_binaryAfterOperator","valueParser_rpnToVETree_binaryAfterOpening","valueParser_rpnToVETree_openingAfterLiteral","valueParser_rpnToVETree_openingAfterReference","valueParser_rpnToVETree_openingAfterClosing","valueParser_rpnToVETree_closingAfterOperator","valueParser_rpnToVETree_closingAfterOpening","parser_nextBorderedPart_missingClosingChar","parser_skipWhitespacesAndChar_charNotFound","projectionNode_constructor_invalidProjectionString","projectionNode_parseProjection_invalidProjectedColumnName","renameNode_parseChanges_invalidRenameString","renameNode_parseChanges_missingArrow","renameNode_parseChanges_invalidNewName","renameNode_parseChanges_keywordNewName","renameNode_parseChanges_multipleRenameOfTheColumn","selectionNode_constructor_invalidString","selectionNode_constructor_emptyString","selectionNode_eval_resultNotBoolean","thetaJoinNode_constructor_invalidString","thetaJoinNode_constructor_emptyString","thetaJoinNode_eval_resultNotBoolean","thetaSemiJoinNode_constructor_invalidString","thetaSemiJoinNode_constructor_emptyString","thetaSemiJoinNode_eval_resultNotBoolean","comparingOperator_eval_differentInputTypes","computingOperator_eval_inputTypesNotNumbers","logicalOperator_eval_leftInputNotBoolean","logicalOperator_eval_rightInputNotBoolean","ErrorFactory","code","params","assertParamsCount","joinStringArrays","expectedCount","a","b","aLen","toConcat","Array","concat","Parser","split","every","c","isLetter","isNameChar","res","exec","toLowerCase","toUpperCase","isDigit","test","first","second","substring","char","digitFound","dotFound","backslashes","curChar","syntaxError","escape","depth","inQuotes","nesting","escapeCount","indexOf","charFound","insideQuotes","ParserIndexed","isWord","toString","isName","isWhitespacesOnly","isNumber","strParts","nextWord","nextName","nextNonWhitespacePart","nextNumber","nextQuotedString","startIndex","getFirstNonNaNIndex","nextBorderedPart","skippedStr","skipWhitespacesAndChar","getNonNaNRange","splitToLines","separatorIndexes","toJoin","lineNum","IndexedString","chars","arr","ic","separator","empty","new","isEmpty","isNaN","NaN","getLastNonNaNIndex","RangeError","newFromArray","sepLen","strSplit","prefixSum","strSplitLenMinusOne","ps","indexAt","_start","_end","trimStr","trim","strings","is","searchString","startsWith","endsWith","searchValue","replaceValue","replace","fromIndex","regexp","filter","lastIndex","getLastIndex","getRange","containsAny","ExprToken","ParenthesisToken","OpeningParentheses","ClosingParentheses","RelationToken","UnaryOperatorToken","selection","projection","rename","BinaryOperatorToken","precedence","precedenceLevelF","precedenceLevelD","precedenceLevelE","precedenceLevelA","precedenceLevelB","precedenceLevelC","RATreeNode","resultRelation","eval","RelationNode","relation","cursorIndex","result","getName","UnaryNode","subtree","Row","types","values","finished","keys","has","orderedColumns","ret","codeError","String","forbiddenColumnNames","forbiddenRelationNames","isForbiddenColumnName","ComparingOperatorType","ProjectionNode","stringRange","doThrow","indexed","parts","part","isEvaluated","source","getResult","projected","parseProjection","semanticError","forEachColumn","addColumn","getRows","newRow","getColumns","getValues","addValue","addRow","fakeEval","getColumnNames","absent","strName","printInLine","getOperationSymbol","ISSToISSMap","keyValue","delete","clear","size","RenameNode","handleError","words","w","beforeError","afterError","changes","parseChanges","toChange","returned","regexMatch","duplicit","after","before","beforeStr","afterStr","VETreeNode","LogicalOperatorType","ComparingOperator","operator","left","right","equal","nonEqual","less","more","lessOrEqual","moreOrEqual","leftResult","rightResult","ComputingOperatorType","LogicalOperator","and","or","not","LiteralValue","ReferenceValue","columnName","getValue","getType","ComputingOperator","plus","minus","multiplication","division","ValueToken","OperatorToken","LogicalNotToken","LogicalAndToken","LogicalOrToken","ComputingMultiplicationToken","ComputingDivisionToken","ComputingPlusToken","ComputingMinusToken","ComparingToken","LiteralToken","ReferenceToken","ValueParser","nullValuesSupport","tokens","parseTokens","assertValidInfixTokens","simplify","rpn","toRPN","rpnToVETree","token","rest","i2","token1","token2","notIndexes","indexesToRemove","t","rpnQueue","operatorsStack","pop","curToken","rpnToVETreeRecursive","deduct","multiply","divide","JSON","stringify","BinaryNode","leftSubtree","rightSubtree","depthSearch","root","findIndexInTree","node","getSubtree","leftSearch","getLeftSubtree","getRightSubtree","getTreeDepth","Math","max","isInRangeAndNotInQuotes","len","cursorIndexInStr","warn","AntijoinType","SelectionNode","boolExpr","parse","bool","newResult","fakeParse","OuterJoinType","AntijoinNode","rowsToKeep","rowsToHelp","leftSource","rightSource","commonColumns","lc","keptRow","helpRow","fakeEvalBinary","CartesianProductNode","leftRow","rightRow","leftColumn","DivisionNode","leftColumns","rightColumns","getSchemaString","resultColumns","getNamesSchemaString","leftRows","rightRows","testRow","lr","entries","NaturalJoinType","OuterJoinNode","full","SetOperationType","NaturalJoinNode","leftSemi","natural","rightSemi","ThetaJoinType","SetOperationNode","union","intersection","typeStr","getTypeStr","rr","AssertType","ThetaJoinNode","condition","getOperationName","bothSourceColumns","booleanResult","sourceColumns","RATreeFactory","unaryClass","expr","binaryClass","difference","ExprParser","relations","deleteCommentLines","THROW_STRICT","rpnToRATree","indexedExpr","fakeParseTokens","NOT_THROW","innerResult","selectionExpected","alternativeTokens","errorAlternative","thetaJoin","message","rightThetaSemijoin","errorRange","fullOuterJoin","leftOuterJoin","rightOuterJoin","leftSemijoin","rightSemijoin","naturalJoin","cartesianProduct","leftAntijoin","rightAntijoin","leftThetaSemijoin","THROW_NOT_STRICT","ignored","restStartIndex","getNextIndexOrNaN","recursiveReturn","operatorEndIndex","relationStartIndex","relationEndIndex","missing","splice","rpnToRATreeRecursive","createUnary","createBinary","TextInput","inputRef","handleChange","disable","forbidden","setState","buttonDisable","handleKeyDown","handleSubmit","current","blur","onSubmit","htmlFor","label","spellCheck","autoComplete","onKeyDown","disabled","buttonText","boxMargin","MessageBox","box","visibility","onmouseenter","clearHideTimeout","onmouseleave","setHideTimeout","paragraph","button","hideBox","moveBox","body","firstElementChild","toggle","display","hideTimeout","init","hideIntervalId","setTimeout","clearTimeout","ExpressionSection","unaryButtons","shift","setOperatorsButtons","innerJoinsButtons","outerJoinsButtons","divisionButton","specialButtons","textAreaRef","lastChange","lastWhisperAndErrorsUpdate","whispersAndErrorsUpdateRate","getCurExpr","evalExpr","tree","indexedParse","expressions","currentExpressionIndex","onEval","errorRanges","er","showError","newExpression","onNewExpression","deleteExpression","onDeleteExpression","saveExpressions","onExportExpressions","loadExpressions","onImportExpressions","addSpecialString","getSelection","firstPart","secondPart","newPosition","newStr","handleExprChange","setSelection","onDone","Date","now","handleCtrlInput","updateWhispersAndErrors","textArea","isFocused","fakeParseResult","wordBeforeCursor","helpArray","likelihood","wordStart","wordEnd","sort","help","sortWhispers","handleExprNameChange","onUnexpectedError","sectionClicked","setInterval","onSelectDifferentExpression","createButton","createOpButtons","buttonProps","prop","marginRight","handleSelectDifferentExpression","minWidth","marginLeft","padding","ResultRelationTable","getOrderByText","orderDir","orderBy","prevState","snapshot","updateOrderBy","getRowsCount","colSpan","sortCol","aValue","bValue","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","localeCompare","headerRow","createHeaderRow","createRows","EvaluationTree","TreeComponent","raTree","selected","nodeHeight","backgroundColorLight","backgroundColorDark","textColorLight","textColorDark","selectedNodeColorLight","unselectedNodeColorLight","selectedNodeColorDark","unselectedNodeColorDark","TreeNodeComponent","useTooltip","tooltipOpen","showTooltip","hideTooltip","nodeWidth","data","title","symbol","Group","top","rx","fill","onMouseOver","tooltipLeft","tooltipTop","onMouseOut","dy","textAnchor","pointerEvents","treeDepth","margin","bottom","yMax","xMax","indexes","parseTreeForDisplayHelper","maxNodeTextLength","parseTreeForDisplay","hierarchy","Tree","links","link","LinkVertical","stroke","strokeWidth","strokeOpacity","descendants","FileDialog","accept","Promise","resolve","element","fileInput","firstChild","file","files","reader","FileReader","onload","readAsText","click","openFilesHelper","fileInfo","readFile","RCToStringMap","entry","parseKey","StoredRelation","columnTypes","columnCount","rowCount","actual","revertState","toDataObject","recomputeErrors","isStoredRelationData","d","checkColumnNames","checkRowInput","columnIndex","reduce","agg","rowIndex","input","lower","_","rowInput","addNewColumn","columnType","checkColumnTypes","obj","isArray","o","isSupportedColumnType","RelationStoreManager","openFiles","skipped","csvToRelation","createValidName","filename","valueSeparator","zip","JSZip","relationToCsv","generateAsync","content","saveAs","blob","Blob","findValueSeparatorChar","nextRowInput","inString","names","getColumnTypes","ResultSection","sectionRef","getCurrentRelation","currentNode","evaluationTreeRoot","handleSelectedNodeChange","exportEvalTreeAsPng","svg","rect","options","expressionName","downloadSVG","exportRelation","save","fromRelation","csvValueSeparator","addRelation","onAddResult","relationType","selectedNode","tableTitle","ExpressionStoreManager","skippedExpressions","loadedFiles","skippedFiles","splitExpressionNameAndText","firstNewLineIndex","firstRow","textContent","samples","project","getSamples","ManagementSection","onLoadProject","onSaveProject","settingsMenu","sample","onLoadSample","createSamplesButton","checked","onNullValuesSupportChange","onCsvValueSeparatorChange","onDarkModeChange","createSettingsButton","href","rel","isProjectObject","isExpression","copyProject","proj","exp","ProjectStoreManager","reject","openFile","defaultLanguage","defaultDarkMode","LocalStorage","storageSupported","storedSeparator","localStorage","getItem","setItem","language","isInit","Storage","BatchProcessor","processFile","status","parseRelations","exprParser","exprCount","reports","processExpression","ops","addOperations","counts","report","reportHeader","formatRelations","parser","evaluationTree","operationsOfTree","contentString","zeroOperations","operations","date","total","binaryOperations","unaryOperations","binary","unary","getDate","padStart","getMonth","getFullYear","getHours","getMinutes","antijoin","cartesian","outerJoin","semijoin","setOperation","thetaSemijoin","storedData","time","processed","timeEnd","storedRelation","fromData","isValid","createRelation","count","operationOfUnaryNode","operationOfBinaryNode","cellPaddingSides","inputMarginSides","EditRelationTable","containerRef","tableHeadRowRef","columnWidths","handleInputResize","inputElement","scrollWidth","getErrors","setSelectedInput","selectedColumn","selectedRow","moveSelectedInputRight","getColumnCount","moveSelectedInputLeft","moveSelectedInputUp","moveSelectedInputDown","getRowCount","onColumnNameChange","onColumnTypeChange","onRowInputChange","handleNewColumn","onNewColumn","scrollTo","handleNewRow","onNewRow","handleDeleteColumn","onDeleteColumn","handleDeleteRow","onDeleteRow","createInput","autoFocus","createDeleteButton","callback","headRow","cells","cell","rowData","createTooltip","rowSpan","border","createNamesRow","createTypesRow","createAddRow","RelationsSection","getCurRel","storedRelations","storedRelationIndex","handleRelationNameChange","onRelationNameChange","loadRelation","onLoadRelation","loadAllRelations","onLoadAllRelations","exportRelations","onExportRelations","importRelations","onImportRelations","deleteRelation","onDeleteStoredRelation","revertRelation","onRevertRelation","newRelation","onNewRelation","deleteAllLoadedRelations","onDeleteLoadedRelations","createRelationMenuButtons","actuality","isActual","handleSelectDifferentRelation","onSelectDifferentRelation","sr","canRevert","getRevertName","PostMail","accessToken","subject","data_js","access_token","request","XMLHttpRequest","onreadystatechange","readyState","response","toParams","open","setRequestHeader","send","encodeURIComponent","MainScreen","expressionSectionRef","reportUnexpectedError","postMail","stack","loadedRelations","selectedRelation","selectedExpression","loadProject","evaluatedExpressionName","updateExpressionsErrors","handleBatch","process","handleLoadProject","load","handleSaveProject","handleLoadSampleProject","handleNullValuesSupportChange","setNullValuesSupport","handleCsvValueSeparatorChange","setCsvValueSeparator","handleLanguageChange","setLanguage","handleDarkModeChange","setDarkMode","setName","handleRelationColumnNameChange","setColumnName","handleRelationColumnTypeChange","setColumnType","handleRelationRowInputChange","setRowInput","handleRelationNewRow","addNewRow","handleRelationNewColumn","handleRelationDeleteRow","deleteRow","handleRelationDeleteColumn","deleteColumn","handleCreateNewRelation","handleDeleteRelation","handleRevertRelation","revert","handleDeleteLoadedRelations","setActual","handleExportRelations","handleImportRelations","info","countBefore","handleLoadRelation","currRelation","handleLoadAllRelations","loaded","msgPart2","expressionSection","handleExprEval","handleExprTextChange","handleCreateNewExpression","handleDeleteExpression","handleExportExpressions","handleImportExpressions","addResultRelation","getDarkMode","getCsvValueSeparator","getLanguage","resultSection","onBatch","onLanguageChange","ReactDOM","render","StrictMode","URL","origin","fetch","headers","contentType","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.f7b4aff6.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\r\n\r\ninterface TooltipButtonProps {\r\n    // text on the button\r\n    text: string,\r\n    // handler of the button click\r\n    onClick: () => void,\r\n    // css class of the button\r\n    className: string,\r\n    // inline styling for button\r\n    style?: React.CSSProperties,\r\n\r\n    // text of the tooltip\r\n    tooltip: string,\r\n    // css class of the tooltip\r\n    tooltipClassName: string,\r\n    // inline styling for tooltip\r\n    tooltipStyle?: React.CSSProperties,\r\n}\r\n\r\ninterface TooltipButtonState {\r\n}\r\n\r\n/**\r\n * Button with a tooltip text.\r\n */\r\nexport class TooltipButton extends React.Component<TooltipButtonProps, TooltipButtonState> {\r\n\r\n    render() {\r\n        return (\r\n            <button\r\n                className={this.props.className}\r\n                onClick={this.props.onClick}\r\n                style={this.props.style}\r\n                >{this.props.text}\r\n                <span\r\n                    className={this.props.tooltipClassName}\r\n                    style={this.props.tooltipStyle}\r\n                >{this.props.tooltip}</span>\r\n            </button>\r\n        );\r\n    }\r\n}","/**\r\n * Error with optional text range of the error.\r\n */\r\nexport default class ErrorWithTextRange extends Error {\r\n    constructor(msg: string, public range?: {start: number, end: number} | undefined) {\r\n        super(msg);\r\n    }\r\n}\r\n\r\n/**\r\n * If the given error is ErrorWithTextRange instance and has undefined range, sets its range to given value.\r\n * Returns (possibly modified) input error.\r\n *\r\n * @param err\r\n * @param range\r\n */\r\nexport function insertRangeIfUndefined<T>(err: T, range: {start: number, end: number} | undefined): T {\r\n    if (err instanceof ErrorWithTextRange && err.range === undefined) {\r\n        err.range = range;\r\n    }\r\n    return err;\r\n}","import ErrorWithTextRange from \"./errorWithTextRange\";\r\n\r\n/**\r\n * Syntax error in an expression structure.\r\n */\r\nexport default class RASyntaxError extends ErrorWithTextRange {\r\n    /**\r\n     * @param msg Adds \"Syntax error: \" before given message\r\n     * @param range optional text range of the error\r\n     */\r\n    constructor(msg: string, range: {start: number, end: number} | undefined) {\r\n        super(\"Syntax error: \" + msg, range);\r\n        if (Error.captureStackTrace) {\r\n            Error.captureStackTrace(this, RASyntaxError);\r\n        }\r\n        this.name = 'RASyntaxError';\r\n    }\r\n}","import ErrorWithTextRange from \"./errorWithTextRange\";\r\n\r\n/**\r\n * Semantic error in an expression structure.\r\n */\r\nexport default class RASemanticError extends ErrorWithTextRange {\r\n    /**\r\n     * @param msg Adds \"Semantic error: \" before given message\r\n     * @param range optional text range of the error\r\n     */\r\n    constructor(msg: string, range: {start: number, end: number} | undefined) {\r\n        super(\"Semantic error: \" + msg, range);\r\n        if (Error.captureStackTrace) {\r\n            Error.captureStackTrace(this, RASemanticError);\r\n        }\r\n        this.name = 'RASemanticError';\r\n    }\r\n}","/**\r\n * Computes width (average on sample of characters) and its height of the given font with given size in pixels.\r\n *\r\n * @param fontFamily\r\n * @param fontSize\r\n */\r\nexport function computeFontSizeInPx(fontFamily: string, fontSize: string): {fontWidth: number, fontHeight: number} {\r\n    const text: string = \"0123456789qwertyuiopasdfghjkllzxcvbnmQWERTYUIOOPASDFGHJKLLZXCVBNM!@#$%^&*()_+[];',./\";\r\n    const div = document.createElement(\"div\");\r\n    div.setAttribute('style', `font-family: ${fontFamily}; font-size: ${fontSize}; position: absolute; white-space: nowrap;`);\r\n    div.innerText = text;\r\n    document.documentElement.appendChild(div);\r\n    const divWidth: number = div.clientWidth;\r\n    const divHeight: number = div.clientHeight;\r\n    div.remove();\r\n    return { fontWidth: divWidth / text.length, fontHeight: divHeight };\r\n}","/**\r\n * Returns start index of the word before given index in the given string.\r\n *\r\n * @param str\r\n * @param index\r\n */\r\nexport function getStartOfWordBeforeIndex(str: string, index: number): number {\r\n    const prefixText: string = str.slice(0, index);\r\n    let i: number = prefixText.length - 1;\r\n    while (true) {\r\n        // if non-name-character is reached\r\n        if (!prefixText.charAt(i).match(/\\w/)) {\r\n            ++i;\r\n            break;\r\n        }\r\n        if (i === 0) {\r\n            break;\r\n        }\r\n        --i;\r\n    }\r\n    return i;\r\n}\r\n\r\n/**\r\n * Returns sorted given array of whispers with respect to given last word before cursor.\r\n * Matched word parts in the whispers are highlighted by CSS span. Not-matched words are made grey.\r\n */\r\nexport function sortWhispers(whispers: string[], wordBeforeCursor: string): string[] {\r\n    // values for sorting whispers\r\n    const startsWithWord: number = 2;\r\n    const containsWord: number = 1;\r\n    // creates help array with whisper likelihoods and highlighted matched parts\r\n    const helpArray: {whisper: string, likelihood: number}[] = whispers.map(whisper => {\r\n        let likelihood = 0;\r\n        const wordStart = whisper.toLowerCase().indexOf(wordBeforeCursor.toLowerCase());\r\n        if (wordStart > -1) {\r\n            likelihood += wordStart === 0 ? startsWithWord : containsWord;\r\n            const wordEnd = wordStart + wordBeforeCursor.length;\r\n            whisper = whisper.slice(0, wordStart) + \"<span class='whisper-matched-word'>\" +\r\n                whisper.slice(wordStart, wordEnd) + \"</span>\" + whisper.slice(wordEnd);\r\n        }\r\n        if (likelihood === 0) {\r\n            whisper = \"<span class='whisper-rejected-word'>\" + whisper + \"</span>\"\r\n        }\r\n        return {whisper, likelihood};\r\n    });\r\n    if (wordBeforeCursor !== \"\") {\r\n        helpArray.sort((x, y) => y.likelihood - x.likelihood);\r\n    }\r\n    return helpArray.map(help => help.whisper);\r\n}","import React from \"react\";\r\nimport './css/xTextArea.css';\r\nimport {mod} from \"../tools/math\";\r\nimport {computeFontSizeInPx} from \"../tools/font\";\r\nimport {getStartOfWordBeforeIndex} from \"../tools/whisper\";\r\n\r\ninterface XTextAreaProps {\r\n    // id of the component\r\n    id: string;\r\n    // current text content of the textarea\r\n    text: string;\r\n    // text to be shown as textarea placeholder\r\n    placeholder: string;\r\n    // error messages and ranges to be highlighted in text area\r\n    errors: {start: number, end: number, msg: string}[];\r\n    // strings whispered to the user to be added at the current position\r\n    whispers: string[];\r\n    // handler of text change\r\n    onChange: (text: string, cursorIndex: number) => void;\r\n    // handler of input with Ctrl key\r\n    onCtrlInput: (ev: KeyboardEvent) => void;\r\n    // true if dark theme should be applied\r\n    darkTheme: boolean;\r\n}\r\n\r\ninterface XTextAreaState {}\r\n\r\n/**\r\n * HTMLTextAreaElement extended for painting number lines, inserting strings given from parent and whispering.\r\n */\r\ntype ExtendedHTMLTextArea = HTMLTextAreaElement & {\r\n    /**\r\n     * (Re)paints line numbers next to textarea.\r\n     *\r\n     * @param darkTheme style to be applied to numbers\r\n     */\r\n    paintLineNumbers: (darkTheme: boolean) => void,\r\n    // reference to canvas element used to paint line numbers\r\n    canvasLines: HTMLCanvasElement,\r\n    // true when the mouse button is clicked down\r\n    mouseIsDown: boolean,\r\n\r\n    /**\r\n     * Updates textarea content to the given value. Updates number of lines.\r\n     */\r\n    update: (value: string, darkTheme: boolean) => void,\r\n    // number of lines in the textarea\r\n    linesCount: number,\r\n\r\n    /**\r\n     * Whispers given array of strings to the user at the current cursor position.\r\n     *\r\n     * @param toWhisper\r\n     */\r\n    createWhisper: (whispers: string[]) => void,\r\n    /**\r\n     * Moves the WhisperDiv to be located next to the current cursor position.\r\n     * The WhisperDiv is moved only if the whisperDiv.isShown is true.\r\n     */\r\n    moveWhisper: () => void,\r\n    /**\r\n     * Hides the WhisperDiv (whisperDiv.isShown is set to false).\r\n     */\r\n    hideWhisper: () => void,\r\n    /**\r\n     * Inserts current selected whisper.\r\n     *\r\n     * @param onChange callback to the parent after text change\r\n     */\r\n    insertCurrentSelectedWhisper: (onChange: (text: string, cursorIndex: number) => void) => void,\r\n    // true when the whisper should not be shown automatically (e.g., after pressing Enter)\r\n    notAutoShowWhisper: boolean,\r\n    // reference to whisper div\r\n    whisperDiv: WhisperDiv,\r\n\r\n    /**\r\n     * Creates error div elements for given ranges.\r\n     */\r\n    updateErrors: (ranges: {start: number, end: number, msg: string}[]) => void,\r\n    /**\r\n     * Moves error div elements to current position.\r\n     */\r\n    moveErrors: () => void,\r\n    // div elements for highlighting errors\r\n    errorDivs: ErrorDiv[]\r\n};\r\n\r\n/**\r\n * HTMLDivElement extended by functions for easy whispering.\r\n */\r\ntype WhisperDiv = HTMLDivElement & {\r\n    // true when the whisper should be shown\r\n    isShown: boolean,\r\n    // index of the selected whisper\r\n    selectedIndex: number,\r\n    /**\r\n     * Updates selected whisper by given difference. Removes highlights from previous highlighted whisper and\r\n     * highlights the new selected. The new index is modulo actual whisper count. The function does nothing, when\r\n     * there no whispers at the moment.\r\n     *\r\n     * @param indexDiff\r\n     */\r\n    changeSelected: (indexDiff: number) => void,\r\n    /**\r\n     * Updates selected whisper to given index. Removes highlights from previous highlighted whisper and\r\n     * highlights the new selected. The new index is modulo actual whisper count. The function does nothing, when\r\n     * there no whispers at the moment.\r\n     *\r\n     * @param newIndex\r\n     */\r\n    setSelected: (newIndex: number) => void,\r\n    /**\r\n     * Returns current selected whisper or undefined, when no whisper is selected.\r\n     */\r\n    getSelectedWhisper: () => string | undefined\r\n};\r\n\r\ntype ErrorDiv = HTMLDivElement & {\r\n    startLine: number,\r\n    startColumn: number,\r\n    rangeLength: number,\r\n    messageSpan: HTMLSpanElement\r\n}\r\n\r\n// @ts-ignore\r\nconst cssConstants: CSSStyleDeclaration = getComputedStyle(document.querySelector(':root'));\r\n\r\nconst fontSize: string = cssConstants.getPropertyValue('--x-textarea-font-size');\r\nconst fontFamily: string = cssConstants.getPropertyValue('--x-textarea-font-family');\r\nconst {fontWidth} = computeFontSizeInPx(fontFamily, fontSize);\r\nconst lineHeight: number = Number(cssConstants.getPropertyValue('--x-textarea-line-height'));\r\nconst numsBackgroundLight: string = cssConstants.getPropertyValue('--light-color-b');\r\nconst numsBackgroundDark: string = cssConstants.getPropertyValue('--dark-color-b');\r\nconst numsColorLight: string = cssConstants.getPropertyValue('--text-color-light');\r\nconst numsColorDark: string = cssConstants.getPropertyValue('--text-color-dark');\r\nconst canvasWidth: number = 24;\r\n\r\n/**\r\n * TextArea extended by line numbers and text highlighting. The component is maintained by JavaScript HTML functions,\r\n * not by React.\r\n */\r\nexport class XTextArea extends React.Component<XTextAreaProps, XTextAreaState> {\r\n    // reference to XTextArea root React div element\r\n    private reactDiv: React.RefObject<HTMLDivElement> = React.createRef<HTMLDivElement>();\r\n    // @ts-ignore - always set before usage in componentDidMount\r\n    private textarea: ExtendedHTMLTextArea;\r\n\r\n    /**\r\n     * Returns current text area selection start and end.\r\n     */\r\n    public getSelection(): {start: number, end: number} {\r\n        return {start: this.textarea.selectionStart, end: this.textarea.selectionEnd};\r\n    }\r\n\r\n    /**\r\n     * Sets text area selection start and end. If end is not given, start value is used as end value as well.\r\n     *\r\n     * @param start\r\n     * @param end\r\n     */\r\n    public setSelection(start: number, end?: number): void {\r\n        this.textarea.setSelectionRange(start, end ? end : start);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the textarea has focus.\r\n     */\r\n    public isFocused(): boolean {\r\n        return document.activeElement !== null && document.activeElement.id === this.props.id + '-ta';\r\n    }\r\n\r\n    /**\r\n     * The text area gains focus in the window.\r\n     */\r\n    public focus(): void {\r\n        this.textarea.focus();\r\n    }\r\n\r\n    /**\r\n     * The component is build by JavaScript HTML functions after mount of the empty div in render function.\r\n     */\r\n    componentDidMount() {\r\n        const props: Readonly<XTextAreaProps> = this.props;\r\n        // @ts-ignore - gets parent div\r\n        const div: HTMLDivElement = document.getElementById(props.id);\r\n\r\n        // LAYOUT (table with 1 row and 2 columns)\r\n        const table = document.createElement('table');\r\n        table.setAttribute('cellspacing','0');\r\n        table.setAttribute('cellpadding','0');\r\n        table.classList.add('x-textarea-table');\r\n        const tr = document.createElement('tr');\r\n        const td1 = document.createElement('td');\r\n        td1.setAttribute('id', props.id + '-td1');\r\n        td1.classList.add('x-textarea-table-td1');\r\n        const td2 = document.createElement('td');\r\n        td2.classList.add('x-textarea-table-td2');\r\n        tr.appendChild(td1);\r\n        tr.appendChild(td2);\r\n        table.appendChild(tr);\r\n\r\n        // TEXTAREA\r\n        // @ts-ignore - extended later in componentDidMount\r\n        const ta: ExtendedHTMLTextArea = document.createElement('textarea');\r\n        ta.setAttribute('id', props.id + '-ta');\r\n        ta.setAttribute('spellcheck', 'false');\r\n        ta.mouseIsDown = false;\r\n        ta.setAttribute('placeholder', this.props.placeholder);\r\n        ta.classList.add('x-textarea', 'cursor-container');\r\n        ta.value = props.text;\r\n\r\n        // TEXTAREA NUMBERS (Canvas)\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = canvasWidth + 4;    // must not set width & height in css !!!\r\n        canvas.classList.add('x-textarea-canvas');\r\n        ta.canvasLines = canvas;\r\n        td1.appendChild(canvas);\r\n        td2.appendChild(ta);\r\n        div.appendChild(table);\r\n\r\n        // TEXTAREA WHISPER DIV\r\n        // @ts-ignore - extended later in componentDidMount\r\n        const whisperDiv: WhisperDiv = document.createElement('div');\r\n        whisperDiv.classList.add('whisper-div');\r\n        whisperDiv.isShown = false;\r\n        whisperDiv.selectedIndex = -1;\r\n        whisperDiv.changeSelected = function (indexDiff: number) {\r\n            this.setSelected(this.selectedIndex + indexDiff);\r\n        }\r\n        whisperDiv.setSelected = function (newIndex: number) {\r\n            if (this.childElementCount > 0) {\r\n                // removes selected highlight from previous selected whisper (if it is valid)\r\n                if (this.selectedIndex > -1 && this.selectedIndex < this.childElementCount) {\r\n                    this.children[this.selectedIndex].classList.remove(\"selected-whisper\");\r\n                }\r\n                // updates the index modulo child count\r\n                this.selectedIndex = mod(newIndex, this.childElementCount);\r\n                // adds selected highlight\r\n                this.children[this.selectedIndex].classList.add(\"selected-whisper\");\r\n            }\r\n        }\r\n        whisperDiv.getSelectedWhisper = function (): string | undefined {\r\n            if (this.selectedIndex > -1 && this.childElementCount > 0) {\r\n                // @ts-ignore\r\n                return this.children[this.selectedIndex].innerText;\r\n            }\r\n            return undefined;\r\n        }\r\n        ta.whisperDiv = whisperDiv;\r\n        td2.appendChild(whisperDiv);\r\n\r\n        // Line numbers rendering inspired by: https://www.w3schools.com/code/tryit.asp?filename=G68VMFWS12UH,\r\n        // Nikola Bozovic, nigerija@gmail.com\r\n        ta.paintLineNumbers = function(darkTheme: boolean): void {\r\n            try {\r\n                const canvas = this.canvasLines;\r\n                if (canvas.height !== this.clientHeight) {\r\n                    canvas.height = this.clientHeight; // on resize\r\n                }\r\n                // @ts-ignore\r\n                const ctx: CanvasRenderingContext2D = canvas.getContext(\"2d\");\r\n                ctx.fillStyle = darkTheme ? numsBackgroundDark : numsBackgroundLight;\r\n                ctx.fillRect(0, 0, canvasWidth + 2, this.scrollHeight + 1);\r\n                ctx.fillStyle = darkTheme ? numsColorDark : numsColorLight;\r\n                ctx.font = fontSize + \" \" + fontFamily;\r\n                for (let i = 0; i < this.linesCount; i++) {\r\n                    const text = \"\" + (i + 1);  // line number\r\n                    ctx.fillText(text,canvasWidth - (text.length * 8), 19 + (i * lineHeight));\r\n                }\r\n            }\r\n            catch(e) {\r\n                console.log('XTextArea paintLineNumbers error: ' + e);\r\n            }\r\n        };\r\n\r\n        ta.update = function (value: string, darkTheme: boolean) {\r\n            this.value = value;\r\n            // computes lines count\r\n            let lines: number = 1;\r\n            for (let i = 0; i < value.length; ++i) {\r\n                if (value.charAt(i) === \"\\n\") {\r\n                    ++lines;\r\n                }\r\n            }\r\n            this.linesCount = lines;\r\n            // set height to fit all lines\r\n            this.style.height = (lines * lineHeight + 8) + \"px\";\r\n            // if the horizontal scrollbar is visible, fits it into the height\r\n            if (this.scrollHeight > this.clientHeight) {\r\n                this.style.height = (this.scrollHeight + lineHeight + 10) + \"px\";\r\n            }\r\n            this.paintLineNumbers(darkTheme);\r\n        }\r\n\r\n        ta.createWhisper = function (whispers: string[]): void {\r\n            if (whispers.length === 0) {\r\n                this.hideWhisper();\r\n            }\r\n            else {\r\n                this.whisperDiv.innerHTML = \"\";\r\n                whispers.forEach((whisper, i) => {\r\n                    const div = document.createElement(\"div\");\r\n                    div.innerHTML = whisper;\r\n                    div.onclick = event => {\r\n                        this.focus();\r\n                        this.whisperDiv.setSelected(i);\r\n                        event.stopPropagation();\r\n                    };\r\n                    div.ondblclick = event => {\r\n                        this.focus();\r\n                        this.insertCurrentSelectedWhisper(props.onChange);\r\n                        this.notAutoShowWhisper = true;\r\n                        event.stopPropagation();\r\n                    };\r\n                    this.whisperDiv.appendChild(div);\r\n                });\r\n                // selects the first whisper after change\r\n                this.whisperDiv.setSelected(0);\r\n                // needs to be set to true before moveWhisper call\r\n                this.whisperDiv.isShown = true;\r\n                // sets the div position\r\n                this.moveWhisper();\r\n            }\r\n        }\r\n\r\n        ta.moveWhisper = function () {\r\n            // updates only if the whisper is shown\r\n            if (this.whisperDiv.isShown) {\r\n                // finds cursor position in the whole string\r\n                const cursorLineAndColumn = getPositionLineAndColumn(this.value, this.selectionEnd);\r\n                // computes position of the bottom end of the cursor relative to the text\r\n                const cursorDistanceFromTATotalTop: number = (cursorLineAndColumn.line + 1) * lineHeight;\r\n                const cursorDistanceFromTATotalLeft: number = cursorLineAndColumn.column * fontWidth;\r\n                const yPos: number = cursorDistanceFromTATotalTop - this.scrollTop;\r\n                const xPos: number = cursorDistanceFromTATotalLeft - this.scrollLeft + 4;\r\n                // shows the div at computed position if the cursor is visible\r\n                if (0 <= yPos && yPos < this.clientHeight && 0 <= xPos && xPos < this.clientWidth) {\r\n                    // if the div is in the upper part of the screen, shows it under the cursor\r\n                    if (this.getBoundingClientRect().y + yPos <= window.innerHeight / 2) {\r\n                        this.whisperDiv.setAttribute('style', `display: block; top: ${yPos + 4}px; left: ${xPos}px;`);\r\n                    }\r\n                    // if the div is in the lower part of the screen, shows it above the cursor\r\n                    else {\r\n                        this.whisperDiv.setAttribute('style',\r\n                            `display: block; bottom: ${this.getBoundingClientRect().height - yPos + lineHeight}px; left: ${xPos}px;`);\r\n                    }\r\n                }\r\n                // hides the div if the cursor is not visible (but DOES NOT SET whisperDiv.isShown to false to re-appear it again)\r\n                else {\r\n                    this.whisperDiv.setAttribute('style', `display: none;`);\r\n                }\r\n            }\r\n        }\r\n\r\n        ta.hideWhisper = function () {\r\n            //whisperDiv.innerHTML = '';\r\n            this.whisperDiv.setAttribute('style', 'display: none;');\r\n            this.whisperDiv.isShown = false;\r\n        }\r\n\r\n        ta.insertCurrentSelectedWhisper = function (onChange: (text: string, cursorIndex: number) => void) {\r\n            const currWhisper: string | undefined = this.whisperDiv.getSelectedWhisper();\r\n            if (currWhisper !== undefined) {\r\n                const i: number = getStartOfWordBeforeIndex(this.value, this.selectionEnd);\r\n                const beforeAdd: string = this.value.slice(0, i);\r\n                const afterAdd: string = this.value.slice(this.selectionEnd);\r\n                const newCursorPos: number = i + currWhisper.length;\r\n                onChange(beforeAdd + currWhisper + afterAdd, newCursorPos);\r\n                this.setSelectionRange(newCursorPos, newCursorPos);\r\n                this.hideWhisper();\r\n            }\r\n        }\r\n\r\n        ta.notAutoShowWhisper = false;\r\n\r\n        // TEXTAREA ERROR RANGE HIGHLIGHTS\r\n        ta.errorDivs = [];\r\n\r\n        ta.moveErrors = function () {\r\n            this.errorDivs.forEach(highlight => {\r\n                // computes position of the highlight relative to the text\r\n                const yPos: number = (highlight.startLine + 1) * lineHeight + 1 - this.scrollTop;\r\n                // shows the div at computed position if the line is visible\r\n                if (1 < yPos && yPos < this.clientHeight) {\r\n                    let width: number = highlight.rangeLength * fontWidth;\r\n                    let xPos: number = highlight.startColumn * fontWidth + 7 - this.scrollLeft;\r\n                    // if the whole highlight is out of the width, does not display it\r\n                    if (xPos > this.clientWidth || xPos + width < 3) {\r\n                        highlight.setAttribute('style', `display: none;`);\r\n                    }\r\n                    else {\r\n                        // updates position of highlights starting before first visible column\r\n                        if (xPos < 3) {\r\n                            width += xPos - 3;\r\n                            xPos = 3;\r\n                        }\r\n                        // updates width of highlights ending after last visible column\r\n                        if (xPos + width > this.clientWidth) {\r\n                            width = this.clientWidth - xPos;\r\n                        }\r\n                        // updates the position of message span when the highlight is on the right side of the screen\r\n                        if (this.getBoundingClientRect().x + xPos >= window.innerWidth / 2) {\r\n                            highlight.messageSpan.setAttribute('style', `right: 50%; left: unset;`);\r\n                        }\r\n                        highlight.setAttribute('style', `display: block; top: ${yPos}px; left: ${xPos}px; width: ${width}px`);\r\n                    }\r\n                }\r\n                // hides the div if the line is not visible\r\n                else {\r\n                    highlight.setAttribute('style', `display: none;`);\r\n                }\r\n            });\r\n        }\r\n\r\n        ta.updateErrors = function (ranges: {start: number, end: number, msg: string}[]) {\r\n            // removes old highlight divs\r\n            this.errorDivs.forEach(highlight => {\r\n                highlight.remove();\r\n            });\r\n            this.errorDivs = [];\r\n\r\n            // appends the highlight div as textarea child and adds it to highlights array\r\n            const pushHighlight = (highlight: ErrorDiv) => {\r\n                // @ts-ignore - adds it to the parent element\r\n                this.parentElement.appendChild(highlight);\r\n                this.errorDivs.push(highlight);\r\n            }\r\n\r\n            ranges.forEach(range => {\r\n                // finds highlight start and end lines and columns\r\n                const start = getPositionLineAndColumn(this.value, range.start);\r\n                const end = getPositionLineAndColumn(this.value, range.end);\r\n                // error on one line only\r\n                if (start.line === end.line) {\r\n                    pushHighlight(createHighlightDiv(start.line, start.column, end.column - start.column,\r\n                        range.msg, this));\r\n                }\r\n                // error on multiple lines\r\n                else {\r\n                    // pushes first line part - from error start to line end\r\n                    pushHighlight(createHighlightDiv(start.line, start.column,\r\n                        getLineLength(this.value, start.line) - start.column, range.msg, this));\r\n                    // pushes middle lines\r\n                    for (let line = start.line + 1; line < end.line; ++line) {\r\n                        pushHighlight(createHighlightDiv(line, 0, getLineLength(this.value, line),\r\n                            range.msg, this));\r\n                    }\r\n                    // pushes last line part - from line start to error end\r\n                    pushHighlight(createHighlightDiv(end.line, 0, end.column, range.msg, this));\r\n                }\r\n            });\r\n\r\n            // moves highlight to current positions\r\n            this.moveErrors();\r\n        }\r\n\r\n        // handles whisper div position when scrolling on page\r\n        window.addEventListener('scroll', () => ta.moveWhisper());\r\n        window.addEventListener('resize', () => {\r\n            ta.moveWhisper();\r\n            ta.moveErrors();\r\n        });\r\n        window.addEventListener('click', () => ta.hideWhisper());\r\n        ta.onscroll     = () => {\r\n            ta.paintLineNumbers(this.props.darkTheme);\r\n            ta.moveWhisper();\r\n            ta.moveErrors();\r\n        };\r\n        //ta.addEventListener(\"focusout\", () => ta.hideWhisper());\r\n        ta.onmousedown  = event => {\r\n            ta.mouseIsDown = true;\r\n            event.stopPropagation();\r\n        }\r\n        ta.onmouseup    = () => {\r\n            ta.mouseIsDown = false;\r\n            ta.paintLineNumbers(this.props.darkTheme);\r\n        };\r\n        ta.onmousemove  = () => {\r\n            if (ta.mouseIsDown) ta.paintLineNumbers(this.props.darkTheme);\r\n        };\r\n        ta.oninput      = (ev) => {\r\n            // @ts-ignore\r\n            this.props.onChange(ev.target.value, ev.target.selectionStart);\r\n        }\r\n        // prevents default behavior of special keys input when whisperDiv is shown, passes key event to the parent\r\n        ta.onkeydown    = (ev) => {\r\n            if (ta.whisperDiv.isShown) {\r\n                if (ev.key === \"ArrowDown\") {\r\n                    ta.whisperDiv.changeSelected(1);\r\n                    ev.preventDefault();\r\n                }\r\n                if (ev.key === \"ArrowUp\") {\r\n                    ta.whisperDiv.changeSelected(-1);\r\n                    ev.preventDefault();\r\n                }\r\n                if (ev.key === \"PageDown\") {\r\n                    // moves selected whisper to bottom\r\n                    ta.whisperDiv.setSelected(-1);\r\n                    ev.preventDefault();\r\n                }\r\n                if (ev.key === \"PageUp\") {\r\n                    // moves selected whisper to top\r\n                    ta.whisperDiv.setSelected(0);\r\n                    ev.preventDefault();\r\n                }\r\n                if (ev.key === \"End\" || ev.key === \"Home\") {\r\n                    ta.hideWhisper();\r\n                    // keeps default behaviour\r\n                }\r\n                if (ev.key === \"Escape\" || ev.key === \"Esc\") {\r\n                    ta.hideWhisper();\r\n                    ev.preventDefault();\r\n                }\r\n                if (ev.key === \"Enter\" && !ev.ctrlKey) {\r\n                    ta.insertCurrentSelectedWhisper(this.props.onChange);\r\n                    ev.preventDefault();\r\n                }\r\n                if (ev.key === \"Enter\" && ev.ctrlKey) {\r\n                    ta.hideWhisper();\r\n                    ev.preventDefault();\r\n                }\r\n                if (ev.key === \"Tab\") {\r\n                    ta.insertCurrentSelectedWhisper(this.props.onChange);\r\n                    ev.preventDefault();\r\n                }\r\n                if (ev.key === \"ArrowLeft\") {\r\n                    const cursor = (ta.selectionStart === 0) ? 0 : (ta.selectionStart - 1);\r\n                    // forces update to recompute whispers if needed\r\n                    this.props.onChange(ta.value, cursor);\r\n                    // keeps default behaviour\r\n                }\r\n                if (ev.key === \"ArrowRight\") {\r\n                    const cursor = (ta.selectionStart === ta.value.length) ? ta.selectionStart : ta.selectionStart + 1;\r\n                    // forces update to recompute whispers if needed\r\n                    this.props.onChange(ta.value, cursor);\r\n                    // keeps default behaviour\r\n                }\r\n            }\r\n            if (ev.key === \"Enter\" || ev.key === \"Tab\") {\r\n                // does not show whisper after pressing Enter or Tab\r\n                ta.notAutoShowWhisper = true;\r\n            }\r\n            if (ev.key === \"Backspace\" && !ta.whisperDiv.isShown) {\r\n                // does not show whisper after pressing Backspace when it is closed\r\n                ta.notAutoShowWhisper = true;\r\n            }\r\n            if (ev.ctrlKey) {\r\n                if (ev.key === \" \") {\r\n                    if (ta.whisperDiv.isShown) {\r\n                        ta.hideWhisper();\r\n                    }\r\n                    else {\r\n                        this.props.onChange(ta.value, ta.selectionStart);\r\n                    }\r\n                }\r\n                this.props.onCtrlInput(ev);\r\n            }\r\n        }\r\n\r\n        // make sure numbers are painted\r\n        ta.update(this.props.text, this.props.darkTheme);\r\n        // shows highlights\r\n        ta.updateErrors(this.props.errors);\r\n        this.textarea = ta;\r\n    }\r\n\r\n    /**\r\n     * Updates text content and component style.\r\n     */\r\n    componentDidUpdate(prevProps: Readonly<XTextAreaProps>) {\r\n        this.textarea.update(this.props.text, this.props.darkTheme);\r\n        if (prevProps.darkTheme !== this.props.darkTheme) {\r\n            this.textarea.paintLineNumbers(this.props.darkTheme);\r\n        }\r\n        // whispers\r\n        if (this.props.whispers !== prevProps.whispers) {\r\n            if (this.textarea.notAutoShowWhisper) {\r\n                this.textarea.notAutoShowWhisper = false;\r\n            }\r\n            else {\r\n                this.textarea.createWhisper(this.props.whispers);\r\n            }\r\n        }\r\n        // highlights error\r\n        if (this.props.errors !== undefined) {\r\n            this.textarea.updateErrors(this.props.errors);\r\n        }\r\n        // first undefined highlight removes 'x-textarea-err' from textarea.className to show selection with blue color\r\n        else if (this.props.errors !== prevProps.errors) {\r\n            this.textarea.classList.remove('x-textarea-err');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders only an empty div. Other maintaining is not provided by React.\r\n     */\r\n    public render() {\r\n        return (\r\n            <div\r\n                ref={this.reactDiv}\r\n                id={this.props.id}\r\n                className=\"x-textarea-div\"\r\n            />\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Computes line and column number for given position in text.\r\n */\r\nfunction getPositionLineAndColumn(text: string, position: number): {line: number, column: number} {\r\n    const textBeforeCursor: string = text.slice(0, position);\r\n    const line: number = (textBeforeCursor.match(/\\n/g) || []).length;\r\n    const lastNewLine: number = textBeforeCursor.lastIndexOf('\\n');\r\n    const column: number = textBeforeCursor.length - lastNewLine - 1;\r\n    return {line, column};\r\n}\r\n\r\n/**\r\n * Returns number of characters on the given line.\r\n */\r\nfunction getLineLength(text: string, line: number): number {\r\n    let newLinesFound = 0;\r\n    let lineStart = 0;  // index of line-th newline\r\n    let lineEnd = 0;    // index of (line+1)-th newline\r\n    for (let i = 0; i < text.length; ++i) {\r\n        if (text.charAt(i) === '\\n') {\r\n            ++newLinesFound;\r\n            if (newLinesFound === line) {\r\n                lineStart = i;\r\n            }\r\n            else if (newLinesFound === line + 1) {\r\n                lineEnd = i;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (lineEnd === 0) {\r\n        lineEnd = text.length; // handles case of last line in text\r\n    }\r\n    return lineEnd - lineStart;\r\n}\r\n\r\n/**\r\n * Creates a div for highlighting text in the given textarea.\r\n */\r\nfunction createHighlightDiv(startLine: number, startColumn: number, rangeLength: number, msg: string,\r\n                            textarea: ExtendedHTMLTextArea): ErrorDiv {\r\n    // @ts-ignore\r\n    const highlight: ErrorDiv = document.createElement('div');\r\n    highlight.classList.add(\"x-textarea-highlight\");\r\n    highlight.startLine = startLine;\r\n    highlight.startColumn = startColumn;\r\n    highlight.rangeLength = rangeLength;\r\n    // dispatches click event to not block textarea underneath highlights\r\n    highlight.onclick = (ev: MouseEvent) => {\r\n        const newEvent: MouseEvent = new MouseEvent(ev.type, {...ev});\r\n        textarea.dispatchEvent(newEvent);\r\n        ev.stopPropagation();\r\n    }\r\n    const span: HTMLSpanElement = document.createElement('span');\r\n    span.classList.add(\"highlight-tooltip\");\r\n    span.innerText = msg;\r\n    highlight.messageSpan = span;\r\n    highlight.appendChild(span);\r\n    return highlight;\r\n}","/**\r\n * Modulo operation with positive result for negative numbers (as % in JavaScript can give negative results).\r\n *\r\n * @param n base number\r\n * @param m dividing number\r\n */\r\nexport function mod(n: number, m: number) {\r\n    return ((n % m) + m) % m;\r\n}","import RASemanticError from \"./raSemanticError\";\r\nimport RASyntaxError from \"./raSyntaxError\";\r\nimport CodeError from \"./codeError\";\r\n\r\n/**\r\n * Codes for CodeErrors.\r\n */\r\nexport enum CodeErrorCodes {\r\n    resultSection_getCurrentRelation_nodeIndexNotFound = 1,\r\n    resultSection_getCurrentRelation_evalError,\r\n    resultSection_saveResultRelation_nullRelationToSave,\r\n    resultSection_handleAddRelation_nullRelationToAdd,\r\n\r\n    row_getOrderedValues_absentColumn,\r\n\r\n    valueParser_rpnToVETreeRecursive_unexpectedToken,\r\n\r\n    exprParser_isValidSequence_unexpectedToken,\r\n    exprParser_rpnToVETreeRecursive_unexpectedToken,\r\n    exprParser_parseTokensForWhisper_thetaJoinBranchError,\r\n    exprParser_parseTokensForWhisper_projectionBranchError\r\n}\r\n\r\n/**\r\n * Codes for RASemanticErrors.\r\n */\r\nexport enum SemanticErrorCodes {\r\n    exprParser_parse_relationNotDefined = 1001,\r\n\r\n    binaryNode_eval_commonColumnsInSources,\r\n    setOperationNode_eval_notEqualColumnsInSources,\r\n    divisionNode_eval_rightColumnsNotSubsetOfLeft,\r\n    divisionNode_eval_rightColumnsNotProperSubsetOfLeft,\r\n    renameNode_eval_absentOriginalColumn,\r\n    renameNode_eval_changeToDuplicitName,\r\n    projectionNode_eval_absentColumn,\r\n\r\n    referenceValue_eval_absentColumn\r\n}\r\n\r\n/**\r\n * Codes for RASyntaxErrors.\r\n */\r\nexport enum SyntaxErrorCodes {\r\n    exprParser_parse_emptyStringGiven = 2001,\r\n    exprParser_parseTokens_outerJoinWhenNullNotSupported,\r\n    exprParser_parseTokens_unexpectedPart,\r\n    exprParser_parseTokens_bothBranchesError,\r\n    exprParser_rpnToVETree_invalidExpression,\r\n    exprParser_assertValidInfixTokens_invalidParentheses,\r\n    exprParser_assertValidInfixTokens_invalidStart,\r\n    exprParser_assertValidInfixTokens_invalidEnd,\r\n    exprParser_assertValidInfixTokens_relationAfterRelation,\r\n    exprParser_assertValidInfixTokens_relationAfterUnary,\r\n    exprParser_assertValidInfixTokens_relationAfterClosing,\r\n    exprParser_assertValidInfixTokens_unaryAfterBinary,\r\n    exprParser_assertValidInfixTokens_unaryAfterOpening,\r\n    exprParser_assertValidInfixTokens_binaryAfterBinary,\r\n    exprParser_assertValidInfixTokens_binaryAfterOpening,\r\n    exprParser_assertValidInfixTokens_openingAfterRelation,\r\n    exprParser_assertValidInfixTokens_openingAfterUnary,\r\n    exprParser_assertValidInfixTokens_openingAfterClosing,\r\n    exprParser_assertValidInfixTokens_closingAfterBinary,\r\n    exprParser_assertValidInfixTokens_closingAfterOpening,\r\n\r\n    valueParser_parseTokens_emptyInput,\r\n    valueParser_parseTokens_unsupportedNull,\r\n    valueParser_parseTokens_unexpectedPart,\r\n    valueParser_toRPN_missingOpeningParenthesis,\r\n    valueParser_toRPN_missingClosingParenthesis,\r\n    valueParser_rpnToVETree_invalidExpression,\r\n    valueParser_rpnToVETree_invalidStart,\r\n    valueParser_rpnToVETree_invalidEnd,\r\n    valueParser_rpnToVETree_literalAfterLiteral,\r\n    valueParser_rpnToVETree_literalAfterReference,\r\n    valueParser_rpnToVETree_literalAfterClosing,\r\n    valueParser_rpnToVETree_referenceAfterLiteral,\r\n    valueParser_rpnToVETree_referenceAfterReference,\r\n    valueParser_rpnToVETree_referenceAfterClosing,\r\n    valueParser_rpnToVETree_notAfterLiteral,\r\n    valueParser_rpnToVETree_notAfterReference,\r\n    valueParser_rpnToVETree_notAfterClosing,\r\n    valueParser_rpnToVETree_binaryAfterOperator,\r\n    valueParser_rpnToVETree_binaryAfterOpening,\r\n    valueParser_rpnToVETree_openingAfterLiteral,\r\n    valueParser_rpnToVETree_openingAfterReference,\r\n    valueParser_rpnToVETree_openingAfterClosing,\r\n    valueParser_rpnToVETree_closingAfterOperator,\r\n    valueParser_rpnToVETree_closingAfterOpening,\r\n\r\n    parser_nextBorderedPart_missingClosingChar,\r\n    parser_skipWhitespacesAndChar_charNotFound,\r\n\r\n    projectionNode_constructor_invalidProjectionString,\r\n    projectionNode_parseProjection_invalidProjectedColumnName,\r\n\r\n    renameNode_parseChanges_invalidRenameString,\r\n    renameNode_parseChanges_missingArrow,\r\n    renameNode_parseChanges_invalidNewName,\r\n    renameNode_parseChanges_keywordNewName,\r\n    renameNode_parseChanges_multipleRenameOfTheColumn,\r\n\r\n    selectionNode_constructor_invalidString,\r\n    selectionNode_constructor_emptyString,\r\n    selectionNode_eval_resultNotBoolean,\r\n\r\n    thetaJoinNode_constructor_invalidString,\r\n    thetaJoinNode_constructor_emptyString,\r\n    thetaJoinNode_eval_resultNotBoolean,\r\n\r\n    thetaSemiJoinNode_constructor_invalidString,\r\n    thetaSemiJoinNode_constructor_emptyString,\r\n    thetaSemiJoinNode_eval_resultNotBoolean,\r\n\r\n    comparingOperator_eval_differentInputTypes,\r\n\r\n    computingOperator_eval_inputTypesNotNumbers,\r\n\r\n    logicalOperator_eval_leftInputNotBoolean,\r\n    logicalOperator_eval_rightInputNotBoolean\r\n}\r\n\r\n/**\r\n * English messages for CodeErrors mapped by their error codes.\r\n */\r\nconst codeErrMsgEng: Map<CodeErrorCodes, string[]> = new Map<CodeErrorCodes, string[]>([\r\n    [CodeErrorCodes.resultSection_getCurrentRelation_nodeIndexNotFound,\r\n        [\"ResultSection.getCurrentRelation: Selected node index in evaluation tree not found.\"]],\r\n    [CodeErrorCodes.resultSection_getCurrentRelation_evalError,\r\n        [\"ResultSection.getCurrentRelation: Evaluation error in result section: \", \"\"]],\r\n    [CodeErrorCodes.resultSection_saveResultRelation_nullRelationToSave,\r\n        [\"ResultSection.saveResultRelation: Result relation is null when tried to save it.\"]],\r\n    [CodeErrorCodes.resultSection_handleAddRelation_nullRelationToAdd,\r\n        [\"ResultSection.handleAddRelation: Result relation is null when tried to add it.\"]],\r\n\r\n    [CodeErrorCodes.row_getOrderedValues_absentColumn,\r\n        [\"Row.getOrderedValues: Column \", \" is absent in row with columns: \", \"\"]],\r\n\r\n    [CodeErrorCodes.valueParser_rpnToVETreeRecursive_unexpectedToken,\r\n        [\"ValueParser.rpnToVETreeRecursive: Unexpected token: \", \".\"]],\r\n\r\n    [CodeErrorCodes.exprParser_isValidSequence_unexpectedToken,\r\n        [\"ExprParser.isValidSequence: Unexpected token: \", \".\"]],\r\n    [CodeErrorCodes.exprParser_rpnToVETreeRecursive_unexpectedToken,\r\n        [\"ExprParser.rpnToVETreeRecursive: Unexpected token: \", \".\"]],\r\n    [CodeErrorCodes.exprParser_parseTokensForWhisper_thetaJoinBranchError,\r\n        [\"ExprParser.parseTokensForWhisper: Error in theta join branch: \", \".\"]],\r\n    [CodeErrorCodes.exprParser_parseTokensForWhisper_projectionBranchError,\r\n        [\"ExprParser.parseTokensForWhisper: Error in projection branch: \", \".\"]]\r\n]);\r\n\r\n/**\r\n * English messages for RASemanticErrors mapped by their error codes.\r\n */\r\nconst semanticErrMsgEng: Map<SemanticErrorCodes, string[]> = new Map<SemanticErrorCodes, string[]>([\r\n    [SemanticErrorCodes.exprParser_parse_relationNotDefined,\r\n        [\"Relation \\\"\", \"\\\" is not defined. Please check relations definitions.\"]],\r\n\r\n    [SemanticErrorCodes.binaryNode_eval_commonColumnsInSources,\r\n        [\"Source relations for \", \" have common columns \\\"\", \"\\\".\"]],\r\n    [SemanticErrorCodes.setOperationNode_eval_notEqualColumnsInSources,\r\n        [\"Source relations \\\"\", \"\\\" and \\\"\", \"\\\" for set \", \" do not have the same column sets.\"]],\r\n    [SemanticErrorCodes.divisionNode_eval_rightColumnsNotSubsetOfLeft,\r\n        [\"Right source relation \\\"\", \"\\\" is not a subset of the left source relation \\\"\", \"\\\".\"]],\r\n    [SemanticErrorCodes.divisionNode_eval_rightColumnsNotProperSubsetOfLeft,\r\n        [\"Right source relation \\\"\", \"\\\" is not a proper subset of the left source relation \\\"\",\r\n            \". There must exist a column in the left relation which is not present in the right relation.\"]],\r\n    [SemanticErrorCodes.renameNode_eval_absentOriginalColumn,\r\n        [\"Invalid rename, column \\\"\", \"\\\" does not exist in the source relation.\"]],\r\n    [SemanticErrorCodes.renameNode_eval_changeToDuplicitName,\r\n        [\"Invalid rename, new column name \\\"\", \"\\\" is duplicit in the changed relation.\"]],\r\n    [SemanticErrorCodes.projectionNode_eval_absentColumn,\r\n        [\"Invalid projection of the column \\\"\", \"\\\". It does not exist in the source relation.\"]],\r\n\r\n    [SemanticErrorCodes.referenceValue_eval_absentColumn,\r\n        [\"Column \\\"\", \"\\\" is absent in a schema with columns: \", \".\"]],\r\n]);\r\n\r\n/**\r\n * English messages for RASyntaxErrors mapped by their error codes.\r\n */\r\nconst syntaxErrMsgEng: Map<SyntaxErrorCodes, string[]> = new Map<SyntaxErrorCodes, string[]>([\r\n    [SyntaxErrorCodes.exprParser_parse_emptyStringGiven,\r\n        [\"Cannot parse an expression from an empty string.\"]],\r\n    [SyntaxErrorCodes.exprParser_parseTokens_outerJoinWhenNullNotSupported,\r\n        [\"Found \", \" when null values are not supported.\"]],\r\n    [SyntaxErrorCodes.exprParser_parseTokens_unexpectedPart,\r\n        [\"Unexpected part \\\"\", \"\\\" in RA expression.\"]],\r\n    [SyntaxErrorCodes.exprParser_parseTokens_bothBranchesError,\r\n        [\"All combinations throw error in \\\"\", \"\\\". When treated as projection:\\n\", \"\\nWhen treated as theta join:\\n\", \"\"]],\r\n    [SyntaxErrorCodes.exprParser_rpnToVETree_invalidExpression,\r\n        [\"Given string is not a valid expression.\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_invalidParentheses,\r\n        [\"Invalid structure of parentheses in the expression.\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_invalidStart,\r\n        [\"RA expression cannot start with \", \".\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_invalidEnd,\r\n        [\"RA expression cannot end with \", \".\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_relationAfterRelation,\r\n        [\"Relation \\\"\", \"\\\" after relation \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_relationAfterUnary,\r\n        [\"Relation \\\"\", \"\\\" after unary operator \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_relationAfterClosing,\r\n        [\"Relation \\\"\", \"\\\" after closing parenthesis.\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_unaryAfterBinary,\r\n        [\"Unary operator \\\"\", \"\\\" after binary operator \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_unaryAfterOpening,\r\n        [\"Unary operator \\\"\", \"\\\" after opening parenthesis.\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_binaryAfterBinary,\r\n        [\"Binary operator \\\"\", \"\\\" after binary operator \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_binaryAfterOpening,\r\n        [\"Binary operator \\\"\", \"\\\" after opening parenthesis.\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_openingAfterRelation,\r\n        [\"Opening parentheses after relation \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_openingAfterUnary,\r\n        [\"Opening parentheses after unary operator \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_openingAfterClosing,\r\n        [\"Opening parentheses after closing parentheses.\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_closingAfterBinary,\r\n        [\"Closing parentheses after binary operator \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.exprParser_assertValidInfixTokens_closingAfterOpening,\r\n        [\"Closing parentheses after opening parentheses.\"]],\r\n\r\n    [SyntaxErrorCodes.valueParser_parseTokens_emptyInput,\r\n        [\"An empty string given as a condition.\"]],\r\n    [SyntaxErrorCodes.valueParser_parseTokens_unsupportedNull,\r\n        [\"Null constant used when null values are not supported.\"]],\r\n    [SyntaxErrorCodes.valueParser_parseTokens_unexpectedPart,\r\n        [\"Unexpected part \\\"\", \"\\\" in expression.\"]],\r\n    [SyntaxErrorCodes.valueParser_toRPN_missingOpeningParenthesis,\r\n        [\"Missing opening parenthesis '(' in an expression.\"]],\r\n    [SyntaxErrorCodes.valueParser_toRPN_missingClosingParenthesis,\r\n        [\"Missing closing parenthesis ')' in an expression.\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_invalidExpression,\r\n        [\"Given string is not a valid expression.\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_invalidStart,\r\n        [\"Expression cannot start with \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_invalidEnd,\r\n        [\"Expression cannot end with \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_literalAfterLiteral,\r\n        [\"Literal \\\"\", \"\\\" after literal \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_literalAfterReference,\r\n        [\"Literal \\\"\", \"\\\" after reference to column \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_literalAfterClosing,\r\n        [\"Literal \\\"\", \"\\\" after closing parentheses.\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_referenceAfterLiteral,\r\n        [\"Reference to column \\\"\", \"\\\" after literal \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_referenceAfterReference,\r\n        [\"Reference to column \\\"\", \"\\\" after reference to column \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_referenceAfterClosing,\r\n        [\"Reference to column \\\"\", \"\\\" after closing parentheses.\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_notAfterLiteral,\r\n        [\"Logical not operator \\\"\", \"\\\" after literal \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_notAfterReference,\r\n        [\"Logical not operator \\\"\", \"\\\" after reference to column \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_notAfterClosing,\r\n        [\"Logical not operator \\\"\", \"\\\" after closing parentheses.\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_binaryAfterOperator,\r\n        [\"Binary operator \\\"\", \"\\\" after binary operator \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_binaryAfterOpening,\r\n        [\"Binary operator \\\"\", \"\\\" after opening parentheses.\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_openingAfterLiteral,\r\n        [\"Opening parentheses after literal \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_openingAfterReference,\r\n        [\"Opening parentheses after reference to column \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_openingAfterClosing,\r\n        [\"Opening parentheses after closing parentheses.\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_closingAfterOperator,\r\n        [\"Closing parentheses after binary operator \\\"\", \"\\\".\"]],\r\n    [SyntaxErrorCodes.valueParser_rpnToVETree_closingAfterOpening,\r\n        [\"Closing parentheses after opening parentheses.\"]],\r\n\r\n    [SyntaxErrorCodes.parser_nextBorderedPart_missingClosingChar,\r\n        [\"Missing '\", \"' after opening '\", \"'.\"]],\r\n    [SyntaxErrorCodes.parser_skipWhitespacesAndChar_charNotFound,\r\n        [\"Expected \\\"\", \"\\\" not found.\"]],\r\n\r\n    [SyntaxErrorCodes.projectionNode_constructor_invalidProjectionString,\r\n        ['\"', \"\\\" is not a projection string. It must be bordered with '[' and ']'.\"]],\r\n    [SyntaxErrorCodes.projectionNode_parseProjection_invalidProjectedColumnName,\r\n        [\"Invalid projection of column \\\"\", \"\\\". Column name must contain letters, number and underscores only and start with a letter.\"]],\r\n\r\n    [SyntaxErrorCodes.renameNode_parseChanges_invalidRenameString,\r\n        ['\"', \"\\\" is not a rename string. It must be bordered with '<' and '>'.\"]],\r\n    [SyntaxErrorCodes.renameNode_parseChanges_missingArrow,\r\n        [\"Invalid rename, please use \\\"OldName -> NewName\\\" for each column renaming separated by commas ','.\"]],\r\n    [SyntaxErrorCodes.renameNode_parseChanges_invalidNewName,\r\n        [\"Invalid rename to \\\"\", \"\\\". New column name must contain letters, number and underscores only and start with a letter.\"]],\r\n    [SyntaxErrorCodes.renameNode_parseChanges_keywordNewName,\r\n        [\"Invalid rename to \\\"\", \"\\\". New column name cannot be a keyword.\"]],\r\n    [SyntaxErrorCodes.renameNode_parseChanges_multipleRenameOfTheColumn,\r\n        [\"Multiple rename of column \\\"\", \"\\\".\"]],\r\n\r\n    [SyntaxErrorCodes.selectionNode_constructor_invalidString,\r\n        [\"Invalid selection, it must be bordered with '(' and ')'.\"]],\r\n    [SyntaxErrorCodes.selectionNode_constructor_emptyString,\r\n        [\"The selection cannot be empty.\"]],\r\n    [SyntaxErrorCodes.selectionNode_eval_resultNotBoolean,\r\n        [\"Result of the selection condition \", \" is not a boolean value, but \", \".\"]],\r\n\r\n    [SyntaxErrorCodes.thetaJoinNode_constructor_invalidString,\r\n        [\"Invalid theta join, it must be bordered with '[' and ']'.\"]],\r\n    [SyntaxErrorCodes.thetaJoinNode_constructor_emptyString,\r\n        [\"The theta join condition cannot be empty.\"]],\r\n    [SyntaxErrorCodes.thetaJoinNode_eval_resultNotBoolean,\r\n        [\"Result of the theta join condition \", \" is not a boolean value, but \", \".\"]],\r\n\r\n    [SyntaxErrorCodes.thetaSemiJoinNode_constructor_invalidString,\r\n        [\"Invalid theta semijoin, it must be bordered with '<' and ']' or '[' and '>'.\"]],\r\n    [SyntaxErrorCodes.thetaSemiJoinNode_constructor_emptyString,\r\n        [\"The theta semijoin condition cannot be empty.\"]],\r\n    [SyntaxErrorCodes.thetaSemiJoinNode_eval_resultNotBoolean,\r\n        [\"Result of the theta semijoin condition \", \" is not a boolean value, but \", \".\"]],\r\n\r\n    [SyntaxErrorCodes.comparingOperator_eval_differentInputTypes,\r\n        [\"Inputs for \\\"\", \"\\\"  have different types \", \" and \", \".\"]],\r\n\r\n    [SyntaxErrorCodes.computingOperator_eval_inputTypesNotNumbers,\r\n        [\"Inputs for \\\"\", \"\\\" are not both numbers, they are \", \" and \", \".\"]],\r\n\r\n    [SyntaxErrorCodes.logicalOperator_eval_leftInputNotBoolean,\r\n        [\"Left input value for \\\"\",  \"\\\" is not a boolean, but \", \".\"]],\r\n    [SyntaxErrorCodes.logicalOperator_eval_rightInputNotBoolean,\r\n        [\"Right input value for \\\"\", \"\\\" is not a boolean, but \", \".\"]]\r\n]);\r\n\r\n/**\r\n * Factory for creating custom application errors: CodeError, RASemanticError, RASyntaxError.\r\n * It creates an error message by given error code and string parameters.\r\n */\r\nexport class ErrorFactory {\r\n\r\n    /**\r\n     * Creates a new CodeError with given code. Params are used to join error messages expecting textual specification.\r\n     *\r\n     * @param code code of the code error\r\n     * @param params textual specification\r\n     */\r\n    public static codeError(code: CodeErrorCodes, ...params: string[]): CodeError {\r\n        let msg: string[] | undefined = codeErrMsgEng.get(code);\r\n        if (msg === undefined) {\r\n            console.log(\"Unknown code of code error given: \" + code);\r\n            msg = [\"Code error\"];\r\n        }\r\n        assertParamsCount(msg.length - 1, params, code);\r\n        return new CodeError(joinStringArrays(msg, params));\r\n    }\r\n\r\n    /**\r\n     * Creates a new RASemanticError with given code and range. Params are used to join error messages expecting textual\r\n     * specification.\r\n     *\r\n     * @param code code of the semantic error\r\n     * @param range text range of the error in the input when defined\r\n     * @param params textual specification\r\n     */\r\n    public static semanticError(code: SemanticErrorCodes, range: {start: number, end: number} | undefined, ...params: string[]): RASemanticError {\r\n        let msg: string[] | undefined = semanticErrMsgEng.get(code);\r\n        if (msg === undefined) {\r\n            console.log(\"Unknown code of semantic error given: \" + code);\r\n            msg = [\"Semantic error\"];\r\n        }\r\n        assertParamsCount(msg.length - 1, params, code);\r\n        return new RASemanticError(joinStringArrays(msg, params), range);\r\n    }\r\n\r\n    /**\r\n     * Creates a new RASyntaxError with given code and range. Params are used to join error messages expecting textual\r\n     * specification.\r\n     *\r\n     * @param code code of the syntax error\r\n     * @param range text range of the error in the input when defined\r\n     * @param params textual specification\r\n     */\r\n    public static syntaxError(code: SyntaxErrorCodes, range: {start: number, end: number} | undefined, ...params: string[]): RASyntaxError {\r\n        let msg: string[] | undefined = syntaxErrMsgEng.get(code);\r\n        if (msg === undefined) {\r\n            console.log(\"Unknown code of syntax error given: \" + code);\r\n            msg = [\"Syntax error\"];\r\n        }\r\n        assertParamsCount(msg.length - 1, params, code);\r\n        return new RASyntaxError(joinStringArrays(msg, params), range);\r\n    }\r\n}\r\n\r\n/**\r\n * Extends the given params array with empty strings to have the length of expectedCount. When the intial length of the\r\n * given params array is same or greater, the array is unchanged.\r\n *\r\n * @param expectedCount\r\n * @param params\r\n * @param code code of the error\r\n */\r\nexport function assertParamsCount(expectedCount: number, params: string[], code: number): void {\r\n    if (params.length !== expectedCount) {\r\n        console.log(\"Unexpected params count for error \" + code + \", expected \" + expectedCount + \", given \" + params.length);\r\n        while (params.length < expectedCount) {\r\n            params.push(\"\");\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Joins given string arrays [a1, a2, ..., an] and [b1, b2, ..., bn-1] to one string \"a1b1a2b2...an-1bn-1an\".\r\n * WARNING: a.length is expected to be at least 1. b.length is expected to be at least \"a.length - 1\".\r\n *\r\n * @param a array of length at least 1\r\n * @param b array of length at least \"a.length - 1\"\r\n */\r\nexport function joinStringArrays(a: string[], b: string[]): string {\r\n    const aLen: number = a.length;\r\n    const toConcat: string[] = Array<string>(2 * aLen - 2);\r\n    for (let i = 1; i < aLen; i++) {\r\n        toConcat[2 * i - 2] = b[i - 1];\r\n        toConcat[2 * i - 1] = a[i];\r\n    }\r\n    return a[0].concat(...toConcat);\r\n}","import Row from \"./row\";\r\nimport {SupportedColumnType} from \"./columnType\";\r\nimport { isEqual } from \"lodash\";\r\n\r\n/**\r\n * Relation from relational algebra. It contains relational schema (set of columns' names and types)\r\n * and relation's relation (set of rows).\r\n */\r\nexport default class Relation {\r\n\r\n    public readonly name: string;\r\n    private columns = new Map<string, SupportedColumnType>();\r\n    private columnNames: string[] = []; // array to have an ordered printing of columns\r\n    private rows: Row[] = [];\r\n    private finishedSchema = false;\r\n\r\n    /**\r\n     * Creates an empty relation of the given name.\r\n     *\r\n     * @param name name of the relation\r\n     */\r\n    constructor(name: string) {\r\n        this.name = name;\r\n    }\r\n\r\n    /**\r\n     * Returns name of the relation.\r\n     */\r\n    public getName(): string {\r\n        return this.name;\r\n    }\r\n\r\n    /**\r\n     * @return true if the relational schema is finished (no more columns can be added)\r\n     */\r\n    public hasFinishedSchema(): boolean {\r\n        return this.finishedSchema;\r\n    }\r\n\r\n    /**\r\n     * Sets the relational schema finished (no more columns can be added).\r\n     */\r\n    public finishSchema(): void {\r\n        this.finishedSchema = true;\r\n    }\r\n\r\n    /**\r\n     * Adds a column to a relational schema if the relational schema is not finished yet.\r\n     *\r\n     * @param name name of the column\r\n     * @param type type of the column\r\n     * @return true if the column was added (relation did not contain a column with the same name before)\r\n     */\r\n    public addColumn(name: string, type: SupportedColumnType): boolean {\r\n        if (!this.hasColumn(name) && !this.hasFinishedSchema()) {\r\n            this.columns.set(name, type);\r\n            this.columnNames.push(name);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks whether the relation has a column with the same name\r\n     * (NOTE: type of the column does not matter).\r\n     *\r\n     * @param name Column name to be checked\r\n     * @return true if the relation has a column with the same name\r\n     */\r\n    public hasColumn(name: string): boolean {\r\n        return this.columnNames.some(cn => cn === name);\r\n    }\r\n\r\n    /**\r\n     * @return map (name -> value) of columns' values in a relation.\r\n     */\r\n    public getColumns(): Map<string, SupportedColumnType> {\r\n        return this.columns;\r\n    }\r\n\r\n    /**\r\n     * @param f function to be applied for each column in the relation\r\n     */\r\n    public forEachColumn(f: (type: SupportedColumnType, name: string) => void): void {\r\n        return this.columns.forEach(f);\r\n    }\r\n\r\n    /**\r\n     * @return array of column names in a relation.\r\n     */\r\n    public getColumnNames(): string[] {\r\n        return this.columnNames;\r\n    }\r\n\r\n    /**\r\n     * @return Number of columns in a relation.\r\n     */\r\n    public getColumnsCount(): number {\r\n        return this.columnNames.length;\r\n    }\r\n\r\n    /**\r\n     * Adds a row to a relation. The row must have the same column set as the relation. If the row was added,\r\n     * sets the row finished and returns true. Also the relational schema of this relation\r\n     * is set finished (no more columns can be added). If the row was not added, returns false.\r\n     * NOTE: Rows in a relation cannot be duplicit, adding a duplicit row returns true, but only one is kept.\r\n     *\r\n     * @param row row to be added\r\n     * @return true if the row was added, false otherwise\r\n     */\r\n    public addRow(row: Row): boolean {\r\n        if (isEqual(row.getTypes(), this.columns)) {\r\n            this.finishSchema();\r\n            row.finish();\r\n            if (!this.rows.some(r => r.equals(row))) {\r\n                this.rows.push(row);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @return array of rows in a relation.\r\n     */\r\n    public getRows(): Row[] {\r\n        return this.rows;\r\n    }\r\n\r\n    /**\r\n     * @return Number of rows in a relation.\r\n     */\r\n    public getRowsCount(): number {\r\n        return this.rows.length;\r\n    }\r\n\r\n    /**\r\n     * Returns a relational schema in a format: RelationName(ColumnOneName: ColumnOneType, ...) - both column names\r\n     * and column types are used.\r\n     *\r\n     * @return relational schema as a string\r\n     */\r\n    public getSchemaString(): string {\r\n        return this.name + \"(\" + [...this.columns].map(s => s[0] + \": \" + s[1]).join(\", \") + \")\";\r\n    }\r\n\r\n    /**\r\n     * Returns a relational schema in a format: RelationName(ColumnOneName, ...) - only column names are used.\r\n     *\r\n     * @return relational schema as a string\r\n     */\r\n    public getNamesSchemaString(): string {\r\n        return this.name + \"(\" + this.columnNames.join(\", \") + \")\";\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of the relation content (column names, column types and rows).\r\n     *\r\n     * @return string representation of the relation\r\n     */\r\n    public contentString(): string {\r\n        const names = this.columnNames.join(', ') + '\\n';\r\n        const types = this.columnNames.map((name) => this.columns.get(name)).join(', ') + '\\n';\r\n        const rows = [...this.rows].map(row => row.getOrderedPrintValues(this.columnNames).join(', ')).join('\\n');\r\n        return names + types + rows;\r\n    }\r\n\r\n    /**\r\n     * Custom equals function for testing purposes.\r\n     *\r\n     * @param other\r\n     */\r\n    public equals(other: any): boolean {\r\n        if (other instanceof Relation) {\r\n            return this.name === other.name &&\r\n                isEqual(this.columns, other.columns) &&\r\n                isEqual(new Set(this.rows), new Set(other.rows));\r\n        }\r\n        return false;\r\n    }\r\n}","/**\r\n * Error caused by fatal error in code of the application.\r\n */\r\nexport default class CodeError extends Error {\r\n    constructor(msg: string) {\r\n        super(msg);\r\n        if (Error.captureStackTrace) {\r\n            Error.captureStackTrace(this, CodeError);\r\n        }\r\n        this.name = 'CodeError';\r\n    }\r\n}","import {ErrorFactory, SyntaxErrorCodes} from \"../error/errorFactory\";\r\nimport RASyntaxError from \"../error/raSyntaxError\";\r\n\r\n/**\r\n * Parser providing general parsing helper functions.\r\n */\r\nexport default class Parser {\r\n\r\n    /**\r\n     * @param str Checked string\r\n     * @return true if the string contains letters only and has length at least 1\r\n     */\r\n    public static isWord(str: string): boolean {\r\n        return str.length > 0 && str.split(\"\").every(c => Parser.isLetter(c));\r\n    }\r\n\r\n    /**\r\n     * @param str Checked string\r\n     * @return true if the string contains letters, numbers and underscores only, has length at least 1 and starts with\r\n     * a letter or an underscore\r\n     */\r\n    public static isName(str: string): boolean {\r\n        if (str.length === 0) {\r\n            return false;\r\n        }\r\n        if (!Parser.isLetter(str.charAt(0)) && str.charAt(0) !== '_') {\r\n            return false;\r\n        }\r\n        return str.split(\"\").every(c => Parser.isNameChar(c));\r\n    }\r\n\r\n    /**\r\n     * @param str Checked string\r\n     * @return true if the string contains whitespaces only\r\n     */\r\n    public static isWhitespacesOnly(str: string): boolean {\r\n        const regex = /\\s*/;\r\n        const res = regex.exec(str);\r\n        return res === null ? false : res[0] === str;\r\n    }\r\n\r\n    /**\r\n     * @param c Checked character\r\n     * @return true if the given string has length one and the character is a letter\r\n     */\r\n    public static isLetter(c: string): boolean {\r\n        return c.length === 1 && c.toLowerCase() !== c.toUpperCase();\r\n    }\r\n\r\n    /**\r\n     * @param c Checked character\r\n     * @return true if the given string has length one and the character is a letter, a number or an underscore\r\n     */\r\n    public static isNameChar(c: string): boolean {\r\n        return Parser.isLetter(c) || Parser.isDigit(c) || c === '_';\r\n    }\r\n\r\n    /**\r\n     * @param c Checked character\r\n     * @return true if the given string has length one and the character is a digit\r\n     */\r\n    public static isDigit(c: string): boolean {\r\n        return c.length === 1 && c.match(/\\d/) !== null;\r\n    }\r\n\r\n    /**\r\n     * @param str Checked string\r\n     * @return true if the string represents a decimal number\r\n     */\r\n    public static isNumber(str: string): boolean {\r\n        return /^[-]?[\\d]+([.][\\d]+)?$/.test(str);\r\n    }\r\n\r\n    /**\r\n     * Splits given string to a starting sequence of letters and its rest and returns these parts in a pair.\r\n     * NOTE: if the string does not start with a letter, as a word is returned an empty string.\r\n     *\r\n     * @param str string to be split\r\n     * @return split string in a pair { word, rest }\r\n     */\r\n    public static nextWord(str: string): { first: string, second: string } {\r\n        if (str === \"\") {\r\n            return { first: \"\", second: \"\" };\r\n        }\r\n        let i: number = 0;\r\n        while (i < str.length) {\r\n            if (!Parser.isLetter(str.charAt(i))) {\r\n                return { first: str.substring(0, i), second: str.substring(i)};\r\n            }\r\n            ++i;\r\n        }\r\n        return { first: str, second: \"\"};\r\n    }\r\n\r\n    /**\r\n     * Splits given string to a starting sequence of letters, numbers and underscores, which starts with a letter or\r\n     * an underscore and its rest and returns these parts in a pair.\r\n     * NOTE: if the string does not start with a letter, or an underscore, as a name is returned an empty string.\r\n     *\r\n     * @param str string to be split\r\n     * @return split string in a pair { name, rest }\r\n     */\r\n    public static nextName(str: string): { first: string, second: string } {\r\n        if (str === \"\") {\r\n            return { first: \"\", second: \"\" };\r\n        }\r\n        if (!Parser.isLetter(str.charAt(0)) && str.charAt(0) !== '_') {\r\n            return { first: \"\", second: str };\r\n        }\r\n        let i: number = 0;\r\n        while (i < str.length) {\r\n            const char: string = str.charAt(i);\r\n            if (!Parser.isLetter(char) && !Parser.isDigit(char) && char !== '_') {\r\n                return { first: str.substring(0, i), second: str.substring(i)};\r\n            }\r\n            ++i;\r\n        }\r\n        return { first: str, second: \"\"};\r\n    }\r\n\r\n    /**\r\n     * Splits given string to a starting sequence of non-whitespace characters and its rest and returns these parts in a pair.\r\n     *\r\n     * @param str string to be split\r\n     * @return split string in a pair { word, rest }\r\n     */\r\n    public static nextNonWhitespacePart(str: string): { first: string, second: string } {\r\n        if (str === \"\") {\r\n            return { first: \"\", second: \"\" };\r\n        }\r\n        let i: number = 0;\r\n        while (i < str.length) {\r\n            if (str.charAt(i).match(/\\s/)) {\r\n                return { first: str.substring(0, i), second: str.substring(i)};\r\n            }\r\n            ++i;\r\n        }\r\n        return { first: str, second: \"\"};\r\n    }\r\n\r\n    /**\r\n     * Splits given string to a starting number and its rest and returns these parts in a pair.\r\n     * NOTE: if the string does not start with a digit, as a number is returned an empty string.\r\n     *\r\n     * @param str string to be split\r\n     * @return split string in a pair (word, rest)\r\n     */\r\n    static nextNumber(str: string): { first: string, second: string } {\r\n        if (str === \"\") {\r\n            return { first: \"\", second: \"\" };\r\n        }\r\n        let i: number = 0;\r\n        // string starts with '-' sign\r\n        if (str.charAt(0) === '-') {\r\n            // if there is a digit after '-', shifts the start\r\n            if (str.length > 1 && Parser.isDigit(str.charAt(1))) {\r\n                i = 1;\r\n            }\r\n            // there is no digit\r\n            else {\r\n                return { first: \"\", second: str };\r\n            }\r\n        }\r\n        let digitFound: boolean = false;\r\n        let dotFound: boolean = false;\r\n        while (i < str.length) {\r\n            if (Parser.isDigit(str.charAt(i))) {\r\n                digitFound = true;\r\n                ++i;\r\n            }\r\n            else if (str.charAt(i) === '.') {\r\n                // second dot or a dot without previous digits\r\n                if (dotFound || !digitFound) {\r\n                    break;\r\n                }\r\n                else {\r\n                    dotFound = true;\r\n                    ++i;\r\n                }\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        const numStr = str.substring(0, i);\r\n        const rest = str.substring(i);\r\n        return { first: numStr, second: rest };\r\n    }\r\n\r\n    /**\r\n     * Splits the given string into starting quoted part and the rest. Quotes can be escaped by an odd count of\r\n     * backslashes.\r\n     * NOTE: When the closing quote is not found until the rest of the line, unclosed string is returned\r\n     * => the error is not thrown, it is only added to the return object.\r\n     * NOTE: First character of the string is expected to be '\"'.\r\n     *\r\n     * @param str string to be split\r\n     * @return pair of the starting bordered part and the rest\r\n     */\r\n    static nextQuotedString(str: string): { first: string, second: string, error: RASyntaxError | undefined } {\r\n        let i: number = 1;\r\n        // backslashes escape the quote character only in odd count\r\n        let backslashes: number = 0;\r\n        while (i < str.length) {\r\n            const curChar = str.charAt(i);\r\n            // increases index for using \"i\" in slicing\r\n            ++i;\r\n            // found quote - changes ignoring of special chars\r\n            if (curChar === '\"' && (backslashes % 2) === 0) {\r\n                return { first: str.slice(0, i), second: str.slice(i), error: undefined };\r\n            }\r\n            // end of line breaks the string\r\n            if (curChar === '\\n') {\r\n                return {\r\n                    first: str.slice(0, i),\r\n                    second: str.slice(i),\r\n                    error: ErrorFactory.syntaxError(SyntaxErrorCodes.parser_nextBorderedPart_missingClosingChar,\r\n                        undefined, '\"', '\"')\r\n                };\r\n            }\r\n            // updates backslash count\r\n            if (curChar === '\\\\') {\r\n                ++backslashes;\r\n            }\r\n            else {\r\n                backslashes = 0;\r\n            }\r\n        }\r\n        return {\r\n            first: str,\r\n            second: \"\",\r\n            error: ErrorFactory.syntaxError(SyntaxErrorCodes.parser_nextBorderedPart_missingClosingChar,\r\n                undefined, '\"', '\"')\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Splits the string to the starting bordered part and the rest and returns these parts in a pair.\r\n     * If there is only one ending character and it differs from the starting one, nested bordering is supported.\r\n     * Characters after an odd count of escape characters are ignored and cannot start or end a bordered part.\r\n     * Starting and ending characters in quoted part are ignored, quotes can be escaped by an odd count of backslashes.\r\n     * NOTE: First character of the string is expected to be 'start'.\r\n     * NOTE: Should not be used for slicing quoted strings, use nextQuotedString instead.\r\n     * NOTE: It is expected, that there are no comments in the given string.\r\n     *\r\n     * @param str string to be split\r\n     * @param start starting character of the string and also starting character of the bordered part (one character)\r\n     * @param end ending characters of the bordered part (one or more characters)\r\n     * @param escape character which makes next character being ignored (default '\\0')\r\n     * @return pair of the starting bordered part and the rest\r\n     */\r\n    static nextBorderedPart(str: string, start: string, end: string, escape: string = '\\0'): { first: string, second: string } {\r\n        let depth: number = 1;\r\n        let i: number = 1;\r\n        // to ignore special characters in quoted part\r\n        let inQuotes: boolean = false;\r\n        // nested bordering is supported if there is only one ending character\r\n        const nesting: boolean = end.length === 1;\r\n        // backslashes escape the quote character only in odd count\r\n        let backslashes: number = 0;\r\n        // escape characters escape the end character only in odd count\r\n        let escapeCount: number = 0;\r\n        while (i < str.length) {\r\n            const curChar = str.charAt(i);\r\n            // checks end of the part (before checking start for a case when start == end)\r\n            if (end.indexOf(curChar) > -1 && (escapeCount % 2) === 0 && !inQuotes) {\r\n                --depth;\r\n            }\r\n            // checks start of the bordered part (if only one ending character was given)\r\n            else if (curChar === start && (escapeCount % 2) === 0 && nesting && !inQuotes) {\r\n                ++depth;\r\n            }\r\n            // found quote - changes ignoring of special chars\r\n            else if (curChar === '\"' && (backslashes % 2) === 0) {\r\n                inQuotes = !inQuotes;\r\n            }\r\n            // updates escape chars count\r\n            if (curChar === escape) {\r\n                ++escapeCount;\r\n            }\r\n            else {\r\n                escapeCount = 0;\r\n            }\r\n            // updates backslash count\r\n            if (curChar === '\\\\') {\r\n                ++backslashes;\r\n            }\r\n            else {\r\n                backslashes = 0;\r\n            }\r\n            // increases index for using \"i\" in slicing\r\n            ++i;\r\n            if (depth === 0) {\r\n                return { first: str.slice(0, i), second: str.slice(i) };\r\n            }\r\n        }\r\n        throw ErrorFactory.syntaxError(SyntaxErrorCodes.parser_nextBorderedPart_missingClosingChar, undefined,\r\n            end.split('').join(\"' or '\"), start);\r\n    }\r\n\r\n    /**\r\n     * Skips all whitespaces and exactly one given character and returns rest of the string.\r\n     * If the string does not match this pattern, throws error.\r\n     *\r\n     * @param str string to be skipped in\r\n     * @param char char to be skipped exactly one time (expected to be string of length 1)\r\n     * @return given string without starting sequence of whitespaces and exactly one char\r\n     */\r\n    public static skipWhitespacesAndChar(str: string, char: string): string {\r\n        let charFound: boolean = false;\r\n        let i: number = 0;\r\n        while (i < str.length) {\r\n            if (str.charAt(i).match(/\\s/)) {\r\n                ++i;\r\n            }\r\n            else if (str.charAt(i) === char && !charFound) {\r\n                charFound = true;\r\n                ++i;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        if (!charFound) {\r\n            throw ErrorFactory.syntaxError(SyntaxErrorCodes.parser_skipWhitespacesAndChar_charNotFound, undefined, char);\r\n        }\r\n        return str.substring(i);\r\n    }\r\n\r\n    /**\r\n     * Deletes all line contents after '//'.\r\n     *\r\n     * @param str string to be deleted comments in\r\n     */\r\n    public static deleteCommentLines(str: string) {\r\n        return str.split('\\n').map(line => {\r\n            let insideQuotes: boolean = false;\r\n            let backslashes: number = 0;\r\n            for (let i = 0; i < line.length; ++i) {\r\n                const curChar = line.charAt(i);\r\n                // quotes found\r\n                if (curChar === '\"' && (backslashes % 2) === 0) {\r\n                    insideQuotes = !insideQuotes;\r\n                }\r\n                if (insideQuotes && curChar === '\\\\') {\r\n                    ++backslashes;\r\n                }\r\n                else {\r\n                    backslashes = 0;\r\n                }\r\n                // double-backslash found outside quotes\r\n                if (!insideQuotes && curChar === '/' && i > 0 && line.charAt(i - 1) === '/') {\r\n                    return line.slice(0, i - 1);\r\n                }\r\n            }\r\n            return line;\r\n        }).join('\\n');\r\n    }\r\n}","import {IndexedString} from \"./indexedString\";\r\nimport Parser from \"./parser\";\r\nimport {insertRangeIfUndefined} from \"../error/errorWithTextRange\";\r\nimport RASyntaxError from \"../error/raSyntaxError\";\r\n\r\n/**\r\n * IndexedParser providing general parsing helper functions for IndexedString. It wraps Parser methods for IndexedStrings.\r\n */\r\nexport default class ParserIndexed {\r\n\r\n    /**\r\n     * @param str Checked indexed string\r\n     * @return true if the string contains letters only and has length at least 1\r\n     */\r\n    public static isWord(str: IndexedString): boolean {\r\n        return Parser.isWord(str.toString());\r\n    }\r\n\r\n    /**\r\n     * @param str Checked string\r\n     * @return true if the string contains letters, numbers and underscores only, has length at least 1 and starts with\r\n     * a letter or an underscore\r\n     */\r\n    public static isName(str: IndexedString): boolean {\r\n        return Parser.isName(str.toString());\r\n    }\r\n\r\n    /**\r\n     * @param str Checked string\r\n     * @return true if the string contains whitespaces only\r\n     */\r\n    public static isWhitespacesOnly(str: IndexedString): boolean {\r\n        return Parser.isWhitespacesOnly(str.toString());\r\n    }\r\n\r\n    /**\r\n     * @param c Checked character\r\n     * @return true if the given string has length one and the character is a letter\r\n     */\r\n    public static isLetter(c: IndexedString): boolean {\r\n        return Parser.isLetter(c.toString());\r\n    }\r\n\r\n    /**\r\n     * @param c Checked character\r\n     * @return true if the given string has length one and the character is a letter, a number or an underscore\r\n     */\r\n    public static isNameChar(c: IndexedString): boolean {\r\n        return Parser.isNameChar(c.toString());\r\n    }\r\n\r\n    /**\r\n     * @param c Checked character\r\n     * @return true if the given string has length one and the character is a digit\r\n     */\r\n    public static isDigit(c: IndexedString): boolean {\r\n        return Parser.isDigit(c.toString());\r\n    }\r\n\r\n    /**\r\n     * @param str Checked string\r\n     * @return true if the string represents a decimal number\r\n     */\r\n    public static isNumber(str: IndexedString): boolean {\r\n        return Parser.isNumber(str.toString());\r\n    }\r\n\r\n    /**\r\n     * Splits given indexed string to a starting sequence of letters and its rest and returns these parts in a pair.\r\n     * NOTE: if the string does not start with a letter, as a word is returned an empty string.\r\n     *\r\n     * @param str indexed string to be split\r\n     * @return split indexed string in a pair { word, rest }\r\n     */\r\n    public static nextWord(str: IndexedString): { first: IndexedString, second: IndexedString } {\r\n        const strParts: { first: string, second: string } = Parser.nextWord(str.toString());\r\n        return { first: str.slice(0, strParts.first.length), second: str.slice(strParts.first.length)};\r\n    }\r\n\r\n    /**\r\n     * Splits given indexed string to a starting sequence of letters, numbers and underscores, which starts with a letter or\r\n     * an underscore and its rest and returns these parts in a pair.\r\n     * NOTE: if the string does not start with a letter, or an underscore, as a name is returned an empty string.\r\n     *\r\n     * @param str string to be split\r\n     * @return split indexed string in a pair { name, rest }\r\n     */\r\n    public static nextName(str: IndexedString): { first: IndexedString, second: IndexedString } {\r\n        const strParts: { first: string, second: string } = Parser.nextName(str.toString());\r\n        return { first: str.slice(0, strParts.first.length), second: str.slice(strParts.first.length)};\r\n    }\r\n\r\n    /**\r\n     * Splits given indexed string to a starting sequence of non-whitespace characters and its rest and returns these\r\n     * parts in a pair.\r\n     *\r\n     * @param str string to be split\r\n     * @return split indexed string in a pair { name, rest }\r\n     */\r\n    public static nextNonWhitespacePart(str: IndexedString): { first: IndexedString, second: IndexedString } {\r\n        const strParts: { first: string, second: string } = Parser.nextNonWhitespacePart(str.toString());\r\n        return { first: str.slice(0, strParts.first.length), second: str.slice(strParts.first.length)};\r\n    }\r\n\r\n    /**\r\n     * Splits given indexed string to a starting number and its rest and returns these parts in a pair.\r\n     * NOTE: if the string does not start with a digit, as a number is returned an empty string.\r\n     *\r\n     * @param str indexed string to be split\r\n     * @return split indexed string in a pair (word, rest)\r\n     */\r\n    static nextNumber(str: IndexedString): { first: IndexedString, second: IndexedString } {\r\n        const strParts: { first: string, second: string } = Parser.nextNumber(str.toString());\r\n        return { first: str.slice(0, strParts.first.length), second: str.slice(strParts.first.length)};\r\n    }\r\n\r\n    /**\r\n     * Splits the given indexed string into starting quoted part and the rest. Quotes can be escaped by an odd count of\r\n     * backslashes.\r\n     * NOTE: When the closing quote is not found until the rest of the line, unclosed string is returned\r\n     * => the error is not thrown, it is only added to the return object.\r\n     * NOTE: First character of the string is expected to be '\"'.\r\n     *\r\n     * @param str string to be split\r\n     * @return pair of the starting bordered part and the rest\r\n     */\r\n    static nextQuotedString(str: IndexedString): { first: IndexedString, second: IndexedString, error: RASyntaxError | undefined } {\r\n        const strParts: { first: string, second: string, error: RASyntaxError | undefined } = Parser.nextQuotedString(str.toString());\r\n        const startIndex = str.getFirstNonNaNIndex();\r\n        if (startIndex !== undefined) {\r\n            strParts.error = insertRangeIfUndefined(strParts.error, {start: startIndex, end: startIndex});\r\n        }\r\n        return {\r\n            first: str.slice(0, strParts.first.length),\r\n            second: str.slice(strParts.first.length),\r\n            error: strParts.error\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Splits the indexed string to the starting bordered part and the rest and returns these parts in a pair.\r\n     * If there is only one ending character and it differs from the starting one, nested bordering is supported.\r\n     * Characters after escape character are ignored and cannot start or end a bordered part.\r\n     * Starting and ending characters in quoted part are ignored.\r\n     * NOTE: First character of the string is expected to be 'start'.\r\n     * NOTE: Should not be used for slicing quoted strings, use nextQuotedString instead.\r\n     * NOTE: It is expected, that there are no comments in the given string.\r\n     *\r\n     * @param str indexed string to be split\r\n     * @param start starting character of the string and also starting character of the bordered part (one character)\r\n     * @param end ending characters of the bordered part (one or more characters)\r\n     * @param escape character which makes next character being ignored (default '\\0')\r\n     * @return pair of the starting bordered part and the rest as indexed strings\r\n     */\r\n    static nextBorderedPart(str: IndexedString, start: string, end: string, escape: string = '\\0'):\r\n        { first: IndexedString, second: IndexedString } {\r\n        try {\r\n            const strParts: { first: string, second: string } = Parser.nextBorderedPart(str.toString(), start, end, escape);\r\n            return { first: str.slice(0, strParts.first.length), second: str.slice(strParts.first.length)};\r\n        }\r\n        catch (err) {\r\n            const startIndex = str.getFirstNonNaNIndex();\r\n            if (startIndex !== undefined) {\r\n                throw insertRangeIfUndefined(err, {start: startIndex, end: startIndex});\r\n            }\r\n            throw err;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Skips all whitespaces and exactly one given character and returns rest of the string.\r\n     * If the string does not match this pattern, throws error.\r\n     *\r\n     * @param str string to be skipped in\r\n     * @param char char to be skipped exactly one time (expected to be string of length 1)\r\n     * @return given string without starting sequence of whitespaces and exactly one char\r\n     */\r\n    public static skipWhitespacesAndChar(str: IndexedString, char: string): IndexedString {\r\n        try {\r\n            const skippedStr: string = Parser.skipWhitespacesAndChar(str.toString(), char);\r\n            return str.slice(str.length() - skippedStr.length);\r\n        }\r\n        catch (err) {\r\n            throw insertRangeIfUndefined(err, str.getNonNaNRange());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes all lines, where two first non-whitespace characters are '//'.\r\n     *\r\n     * @param str indexed string to be deleted comments in\r\n     */\r\n    public static deleteCommentLines(str: IndexedString) {\r\n        const {split, separatorIndexes} = str.splitToLines();\r\n        const toJoin = split.map((line, lineNum) => {\r\n            let insideQuotes: boolean = false;\r\n            let backslashes: number = 0;\r\n            for (let i = 0; i < line.length(); ++i) {\r\n                const curChar = line.charAt(i);\r\n                // quotes found\r\n                if (curChar === '\"' && (backslashes % 2) === 0) {\r\n                    insideQuotes = !insideQuotes;\r\n                }\r\n                if (insideQuotes && curChar === '\\\\') {\r\n                    ++backslashes;\r\n                }\r\n                else {\r\n                    backslashes = 0;\r\n                }\r\n                // double-backslash found outside quotes\r\n                if (!insideQuotes && curChar === '/' && i > 0 && line.charAt(i - 1) === '/') {\r\n                    return line.slice(0, i - 1);\r\n                }\r\n            }\r\n            return line;\r\n        });\r\n        return IndexedString.join(toJoin, '\\n', separatorIndexes);\r\n    }\r\n}","import ParserIndexed from \"./parserIndexed\";\r\nimport Parser from \"./parser\";\r\nimport RASyntaxError from \"../error/raSyntaxError\";\r\n\r\n/**\r\n * Immutable string representation with index of each character. Provides some usual string functions.\r\n */\r\nexport class IndexedString {\r\n\r\n    /**\r\n     * Creates a new IndexedString instance representing the given string. StartIndex is used as the offset for indexes.\r\n     * When the startIndex is omitted, 0 is used. When NaN is given, all indexes are NaN.\r\n     * Indexes of the characters are (0 + startIndex, ..., str.length - 1 + startIndex).\r\n     * NOTE: Each character has its own index. That means '\\r\\n' line separator has two indexes. For expected behavior, use\r\n     * '\\n' separator instead.\r\n     *\r\n     * @param str string\r\n     * @param startIndex\r\n     */\r\n    public static new(str: string, startIndex: number = 0): IndexedString {\r\n        return new IndexedString(str, str.split('').map((char, index) => {return {char: char, index: index + startIndex}}));\r\n    }\r\n\r\n    /**\r\n     * Creates a new IndexedString instance representing an empty string \"\".\r\n     */\r\n    public static empty(): IndexedString {\r\n        return new IndexedString('', []);\r\n    }\r\n\r\n    /**\r\n     * Creates a new IndexedString instance representing the given array of IndexedChars.\r\n     * The array is deep copied for immutability.\r\n     *\r\n     * @param arr IndexedChar array\r\n     */\r\n    public static newFromArray(arr: IndexedChar[]): IndexedString {\r\n        return new IndexedString(arr.map(ic => ic.char).join(''), arr.map(ic => {return {char: ic.char, index: ic.index}}));\r\n    }\r\n\r\n    /**\r\n     * Joins given array of IndexedStrings with given separator. Inserted separators have indexed given from the\r\n     * separatorIndexes array. NOTE: separatorIndexes array is expected to have length at least \"arr.length - 1\".\r\n     *\r\n     * @param arr array to join\r\n     * @param separator separator string\r\n     * @param separatorIndexes\r\n     */\r\n    public static join(arr: IndexedString[], separator: string, separatorIndexes: number[]): IndexedString {\r\n        if (arr.length === 0) {\r\n            return IndexedString.empty();\r\n        }\r\n        if (arr.length === 1) {\r\n            return arr[0];\r\n        }\r\n        const toConcat: IndexedString[] = Array<IndexedString>(2 * arr.length - 2);\r\n        for (let i = 1; i < arr.length; i++) {\r\n            toConcat[2 * i - 2] = IndexedString.new(separator, separatorIndexes[i - 1]);\r\n            toConcat[2 * i - 1] = arr[i];\r\n        }\r\n        return arr[0].concat(...toConcat);\r\n    }\r\n\r\n    /**\r\n     * Private constructor to ensure compatible string and IndexCharArray.\r\n     *\r\n     * @param str string representation\r\n     * @param chars IndexedChar representation\r\n     */\r\n    private constructor(private readonly str: string, private readonly chars: IndexedChar[]) { }\r\n\r\n    /**\r\n     * Returns string representation of the IndexedString.\r\n     */\r\n    public toString(): string {\r\n        return this.str;\r\n    }\r\n\r\n    /**\r\n     * Returns length of the string.\r\n     */\r\n    public length(): number {\r\n        return this.str.length;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the IndexedString represents an empty string \"\".\r\n     */\r\n    public isEmpty(): boolean {\r\n        return this.length() === 0;\r\n    }\r\n\r\n    /**\r\n     * Returns IndexedChar array representing the IndexedString.\r\n     * The array is reference to inner IndexedString structure.\r\n     */\r\n    public getChars(): IndexedChar[] {\r\n        return this.chars;\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the first character of the IndexedString. Returns undefined if empty.\r\n     */\r\n    public getFirstIndex(): number | undefined {\r\n        if (this.isEmpty()) {\r\n            return undefined;\r\n        }\r\n        return this.chars[0].index;\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the last character of the IndexedString. Returns undefined if empty.\r\n     */\r\n    public getLastIndex(): number | undefined {\r\n        if (this.isEmpty()) {\r\n            return undefined;\r\n        }\r\n        return this.chars[this.length() - 1].index;\r\n    }\r\n\r\n    /**\r\n     * Returns the first non-NaN index of a character of the IndexedString. Returns undefined if empty.\r\n     * If all indexes are NaN, NaN is returned.\r\n     */\r\n    public getFirstNonNaNIndex(): number | undefined {\r\n        if (this.isEmpty()) {\r\n            return undefined;\r\n        }\r\n        for (let i = 0; i < this.length(); i++) {\r\n            if (!isNaN(this.chars[i].index)) {\r\n                return this.chars[i].index;\r\n            }\r\n        }\r\n        return NaN;\r\n    }\r\n\r\n    /**\r\n     * Returns the last non-NaN index of a character of the IndexedString. Returns undefined if empty.\r\n     * If all indexes are NaN, NaN is returned.\r\n     */\r\n    public getLastNonNaNIndex(): number | undefined {\r\n        if (this.isEmpty()) {\r\n            return undefined;\r\n        }\r\n        for (let i = this.length() - 1; i >= 0; i--) {\r\n            if (!isNaN(this.chars[i].index)) {\r\n                return this.chars[i].index;\r\n            }\r\n        }\r\n        return NaN;\r\n    }\r\n\r\n    /**\r\n     * Returns indexes of the first and the last character of the IndexedString. Returns undefined if empty.\r\n     */\r\n    public getRange(): {start: number, end: number} | undefined {\r\n        if (this.isEmpty()) {\r\n            return undefined;\r\n        }\r\n        return { start: this.chars[0].index, end: this.chars[this.length() - 1].index };\r\n    }\r\n\r\n    /**\r\n     * Returns the first and the last non-NaN indexes of characters of the IndexedString. Returns undefined if empty or\r\n     * if all indexes are NaN.\r\n     */\r\n    public getNonNaNRange(): {start: number, end: number} | undefined {\r\n        if (this.isEmpty()) {\r\n            return undefined;\r\n        }\r\n        // @ts-ignore\r\n        const start: number = this.getFirstNonNaNIndex();\r\n        // returns undefined when all indexes are NaN\r\n        if (isNaN(start)) {\r\n            return undefined;\r\n        }\r\n        // @ts-ignore\r\n        const end: number = this.getLastNonNaNIndex();\r\n        return { start: start, end: end };\r\n    }\r\n\r\n    /**\r\n     * Returns an IndexedString representation of the character at the given index. Throws RangeError if the index is\r\n     * out of string bounds.\r\n     *\r\n     * @param index number\r\n     */\r\n    public indexedCharAt(index: number): IndexedString {\r\n        if (index < 0 || index >= this.length()) {\r\n            throw new RangeError();\r\n        }\r\n        return IndexedString.newFromArray([this.chars[index]]);\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of the character at the given index. Throws RangeError if the index is\r\n     * out of IndexedString bounds.\r\n     *\r\n     * @param index\r\n     */\r\n    public charAt(index: number): string {\r\n        if (index < 0 || index >= this.length()) {\r\n            throw new RangeError();\r\n        }\r\n        return this.chars[index].char;\r\n    }\r\n\r\n    /**\r\n     * Returns an original position index of the character at the given current index. Throws RangeError if the given index is\r\n     * out of IndexedString bounds.\r\n     *\r\n     * @param index\r\n     */\r\n    public indexAt(index: number): number {\r\n        if (index < 0 || index >= this.length()) {\r\n            throw new RangeError();\r\n        }\r\n        return this.chars[index].index;\r\n    }\r\n\r\n    /**\r\n     * Split a string into substrings using the specified separator and return them as an array.\r\n     * It does not accept RegEx separators and array limit as built-in string.\r\n     *\r\n     * @param separator string separator\r\n     */\r\n    public split(separator: string): IndexedString[] {\r\n        if (this.isEmpty()) {\r\n            if (separator === '') {\r\n                return [];\r\n            }\r\n            return [IndexedString.empty()];\r\n        }\r\n        const sepLen: number = separator.length;\r\n        const strSplit: string[] = this.str.split(separator);\r\n        const prefixSum: number[] = Array<number>(strSplit.length);\r\n        prefixSum[0] = 0;\r\n        for (let i = 1; i < strSplit.length; i++) {\r\n            prefixSum[i] = prefixSum[i - 1] + strSplit[i - 1].length + sepLen;\r\n        }\r\n\r\n        return strSplit.map((strSplit, index) => {\r\n            return new IndexedString(strSplit, this.chars.slice(prefixSum[index], prefixSum[index] + strSplit.length));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Split a string into substrings using the '\\n' separator and return them as an array.\r\n     * Also, it returns indexes of removed '\\n's.\r\n     */\r\n    public splitToLines(): {split: IndexedString[], separatorIndexes: number[]} {\r\n        if (this.isEmpty()) {\r\n            return {split: [IndexedString.empty()], separatorIndexes: []};\r\n        }\r\n        const strSplit: string[] = this.str.split('\\n');\r\n        const strSplitLenMinusOne = strSplit.length - 1;\r\n        const prefixSum: number[] = Array<number>(strSplit.length);\r\n        const separatorIndexes: number[] = Array<number>(strSplit.length - 1);\r\n        prefixSum[0] = 0;\r\n        for (let i = 0; i < strSplitLenMinusOne; i++) {\r\n            const ps = prefixSum[i] + strSplit[i].length + 1;\r\n            separatorIndexes[i] = this.indexAt(ps - 1);\r\n            prefixSum[i + 1] = ps;\r\n        }\r\n\r\n        const split = strSplit.map((strSplit, index) => {\r\n            return new IndexedString(strSplit, this.chars.slice(prefixSum[index], prefixSum[index] + strSplit.length));\r\n        });\r\n        return {split, separatorIndexes};\r\n    }\r\n\r\n    /**\r\n     * Returns a section of a IndexedString.\r\n     *\r\n     * @param start The index of the beginning of the specified portion of stringObj.\r\n     * @param end The index of the end of the specified portion of IndexedString. The substring includes the characters\r\n     * up to, but not including, the character indicated by end. If this value is not specified, the substring\r\n     * continues to the end of IndexedString.\r\n     */\r\n    public slice(start: number, end?: number): IndexedString {\r\n        const _start = start < 0 ? this.length() + start : start;\r\n        const _end = end !== undefined ? (end < 0 ? this.length() + end : end) : this.length();\r\n        if (_start > _end || _start < 0 || _end > this.length()) {\r\n            throw new RangeError();\r\n        }\r\n        return IndexedString.newFromArray(this.chars.slice(_start, _end));\r\n    }\r\n\r\n    /**\r\n     * Removes the leading and trailing white space and line terminator characters from a string.\r\n     */\r\n    public trim(): IndexedString {\r\n        const trimStr: string = this.str.trim();\r\n        if (trimStr === '') {\r\n            return new IndexedString('', []);\r\n        }\r\n        const start: number = this.str.indexOf(trimStr.charAt(0));\r\n        return IndexedString.newFromArray(this.chars.slice(start, start + trimStr.length));\r\n    }\r\n\r\n    /**\r\n     * Returns a string that contains the concatenation of this IndexedString with multiple other.\r\n     *\r\n     * @param strings The IndexedStrings to append to the end of the string.\r\n     */\r\n    public concat(...strings: IndexedString[]) {\r\n        return IndexedString.newFromArray(this.chars.concat(...strings.map(is => is.chars)));\r\n    }\r\n\r\n    /**\r\n     * Returns true if the searchString sequence is the same as the corresponding\r\n     * elements of this object starting at position. Otherwise returns false.\r\n     *\r\n     * @param searchString\r\n     * @param position\r\n     */\r\n    public startsWith(searchString: string, position?: number | undefined): boolean {\r\n        return this.str.startsWith(searchString, position);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the searchString sequence is the same as the corresponding\r\n     * elements of this object starting at endPosition – searchString.length. Otherwise returns false.\r\n     *\r\n     * @param searchString\r\n     * @param position\r\n     */\r\n    public endsWith(searchString: string, position?: number | undefined): boolean {\r\n        return this.str.endsWith(searchString, position);\r\n    }\r\n\r\n    /**\r\n     * Replaces text in a string, using a regular expression or search string.\r\n     * NOTE: Returns built-in string.\r\n     *\r\n     * @param searchValue A string or RegEx to search for.\r\n     * @param replaceValue A string containing the text to replace for every successful match of searchValue in this string.\r\n     */\r\n    public replace(searchValue: string | RegExp, replaceValue: string): string {\r\n        return this.str.replace(searchValue, replaceValue);\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first occurrence of a substring.\r\n     *\r\n     * @param searchValue The substring to search for in the string\r\n     * @param fromIndex The index at which to begin searching the String object. If omitted, search starts at the beginning of the string.\r\n     */\r\n    public indexOf(searchValue: string, fromIndex?: number): number {\r\n        return this.str.indexOf(searchValue, fromIndex);\r\n    }\r\n\r\n    /**\r\n     * Matches a string with a regular expression, and returns an array containing the results of that search.\r\n     *\r\n     * @param regexp A variable name or string literal containing the regular expression pattern and flags.\r\n     */\r\n    public match(regexp: string | RegExp): RegExpMatchArray | null {\r\n        return this.str.match(regexp);\r\n    }\r\n\r\n    /**\r\n     * Creates a deep copy of the IndexedString.\r\n     */\r\n    public copy(): IndexedString {\r\n        return new IndexedString(this.str, this.chars.map(ic => {return {char: ic.char, index: ic.index}}));\r\n    }\r\n\r\n    /**\r\n     * Returns deep copy of the string with all whitespaces removed.\r\n     */\r\n    public removeWhitespaces(): IndexedString {\r\n        return new IndexedString(this.str.replace(/\\s/g, ''), this.chars\r\n            .filter(ic => {return !/\\s/.test(ic.char)})\r\n            .map(ic => {return {char: ic.char, index: ic.index}})\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns next index of the string (this.getLastIndex() + 1), if last index of the string is a number.\r\n     * Otherwise, returns NaN.\r\n     */\r\n    public getNextIndexOrNaN(): number {\r\n        const lastIndex = this.getLastIndex();\r\n        return lastIndex === undefined ? NaN : lastIndex + 1;\r\n    }\r\n}\r\n\r\n/**\r\n * Indexed representation of one character.\r\n * WARNING: It is always assumed that IndexedChar.char is a string of length 1.\r\n */\r\nexport interface IndexedChar {\r\n    char: string,\r\n    index: number\r\n}\r\n\r\n/**\r\n * Gets string range: when IndexedString given, returns str.getNonNaNRange(), when string given, returns undefined.\r\n *\r\n * @param str string to get the range of\r\n */\r\nexport function getRange(str: string | IndexedString): {start: number, end: number} | undefined {\r\n    return (str instanceof IndexedString) ? str.getNonNaNRange() : undefined;\r\n}\r\n\r\n/**\r\n * Gets strings length.\r\n *\r\n * @param str string to get the length of\r\n */\r\nexport function length(str: string | IndexedString): number {\r\n    return (str instanceof IndexedString) ? str.length() : str.length;\r\n}\r\n\r\n/**\r\n * Returns true if the given string is empty.\r\n *\r\n * @param str\r\n */\r\nexport function isEmpty(str: string | IndexedString): boolean {\r\n    if (str instanceof IndexedString) {\r\n        return str.isEmpty();\r\n    }\r\n    return str === \"\";\r\n}\r\n\r\n/**\r\n * Returns next quoted part of the given string. Returned parts are of the same type as the argument.\r\n * See Parser.nextQuotedString for details.\r\n */\r\nexport function nextQuotedString(str: string | IndexedString): { first: string, second: string, error: RASyntaxError | undefined } |\r\n    { first: IndexedString, second: IndexedString, error: RASyntaxError | undefined } {\r\n    if (str instanceof IndexedString) {\r\n        return ParserIndexed.nextQuotedString(str);\r\n    }\r\n    return Parser.nextQuotedString(str);\r\n}\r\n\r\n/**\r\n * Returns next bordered part of the given string. Returned parts are of the same type as the argument.\r\n * See Parser.nextBorderedPart for details.\r\n */\r\nexport function nextBorderedPart(str: string | IndexedString, start: string, end: string, escape?: string):\r\n    {first: IndexedString, second: IndexedString} | {first: string, second: string} {\r\n    if (str instanceof IndexedString) {\r\n        return ParserIndexed.nextBorderedPart(str, start, end, escape);\r\n    }\r\n    return Parser.nextBorderedPart(str, start, end, escape);\r\n}\r\n\r\n/**\r\n * Returns true if the string str contains any of the characters from string chars. Otherwise, returns false.\r\n *\r\n * @param str\r\n * @param chars\r\n */\r\nexport function containsAny(str: string | IndexedString, chars: string): boolean {\r\n    for (let i = 0; i < chars.length; ++i) {\r\n        if (str.indexOf(chars[i]) > -1) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}","import {BinaryNodeClass} from \"../ratree/binaryNode\";\r\nimport {getRange, IndexedString} from \"../tools/indexedString\";\r\nimport {UnaryNodeClass} from \"../ratree/unaryNode\";\r\n\r\n/**\r\n * Abstract parent class for all RATokens.\r\n */\r\nexport abstract class ExprToken {\r\n    protected constructor(public readonly str: string | IndexedString) {\r\n    }\r\n\r\n    /**\r\n     * Gets token start and end index in the text (if the token has IndexedString representation) or undefined.\r\n     */\r\n    public getRange(): {start: number, end: number} | undefined {\r\n        return getRange(this.str);\r\n    }\r\n}\r\n\r\n/**\r\n * Parentheses.\r\n */\r\nexport abstract class ParenthesisToken extends ExprToken {}\r\n\r\nexport class OpeningParentheses extends ParenthesisToken {\r\n    public constructor(str: string | IndexedString) {\r\n        super(str);\r\n    }\r\n}\r\n\r\nexport class ClosingParentheses extends ParenthesisToken {\r\n    public constructor(str: string | IndexedString) {\r\n        super(str);\r\n    }\r\n}\r\n\r\n/**\r\n * Relation reference.\r\n */\r\nexport class RelationToken extends ExprToken {\r\n    public constructor(name: string | IndexedString) {\r\n        super(name);\r\n    }\r\n}\r\n\r\n/**\r\n * Unary operators.\r\n */\r\nexport class UnaryOperatorToken extends ExprToken {\r\n\r\n    public static selection(selection: string | IndexedString) {\r\n        return new UnaryOperatorToken(selection, \"selection\");\r\n    }\r\n\r\n    public static projection(projection: string | IndexedString) {\r\n        return new UnaryOperatorToken(projection, \"projection\");\r\n    }\r\n\r\n    public static rename(rename: string | IndexedString) {\r\n        return new UnaryOperatorToken(rename, \"rename\");\r\n    }\r\n\r\n    private constructor(str: string | IndexedString, public readonly type: UnaryNodeClass) {\r\n        super(str);\r\n    }\r\n}\r\n\r\n/**\r\n * Precedence values for binary operators (highest to lowest). As there is no fixed precedence order for RA and set\r\n * operation, we chose the following.\r\n */\r\nconst precedenceLevelA: number = 10;\r\nconst cartesianPrecedence: number = precedenceLevelA;\r\nconst naturalPrecedence: number = precedenceLevelA;\r\nconst thetaPrecedence: number = precedenceLevelA;\r\n\r\nconst precedenceLevelB: number = precedenceLevelA - 1;\r\nconst semiPrecedence: number = precedenceLevelB;\r\nconst antiPrecedence: number = precedenceLevelB;\r\nconst thetaSemiPrecedence: number = precedenceLevelB;\r\n\r\nconst precedenceLevelC: number = precedenceLevelB - 1;\r\nconst outerPrecedence: number = precedenceLevelC;\r\n\r\nconst precedenceLevelD: number = precedenceLevelC - 1;\r\nconst divisionPrecedence: number = precedenceLevelD;\r\n\r\nconst precedenceLevelE: number = precedenceLevelD - 1;\r\nconst intersectionPrecedence: number = precedenceLevelE;\r\n\r\nconst precedenceLevelF: number = precedenceLevelE - 1;\r\nconst differencePrecedence: number = precedenceLevelF;\r\n\r\nconst precedenceLevelG: number = precedenceLevelF - 1;\r\nconst unionPrecedence: number = precedenceLevelG;\r\n\r\n/**\r\n * Binary operators.\r\n */\r\nexport class BinaryOperatorToken extends ExprToken {\r\n\r\n    static naturalJoin(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, naturalPrecedence, \"natural join\");\r\n    }\r\n\r\n    static cartesianProduct(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, cartesianPrecedence, \"cartesian product\");\r\n    }\r\n\r\n    static union(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, unionPrecedence, \"union\");\r\n    }\r\n\r\n    static intersection(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, intersectionPrecedence, \"intersection\");\r\n    }\r\n\r\n    static difference(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, differencePrecedence, \"difference\");\r\n    }\r\n\r\n    static leftSemijoin(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, semiPrecedence, \"left semijoin\");\r\n    }\r\n\r\n    static rightSemijoin(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, semiPrecedence, \"right semijoin\");\r\n    }\r\n\r\n    static leftAntijoin(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, antiPrecedence, \"left antijoin\");\r\n    }\r\n\r\n    static rightAntijoin(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, antiPrecedence, \"right antijoin\");\r\n    }\r\n\r\n    static thetaJoin(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, thetaPrecedence, \"theta join\");\r\n    }\r\n\r\n    static leftThetaSemijoin(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, thetaSemiPrecedence, \"left theta semijoin\");\r\n    }\r\n\r\n    static rightThetaSemijoin(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, thetaSemiPrecedence, \"right theta semijoin\");\r\n    }\r\n\r\n    static fullOuterJoin(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, outerPrecedence, \"full outer join\");\r\n    }\r\n\r\n    static leftOuterJoin(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, outerPrecedence, \"left outer join\");\r\n    }\r\n\r\n    static rightOuterJoin(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, outerPrecedence, \"right outer join\");\r\n    }\r\n\r\n    static division(str: string | IndexedString): BinaryOperatorToken {\r\n        return new BinaryOperatorToken(str, divisionPrecedence, \"division\");\r\n    }\r\n\r\n    private constructor(str: string | IndexedString, public readonly precedence: number, public readonly type: BinaryNodeClass) {\r\n        super(str);\r\n    }\r\n}","import Relation from \"../relation/relation\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\n\r\n/**\r\n * Abstract general node of the relational algebra syntactic tree.\r\n */\r\nexport default abstract class RATreeNode {\r\n\r\n    protected resultRelation: Relation | undefined;\r\n\r\n    protected constructor() {\r\n    }\r\n\r\n    /**\r\n     * Evaluates the RA query in this node and its subtree.\r\n     * After successful call, this.resultRelation must be set to valid Relation.\r\n     */\r\n    public abstract eval(): void;\r\n\r\n    /**\r\n     * Evaluates the RA query in this node and its subtree.\r\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\r\n     * Otherwise returns the result relation schema (only column names, no rows).\r\n     * When an error occurs, it is faked to work, and adds it to the errors array.\r\n     *\r\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper\r\n     */\r\n    public abstract fakeEval(cursorIndex: number): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]};\r\n\r\n    /**\r\n     * @return true if this node and its subtree was already evaluated\r\n     */\r\n    public isEvaluated(): boolean {\r\n        return this.resultRelation !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Returns the resulting relation. The node and its subtree is evaluated if it was not evaluated before.\r\n     *\r\n     * @return resulting relation gained by evaluating this node and its subtree\r\n     */\r\n    public getResult(): Relation {\r\n        if (this.resultRelation === undefined) {\r\n            this.eval();\r\n        }\r\n        // @ts-ignore\r\n        return this.resultRelation;\r\n    }\r\n\r\n    /**\r\n     * Creates a string with a structure of the RA tree in one line.\r\n     *\r\n     * @return string with a structure of the RA tree in one line\r\n     */\r\n    public abstract printInLine(): string;\r\n\r\n    /**\r\n     * Return the word name of the RA operation of the node.\r\n     * Example: returns \"Selection\" for SelectionNode.\r\n     *\r\n     * @return name of the RA operation of the node\r\n     */\r\n    public abstract getOperationName(): string;\r\n\r\n    /**\r\n     * Return the symbolic representation of the RA operation of the node.\r\n     * Example: returns \"(some + expr = 15)\" for SelectionNode.\r\n     *\r\n     * @return name of the RA operation of the node\r\n     */\r\n    public abstract getOperationSymbol(): string;\r\n}","import Relation from \"../relation/relation\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\n\r\n/**\r\n * Leave node of the relational algebra syntactic tree with reference to a source relation.\r\n */\r\nexport default class RelationNode extends RATreeNode {\r\n\r\n    public constructor(relation: Relation) {\r\n        super();\r\n        this.resultRelation = relation;\r\n    }\r\n\r\n    public eval(): void {\r\n        // nothing to evaluate\r\n    }\r\n\r\n    public fakeEval(cursorIndex: number): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} {\r\n        // @ts-ignore\r\n        return {result: this.resultRelation, whispers: [], errors: []};\r\n    }\r\n\r\n    public printInLine(): string {\r\n        // @ts-ignore\r\n        return this.resultRelation.getName();\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        // @ts-ignore\r\n        return this.resultRelation.getName();\r\n    }\r\n\r\n    public getOperationSymbol(): string {\r\n        return \"\";\r\n    }\r\n}","import RATreeNode from \"./raTreeNode\";\r\n\r\n/**\r\n * Classes extending unary node.\r\n */\r\nexport type UnaryNodeClass = \"rename\" | \"projection\" | \"selection\";\r\n\r\n/**\r\n * Abstract node of the relational algebra syntactic tree with one subtree.\r\n */\r\nexport default abstract class UnaryNode extends RATreeNode {\r\n\r\n    protected subtree: RATreeNode;\r\n\r\n    protected constructor(subtree: RATreeNode) {\r\n        super();\r\n        this.subtree = subtree;\r\n    }\r\n\r\n    public getSubtree(): RATreeNode {\r\n        return this.subtree;\r\n    }\r\n}","import {ColumnContent, SupportedColumnType} from \"./columnType\";\r\nimport {isEqual} from \"lodash\";\r\nimport {CodeErrorCodes, ErrorFactory} from \"../error/errorFactory\";\r\n\r\n/**\r\n * Row stores a set of columns' values in a relation.\r\n */\r\nexport default class Row {\r\n\r\n    private readonly types = new Map<string, SupportedColumnType>();\r\n    private values = new Map<string, ColumnContent>();\r\n    private finished: boolean;\r\n\r\n    /**\r\n     * Creates a new row with given columns. Given column set is final, no more column can be added.\r\n     * Given columns' values are set to null. They can be set to a new value by addColumn function, as long as the row\r\n     * is not set finished.\r\n     *\r\n     * @param columns set of columns in a row\r\n     */\r\n    public constructor(columns: Map<string, SupportedColumnType>) {\r\n        // adds empty columns\r\n        columns.forEach((value, name) => {\r\n            this.values.set(name, null);\r\n        });\r\n        this.types = columns;\r\n        this.finished = false;\r\n    }\r\n\r\n    /**\r\n     * Returns whether the row is finished and no more column change is possible.\r\n     *\r\n     * @return true if the row is finished\r\n     */\r\n    public isFinished(): boolean {\r\n        return this.finished;\r\n    }\r\n\r\n    /**\r\n     * Sets the row as finished, no more changes in column values are possible.\r\n     */\r\n    public finish(): void {\r\n        this.finished = true;\r\n    }\r\n\r\n    /**\r\n     * Gets name of all columns in a row.\r\n     *\r\n     * @return set of all columns' names\r\n     */\r\n    public getColumnNames(): IterableIterator<string> {\r\n        return this.types.keys();\r\n    }\r\n\r\n    /**\r\n     * Adds a value to the row. If the addition succeeded, returns true. It can fail, if the row is finished,\r\n     * if there is no column of the given name or if there is a column with the name, but different type.\r\n     *\r\n     * @param name name of the column\r\n     * @param value new value of the column\r\n     * @return true if addition succeeded\r\n     */\r\n    public addValue(name: string, value: ColumnContent): boolean {\r\n        // finished row or not present column\r\n        if (this.finished || !this.types.has(name)) {\r\n            return false;\r\n        }\r\n        let givenType = typeof value;\r\n        // null can be set all column types\r\n        if (value !== null && givenType !== this.types.get(name)) {\r\n            return false;\r\n        }\r\n        this.values.set(name, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets the value (possibly null) of the column with the given name. If there is no column with this name, undefined is returned.\r\n     *\r\n     * @param name name of the column\r\n     * @return value of the column or undefined if there is no such column\r\n     */\r\n    public getValue(name: string): ColumnContent | undefined {\r\n        return this.values.get(name);\r\n    }\r\n\r\n    /**\r\n     * Returns the type of the given column or undefined if the column is absent.\r\n     *\r\n     * @param name name of the column\r\n     * @return the type of the column\r\n     */\r\n    public getType(name: string): SupportedColumnType | undefined {\r\n        return this.types.get(name);\r\n    }\r\n\r\n    /**\r\n     * Gets types of all columns.\r\n     *\r\n     * @return map of columns (name -> type)\r\n     */\r\n    public getTypes(): Map<string, SupportedColumnType> {\r\n        return this.types;\r\n    }\r\n\r\n    /**\r\n     * Gets values of all columns.\r\n     *\r\n     * @return map of columns (name -> value)\r\n     */\r\n    public getValues(): Map<string, ColumnContent> {\r\n        return this.values;\r\n    }\r\n\r\n    /**\r\n     * Returns values of all columns ordered by given array of column names. OrderedColumns are expected to be from the\r\n     * relation that contains the row. The returned values are converted to string type. String column values are\r\n     * changed to printing representation - escaped '\\\\' and '\"' are returned without the escape '\\\\'.\r\n     *\r\n     * @param orderedColumns order of columns to be returned\r\n     * @return ordered array of values\r\n     */\r\n    public getOrderedPrintValues(orderedColumns: string[]): string[] {\r\n        let ret: string[] = [];\r\n        orderedColumns.forEach(column => {\r\n            const value = this.values.get(column);\r\n            const type = this.types.get(column);\r\n            // should be handled before call\r\n            if (value === undefined || type === undefined) {\r\n                throw ErrorFactory.codeError(CodeErrorCodes.row_getOrderedValues_absentColumn, column, [...this.types.values()].join(', '));\r\n            }\r\n            if (type === \"string\") {\r\n                const str = String(value).replace(/\\\\\"/g, '\"').replace(/\\\\\\\\/g, '\\\\');\r\n                ret.push(str);\r\n            }\r\n            else {\r\n                ret.push(String(value));\r\n            }\r\n        });\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Custom equals function.\r\n     *\r\n     * @param other\r\n     */\r\n    public equals(other: Object): boolean {\r\n        if (other instanceof Row) {\r\n            return isEqual(this.types, other.types) && isEqual(this.values, other.values);\r\n        }\r\n        return false;\r\n    }\r\n}\r\n","import {IndexedString} from \"./indexedString\";\r\n\r\n/**\r\n * Lowercase reserved keywords which cannot be used for column names. They are:\r\n * - Null value: null\r\n * - Boolean values: true, false\r\n * - Empty string: \"\"\r\n */\r\nconst forbiddenColumnNames: string[] = [\"null\", \"true\", \"false\", \"\"];\r\n\r\n/**\r\n * Reserved keywords which cannot be used for relation names. They are:\r\n * - First characters of outer joins: F, L, R, f, l, r\r\n * - Empty string: \"\"\r\n */\r\nconst forbiddenRelationNames: string[] = [\"F\", \"L\", \"R\", \"\"];\r\n\r\n/**\r\n * Returns lowercase reserved keywords which cannot be used for column names. They are:\r\n * - Null value: null\r\n * - Boolean values: true, false\r\n * - Empty string: \"\"\r\n */\r\nexport function getForbiddenColumnNames(): string[] {\r\n    return forbiddenColumnNames;\r\n}\r\n\r\n/**\r\n * Returns reserved keywords which cannot be used for relation names. They are:\r\n * - First characters of outer joins: F, L, R, f, l, r\r\n * - Empty string: \"\"\r\n */\r\nexport function getForbiddenRelationNames(): string[] {\r\n    return forbiddenRelationNames;\r\n}\r\n\r\n/**\r\n * Returns true if the given string is forbidden as a column name.\r\n */\r\nexport function isForbiddenColumnName(str: string | IndexedString): boolean {\r\n    return forbiddenColumnNames.indexOf(str.toString().toLowerCase()) > -1;\r\n}\r\n\r\n/**\r\n * Returns true if the given string is forbidden as a relation name.\r\n */\r\nexport function isForbiddenRelationName(str: string | IndexedString): boolean {\r\n    // does not use to lower because forbidden names are upper\r\n    return forbiddenRelationNames.indexOf(str.toString()) > -1;\r\n}","import Row from \"../relation/row\";\r\nimport {VETreeNode} from \"./veTreeNode\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\nimport {ErrorFactory, SyntaxErrorCodes} from \"../error/errorFactory\";\r\nimport {getRange, IndexedString} from \"../tools/indexedString\";\r\n\r\n/**\r\n * Types of ComparingOperator class.\r\n */\r\nexport enum ComparingOperatorType {\r\n    equal,\r\n    nonEqual,\r\n    less,\r\n    more,\r\n    lessOrEqual,\r\n    moreOrEqual\r\n}\r\n\r\n/**\r\n * Comparing operator compares two values and returns boolean.\r\n */\r\nexport class ComparingOperator extends VETreeNode {\r\n\r\n    /**\r\n     * Creates new ComparingOperator instance of equality type (type = ComparingOperatorType.equal).\r\n     *\r\n     * @param operator used string representation of equality operator\r\n     * @param left left subtree producing a value\r\n     * @param right right subtree producing a value\r\n     * @return new ComparingOperator instance of equality type\r\n     */\r\n    public static equal(operator: string | IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\r\n        return new ComparingOperator(ComparingOperatorType.equal, operator, left, right);\r\n    }\r\n\r\n    /**\r\n     * Creates new ComparingOperator instance of non-equality type (type = ComparingOperatorType.nonEqual).\r\n     *\r\n     * @param operator used string representation of non-equality operator\r\n     * @param left left subtree producing a value\r\n     * @param right right subtree producing a value\r\n     * @return new ComparingOperator instance of non-equality type\r\n     */\r\n    public static nonEqual(operator: string | IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\r\n        return new ComparingOperator(ComparingOperatorType.nonEqual, operator, left, right);\r\n    }\r\n\r\n    /**\r\n     * Creates new ComparingOperator instance of less type (type = ComparingOperatorType.less).\r\n     *\r\n     * @param operator used string representation of less operator\r\n     * @param left left subtree producing a value\r\n     * @param right right subtree producing a value\r\n     * @return new ComparingOperator instance of less type\r\n     */\r\n    public static less(operator: string | IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\r\n        return new ComparingOperator(ComparingOperatorType.less, operator, left, right);\r\n    }\r\n\r\n    /**\r\n     * Creates new ComparingOperator instance of more type (type = ComparingOperatorType.more).\r\n     *\r\n     * @param operator used string representation of more operator\r\n     * @param left left subtree producing a value\r\n     * @param right right subtree producing a value\r\n     * @return new ComparingOperator instance of more type\r\n     */\r\n    public static more(operator: string | IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\r\n        return new ComparingOperator(ComparingOperatorType.more, operator, left, right);\r\n    }\r\n\r\n    /**\r\n     * Creates new ComparingOperator instance of less-or-equal type (type = ComparingOperatorType.lessOrEqual).\r\n     *\r\n     * @param operator used string representation of less-or-equal operator\r\n     * @param left left subtree producing a value\r\n     * @param right right subtree producing a value\r\n     * @return new ComparingOperator instance of less-or-equal type\r\n     */\r\n    public static lessOrEqual(operator: string | IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\r\n        return new ComparingOperator(ComparingOperatorType.lessOrEqual, operator, left, right);\r\n    }\r\n\r\n    /**\r\n     * Creates new ComparingOperator instance of more-or-equal type (type = ComparingOperatorType.moreOrEqual).\r\n     *\r\n     * @param operator used string representation of more-or-equal operator\r\n     * @param left left subtree producing a value\r\n     * @param right right subtree producing a value\r\n     * @return new ComparingOperator instance of more-or-equal type\r\n     */\r\n    public static moreOrEqual(operator: string | IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\r\n        return new ComparingOperator(ComparingOperatorType.moreOrEqual, operator, left, right);\r\n    }\r\n\r\n    /**\r\n     * Creates new ComparingOperator of the given type.\r\n     *\r\n     * @param type ComparingOperator type\r\n     * @param operator used string representation of the operator\r\n     * @param left left subtree producing a value\r\n     * @param right right subtree producing a value\r\n     */\r\n    public constructor(private readonly type: ComparingOperatorType, private readonly operator: string | IndexedString,\r\n                       private readonly left: VETreeNode, private readonly right: VETreeNode) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Evaluate the node and its subtrees and compares their value results to produce a boolean value. It needs to\r\n     * receive results of the same type from its subtrees.\r\n     * NOTE: If one of the subtrees' results is null, only equality and non-equality are valid. Other comparing\r\n     * operations returns always false.\r\n     *\r\n     * @param source row with actual values of columns recursively passed to leaf reference nodes\r\n     * @return boolean comparing left and right subtrees' values\r\n     */\r\n    public eval(source: Row): { value: boolean, type: \"boolean\" } {\r\n        const leftResult: { value: ColumnContent, type: SupportedColumnType | \"null\" } = this.left.eval(source);\r\n        const rightResult: { value: ColumnContent, type: SupportedColumnType | \"null\" } = this.right.eval(source);\r\n\r\n        if (leftResult.type !== \"null\" && rightResult.type !== \"null\" && leftResult.type !== rightResult.type) {\r\n            throw ErrorFactory.syntaxError(SyntaxErrorCodes.comparingOperator_eval_differentInputTypes,\r\n                getRange(this.operator), this.operator.toString(), leftResult.type, rightResult.type);\r\n        }\r\n\r\n        // if both values are null but both types are not null, returns false\r\n        if (leftResult.value === null && rightResult.value === null && leftResult.type !== \"null\" && rightResult.type !== \"null\") {\r\n            return {value: false, type: \"boolean\"};\r\n        }\r\n        if (this.type === ComparingOperatorType.equal) {\r\n            return {value: leftResult.value === rightResult.value, type: \"boolean\"};\r\n        }\r\n        if (this.type === ComparingOperatorType.nonEqual) {\r\n            // if any value of non-null type is null, returns false\r\n            if ((leftResult.value === null && leftResult.type !== \"null\") || (rightResult.value === null && rightResult.type !== \"null\")) {\r\n                return {value: false, type: \"boolean\"};\r\n            }\r\n            return {value: leftResult.value !== rightResult.value, type: \"boolean\"};\r\n        }\r\n        if (this.type === ComparingOperatorType.less) {\r\n            if (leftResult.value === null || rightResult.value === null) {\r\n                return {value: false, type: \"boolean\"};\r\n            }\r\n            return {value: leftResult.value < rightResult.value, type: \"boolean\"};\r\n        }\r\n        if (this.type === ComparingOperatorType.more) {\r\n            if (leftResult.value === null || rightResult.value === null) {\r\n                return {value: false, type: \"boolean\"};\r\n            }\r\n            return {value: leftResult.value > rightResult.value, type: \"boolean\"};\r\n        }\r\n        if (this.type === ComparingOperatorType.lessOrEqual) {\r\n            if (leftResult.value === null || rightResult.value === null) {\r\n                return {value: false, type: \"boolean\"};\r\n            }\r\n            return {value: leftResult.value <= rightResult.value, type: \"boolean\"};\r\n        }\r\n        // if (this.type === ComparingOperatorType.moreOrEqual)\r\n            if (leftResult.value === null || rightResult.value === null) {\r\n                return {value: false, type: \"boolean\"};\r\n            }\r\n            return {value: leftResult.value >= rightResult.value, type: \"boolean\"};\r\n    }\r\n\r\n    public toString(): string {\r\n        return \"(\" + this.left.toString() + \" \" + this.operator + \" \" + this.right.toString() + \")\";\r\n    }\r\n}","import UnaryNode from \"./unaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Parser from \"../tools/parser\";\r\nimport Relation from \"../relation/relation\";\r\nimport Row from \"../relation/row\";\r\nimport {getRange, IndexedString, isEmpty} from \"../tools/indexedString\";\r\nimport {ErrorFactory, SemanticErrorCodes, SyntaxErrorCodes} from \"../error/errorFactory\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\nimport {isForbiddenColumnName} from \"../tools/keywords\";\r\nimport ParserIndexed from \"../tools/parserIndexed\";\r\n\r\n/**\r\n * Projection node of the relational algebra syntactic tree.\r\n */\r\nexport default class ProjectionNode extends UnaryNode {\r\n\r\n    private readonly projection: string | IndexedString;\r\n    private readonly stringRange: { start: number, end: number } | undefined;\r\n\r\n    /**\r\n     * Expects the projection string to start with '[' and end with ']'.\r\n     *\r\n     * @param projection\r\n     * @param subtree\r\n     */\r\n    constructor(projection: string | IndexedString, subtree: RATreeNode) {\r\n        super(subtree);\r\n        this.projection = projection;\r\n        this.stringRange = getRange(projection);\r\n    }\r\n\r\n    /**\r\n     * Parses projection string to set of projected columns.\r\n     * If doThrow is true, throws found errors. Otherwise, adds found errors to given errors array.\r\n     */\r\n    private parseProjection(doThrow: boolean, errors: ErrorWithTextRange[] = []): Set<string | IndexedString> {\r\n        const ret: Set<string | IndexedString> = new Set<string>();\r\n        const indexed: boolean = this.projection instanceof IndexedString\r\n        // @ts-ignore\r\n        let str: string | IndexedString = this.projection.slice(1, -1);\r\n        let parts: (string | IndexedString)[] = str.split(\",\");\r\n        parts.forEach(part => {\r\n            part = part.trim();\r\n            // @ts-ignore\r\n            const isName = indexed ? ParserIndexed.isName(part) : Parser.isName(part);\r\n            if (isName && !isForbiddenColumnName(part)) {\r\n                ret.add(part);\r\n            }\r\n            else {\r\n                let range = getRange(part);\r\n                if (isEmpty(part) && this.stringRange !== undefined) {\r\n                    range = {start: this.stringRange.start, end: this.stringRange.start};\r\n                }\r\n                const error = ErrorFactory.syntaxError(SyntaxErrorCodes.projectionNode_parseProjection_invalidProjectedColumnName,\r\n                    range, part.toString());\r\n                if (doThrow) {\r\n                    throw error;\r\n                }\r\n                else {\r\n                    errors.push(error);\r\n                }\r\n            }\r\n        });\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Expectations: projected names are subset of source schema\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n        const source: Relation = this.subtree.getResult();\r\n        const projected: string[] = [...this.parseProjection(true)].map(value => value.toString());\r\n        // checks if projected columns really exist in source relation\r\n        projected.forEach(name => {\r\n            if (!source.hasColumn(name.toString())) {\r\n                throw ErrorFactory.semanticError(SemanticErrorCodes.projectionNode_eval_absentColumn,\r\n                    getRange(name), name.toString());\r\n            }\r\n        });\r\n\r\n        const result: Relation = new Relation(source.getName() + \"[...]\");\r\n        // projection of relational schema\r\n        source.forEachColumn((type, name) => {\r\n            if (projected.indexOf(name) > -1) {\r\n                result.addColumn(name, type);\r\n            }\r\n        });\r\n        // projection of relation rows\r\n        source.getRows().forEach(row => {\r\n             let newRow: Row = new Row(result.getColumns());\r\n             row.getValues().forEach((value, name) => {\r\n                 if (projected.indexOf(name) > -1) {\r\n                     newRow.addValue(name, value);\r\n                 }\r\n             });\r\n             result.addRow(newRow);\r\n        });\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: projected names are subset of source schema\r\n     * Returned schema: intersection of projected names and source schema\r\n     * Second possible approach would be to return all projected names - less strict.\r\n     */\r\n    public fakeEval(cursorIndex: number): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} {\r\n        let source: {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} = this.subtree.fakeEval(cursorIndex);\r\n        // checks whether the cursor is in this projection block - saves current available columns\r\n        let whispers = source.whispers;\r\n        if (this.stringRange !== undefined && this.stringRange.start < cursorIndex && cursorIndex <= this.stringRange.end) {\r\n            whispers = source.result.getColumnNames();\r\n        }\r\n        // adds errors from current expression\r\n        const errors = source.errors;\r\n        const projected: Set<string | IndexedString> = this.parseProjection(false, errors);\r\n        // creates relational schema - \"projected columns\"\r\n        const result: Relation = new Relation(source.result.name + \"[...]\");\r\n        // adds only projected, which exist in source\r\n        const absent: (string | IndexedString)[] = [];\r\n        projected.forEach(name => {\r\n            const strName = name.toString();\r\n            if (source.result.hasColumn(strName)) {\r\n                // @ts-ignore - strName must be in the source now\r\n                result.addColumn(strName, source.result.getColumns().get(strName));\r\n            }\r\n            else {\r\n                absent.push(name);\r\n            }\r\n        });\r\n        absent.forEach(column => {\r\n            errors.push(ErrorFactory.semanticError(SemanticErrorCodes.projectionNode_eval_absentColumn,\r\n                getRange(column), column.toString()));\r\n        });\r\n        return {result, whispers, errors};\r\n    }\r\n\r\n    printInLine(): string {\r\n        return this.subtree.printInLine() + this.getOperationSymbol();\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        return \"Projection\";\r\n    }\r\n\r\n    public getOperationSymbol(): string {\r\n        return this.projection.replace(/\\s+/g, ' ');\r\n    }\r\n}","import {IndexedString} from \"./indexedString\";\r\n\r\ninterface KeyValue {\r\n    key: string | IndexedString,\r\n    value: string | IndexedString\r\n}\r\n\r\n/**\r\n * Wrapper of JavaScript Map object to provide usage of object (string | IndexedString) as a key.\r\n * Keys \"IndexedString: something\" and \"string: something\" are equal for this map.\r\n */\r\nexport class ISSToISSMap {\r\n    private map: Map<string, KeyValue> = new Map<string, KeyValue>();\r\n\r\n    public get(key: string | IndexedString): string | IndexedString | undefined {\r\n        const keyValue = this.map.get(key.toString());\r\n        return keyValue === undefined ? undefined : keyValue.value;\r\n    }\r\n\r\n    public set(key: string | IndexedString, value: string | IndexedString): void {\r\n        this.map.set(key.toString(), {key, value});\r\n    }\r\n\r\n    public delete(key: string | IndexedString): boolean {\r\n        return this.map.delete(key.toString());\r\n    }\r\n\r\n    public has(key: string | IndexedString): boolean {\r\n        return this.map.has(key.toString());\r\n    }\r\n\r\n    public clear(): void {\r\n        this.map.clear();\r\n    }\r\n\r\n    public size(): number {\r\n        return this.map.size;\r\n    }\r\n\r\n    public forEach(f: (value: string | IndexedString, row: string | IndexedString, index?: number) => void): void {\r\n        [...this.map.values()].forEach((keyValue, index) => f(keyValue.value, keyValue.key, index));\r\n    }\r\n}","import UnaryNode from \"./unaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Parser from \"../tools/parser\";\r\nimport Relation from \"../relation/relation\";\r\nimport {SupportedColumnType} from \"../relation/columnType\";\r\nimport Row from \"../relation/row\";\r\nimport {getRange, IndexedString, isEmpty} from \"../tools/indexedString\";\r\nimport {ErrorFactory, SemanticErrorCodes, SyntaxErrorCodes} from \"../error/errorFactory\";\r\nimport {isForbiddenColumnName} from \"../tools/keywords\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\nimport {ISSToISSMap} from \"../tools/issToISSMap\";\r\n\r\n/**\r\n * Renaming node of the relational algebra syntactic tree.\r\n */\r\nexport default class RenameNode extends UnaryNode {\r\n\r\n    private readonly rename: string | IndexedString;\r\n    private readonly stringRange: { start: number, end: number } | undefined;\r\n\r\n    /**\r\n     * Creates a new renaming node with given subtree.\r\n     * The rename string is expected to start with '<' and end with '>'.\r\n     *\r\n     * @param rename string describing each renaming\r\n     * @param subtree source subtree for renaming\r\n     */\r\n    public constructor(rename: string | IndexedString, subtree: RATreeNode) {\r\n        super(subtree);\r\n        this.rename = rename;\r\n        this.stringRange = getRange(rename);\r\n    }\r\n\r\n    private parseChanges(doThrow: boolean, errors: ErrorWithTextRange[] = []): ISSToISSMap {\r\n        const handleError = (error: SyntaxError) => {\r\n            if (doThrow) {\r\n                throw error;\r\n            } else {\r\n                errors.push(error);\r\n            }\r\n        }\r\n        const parts: (string | IndexedString)[] = this.rename.slice(1, -1).split(\",\");\r\n        const ret: ISSToISSMap = new ISSToISSMap();\r\n        for (let part of parts) {\r\n            // @ts-ignore\r\n            let words: (string | IndexedString)[] = part.split(\"->\").map(w => w.trim());\r\n            let beforeError = false; // true when there was an error in before in \"before -> after\"\r\n            let afterError = false;  // true when there was an error in after in \"before -> after\"\r\n            if (words.length !== 2) {\r\n                let range = getRange(part);\r\n                if (isEmpty(part) && this.stringRange !== undefined) {\r\n                    range = {start: this.stringRange.start, end: this.stringRange.start};\r\n                }\r\n                handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.renameNode_parseChanges_missingArrow, range));\r\n                beforeError = true;\r\n                afterError = true;\r\n            }\r\n            if (!beforeError && ret.has(words[0].toString())) {\r\n                handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.renameNode_parseChanges_multipleRenameOfTheColumn,\r\n                    getRange(words[0]), words[0].toString()));\r\n                beforeError = true;\r\n            }\r\n            if (!afterError && !Parser.isName(words[1].toString())) {\r\n                handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.renameNode_parseChanges_invalidNewName,\r\n                    getRange(words[1]), words[1].toString()));\r\n                afterError = true;\r\n            }\r\n            if (!afterError && isForbiddenColumnName(words[1])) {\r\n                handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.renameNode_parseChanges_keywordNewName,\r\n                    getRange(words[1]), words[1].toString()));\r\n                afterError = true;\r\n            }\r\n            // if no error found, adds original rename pair\r\n            if (!beforeError && !afterError) {\r\n                ret.set(words[0], words[1]);\r\n            }\r\n            // if no before error, fakes rename \"before -> before\"\r\n            else if (!beforeError) {\r\n                ret.set(words[0], words[0]);\r\n            }\r\n            // if no after error, fakes rename \"\"\" -> before\", where empty string has undefined range\r\n            else if (!afterError) {\r\n                ret.set(\"\", words[0]);\r\n            }\r\n            // if both errors, adds nothing\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Expectations: original names in projection pair (original -> new) are subset of the source schema,\r\n     * new names with rest of the source schema contain no duplicity\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n        const changes: ISSToISSMap = this.parseChanges(true);\r\n        const source: Relation = this.subtree.getResult();\r\n        // check whether all columns to rename are in source relation\r\n        changes.forEach((value, key) => {\r\n             if (source.getColumnNames().indexOf(key.toString()) === -1) {\r\n                 throw ErrorFactory.semanticError(SemanticErrorCodes.renameNode_eval_absentOriginalColumn,\r\n                     getRange(key), key.toString());\r\n             }\r\n        });\r\n        // rename of relational schema\r\n        const result: Relation = new Relation(source.getName() + \"<...>\");\r\n        const toChange: Map<string, SupportedColumnType> = new Map<string, SupportedColumnType>();\r\n        // in first loop adds unchanged columns only\r\n        source.forEachColumn((type, name) => {\r\n            if (changes.has(name)) {\r\n                toChange.set(name, type);\r\n            }\r\n            else {\r\n                result.addColumn(name, type);\r\n            }\r\n        });\r\n        // in second loop adds changed columns\r\n        toChange.forEach((type, name) => {\r\n            // @ts-ignore (changes must contain 'name' key now)\r\n            if (!result.addColumn(changes.get(name).toString(), type)) {\r\n                throw ErrorFactory.semanticError(SemanticErrorCodes.renameNode_eval_changeToDuplicitName,\r\n                    getRange(this.rename), changes.get(name) as string);\r\n            }\r\n        });\r\n        // rename of relation rows\r\n        source.getRows().forEach(row => {\r\n            const newRow: Row = new Row(result.getColumns());\r\n            row.getValues().forEach((value, name) => {\r\n                const returned = changes.get(name);\r\n                if (typeof returned === \"undefined\") {\r\n                    newRow.addValue(name, value);\r\n                }\r\n                else {\r\n                    newRow.addValue(returned.toString(), value);\r\n                }\r\n            });\r\n            result.addRow(newRow);\r\n        });\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: original names in projection pair (original -> new) are subset of the source schema,\r\n     * new names with rest of the source schema contain no duplicity\r\n     * Returned schema: if the cursor is not after the arrow '->' returns\r\n     * (source schema minus originals) union (news whose originals were in source schema),\r\n     * otherwise returns empty array (does not whisper to what the user should rename)\r\n     * Second possible approach would be to return (source schema minus originals) union (news) - less strict.\r\n     */\r\n    public fakeEval(cursorIndex: number): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} {\r\n        const source: {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} = this.subtree.fakeEval(cursorIndex);\r\n        // checks whether the cursor is in this rename block\r\n        let whispers = source.whispers;\r\n        if (this.stringRange !== undefined && this.stringRange.start < cursorIndex && cursorIndex <= this.stringRange.end) {\r\n            // if the last special character before cursor is '<' or ',' returns current available columns (subtree schema)\r\n            const beforeCursor: string | IndexedString = this.rename.slice(0, cursorIndex - this.stringRange.start).trim();\r\n            const regexMatch = beforeCursor.match(/.*[^\\w\\s]/);\r\n            if (regexMatch !== null && (regexMatch[0].endsWith('<') || regexMatch[0].endsWith(','))) {\r\n                whispers = source.result.getColumnNames();\r\n            }\r\n        }\r\n        // adds errors from current expression\r\n        const errors = source.errors;\r\n        const changes: ISSToISSMap = this.parseChanges(false, errors);\r\n        // creates relational schema - \"(source minus to-rename) union (renamed existing in source)\"\r\n        const result: Relation = new Relation(source.result.getName() + \"<...>\");\r\n        // in first loop adds source columns which are not in changes.keys\r\n        source.result.forEachColumn((type, name) => {\r\n            if (!changes.has(name)) {\r\n                result.addColumn(name, type);\r\n            }\r\n        });\r\n        // in second loop adds changes.values whose changes.keys are in source\r\n        const absent: (string | IndexedString)[] = [];\r\n        const duplicit: (string | IndexedString)[] = [];\r\n        changes.forEach((after, before) => {\r\n            const beforeStr = before.toString();\r\n            const afterStr = after.toString();\r\n            if (!source.result.hasColumn(beforeStr) && before !== \"\") {\r\n                absent.push(before);\r\n            }\r\n            // @ts-ignore source must have beforeStr now\r\n            else if(!result.addColumn(afterStr, source.result.getColumns().get(beforeStr))) {\r\n                duplicit.push(after);\r\n            }\r\n        });\r\n        absent.forEach(column => {\r\n            errors.push(ErrorFactory.semanticError(SemanticErrorCodes.renameNode_eval_absentOriginalColumn,\r\n                getRange(column), column.toString()));\r\n        });\r\n        duplicit.forEach(column => {\r\n            errors.push(ErrorFactory.semanticError(SemanticErrorCodes.renameNode_eval_changeToDuplicitName,\r\n                getRange(column), column.toString()));\r\n        });\r\n        return {result, whispers, errors};\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return this.subtree.printInLine() + this.getOperationSymbol();\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        return \"Rename\";\r\n    }\r\n\r\n    public getOperationSymbol(): string {\r\n        return this.rename.replace(/\\s+/g, ' ');\r\n    }\r\n}","import Row from \"../relation/row\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\n\r\n/**\r\n * Abstract class for value-evaluating nodes producing new values.\r\n */\r\nexport abstract class VETreeNode {\r\n\r\n    /**\r\n     * Evaluates this value-evaluating tree.\r\n     *\r\n     * @param source row with values to be used to reference to\r\n     * @return evaluated value and its type\r\n     */\r\n    public abstract eval(source: Row): { value: ColumnContent, type: SupportedColumnType | \"null\" };\r\n\r\n    /**\r\n     * @return string representation of the value-evaluating tree\r\n     */\r\n    public abstract toString(): string;\r\n}","import Row from \"../relation/row\";\r\nimport {VETreeNode} from \"./veTreeNode\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\nimport {ErrorFactory, SyntaxErrorCodes} from \"../error/errorFactory\";\r\nimport {getRange, IndexedString} from \"../tools/indexedString\";\r\n\r\n/**\r\n * Types of LogicalOperator class.\r\n */\r\nenum LogicalOperatorType {\r\n    and,\r\n    or,\r\n    not\r\n}\r\n\r\n/**\r\n * Logical operator chains boolean values and produces new ones.\r\n */\r\nexport class LogicalOperator extends VETreeNode {\r\n\r\n    /**\r\n     * Creates an 'and' logical operator.\r\n     *\r\n     * @param operator String representing an 'and' in input (used to printing)\r\n     * @param left Left subtree evaluating to a boolean value\r\n     * @param right Right subtree evaluating to a boolean value\r\n     */\r\n    public static and(operator: string | IndexedString, left: VETreeNode, right: VETreeNode): LogicalOperator {\r\n        return new LogicalOperator(LogicalOperatorType.and, operator, left, right);\r\n    }\r\n\r\n    /**\r\n     * Creates an 'or' logical operator.\r\n     *\r\n     * @param operator String representing an 'or' in input (used to printing)\r\n     * @param left Left subtree evaluating to a boolean value\r\n     * @param right Right subtree evaluating to a boolean value\r\n     */\r\n    public static or(operator: string | IndexedString, left: VETreeNode, right: VETreeNode): LogicalOperator {\r\n        return new LogicalOperator(LogicalOperatorType.or, operator, left, right);\r\n    }\r\n\r\n    /**\r\n     * Creates a 'not' logical operator.\r\n     *\r\n     * @param operator String representing a 'not' in input (used to printing)\r\n     * @param subtree Subtree evaluating to a boolean value\r\n     */\r\n    public static not(operator: string | IndexedString, subtree: VETreeNode): LogicalOperator {\r\n        return new LogicalOperator(LogicalOperatorType.not, operator, subtree);\r\n    }\r\n\r\n    private constructor(private readonly type: LogicalOperatorType, private readonly operator: string | IndexedString,\r\n                        private readonly left: VETreeNode, private readonly right?: VETreeNode) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Evaluates recursively subtrees and transforms their boolean results into a new boolean.\r\n     * If any subtree evaluates to string or number, throws error.\r\n     *\r\n     * @param source row with actual values of columns recursively passed to leaf reference nodes\r\n     * @return boolean comparing left and right subtrees' values\r\n     */\r\n    public eval(source: Row): { value: boolean, type: \"boolean\" } {\r\n\r\n        const leftResult: { value: ColumnContent, type: SupportedColumnType | \"null\" } = this.left.eval(source);\r\n        if (leftResult.type !== \"boolean\") {\r\n            throw ErrorFactory.syntaxError(SyntaxErrorCodes.logicalOperator_eval_leftInputNotBoolean,\r\n                getRange(this.operator), this.operator.toString(), leftResult.type);\r\n        }\r\n\r\n        if (this.type === LogicalOperatorType.not) {\r\n            if (leftResult.value === null) {\r\n                return { value: false, type: \"boolean\" };\r\n            }\r\n            return { value: !leftResult.value, type: \"boolean\" };\r\n        }\r\n        else {\r\n            // @ts-ignore (in and/or operations right subtree must exist)\r\n            const rightResult: { value: ColumnContent, type: SupportedColumnType | \"null\" } = this.right.eval(source);\r\n            if (rightResult.type !== \"boolean\") {\r\n                throw ErrorFactory.syntaxError(SyntaxErrorCodes.logicalOperator_eval_rightInputNotBoolean,\r\n                    getRange(this.operator), this.operator.toString(), rightResult.type);\r\n            }\r\n\r\n            if (this.type === LogicalOperatorType.and) {\r\n                if (leftResult.value === null || rightResult.value === null) {\r\n                    return { value: false, type: \"boolean\" };\r\n                }\r\n                // @ts-ignore (they must be both booleans now)\r\n                return { value: leftResult.value && rightResult.value, type: \"boolean\" };\r\n            }\r\n            else /* if (this.type === LogicalOperatorType.or)*/ {\r\n                if (leftResult.value === null && rightResult.value === null) {\r\n                    return { value: false, type: \"boolean\" };\r\n                }\r\n                if (leftResult.value === null) {\r\n                    // @ts-ignore (it must be boolean now)\r\n                    return { value: rightResult.value, type: \"boolean\" };\r\n                }\r\n                if (rightResult.value === null) {\r\n                    // @ts-ignore (it must be boolean now)\r\n                    return { value: leftResult.value, type: \"boolean\" };\r\n                }\r\n                // @ts-ignore (they must be both booleans now)\r\n                return { value: leftResult.value || rightResult.value, type: \"boolean\" };\r\n            }\r\n        }\r\n    }\r\n\r\n    public toString(): string {\r\n        if (this.type === LogicalOperatorType.not) {\r\n            return this.operator + \"(\" + this.left.toString() + \")\";\r\n        }\r\n        // @ts-ignore (in and, or operations right subtree must exist)\r\n        return \"(\" + this.left.toString() + \" \" + this.operator.toString() + \" \" + this.right.toString() + \")\";\r\n    }\r\n}","import Row from \"../relation/row\";\r\nimport {VETreeNode} from \"./veTreeNode\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\nimport {ErrorFactory, SyntaxErrorCodes} from \"../error/errorFactory\";\r\n\r\n/**\r\n * Types of ComputingOperator class.\r\n */\r\nenum ComputingOperatorType {\r\n    plus = \"+\",\r\n    minus = \"-\",\r\n    multiplication = \"*\",\r\n    division = \"/\"\r\n}\r\n\r\n/**\r\n * Comparing operator takes two number values and returns a new computed number.\r\n */\r\nexport class ComputingOperator extends VETreeNode {\r\n\r\n    /**\r\n     * Creates an addition (+) computing operator.\r\n     *\r\n     * @param left Left subtree evaluating to a number value\r\n     * @param right Right subtree evaluating to a number value\r\n     * @param range Range of the operator in the input string to highlight errors\r\n     */\r\n    public static add(left: VETreeNode, right: VETreeNode, range: {start: number, end: number} | undefined): ComputingOperator {\r\n        return new ComputingOperator(ComputingOperatorType.plus, left, right, range);\r\n    }\r\n\r\n    /**\r\n     * Creates a deduction (-) computing operator.\r\n     *\r\n     * @param left Left subtree evaluating to a number value\r\n     * @param right Right subtree evaluating to a number value\r\n     * @param range Range of the operator in the input string to highlight errors\r\n     */\r\n    public static deduct(left: VETreeNode, right: VETreeNode, range: {start: number, end: number} | undefined): ComputingOperator {\r\n        return new ComputingOperator(ComputingOperatorType.minus, left, right, range);\r\n    }\r\n\r\n    /**\r\n     * Creates a multiplication (*) computing operator.\r\n     *\r\n     * @param left Left subtree evaluating to a number value\r\n     * @param right Right subtree evaluating to a number value\r\n     * @param range Range of the operator in the input string to highlight errors\r\n     */\r\n    public static multiply(left: VETreeNode, right: VETreeNode, range: {start: number, end: number} | undefined): ComputingOperator {\r\n        return new ComputingOperator(ComputingOperatorType.multiplication, left, right, range);\r\n    }\r\n\r\n    /**\r\n     * Creates a division (/) computing operator.\r\n     *\r\n     * @param left Left subtree evaluating to a number value\r\n     * @param right Right subtree evaluating to a number value\r\n     * @param range Range of the operator in the input string to highlight errors\r\n     */\r\n    public static divide(left: VETreeNode, right: VETreeNode, range: {start: number, end: number} | undefined): ComputingOperator {\r\n        return new ComputingOperator(ComputingOperatorType.division, left, right, range);\r\n    }\r\n\r\n    private constructor(private readonly type: ComputingOperatorType, private readonly left: VETreeNode,\r\n                        private readonly right: VETreeNode, private readonly range: {start: number, end: number} | undefined) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Evaluates recursively subtrees and transforms their number results into a new number.\r\n     * If any subtree evaluates to string or boolean, throws error.\r\n     * If any subtree evaluates to null, returns null.\r\n     *\r\n     * @param source row with actual values of columns recursively passed to leaf reference nodes\r\n     * @return number produced from subtrees with given operation, or null if any subtree returned null\r\n     */\r\n    public eval(source: Row): { value: number | null, type: \"number\" } {\r\n        const leftResult: { value: ColumnContent, type: SupportedColumnType | \"null\" } = this.left.eval(source);\r\n        const rightResult: { value: ColumnContent, type: SupportedColumnType | \"null\" } = this.right.eval(source);\r\n\r\n        if (leftResult.type !== \"number\" || rightResult.type !== \"number\") {\r\n            throw ErrorFactory.syntaxError(SyntaxErrorCodes.computingOperator_eval_inputTypesNotNumbers, this.range,\r\n                this.type, leftResult.type, rightResult.type);\r\n        }\r\n\r\n        if (leftResult.value === null || rightResult.value === null) {\r\n            return { value: null, type: \"number\" };\r\n        }\r\n\r\n        switch (this.type) {\r\n            case ComputingOperatorType.plus:\r\n                // @ts-ignore (ensured by first if)\r\n                return { value: leftResult.value + rightResult.value, type: \"number\" };\r\n            case ComputingOperatorType.minus:\r\n                // @ts-ignore (ensured by first if)\r\n                return { value: leftResult.value - rightResult.value, type: \"number\" };\r\n            case ComputingOperatorType.multiplication:\r\n                // @ts-ignore (ensured by first if)\r\n                return { value: leftResult.value * rightResult.value, type: \"number\" };\r\n            case ComputingOperatorType.division:\r\n                // @ts-ignore (ensured by first if)\r\n                return { value: leftResult.value / rightResult.value, type: \"number\" };\r\n        }\r\n    }\r\n\r\n    public toString(): string {\r\n        return \"(\" + this.left.toString() + \" \" + this.type + \" \" + this.right.toString() + \")\";\r\n    }\r\n}","import Row from \"../relation/row\";\r\nimport {VETreeNode} from \"./veTreeNode\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\n\r\n/**\r\n * Class storing literal value of number, string or null type.\r\n */\r\nexport class LiteralValue extends VETreeNode {\r\n\r\n    /**\r\n     * Creates a literal storing given value.\r\n     *\r\n     * @param value value to be returned by eval(...) function\r\n     * @param type type of the literal value\r\n     */\r\n    public constructor(private readonly value: ColumnContent, private readonly type: SupportedColumnType | \"null\") {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Returns stored value.\r\n     *\r\n     * @param source row with actual values of columns (note: not used in literals)\r\n     * @return stored value and its type\r\n     */\r\n    public eval(source: Row): { value: ColumnContent, type: SupportedColumnType | \"null\" } {\r\n        return { value: this.value, type: this.type };\r\n    }\r\n\r\n    public toString(): string {\r\n        if (this.value === null) {\r\n            return \"null\";\r\n        }\r\n        return this.value.toString();\r\n    }\r\n}","import Row from \"../relation/row\";\r\nimport {VETreeNode} from \"./veTreeNode\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\nimport {ErrorFactory, SemanticErrorCodes} from \"../error/errorFactory\";\r\nimport {getRange, IndexedString} from \"../tools/indexedString\";\r\n\r\n/**\r\n * Class storing reference to a column.\r\n */\r\nexport class ReferenceValue extends VETreeNode {\r\n\r\n    /**\r\n     * Creates a reference to the given column.\r\n     *\r\n     * @param columnName name of the column whose value is returned by eval(...) function\r\n     */\r\n    public constructor(private readonly columnName: string | IndexedString) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Returns value (expected to be string, number, or boolean) of the referenced column from given source row.\r\n     *\r\n     * @param source row with actual values of columns\r\n     * @return referenced value and its type\r\n     */\r\n    public eval(source: Row): { value: ColumnContent, type: SupportedColumnType } {\r\n        const value: ColumnContent | undefined = source.getValue(this.columnName.toString());\r\n        const type: SupportedColumnType | undefined = source.getType(this.columnName.toString());\r\n        if (value === undefined || type === undefined) {\r\n            throw ErrorFactory.semanticError(SemanticErrorCodes.referenceValue_eval_absentColumn,\r\n                getRange(this.columnName), this.columnName.toString(), [...source.getColumnNames()].join(', '));\r\n        }\r\n        return { value: value, type: type };\r\n    }\r\n\r\n    public toString(): string {\r\n        return this.columnName.toString();\r\n    }\r\n}","import {ComparingOperatorType} from \"../vetree/comparingOperator\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\nimport {IndexedString} from \"../tools/indexedString\";\r\n\r\n/**\r\n * Precedence value for all token types.\r\n */\r\nconst precedenceNot: number = 50;\r\nconst precedenceMulDiv: number = 30;\r\nconst precedencePlusMinus: number = 25;\r\nconst precedenceComparison: number = 20;\r\nconst precedenceAnd: number = 10;\r\nconst precedenceOr: number = 5;\r\n\r\n/**\r\n * Tokens used for parsing of string expression to BooleanEvaluating tree.\r\n */\r\nexport abstract class ValueToken {\r\n    protected constructor(public readonly str: string | IndexedString) {}\r\n\r\n    /**\r\n     * Gets token start and end index in the text (if the token has IndexedString representation) or undefined.\r\n     */\r\n    public getRange(): {start: number, end: number} | undefined {\r\n        return this.str instanceof IndexedString ? this.str.getNonNaNRange() : undefined;\r\n    }\r\n}\r\n\r\nexport abstract class OperatorToken extends ValueToken {\r\n    protected constructor(str: string | IndexedString, readonly precedence: number) {\r\n        super(str);\r\n    }\r\n}\r\n\r\nexport class LogicalNotToken extends OperatorToken {\r\n    constructor(operator: string | IndexedString) {\r\n        super(operator, precedenceNot);\r\n    }\r\n}\r\n\r\nexport class LogicalAndToken extends OperatorToken {\r\n    constructor(operator: string | IndexedString) {\r\n        super(operator, precedenceAnd);\r\n    }\r\n}\r\n\r\nexport class LogicalOrToken extends OperatorToken {\r\n    constructor(operator: string | IndexedString) {\r\n        super(operator, precedenceOr);\r\n    }\r\n}\r\n\r\nexport class ComputingMultiplicationToken extends OperatorToken {\r\n    constructor(operator: string | IndexedString) {\r\n        super(operator, precedenceMulDiv);\r\n    }\r\n}\r\n\r\nexport class ComputingDivisionToken extends OperatorToken {\r\n    constructor(operator: string | IndexedString) {\r\n        super(operator, precedenceMulDiv);\r\n    }\r\n}\r\n\r\nexport class ComputingPlusToken extends OperatorToken {\r\n    constructor(operator: string | IndexedString) {\r\n        super(operator, precedencePlusMinus);\r\n    }\r\n}\r\n\r\nexport class ComputingMinusToken extends OperatorToken {\r\n    constructor(operator: string | IndexedString) {\r\n        super(operator, precedencePlusMinus);\r\n    }\r\n}\r\n\r\nexport class ComparingToken extends OperatorToken {\r\n    constructor(readonly type: ComparingOperatorType, operator: string | IndexedString) {\r\n        super(operator, precedenceComparison);\r\n    }\r\n}\r\n\r\nexport abstract class ParenthesisToken extends ValueToken {\r\n    protected constructor(operator: string | IndexedString) {\r\n        super(operator);\r\n    }\r\n}\r\n\r\nexport class OpeningParentheses extends ParenthesisToken {\r\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\r\n    constructor(operator: string | IndexedString) {\r\n        super(operator);\r\n    }\r\n}\r\n\r\nexport class ClosingParentheses extends ParenthesisToken {\r\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\r\n    constructor(operator: string | IndexedString) {\r\n        super(operator);\r\n    }\r\n}\r\n\r\nexport class LiteralToken extends ValueToken {\r\n    constructor(str: string | IndexedString, readonly value: ColumnContent, readonly type: SupportedColumnType | \"null\") {\r\n        super(str);\r\n    }\r\n}\r\n\r\nexport class ReferenceToken extends ValueToken {\r\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\r\n    constructor(columnName: string | IndexedString) {\r\n        super(columnName);\r\n    }\r\n}","import Parser from \"../tools/parser\";\r\nimport {ComparingOperator, ComparingOperatorType} from \"../vetree/comparingOperator\";\r\nimport {LogicalOperator} from \"../vetree/logicalOperator\";\r\nimport {LiteralValue} from \"../vetree/literalValue\";\r\nimport {ReferenceValue} from \"../vetree/referenceValue\";\r\nimport {ComputingOperator} from \"../vetree/computingOperator\";\r\nimport {\r\n    ClosingParentheses,\r\n    ComparingToken,\r\n    ComputingDivisionToken,\r\n    ComputingMinusToken,\r\n    ComputingMultiplicationToken,\r\n    ComputingPlusToken,\r\n    LiteralToken,\r\n    LogicalAndToken,\r\n    LogicalNotToken,\r\n    LogicalOrToken,\r\n    OpeningParentheses,\r\n    OperatorToken,\r\n    ParenthesisToken,\r\n    ReferenceToken,\r\n    ValueToken\r\n} from \"./valueTokens\"\r\nimport {VETreeNode} from \"../vetree/veTreeNode\";\r\nimport {getRange, IndexedString, isEmpty, length, nextQuotedString} from \"../tools/indexedString\";\r\nimport ParserIndexed from \"../tools/parserIndexed\";\r\nimport ErrorWithTextRange, {insertRangeIfUndefined} from \"../error/errorWithTextRange\";\r\nimport {CodeErrorCodes, ErrorFactory, SemanticErrorCodes, SyntaxErrorCodes} from \"../error/errorFactory\";\r\nimport RASyntaxError from \"../error/raSyntaxError\";\r\n\r\n/**\r\n * Parser of string infix boolean and algebraic expression to value-evaluating tree.\r\n */\r\nexport default class ValueParser {\r\n\r\n    /**\r\n     * Parses given string infix boolean and algebraic expression into an value-evaluating tree and returns the tree.\r\n     * Uses Shunting-yard algorithm (first, it transforms the string into reverse polish notation).\r\n     * Supported expressions:\r\n     * - logical: and (&&, &), or (||, |), not (!, ~)\r\n     * - computing: addition (+), deduction (-), multiplication (*), division (/)\r\n     * - comparing: equal (==, =), non-equal (!=, <>), less (<), more (>), less-or-equal (<=), more-or-equal (>=)\r\n     * - literals: numbers (1, 5.02, etc.), strings (\"String\", \"With inner \\\" symbol\", etc.), nulls (null),\r\n     * booleans (true, false)\r\n     * - column references (ColumnNameAsStringWithoutQuotes, Id, etc.)\r\n     * If the given string is IndexedString, thrown errors contain error range information.\r\n     *\r\n     * @param str infix boolean and algebraic expression to be parsed\r\n     * @param nullValuesSupport whether null values are supported\r\n     * @return VETreeNode tree (its root)\r\n     */\r\n    public static parse(str: string | IndexedString, nullValuesSupport: boolean): VETreeNode {\r\n        let tokens: ValueToken[] = ValueParser.parseTokens(str, nullValuesSupport, true);\r\n        this.assertValidInfixTokens(tokens, true);\r\n        tokens = this.simplify(tokens);\r\n        try {\r\n            const rpn: ValueToken[] = ValueParser.toRPN(tokens);\r\n            return ValueParser.rpnToVETree(rpn);\r\n        }\r\n        catch (err) {\r\n            throw insertRangeIfUndefined(err, getRange(str));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses given string infix boolean and algebraic expression and returns errors in it.\r\n     * For supported operations see ValueParser.parse().\r\n     *\r\n     * @param str infix boolean and algebraic expression to be parsed\r\n     * @param nullValuesSupport whether null values are supported\r\n     * @param columns\r\n     */\r\n    public static fakeParse(str: IndexedString, nullValuesSupport: boolean, columns: string[]): ErrorWithTextRange[] {\r\n        const errors: ErrorWithTextRange[] = [];\r\n        let tokens: ValueToken[] = ValueParser.parseTokens(str, nullValuesSupport, false, errors);\r\n        tokens.forEach(token => {\r\n            if (token instanceof ReferenceToken && columns.indexOf(token.str.toString()) === -1) {\r\n                errors.push(ErrorFactory.semanticError(SemanticErrorCodes.referenceValue_eval_absentColumn,\r\n                    getRange(token.str), token.str.toString(), columns.join(', ')));\r\n            }\r\n        })\r\n        this.assertValidInfixTokens(tokens, false, errors);\r\n        return errors;\r\n    }\r\n\r\n    /**\r\n     * Parses given string infix boolean and algebraic expression into an array of Tokens.\r\n     * Tokens are returned infix (in order parsed from string).\r\n     * If doThrow is true, found errors are thrown. Otherwise, they are added in errors array and ignored.\r\n     *\r\n     * @param str infix boolean and algebraic expression to be parsed\r\n     * @param nullValuesSupport whether null values are supported\r\n     * @param doThrow true if errors should be thrown\r\n     * @param errors array for storing not thrown errors\r\n     * @return infix array of parsed Tokens\r\n     */\r\n    public static parseTokens(str: string | IndexedString, nullValuesSupport: boolean, doThrow: boolean,\r\n                              errors: ErrorWithTextRange[] = []): ValueToken[] {\r\n        const handleError = (error: RASyntaxError) => {\r\n            if (doThrow) {\r\n                throw error;\r\n            }\r\n            else {\r\n                errors.push(error);\r\n            }\r\n        }\r\n        let rest: string | IndexedString = str.trim();\r\n        if (isEmpty(rest)) {\r\n            handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_parseTokens_emptyInput, undefined));\r\n        }\r\n        const tokens: ValueToken[] = [];\r\n        while (!isEmpty(rest)) {\r\n            rest = rest.trim();\r\n            // PARENTHESES\r\n            if (rest.startsWith('(')) {\r\n                tokens.push(new OpeningParentheses(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            else if (rest.startsWith(')')) {\r\n                tokens.push(new ClosingParentheses(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            // COMPUTING OPERATORS\r\n            else if (rest.startsWith('+')) {\r\n                tokens.push(new ComputingPlusToken(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            else if (rest.startsWith('-')) {\r\n                tokens.push(new ComputingMinusToken(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            else if (rest.startsWith('*')) {\r\n                tokens.push(new ComputingMultiplicationToken(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            else if (rest.startsWith('/')) {\r\n                tokens.push(new ComputingDivisionToken(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            // COMPARING OPERATORS\r\n            else if (rest.startsWith('==')) {\r\n                tokens.push(new ComparingToken(ComparingOperatorType.equal, rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n            }\r\n            else if (rest.startsWith('=')) {     // NOTE: needs to be after '==' check\r\n                tokens.push(new ComparingToken(ComparingOperatorType.equal, rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            else if (rest.startsWith('!=')) {\r\n                tokens.push(new ComparingToken(ComparingOperatorType.nonEqual, rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n            }\r\n            else if (rest.startsWith('<>')) {\r\n                tokens.push(new ComparingToken(ComparingOperatorType.nonEqual, rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n            }\r\n            else if (rest.startsWith('<=')) {\r\n                tokens.push(new ComparingToken(ComparingOperatorType.lessOrEqual, rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n            }\r\n            else if (rest.startsWith('>=')) {\r\n                tokens.push(new ComparingToken(ComparingOperatorType.moreOrEqual, rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n            }\r\n            else if (rest.startsWith('<')) {\r\n                tokens.push(new ComparingToken(ComparingOperatorType.less, rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            else if (rest.startsWith('>')) {\r\n                tokens.push(new ComparingToken(ComparingOperatorType.more, rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            // LOGICAL OPERATORS\r\n            else if (rest.startsWith('!') || rest.startsWith('~')\r\n                || rest.startsWith('\\u00ac')) { // NOTE: needs to be after '!=' check\r\n                tokens.push(new LogicalNotToken(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            else if (rest.startsWith('&&')) {\r\n                tokens.push(new LogicalAndToken(rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n            }\r\n            else if (rest.startsWith('&') || rest.startsWith('\\u2227')) { // NOTE: needs to be after '&&' check\r\n                tokens.push(new LogicalAndToken(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            else if (rest.startsWith('||')) {\r\n                tokens.push(new LogicalOrToken(rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n            }\r\n            else if (rest.startsWith('|') || rest.startsWith('\\u2228')) { // NOTE: needs to be after '||' check\r\n                tokens.push(new LogicalOrToken(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n            }\r\n            // LITERALS\r\n            else if (rest.startsWith('\"')) {\r\n                const split = nextQuotedString(rest);\r\n                if (split.error !== undefined) {\r\n                    handleError(split.error);\r\n                }\r\n                const end = length(split.first) > 1 ? -1 : undefined;\r\n                const str = split.first.slice(1, end);\r\n                tokens.push(new LiteralToken(str, str.toString(), \"string\"));\r\n                rest = split.second;\r\n            }\r\n            else if (Parser.isDigit(rest.charAt(0))) {\r\n                let split = (rest instanceof IndexedString) ? ParserIndexed.nextNumber(rest) : Parser.nextNumber(rest);\r\n                tokens.push(new LiteralToken(split.first, Number(split.first.toString()), \"number\"));\r\n                rest = split.second;\r\n            }\r\n            else if (rest.startsWith('null')) {\r\n                if (!nullValuesSupport) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_parseTokens_unsupportedNull,\r\n                        getRange(rest.slice(0, 4))));\r\n                }\r\n                tokens.push(new LiteralToken(rest.slice(0, 4), null, \"null\"));\r\n                rest = rest.slice(4);\r\n            }\r\n            else if (rest.startsWith('true') || rest.startsWith('True') || rest.startsWith('TRUE')) {\r\n                tokens.push(new LiteralToken(rest.slice(0, 4), true, \"boolean\"));\r\n                rest = rest.slice(4);\r\n            }\r\n            else if (rest.startsWith('false') || rest.startsWith('False') || rest.startsWith('FALSE')) {\r\n                tokens.push(new LiteralToken(rest.slice(0, 5), false, \"boolean\"));\r\n                rest = rest.slice(5);\r\n            }\r\n            // COLUMN REFERENCE\r\n            else if (Parser.isLetter(rest.charAt(0)) || rest.charAt(0) === '_') {\r\n                let split = (rest instanceof IndexedString) ? ParserIndexed.nextName(rest) : Parser.nextName(rest);\r\n                tokens.push(new ReferenceToken(split.first));\r\n                rest = split.second;\r\n            }\r\n            // UNEXPECTED PART\r\n            else {\r\n                const split = (rest instanceof IndexedString) ? ParserIndexed.nextNonWhitespacePart(rest) : Parser.nextNonWhitespacePart(rest);\r\n                handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_parseTokens_unexpectedPart,\r\n                    getRange(split.first), split.first.toString()));\r\n                rest = rest.slice(length(split.first));\r\n            }\r\n        }\r\n        return tokens;\r\n    }\r\n\r\n    /**\r\n     * It checks whether all adjacent pairs of tokens are possible and if the array start and end are valid\r\n     * (e.i., it starts with '(', literal, column reference or '!' and it ends with ')', literal or column reference).\r\n     * If doThrow is true, found errors are thrown. Otherwise, they are added in errors array and ignored.\r\n     */\r\n    public static assertValidInfixTokens(tokens: ValueToken[], doThrow: boolean, errors: ErrorWithTextRange[] = []) {\r\n        if (tokens.length === 0) {\r\n            return;\r\n        }\r\n        \r\n        const handleError = (error: RASyntaxError) => {\r\n            if (doThrow) {\r\n                throw error;\r\n            }\r\n            else {\r\n                errors.push(error);\r\n            }\r\n        }\r\n        \r\n        // checks start of an array: it must start with '(', literal, reference or '!'\r\n        // it cannot start with binary operator or ')'\r\n        if ((tokens[0] instanceof ClosingParentheses) || ((tokens[0] instanceof OperatorToken) && !(tokens[0] instanceof LogicalNotToken))) {\r\n            handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_invalidStart,\r\n                tokens[0].getRange(), tokens[0].str.toString()));\r\n        }\r\n        // checks end of an array: it must end with ')', literal or reference\r\n        // it cannot end with operator or '('\r\n        if ((tokens[tokens.length - 1] instanceof OpeningParentheses) || (tokens[tokens.length - 1] instanceof OperatorToken)) {\r\n            handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_invalidEnd,\r\n                tokens[tokens.length - 1].getRange(), tokens[tokens.length - 1].str.toString()));\r\n        }\r\n        // checks adjacent pairs of tokens\r\n        let i2: number = 1;\r\n        while (i2 < tokens.length) {\r\n            const token1: ValueToken = tokens[i2 - 1];\r\n            const token2: ValueToken = tokens[i2];\r\n            ++i2;\r\n\r\n            // valid predecessors: operator or '('\r\n            // invalid predecessors: literal, reference or ')'\r\n            if (token2 instanceof LiteralToken) {\r\n                if (token1 instanceof LiteralToken) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_literalAfterLiteral,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof ReferenceToken) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_literalAfterReference,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof ClosingParentheses) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_literalAfterClosing,\r\n                        token2.getRange(), token2.str.toString()));\r\n                }\r\n            }\r\n            // valid predecessors: operator or '('\r\n            // invalid predecessors: literal, reference or ')'\r\n            else if (token2 instanceof ReferenceToken) {\r\n                if (token1 instanceof LiteralToken) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_referenceAfterLiteral,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof ReferenceToken) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_referenceAfterReference,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof ClosingParentheses) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_referenceAfterClosing,\r\n                        token2.getRange(), token2.str.toString()));\r\n                }\r\n            }\r\n            // valid predecessors: operator or '('\r\n            // invalid predecessors: literal, reference or ')'\r\n            else if (token2 instanceof LogicalNotToken) {\r\n                if (token1 instanceof LiteralToken) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_notAfterLiteral,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof ReferenceToken) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_notAfterReference,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof ClosingParentheses) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_notAfterClosing,\r\n                        token2.getRange(), token2.str.toString()));\r\n                }\r\n            }\r\n            // valid predecessors: literal, reference or ')'\r\n            // invalid predecessors: operator or '('\r\n            else if (token2 instanceof OperatorToken /* only binary (without LogicalNotToken) */ ) {\r\n                if (token1 instanceof OperatorToken) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_binaryAfterOperator,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof OpeningParentheses) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_binaryAfterOpening,\r\n                        token2.getRange(), token2.str.toString()));\r\n                }\r\n            }\r\n            // valid predecessors: operator or '('\r\n            // invalid predecessors: literal, reference or ')'\r\n            else if (token2 instanceof OpeningParentheses) {\r\n                if (token1 instanceof LiteralToken) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_openingAfterLiteral,\r\n                        token2.getRange(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof ReferenceToken) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_openingAfterReference,\r\n                        token2.getRange(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof ClosingParentheses) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_openingAfterClosing,\r\n                        token2.getRange()));\r\n                }\r\n            }\r\n            // valid predecessors: literal or reference\r\n            // invalid predecessors: operator, '(' or ')'\r\n            else if (token2 instanceof ClosingParentheses) {\r\n                if (token1 instanceof OperatorToken) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_closingAfterOperator,\r\n                        token2.getRange(), token1.str.toString()));\r\n                }\r\n                if (token1 instanceof OpeningParentheses) {\r\n                    handleError(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_closingAfterOpening,\r\n                        token2.getRange()));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Simplifies given token array in infix form. That means all groups of LogicalNotTokens ('!') are reduced to 1 or 0\r\n     * tokens (\"!\" => \"!\", \"!!\" => \"\", \"!!!\" => \"!\", \"!!!!\" => \"\", ...).\r\n     *\r\n     * @param tokens tokens to simplify\r\n     */\r\n    public static simplify(tokens: ValueToken[]): ValueToken[] {\r\n        const notIndexes: number[] = [];\r\n        const indexesToRemove: Set<number> = new Set<number>();\r\n        // finds indexes in tokens where '!'s are\r\n        tokens.forEach((token, i) => {\r\n            if (token instanceof LogicalNotToken) {\r\n                notIndexes.push(i);\r\n            }\r\n        });\r\n        for (let i = 1; i < notIndexes.length; ++i) {\r\n            // if there is \"x - 1\" and \"x\" next to each other, adds them to remove\r\n            if (notIndexes[i - 1] + 1 === notIndexes[i]) {\r\n                indexesToRemove.add(notIndexes[i - 1]);\r\n                indexesToRemove.add(notIndexes[i]);\r\n                notIndexes[i] = NaN; // sets to NaN to not remove possible third '!' in a row\r\n            }\r\n        }\r\n        if (indexesToRemove.size === 0) {\r\n            return tokens;\r\n        }\r\n        return tokens.filter((t, i) => !indexesToRemove.has(i));\r\n    }\r\n\r\n    /**\r\n     * Transforms given infix boolean and algebraic expression into postfix (reverse polish) form.\r\n     *\r\n     * @param tokens infix boolean and algebraic expression as Token array\r\n     * @return postfix (reverse polish) form of given array\r\n     */\r\n    public static toRPN(tokens: ValueToken[]): ValueToken[] {\r\n        const rpnQueue: ValueToken[] = [];\r\n        const operatorsStack: Array<OperatorToken | ParenthesisToken> = [];\r\n        tokens.forEach(token => {\r\n            if (token instanceof LiteralToken || token instanceof ReferenceToken) {\r\n                rpnQueue.push(token);\r\n            }\r\n            else if (token instanceof OperatorToken) {\r\n                while (operatorsStack.length > 0 && operatorsStack[operatorsStack.length - 1] instanceof OperatorToken) {\r\n                    // @ts-ignore (token must be of OperatorToken class)\r\n                    let other: OperatorToken = operatorsStack[operatorsStack.length - 1];\r\n                    // all used operators have left associativity\r\n                    if (token.precedence <= other.precedence) {\r\n                        // @ts-ignore (token must be present)\r\n                        rpnQueue.push(operatorsStack.pop());\r\n                    }\r\n                    else {\r\n                        break;\r\n                    }\r\n                }\r\n                operatorsStack.push(token);\r\n            }\r\n            else if (token instanceof OpeningParentheses) {\r\n                operatorsStack.push(token);\r\n            }\r\n            else if (token instanceof ClosingParentheses) {\r\n                while (true) {\r\n                    if (operatorsStack.length === 0) {\r\n                        throw ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_toRPN_missingOpeningParenthesis,\r\n                            undefined);\r\n                    }\r\n                    if (operatorsStack[operatorsStack.length - 1] instanceof OpeningParentheses) {\r\n                        operatorsStack.pop();\r\n                        break;\r\n                    }\r\n                    // @ts-ignore (token must be present)\r\n                    rpnQueue.push(operatorsStack.pop());\r\n                }\r\n            }\r\n        });\r\n        while (operatorsStack.length > 0) {\r\n            // @ts-ignore (token must be present)\r\n            const curToken: ValueToken = operatorsStack.pop();\r\n            if (curToken instanceof OpeningParentheses) {\r\n                throw ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_toRPN_missingClosingParenthesis,\r\n                    undefined);\r\n            }\r\n            else {\r\n                rpnQueue.push(curToken);\r\n            }\r\n        }\r\n        return rpnQueue;\r\n    }\r\n\r\n    /**\r\n     * Creates a value-evaluating tree from the given array of tokens in reverse polish form.\r\n     * Wraps recursive function rpnToVETreeRecursive(tokens), when not all tokens are used, throws error.\r\n     *\r\n     * @param tokens value-evaluating expression in reverse polish form\r\n     * @return VETreeNode tree (its root)\r\n     */\r\n    public static rpnToVETree(tokens: ValueToken[]): VETreeNode {\r\n        const ret: VETreeNode = this.rpnToVETreeRecursive(tokens);\r\n        // not all tokens were used\r\n        if (tokens.length > 0) {\r\n            throw ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_invalidExpression, undefined);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Creates a value-evaluating tree from the given array of tokens in reverse polish form.\r\n     *\r\n     * @param tokens value-evaluating expression in reverse polish form\r\n     * @return VETreeNode tree (its root)\r\n     */\r\n    public static rpnToVETreeRecursive(tokens: ValueToken[]): VETreeNode {\r\n        if (tokens.length === 0) {\r\n            throw ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_rpnToVETree_invalidExpression, undefined);\r\n        }\r\n        // @ts-ignore (there must be a token)\r\n        const token: ValueToken = tokens.pop();\r\n        if (token instanceof LogicalNotToken) {\r\n            const subtree: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            return LogicalOperator.not(token.str, subtree);\r\n        }\r\n        if (token instanceof LogicalAndToken) {\r\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            return LogicalOperator.and(token.str, left, right);\r\n        }\r\n        if (token instanceof LogicalOrToken) {\r\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            return LogicalOperator.or(token.str, left, right);\r\n        }\r\n        if (token instanceof ComparingToken) {\r\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            return new ComparingOperator(token.type, token.str.toString(), left, right);\r\n        }\r\n        if (token instanceof LiteralToken) {\r\n            return new LiteralValue(token.value, token.type);\r\n        }\r\n        if (token instanceof ReferenceToken) {\r\n            return new ReferenceValue(token.str);\r\n        }\r\n        if (token instanceof ComputingPlusToken) {\r\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            return ComputingOperator.add(left, right, token.getRange());\r\n        }\r\n        if (token instanceof ComputingMinusToken) {\r\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            return ComputingOperator.deduct(left, right, token.getRange());\r\n        }\r\n        if (token instanceof ComputingMultiplicationToken) {\r\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            return ComputingOperator.multiply(left, right, token.getRange());\r\n        }\r\n        if (token instanceof ComputingDivisionToken) {\r\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\r\n            return ComputingOperator.divide(left, right, token.getRange());\r\n        }\r\n        // should never happen\r\n        throw ErrorFactory.codeError(CodeErrorCodes.valueParser_rpnToVETreeRecursive_unexpectedToken, JSON.stringify(token));\r\n    }\r\n}","import RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\n\r\n/**\r\n * Classes extending binary node.\r\n */\r\nexport type BinaryNodeClass = \"left antijoin\" | \"right antijoin\" | \"cartesian product\" | \"division\" | \"natural join\"\r\n    | \"left outer join\" | \"right outer join\" | \"full outer join\" | \"left semijoin\" | \"right semijoin\" | \"union\"\r\n    | \"intersection\" | \"difference\" | \"theta join\" | \"left theta semijoin\" | \"right theta semijoin\";\r\n\r\n/**\r\n * Abstract node of the relational algebra syntactic tree with two subtrees.\r\n */\r\nexport default abstract class BinaryNode extends RATreeNode {\r\n\r\n    protected leftSubtree: RATreeNode;\r\n    protected rightSubtree: RATreeNode;\r\n\r\n    protected constructor(left: RATreeNode, right: RATreeNode) {\r\n        super();\r\n        this.leftSubtree = left;\r\n        this.rightSubtree = right;\r\n    }\r\n\r\n    public getLeftSubtree(): RATreeNode {\r\n        return this.leftSubtree;\r\n    }\r\n\r\n    public getRightSubtree(): RATreeNode {\r\n        return this.rightSubtree;\r\n    }\r\n\r\n    /**\r\n     * Fake evaluates left and right subtrees of the current not-parametrized binary node.\r\n     * If not, returns new simple faked schema with empty \"\" name:\r\n     * - type = union: returns union of source schemas\r\n     * - type = left: returns left source schema\r\n     * - type = right: returns right source schema\r\n     */\r\n    protected fakeEvalBinary(cursorIndex: number, type: \"union\" | \"left\" | \"right\"): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} {\r\n        // evaluates the subtrees\r\n        const left: {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} = this.leftSubtree.fakeEval(cursorIndex);\r\n        const right: {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} = this.rightSubtree.fakeEval(cursorIndex);\r\n        // creates return relation\r\n        const result: Relation = new Relation(\"\");\r\n        if (type === \"left\" || type === \"union\") {\r\n            left.result.forEachColumn((type, name) => result.addColumn(name, type));\r\n        }\r\n        if (type === \"right\" || type === \"union\") {\r\n            right.result.forEachColumn((type, name) => result.addColumn(name, type));\r\n        }\r\n        left.errors.push(...right.errors);\r\n        return {result, whispers: left.whispers.length !== 0 ? left.whispers : right.whispers, errors: left.errors};\r\n    }\r\n}","import RATreeNode from \"./raTreeNode\";\r\nimport UnaryNode from \"./unaryNode\";\r\nimport BinaryNode from \"./binaryNode\";\r\nimport {IndexedString} from \"../tools/indexedString\";\r\n\r\n/**\r\n * Finds the root in the given tree with the given index with respect to depth first search. Root has index 0.\r\n *\r\n * @param root root of the searched tree\r\n * @param index index to be found\r\n * @return found root with given index or null if not found\r\n */\r\nexport function depthSearch(root: RATreeNode, index: number): RATreeNode | null {\r\n    let i: number = 0;\r\n    const findIndexInTree = (node: RATreeNode): RATreeNode | null => {\r\n        // wanted index found\r\n        if (i === index) {\r\n            return node;\r\n        }\r\n        i++;\r\n        if (node instanceof UnaryNode) {\r\n            return findIndexInTree(node.getSubtree());\r\n        }\r\n        if (node instanceof BinaryNode) {\r\n            const leftSearch = findIndexInTree(node.getLeftSubtree());\r\n            if (leftSearch === null) {\r\n                return findIndexInTree(node.getRightSubtree());\r\n            }\r\n            return leftSearch;\r\n        }\r\n        // end of the branch without the result\r\n        return null;\r\n    }\r\n    return findIndexInTree(root);\r\n}\r\n\r\n/**\r\n * Computes depth of the tree. One node has depth 0.\r\n *\r\n * @param root root of the tree to compute the depth for\r\n * @return tree depth\r\n */\r\nexport function getTreeDepth(root: RATreeNode): number {\r\n    if (root instanceof BinaryNode) {\r\n        const left: number = getTreeDepth(root.getLeftSubtree());\r\n        const right: number = getTreeDepth(root.getRightSubtree());\r\n        return Math.max(left, right) + 1;\r\n    }\r\n    if (root instanceof UnaryNode) {\r\n        return getTreeDepth(root.getSubtree()) + 1;\r\n    }\r\n    return 0;\r\n}\r\n\r\n/**\r\n * Returns true, if the given cursor position is in the given range and it is not inside quotes.\r\n * Note: given range is expected to be computed from given string.\r\n */\r\nexport function isInRangeAndNotInQuotes(cursor: number, range: { start: number, end: number } | undefined, str: string | IndexedString): boolean {\r\n    if (range !== undefined && str instanceof IndexedString && range.start < cursor && cursor <= range.end) {\r\n        const len = range.end - range.start;\r\n        const s = str.toString();\r\n        const cursorIndexInStr = cursor - range.start;\r\n        let insideQuotes: boolean = false;\r\n        let backslashes: number = 0;\r\n        for (let i = 0; i < len; ++i) {\r\n            const curChar = s.charAt(i);\r\n            // quotes found\r\n            if (curChar === '\"' && (backslashes % 2) === 0) {\r\n                insideQuotes = !insideQuotes;\r\n            }\r\n            if (insideQuotes && curChar === '\\\\') {\r\n                ++backslashes;\r\n            }\r\n            else {\r\n                backslashes = 0;\r\n            }\r\n            if (i === cursorIndexInStr - 1) {\r\n                // when the cursor was reached, returns true, when it is not in quotes\r\n                return !insideQuotes;\r\n            }\r\n        }\r\n        console.warn(\"isInRangeAndNotInQuotes outside range\")\r\n    }\r\n    return false;\r\n}","import BinaryNode from \"./binaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport Row from \"../relation/row\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\n\r\n/**\r\n * Types of antijoin node.\r\n */\r\nexport enum AntijoinType {\r\n    left = \"\\u22b3\",\r\n    right = \"\\u22b2\"\r\n}\r\n\r\n/**\r\n * Antijoin node of the relational algebra syntactic tree.\r\n */\r\nexport default class AntijoinNode extends BinaryNode {\r\n\r\n    private readonly type: AntijoinType;\r\n\r\n    public constructor(operator: AntijoinType, leftSubtree: RATreeNode, rightSubtree: RATreeNode) {\r\n        super(leftSubtree, rightSubtree);\r\n        this.type = operator;\r\n    }\r\n\r\n    /**\r\n     * Expectations on source schemas: none\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n        const leftSource: Relation = this.leftSubtree.getResult();\r\n        const rightSource: Relation = this.rightSubtree.getResult();\r\n        // intersection of columns in left and right subtree\r\n        const commonColumns: string[] = leftSource.getColumnNames().filter(lc => rightSource.hasColumn(lc));\r\n        let rowsToKeep: Row[];   // rows from the subtree, which have to be kept in result\r\n        let rowsToHelp: Row[];\r\n        // change of relational schema\r\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + this.type + rightSource.getName() + \")\");\r\n        if (this.type === AntijoinType.left) {\r\n            leftSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n            rowsToKeep = leftSource.getRows();\r\n            rowsToHelp = rightSource.getRows();\r\n        }\r\n        else {\r\n            rightSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n            rowsToKeep = rightSource.getRows();\r\n            rowsToHelp = leftSource.getRows();\r\n        }\r\n        // join of relation rows\r\n        rowsToKeep.forEach(keptRow => {\r\n            let someMatch: boolean = rowsToHelp.some(helpRow => {\r\n                // if all common columns match, the row should not be added\r\n                return commonColumns.every(c => keptRow.getValue(c) === helpRow.getValue(c));\r\n            });\r\n            if (!someMatch) {\r\n                let newRow: Row = new Row(result.getColumns());\r\n                keptRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                result.addRow(newRow);\r\n            }\r\n        });\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: none\r\n     * Returned schema: left/right source schema (for left/right antijoin)\r\n     */\r\n    public fakeEval(cursorIndex: number): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} {\r\n        const type = this.type === AntijoinType.left ? \"left\" : \"right\";\r\n        return this.fakeEvalBinary(cursorIndex, type);\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return \"(\" + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + \")\";\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        return this.type === AntijoinType.left ? \"Left antijoin\" : \"Right antijoin\";\r\n    }\r\n\r\n    public getOperationSymbol(): string {\r\n        return this.type;\r\n    }\r\n}","import UnaryNode from \"./unaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport {VETreeNode} from \"../vetree/veTreeNode\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\nimport {getRange, IndexedString} from \"../tools/indexedString\";\r\nimport ValueParser from \"../expression/valueParser\";\r\nimport {ErrorFactory, SyntaxErrorCodes} from \"../error/errorFactory\";\r\nimport ErrorWithTextRange, {insertRangeIfUndefined} from \"../error/errorWithTextRange\";\r\nimport {isInRangeAndNotInQuotes} from \"./raTreeTools\";\r\n\r\n/**\r\n * Selection node of the relational algebra syntactic tree.\r\n */\r\nexport default class SelectionNode extends UnaryNode {\r\n\r\n    private readonly selection: string | IndexedString;\r\n    private readonly stringRange: { start: number, end: number } | undefined;\r\n    private readonly nullValuesSupport: boolean;\r\n\r\n    /**\r\n     * Expects the selection string to start with '(' and end with ')'.\r\n     *\r\n     * @param selection\r\n     * @param subtree\r\n     * @param nullValuesSupport\r\n     */\r\n    public constructor(selection: string | IndexedString, subtree: RATreeNode, nullValuesSupport: boolean) {\r\n        super(subtree);\r\n        this.selection = selection;\r\n        this.stringRange = getRange(selection);\r\n        this.nullValuesSupport = nullValuesSupport;\r\n    }\r\n\r\n    /**\r\n     * Expectations: condition is valid expression which evaluates to boolean\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n\r\n        let boolExpr: VETreeNode;\r\n        try {\r\n            boolExpr = ValueParser.parse(this.selection.slice(1, -1), this.nullValuesSupport);\r\n        }\r\n        catch (e) {\r\n            throw insertRangeIfUndefined(e, this.stringRange);\r\n        }\r\n\r\n        const source: Relation = this.subtree.getResult();\r\n        const result: Relation = new Relation(source.name + \"(...)\");\r\n        source.forEachColumn((type, name) => result.addColumn(name, type));\r\n\r\n        source.getRows().forEach(row => {\r\n            let bool: { value: ColumnContent, type: SupportedColumnType | \"null\" } = boolExpr.eval(row);\r\n            if (bool.type !== \"boolean\") {\r\n                throw ErrorFactory.syntaxError(SyntaxErrorCodes.selectionNode_eval_resultNotBoolean,\r\n                    this.stringRange, this.selection.replace(/\\s+/g, \" \"), bool.type);\r\n            }\r\n            if (bool.value) {\r\n                result.addRow(row);\r\n            }\r\n        });\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: columns names used in the condition exists in source schema\r\n     * Returned schema: source schema\r\n     * Usage of absent column names does not affect returned schema.\r\n     */\r\n    public fakeEval(cursorIndex: number): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} {\r\n        let {result, whispers, errors} = this.subtree.fakeEval(cursorIndex);\r\n        const newResult = new Relation(result.getName() + \"(...)\");\r\n        result.forEachColumn((type, name) => {\r\n            newResult.addColumn(name, type);\r\n        });\r\n        result = newResult;\r\n        // checks whether the cursor is in this selection block (and not in the string) - saves current available columns\r\n        if (isInRangeAndNotInQuotes(cursorIndex, this.stringRange, this.selection)) {\r\n            whispers = result.getColumnNames();\r\n        }\r\n        // checks empty selection input\r\n        if (this.selection.toString().slice(1, -1).trim().length  === 0) {\r\n            errors.push(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_parseTokens_emptyInput, this.stringRange));\r\n        }\r\n        // adds errors from current expression\r\n        else if (this.selection instanceof IndexedString) {\r\n            errors.push(...ValueParser.fakeParse(this.selection.slice(1, -1), this.nullValuesSupport, result.getColumnNames()));\r\n        }\r\n        // result schema is the same as the source\r\n        return {result, whispers, errors};\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return this.subtree.printInLine() + this.getOperationSymbol();\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        return \"Selection\";\r\n    }\r\n\r\n    public getOperationSymbol(): string {\r\n        return this.selection.replace(/\\s+/g, ' ');\r\n    }\r\n}","import BinaryNode from \"./binaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport Row from \"../relation/row\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\n\r\n/**\r\n * Types of outer join node.\r\n */\r\nexport enum OuterJoinType {\r\n    left = \"*L*\",\r\n    right = \"*R*\",\r\n    full = \"*F*\"\r\n}\r\n\r\n/**\r\n * Outer join node of the relational algebra syntactic tree.\r\n */\r\nexport default class OuterJoinNode extends BinaryNode {\r\n\r\n    private readonly type: OuterJoinType;\r\n\r\n    public constructor(operator: OuterJoinType, leftSubtree: RATreeNode, rightSubtree: RATreeNode) {\r\n        super(leftSubtree, rightSubtree);\r\n        this.type = operator;\r\n    }\r\n\r\n    /**\r\n     * Expectations on source schemas: none\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n        const leftSource: Relation = this.leftSubtree.getResult();\r\n        const rightSource: Relation = this.rightSubtree.getResult();\r\n        // change of relational schema\r\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + this.type + rightSource.getName() + \")\");\r\n        leftSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n        rightSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n        // join of relation rows\r\n        const leftRows: Row[] = leftSource.getRows();\r\n        const rightRows: Row[] = rightSource.getRows();\r\n        // intersection of columns in left and right subtree\r\n        const commonColumns: string[] = leftSource.getColumnNames().filter(lc => rightSource.hasColumn(lc));\r\n        // adds naturally joined rows\r\n        leftRows.forEach(leftRow => {\r\n            rightRows.forEach(rightRow => {\r\n                // if all common columns have the same value\r\n                if (commonColumns.every(c => leftRow.getValue(c) === rightRow.getValue(c))) {\r\n                    let newRow: Row = new Row(result.getColumns());\r\n                    leftRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                    rightRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                    result.addRow(newRow);\r\n                }\r\n            });\r\n        });\r\n        // adds left source rows with right null values\r\n        if (this.type === OuterJoinType.left || this.type === OuterJoinType.full) {\r\n            leftRows.forEach(leftRow => {\r\n                let someMatch: boolean = rightRows.some(rightRow => {\r\n                    // if all common columns match, the row should not be added\r\n                    return commonColumns.every(c => leftRow.getValue(c) === rightRow.getValue(c));\r\n                });\r\n                if (!someMatch) {\r\n                    let newRow: Row = new Row(result.getColumns());\r\n                    leftRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                    result.addRow(newRow);\r\n                }\r\n            });\r\n        }\r\n        // adds right source rows with left null values\r\n        if (this.type === OuterJoinType.right || this.type === OuterJoinType.full) {\r\n            rightRows.forEach(rightRow => {\r\n                let someMatch: boolean = leftRows.some(leftRow => {\r\n                    // if all common columns match, the row should not be added\r\n                    return commonColumns.every(c => leftRow.getValue(c) === rightRow.getValue(c));\r\n                });\r\n                if (!someMatch) {\r\n                    let newRow: Row = new Row(result.getColumns());\r\n                    rightRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                    result.addRow(newRow);\r\n                }\r\n            });\r\n        }\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: none\r\n     * Returned schema: union of source schemas (in all cases - full/left/right)\r\n     */\r\n    public fakeEval(cursorIndex: number): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} {\r\n        return this.fakeEvalBinary(cursorIndex, \"union\");\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return \"(\" + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + \")\";\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        let typeStr: string;\r\n        if (this.type === OuterJoinType.left) {\r\n            typeStr = \"Left\";\r\n        }\r\n        else if (this.type === OuterJoinType.right) {\r\n            typeStr = \"Right\";\r\n        }\r\n        else {\r\n            typeStr = \"Full\";\r\n        }\r\n        return typeStr + \" outer join\";\r\n    }\r\n\r\n    public getOperationSymbol(): string {\r\n        return this.type;\r\n    }\r\n}","import BinaryNode from \"./binaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport Row from \"../relation/row\";\r\nimport {ErrorFactory, SemanticErrorCodes} from \"../error/errorFactory\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\n\r\n/**\r\n * Cartesian product node of the relational algebra syntactic tree.\r\n */\r\nexport default class CartesianProductNode extends BinaryNode {\r\n\r\n    public constructor(leftSubtree: RATreeNode, rightSubtree: RATreeNode, private stringRange?: { start: number, end: number }) {\r\n        super(leftSubtree, rightSubtree);\r\n    }\r\n\r\n    /**\r\n     * Expectations on source schemas: disjointness\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n        const leftSource: Relation = this.leftSubtree.getResult();\r\n        const rightSource: Relation = this.rightSubtree.getResult();\r\n        // join of relational schema\r\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + \"\\u2a2f\" + rightSource.getName() + \")\");\r\n        leftSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n        rightSource.forEachColumn((type, name) => {\r\n            if (!result.addColumn(name, type)) {\r\n                throw ErrorFactory.semanticError(SemanticErrorCodes.binaryNode_eval_commonColumnsInSources,\r\n                    this.stringRange, \"cartesian product\", name);\r\n            }\r\n        });\r\n        // join of relation rows\r\n        leftSource.getRows().forEach(leftRow => {\r\n            rightSource.getRows().forEach(rightRow => {\r\n                let newRow: Row = new Row(result.getColumns());\r\n                leftRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                rightRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                result.addRow(newRow);\r\n            });\r\n        });\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: disjointness\r\n     * Returned schema: union of source schemas\r\n     * Returned fake schema is not affected when disjointness is not held\r\n     */\r\n    public fakeEval(cursorIndex: number): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]}{\r\n        // evaluates the subtrees\r\n        const left: {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} = this.leftSubtree.fakeEval(cursorIndex);\r\n        const right: {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} = this.rightSubtree.fakeEval(cursorIndex);\r\n        // creates return relation\r\n        const result: Relation = new Relation(\"\");\r\n        left.result.forEachColumn((type, name) => result.addColumn(name, type));\r\n        right.result.forEachColumn((type, name) => result.addColumn(name, type));\r\n        // checks errors\r\n        left.errors.push(...right.errors);\r\n        const commonColumns: string[] = [];\r\n        left.result.getColumnNames().forEach(leftColumn => {\r\n            if (right.result.hasColumn(leftColumn)) {\r\n                commonColumns.push(leftColumn);\r\n            }\r\n        });\r\n        if (commonColumns.length > 0) {\r\n            left.errors.push(ErrorFactory.semanticError(SemanticErrorCodes.binaryNode_eval_commonColumnsInSources,\r\n                this.stringRange, \"cartesian product\", commonColumns.join('\", \"')));\r\n        }\r\n        return {result, whispers: left.whispers.length !== 0 ? left.whispers : right.whispers, errors: left.errors};\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return \"(\" + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + \")\";\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        return \"Cartesian product\";\r\n    }\r\n\r\n    public getOperationSymbol(): string {\r\n        return \"⨯\";\r\n    }\r\n}","import BinaryNode from \"./binaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport Row from \"../relation/row\";\r\nimport {SupportedColumnType} from \"../relation/columnType\";\r\nimport {ErrorFactory, SemanticErrorCodes} from \"../error/errorFactory\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\n\r\n/**\r\n * Division node of the relational algebra syntactic tree.\r\n */\r\nexport default class DivisionNode extends BinaryNode {\r\n\r\n    public constructor(leftSubtree: RATreeNode, rightSubtree: RATreeNode, private stringRange?: { start: number, end: number }) {\r\n        super(leftSubtree, rightSubtree);\r\n    }\r\n\r\n    /**\r\n     * Expectations on source schemas: right source schema is a proper subset of left source schema\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n        const leftSource: Relation = this.leftSubtree.getResult();\r\n        const rightSource: Relation = this.rightSubtree.getResult();\r\n        const leftColumns: Map<string, SupportedColumnType> = leftSource.getColumns();\r\n        const rightColumns: Map<string, SupportedColumnType> = rightSource.getColumns();\r\n\r\n        if (![...rightColumns].every(value => leftColumns.has(value[0]) && leftColumns.get(value[0]) === value[1])) {\r\n            throw ErrorFactory.semanticError(SemanticErrorCodes.divisionNode_eval_rightColumnsNotSubsetOfLeft,\r\n                this.stringRange, rightSource.getSchemaString(), leftSource.getSchemaString());\r\n        }\r\n\r\n        // difference of columns in left and right subtree\r\n        const resultColumns: Map<string, SupportedColumnType> = new Map<string, SupportedColumnType>();\r\n        leftColumns.forEach((type, name) => {\r\n           if (!rightColumns.has(name)) {\r\n               resultColumns.set(name, type);\r\n           }\r\n        });\r\n\r\n        if (resultColumns.size === 0) {\r\n            throw ErrorFactory.semanticError(SemanticErrorCodes.divisionNode_eval_rightColumnsNotProperSubsetOfLeft,\r\n                this.stringRange, rightSource.getNamesSchemaString(), leftSource.getNamesSchemaString());\r\n        }\r\n\r\n        // join of relational schema\r\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + \"\\u00f7\" + rightSource.getName() + \")\");\r\n        resultColumns.forEach((type, name) => result.addColumn(name, type));\r\n        // filter relation rows\r\n        const leftRows: Row[] = leftSource.getRows();\r\n        const rightRows: Row[] = rightSource.getRows();\r\n        leftRows.forEach(leftRow => {\r\n           if (rightRows.every(rightRow => {\r\n               // creates a row with left row's extra columns and right row's common columns\r\n               let testRow: Row = new Row(leftColumns);\r\n               // left row's extra columns\r\n               // @ts-ignore ('name' must be present in left row)\r\n               resultColumns.forEach((type, name) => testRow.addValue(name, leftRow.getValue(name)));\r\n               // right row's common columns\r\n               rightRow.getValues().forEach((type, name) => testRow.addValue(name, type));\r\n               // tests if the created row exists in left relation\r\n               return [...leftRows].some(lr => lr.equals(testRow));\r\n           })) {\r\n               let newRow: Row = new Row(result.getColumns());\r\n               // @ts-ignore ('name' must be present in left row)\r\n               resultColumns.forEach((value, name) => newRow.addValue(name, leftRow.getValue(name)));\r\n               result.addRow(newRow);\r\n           }\r\n        });\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: right source schema is a proper subset of left source schema\r\n     * Returned schema: left source schema minus right source schema\r\n     * Returned fake schema may be empty (right source schema may contain all left source columns).\r\n     */\r\n    public fakeEval(cursorIndex: number): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} {\r\n        const left: {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} = this.leftSubtree.fakeEval(cursorIndex);\r\n        const right: {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} = this.rightSubtree.fakeEval(cursorIndex);\r\n        const leftColumns = left.result.getColumns();\r\n        const rightColumns = right.result.getColumns();\r\n        // creates relation schema - \"left columns minus right columns\"\r\n        const resultColumns = new Map([...leftColumns.entries()].filter(([key, _]) => !rightColumns.has(key)));\r\n        const result = new Relation(\"(\" + left.result.getName() + \"\\u00f7\" + right.result.getName() + \")\");\r\n        resultColumns.forEach((type, name) => result.addColumn(name, type));\r\n        // checks errors in schema\r\n        const errors = left.errors;\r\n        errors.push(...right.errors);\r\n        if (![...rightColumns].every(value => leftColumns.has(value[0]) && leftColumns.get(value[0]) === value[1])\r\n            && left.result.getName() !== \"\") {\r\n            errors.push(ErrorFactory.semanticError(SemanticErrorCodes.divisionNode_eval_rightColumnsNotSubsetOfLeft,\r\n                this.stringRange, right.result.getSchemaString(), left.result.getSchemaString()));\r\n        }\r\n        else if (resultColumns.size === 0 && left.result.getName() !== \"\") {\r\n            errors.push(ErrorFactory.semanticError(SemanticErrorCodes.divisionNode_eval_rightColumnsNotProperSubsetOfLeft,\r\n                this.stringRange, right.result.getNamesSchemaString(), left.result.getNamesSchemaString()));\r\n        }\r\n        return {result, whispers: left.whispers.length !== 0 ? left.whispers : right.whispers, errors};\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return \"(\" + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + \")\";\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        return \"Division\";\r\n    }\r\n\r\n    public getOperationSymbol(): string {\r\n        return \"÷\";\r\n    }\r\n}","import BinaryNode from \"./binaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport Row from \"../relation/row\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\n\r\n/**\r\n * Types of natural join node.\r\n */\r\nexport enum NaturalJoinType {\r\n    natural = \"*\",\r\n    leftSemi = \"<*\",\r\n    rightSemi = \"*>\"\r\n}\r\n\r\n/**\r\n * Natural join or semi join node of the relational algebra syntactic tree.\r\n */\r\nexport default class NaturalJoinNode extends BinaryNode {\r\n\r\n    private readonly type: NaturalJoinType;\r\n\r\n    public constructor(operator: NaturalJoinType, leftSubtree: RATreeNode, rightSubtree: RATreeNode) {\r\n        super(leftSubtree, rightSubtree);\r\n        this.type = operator;\r\n    }\r\n\r\n    /**\r\n     * Expectations on source schemas: none\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n        const leftSource: Relation = this.leftSubtree.getResult();\r\n        const rightSource: Relation = this.rightSubtree.getResult();\r\n        // intersection of columns in left and right subtree\r\n        const commonColumns: string[] = leftSource.getColumnNames().filter(lc => rightSource.hasColumn(lc));\r\n        // change of relational schema\r\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + this.type + rightSource.getName() + \")\");\r\n        if (this.type === NaturalJoinType.leftSemi || this.type === NaturalJoinType.natural) {\r\n            leftSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n        }\r\n        if (this.type === NaturalJoinType.rightSemi || this.type === NaturalJoinType.natural) {\r\n            rightSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n        }\r\n        // join of relation rows\r\n        leftSource.getRows().forEach(leftRow => {\r\n            rightSource.getRows().forEach(rightRow => {\r\n                // if all common columns have the same value\r\n                if ([...commonColumns].every(c => leftRow.getValue(c) === rightRow.getValue(c))) {\r\n                    let newRow: Row = new Row(result.getColumns());\r\n                    if (this.type === NaturalJoinType.leftSemi || this.type === NaturalJoinType.natural) {\r\n                        leftRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                    }\r\n                    if (this.type === NaturalJoinType.rightSemi || this.type === NaturalJoinType.natural) {\r\n                        rightRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                    }\r\n                    result.addRow(newRow);\r\n                }\r\n            });\r\n        });\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: none\r\n     * Returned schema: left/right/both source schema (for left-semijoin/right-semijoin/natural join)\r\n     */\r\n    public fakeEval(cursorIndex: number): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} {\r\n        let type: \"union\" | \"left\" | \"right\" = \"union\";\r\n        if (this.type === NaturalJoinType.leftSemi) {\r\n            type = \"left\";\r\n        }\r\n        else if (this.type === NaturalJoinType.rightSemi) {\r\n            type = \"right\";\r\n        }\r\n        return this.fakeEvalBinary(cursorIndex, type);\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return \"(\" + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + \")\";\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        if (this.type === NaturalJoinType.leftSemi) {\r\n            return \"Left semijoin\";\r\n        }\r\n        else if (this.type === NaturalJoinType.rightSemi) {\r\n            return \"Right semijoin\";\r\n        }\r\n        else {\r\n            return \"Natural join\";\r\n        }\r\n    }\r\n\r\n    public getOperationSymbol(): string {\r\n        return \"*\";\r\n    }\r\n\r\n    public getType(): NaturalJoinType {\r\n        return this.type;\r\n    }\r\n}","import BinaryNode from \"./binaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport Row from \"../relation/row\";\r\nimport { isEqual } from \"lodash\";\r\nimport {ErrorFactory, SemanticErrorCodes} from \"../error/errorFactory\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\n\r\n/**\r\n * Types of set operation node.\r\n */\r\nexport enum SetOperationType {\r\n    union = \"\\u222a\",\r\n    intersection = \"\\u2229\",\r\n    difference = \"\\\\\"\r\n}\r\n\r\n/**\r\n * Set operation node of the relational algebra syntactic tree.\r\n */\r\nexport default class SetOperationNode extends BinaryNode {\r\n\r\n    private readonly type: SetOperationType;\r\n\r\n    public constructor(operator: SetOperationType, leftSubtree: RATreeNode, rightSubtree: RATreeNode,\r\n                       private stringRange?: { start: number, end: number }) {\r\n        super(leftSubtree, rightSubtree);\r\n        this.type = operator;\r\n    }\r\n\r\n    private getTypeStr(): string {\r\n        if (this.type === SetOperationType.union) {\r\n            return \"Union\";\r\n        }\r\n        else if (this.type === SetOperationType.intersection) {\r\n            return \"Intersection\";\r\n        }\r\n        else {\r\n            return \"Difference\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Expectations on source schemas: equality\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n        const leftSource: Relation = this.leftSubtree.getResult();\r\n        const rightSource: Relation = this.rightSubtree.getResult();\r\n\r\n        if (!isEqual(leftSource.getColumns(), rightSource.getColumns())) {\r\n            let typeStr: string = this.getTypeStr().toLowerCase();\r\n            throw ErrorFactory.semanticError(SemanticErrorCodes.setOperationNode_eval_notEqualColumnsInSources,\r\n                this.stringRange, leftSource.getSchemaString(), rightSource.getSchemaString(), typeStr);\r\n        }\r\n        // copy of relational schema\r\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + this.type + rightSource.getName() + \")\");\r\n        leftSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n        // change of relation rows\r\n        let resultRows: Row[];\r\n        const leftRows: Row[] = leftSource.getRows();\r\n        const rightRows: Row[] = rightSource.getRows();\r\n        if (this.type === SetOperationType.union) {\r\n            resultRows = [...leftRows, ...rightRows];\r\n        }\r\n        else if (this.type === SetOperationType.intersection) {\r\n            resultRows = [...leftRows].filter(lr => [...rightRows].some(rr => lr.equals(rr)));\r\n        }\r\n        else /* this.type === SetOperationType.difference */ {\r\n            resultRows = [...leftRows].filter(lr => ![...rightRows].some(rr => lr.equals(rr)));\r\n        }\r\n        resultRows.forEach(row => result.addRow(row));\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: equality\r\n     * Returned schema: intersection of source schemas\r\n     * Returned schema may be empty (when there is no common column in sources).\r\n     * Second possible approach would be to return union of source schemas (less strict).\r\n     */\r\n    public fakeEval(cursorIndex: number): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} {\r\n        const left: {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} = this.leftSubtree.fakeEval(cursorIndex);\r\n        const right: {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} = this.rightSubtree.fakeEval(cursorIndex);\r\n        // join of relational schema - \"left intersection right\"\r\n        const result: Relation = new Relation(\"(\" + left.result.getName() + this.type + right.result.getName() + \")\");\r\n        left.result.forEachColumn((type, name) => {\r\n            if (right.result.hasColumn(name)) {\r\n                result.addColumn(name, type);\r\n            }\r\n        });\r\n        // checks errors in schema\r\n        const errors = left.errors;\r\n        errors.push(...right.errors);\r\n        if (!isEqual(left.result.getColumns(), right.result.getColumns()) && left.result.getName() !== \"\" && right.result.getName() !== \"\") {\r\n            let typeStr: string = this.getTypeStr().toLowerCase();\r\n            errors.push(ErrorFactory.semanticError(SemanticErrorCodes.setOperationNode_eval_notEqualColumnsInSources,\r\n                this.stringRange, left.result.getSchemaString(), right.result.getSchemaString(), typeStr));\r\n        }\r\n        return {result, whispers: left.whispers.length !== 0 ? left.whispers : right.whispers, errors};\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return \"(\" + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + \")\";\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        return this.getTypeStr();\r\n    }\r\n\r\n    public getOperationSymbol(): string {\r\n        return this.type;\r\n    }\r\n}","import BinaryNode from \"./binaryNode\";\r\nimport RATreeNode from \"./raTreeNode\";\r\nimport Relation from \"../relation/relation\";\r\nimport Row from \"../relation/row\";\r\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\r\nimport {VETreeNode} from \"../vetree/veTreeNode\";\r\nimport {getRange, IndexedString} from \"../tools/indexedString\";\r\nimport ValueParser from \"../expression/valueParser\";\r\nimport {ErrorFactory, SemanticErrorCodes, SyntaxErrorCodes} from \"../error/errorFactory\";\r\nimport ErrorWithTextRange, {insertRangeIfUndefined} from \"../error/errorWithTextRange\";\r\nimport {isInRangeAndNotInQuotes} from \"./raTreeTools\";\r\n\r\n/**\r\n * Types of theta join node.\r\n */\r\nexport enum ThetaJoinType {\r\n    full = \"[]\",\r\n    left = \"<]\",\r\n    right = \"[>\"\r\n}\r\n\r\n/**\r\n * Theta join or theta semijoin node of the relational algebra syntactic tree.\r\n */\r\nexport default class ThetaJoinNode extends BinaryNode {\r\n\r\n    private readonly type: ThetaJoinType;\r\n    private readonly condition: string | IndexedString;\r\n    private readonly stringRange: { start: number, end: number } | undefined;\r\n    private readonly nullValuesSupport: boolean;\r\n\r\n    /**\r\n     * Expects the condition string to start with '<' and end with ']' or start with '[' and end with '>'.\r\n     */\r\n    public constructor(type: ThetaJoinType, condition: string | IndexedString,\r\n                       leftSubtree: RATreeNode, rightSubtree: RATreeNode, nullValuesSupport: boolean) {\r\n        super(leftSubtree, rightSubtree);\r\n        this.condition = condition;\r\n        this.stringRange = getRange(condition);\r\n        this.nullValuesSupport = nullValuesSupport;\r\n        this.type = type;\r\n    }\r\n\r\n    /**\r\n     * Expectations on source schemas: disjointness\r\n     * Other expectations: condition is valid expression which evaluates to boolean\r\n     */\r\n    public eval(): void {\r\n        if (this.isEvaluated()) {\r\n            return;\r\n        }\r\n\r\n        let boolExpr: VETreeNode;\r\n        try {\r\n            boolExpr = ValueParser.parse(this.condition.slice(1, -1), this.nullValuesSupport);   // slices brackets out\r\n        }\r\n        catch (e) {\r\n            throw insertRangeIfUndefined(e, this.stringRange);\r\n        }\r\n\r\n        const leftSource: Relation = this.leftSubtree.getResult();\r\n        const rightSource: Relation = this.rightSubtree.getResult();\r\n\r\n        leftSource.getColumnNames().forEach(leftColumn => {\r\n            if (rightSource.hasColumn(leftColumn)) {\r\n                throw ErrorFactory.semanticError(SemanticErrorCodes.binaryNode_eval_commonColumnsInSources, this.stringRange,\r\n                    this.getOperationName().toLowerCase(), leftColumn);\r\n            }\r\n        });\r\n        // change of relational schema\r\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + this.type.charAt(0) + \"...\" + this.type.charAt(1) + rightSource.getName() + \")\");\r\n        if (this.type === ThetaJoinType.left || this.type === ThetaJoinType.full) {\r\n            leftSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n        }\r\n        if (this.type === ThetaJoinType.right || this.type === ThetaJoinType.full) {\r\n            rightSource.forEachColumn((type, name) => result.addColumn(name, type));\r\n        }\r\n        // combine columns of both source relations to use it in testing row\r\n        const bothSourceColumns: Map<string, SupportedColumnType> = new Map<string, SupportedColumnType>(leftSource.getColumns());\r\n        rightSource.forEachColumn((type, name) => bothSourceColumns.set(name, type));\r\n\r\n        leftSource.getRows().forEach(leftRow => {\r\n            rightSource.getRows().forEach(rightRow => {\r\n                const testRow: Row = new Row(bothSourceColumns);\r\n                leftRow.getValues().forEach((value, name) => testRow.addValue(name, value));\r\n                rightRow.getValues().forEach((value, name) => testRow.addValue(name, value));\r\n                // checks whether the combined row from both relations' columns satisfies the condition\r\n                let booleanResult: { value: ColumnContent, type: SupportedColumnType | \"null\" } = boolExpr.eval(testRow);\r\n                if (booleanResult.type !== \"boolean\") {\r\n                    throw ErrorFactory.syntaxError(SyntaxErrorCodes.thetaSemiJoinNode_eval_resultNotBoolean,\r\n                        this.stringRange, this.condition.replace(/\\s+/g, \" \"), booleanResult.type);\r\n                }\r\n                if (booleanResult.value) {\r\n                    const newRow: Row = new Row(result.getColumns());\r\n                    if (this.type === ThetaJoinType.left || this.type === ThetaJoinType.full) {\r\n                        leftRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                    }\r\n                    if (this.type === ThetaJoinType.right || this.type === ThetaJoinType.full) {\r\n                        rightRow.getValues().forEach((value, name) => newRow.addValue(name, value));\r\n                    }\r\n                    result.addRow(newRow);\r\n                }\r\n            });\r\n        });\r\n        this.resultRelation = result;\r\n    }\r\n\r\n    /**\r\n     * Strict expectations: disjointness\r\n     * Returned schema: left/right/both source schema (for left/right/full semijoin)\r\n     * Returned fake schema is not affected when disjointness is not held\r\n     */\r\n    public fakeEval(cursorIndex: number): {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} {\r\n        const left: {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} = this.leftSubtree.fakeEval(cursorIndex);\r\n        const right: {result: Relation, whispers: string[], errors: ErrorWithTextRange[]} = this.rightSubtree.fakeEval(cursorIndex);\r\n        const sourceColumns: string[] = [];\r\n        sourceColumns.push(...left.result.getColumnNames());\r\n        sourceColumns.push(...right.result.getColumnNames());\r\n        // creates return relation\r\n        const result: Relation = new Relation(\"\");\r\n        if (this.type === ThetaJoinType.left || this.type === ThetaJoinType.full) {\r\n            left.result.forEachColumn((type, name) => result.addColumn(name, type));\r\n        }\r\n        if (this.type === ThetaJoinType.right || this.type === ThetaJoinType.full) {\r\n            right.result.forEachColumn((type, name) => result.addColumn(name, type));\r\n        }\r\n        // checks whether the cursor is in this condition block (and not in the string) - saves current available columns\r\n        let whispers = left.whispers.length !== 0 ? left.whispers : right.whispers;\r\n        if (isInRangeAndNotInQuotes(cursorIndex, this.stringRange, this.condition)) {\r\n            whispers = sourceColumns;\r\n        }\r\n        // adds errors from current expression\r\n        const errors = left.errors;\r\n        errors.push(...right.errors);\r\n        const commonColumns: string[] = [];\r\n        left.result.getColumnNames().forEach(leftColumn => {\r\n            if (right.result.hasColumn(leftColumn)) {\r\n                commonColumns.push(leftColumn);\r\n            }\r\n        });\r\n        if (commonColumns.length > 0 && this.stringRange !== undefined) {\r\n            errors.push(ErrorFactory.semanticError(SemanticErrorCodes.binaryNode_eval_commonColumnsInSources,\r\n                {start: this.stringRange.start, end: this.stringRange.start},   // highlight only opening bracket\r\n                this.getOperationName().toLowerCase(), commonColumns.join('\", \"')));\r\n        }\r\n        // checks empty condition input\r\n        if (this.condition.toString().slice(1, -1).trim().length  === 0) {\r\n            errors.push(ErrorFactory.syntaxError(SyntaxErrorCodes.valueParser_parseTokens_emptyInput, this.stringRange));\r\n        }\r\n        else if (this.condition instanceof IndexedString) {\r\n            errors.push(...ValueParser.fakeParse(this.condition.slice(1, -1), this.nullValuesSupport, sourceColumns));\r\n        }\r\n        return {result, whispers, errors};\r\n    }\r\n\r\n    public printInLine(): string {\r\n        return \"(\" + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + \")\";\r\n    }\r\n\r\n    public getOperationName(): string {\r\n        if (this.type === ThetaJoinType.left) {\r\n            return \"Left theta semijoin\";\r\n        }\r\n        else if (this.type === ThetaJoinType.right) {\r\n            return \"Right theta semijoin\";\r\n        }\r\n        else {\r\n            return \"Theta join\";\r\n        }\r\n    }\r\n\r\n    public getOperationSymbol(): string {\r\n        return this.condition.replace(/\\s+/g, ' ');\r\n    }\r\n\r\n    public getType(): ThetaJoinType {\r\n        return this.type;\r\n    }\r\n}","import Relation from \"../relation/relation\";\r\nimport {CodeErrorCodes, ErrorFactory, SemanticErrorCodes, SyntaxErrorCodes} from \"../error/errorFactory\";\r\nimport {\r\n    BinaryOperatorToken,\r\n    ClosingParentheses,\r\n    ExprToken,\r\n    OpeningParentheses,\r\n    ParenthesisToken,\r\n    RelationToken,\r\n    UnaryOperatorToken\r\n} from \"./exprTokens\";\r\nimport Parser from \"../tools/parser\";\r\nimport CodeError from \"../error/codeError\";\r\nimport RATreeNode from \"../ratree/raTreeNode\";\r\nimport RelationNode from \"../ratree/relationNode\";\r\nimport {\r\n    containsAny,\r\n    getRange,\r\n    IndexedString,\r\n    isEmpty,\r\n    nextBorderedPart\r\n} from \"../tools/indexedString\";\r\nimport ParserIndexed from \"../tools/parserIndexed\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\nimport RATreeFactory from \"../ratree/raTreeFactory\";\r\n\r\n/**\r\n * Assertion types for assertValidInfixTokens function.\r\n */\r\nenum AssertType {\r\n    NOT_THROW,\r\n    THROW_STRICT,\r\n    THROW_NOT_STRICT\r\n}\r\n\r\n/**\r\n * Parser of relational algebra expressions. Provides parsing function parse(String expr) and additional\r\n * helping functions and predicates. Uses IndexedString to describe error ranges in thrown errors.\r\n */\r\nexport class ExprParser {\r\n\r\n    /**\r\n     * Creates a parser with given source relations.\r\n     *\r\n     * @param relations Map with relations' names as keys and relation themselves as values used as source for leave nodes\r\n     * @param nullValuesSupport whether to support null values\r\n     */\r\n    public constructor(readonly relations: Map<string, Relation>, readonly nullValuesSupport: boolean) {}\r\n\r\n    /**\r\n     * Parses given relational algebra expression 'expr' and returns tree of RA operations.\r\n     * Expression is expected to respect following constraints:\r\n     * - all relation's and column's names contain letters, numbers and underscores only\r\n     * - all relation's and column's names start with a letter\r\n     * - used operations must be in a practical notation and be well-structured\r\n     * - comment begins with '//' and ends with newline\r\n     *\r\n     * Supported operations are:\r\n     * - projection of columns: Relation[projectedColumn1, ...]\r\n     * - selection of rows: Relation(condition)\r\n     * - rename of columns: Relation<oldName -> newName, ...>\r\n     * - cartesian product: A \\u2a2f B\r\n     * - natural join: A * B\r\n     * - theta join: A [condition] B\r\n     * - left and right semijoin: A <* B and A *> B\r\n     * - left and right antijoin: A \\u22b3 B and A \\u22b2 B\r\n     * - left and right theta semijoin: A <condition] B and A [condition> B\r\n     * - division: A \\u00f7 B\r\n     * - left, right and full outer join: A *L* B, A *R* B and A *F* B\r\n     * - union, intersection and difference: A \\u222a B, A \\u2229 B and A \\ B\r\n     *\r\n     * See ValueParser for condition constraints.\r\n     *\r\n     * @param expr relational algebra expression in expected format\r\n     * @return tree structure of 'expr'\r\n     */\r\n    public parse(expr: string): RATreeNode {\r\n        expr = Parser.deleteCommentLines(expr);\r\n        if (expr.trim() === \"\") {\r\n            throw ErrorFactory.syntaxError(SyntaxErrorCodes.exprParser_parse_emptyStringGiven, undefined);\r\n        }\r\n        const tokens: ExprToken[] = this.parseTokens(expr);\r\n        this.assertValidInfixTokens(tokens, AssertType.THROW_STRICT);\r\n        const rpn: ExprToken[] = this.toRPN(tokens);\r\n        return this.rpnToRATree(rpn, true);\r\n    }\r\n\r\n    /**\r\n     * Indexed version of ExprParser.parse() function. Uses IndexedString to describe error ranges.\r\n     * See ExprParser.parse for detailed description.\r\n     *\r\n     * @param expr relational algebra expression in expected format\r\n     * @return tree structure of 'expr'\r\n     */\r\n    public indexedParse(expr: string): RATreeNode {\r\n        const indexedExpr = ParserIndexed.deleteCommentLines(IndexedString.new(expr));\r\n        if (indexedExpr.trim().isEmpty()) {\r\n            throw ErrorFactory.syntaxError(SyntaxErrorCodes.exprParser_parse_emptyStringGiven, undefined);\r\n        }\r\n        const tokens: ExprToken[] = this.parseTokens(indexedExpr);\r\n        this.assertValidInfixTokens(tokens, AssertType.THROW_STRICT);\r\n        const rpn: ExprToken[] = this.toRPN(tokens);\r\n        return this.rpnToRATree(rpn, true);\r\n    }\r\n\r\n    /**\r\n     * Parses given expression and finds words to whisper for the given cursorIndex.\r\n     * If the cursor is located next to any RA operator, returns list of all defined relation names.\r\n     * If the cursor is located inside any RA operator, which uses relation columns, returns list of available column\r\n     * names at given place.\r\n     * If a parsing error occurs, it is faked to work or ignored and reported in returning errors array.\r\n     */\r\n    public fakeParse(expr: string, cursorIndex: number): {whispers: string[], errors: ErrorWithTextRange[]} {\r\n        if (expr.trim() === \"\") {\r\n            return {whispers: [...this.relations.keys()], errors: []};\r\n        }\r\n        const indexedExpr = ParserIndexed.deleteCommentLines(IndexedString.new(expr));\r\n        const {whispers, tokens, errors} = this.fakeParseTokens(indexedExpr, cursorIndex);\r\n        // prevent errors in creation of RPN\r\n        if (tokens.length === 0) {\r\n            return {whispers: whispers, errors: errors};\r\n        }\r\n        // fakes found errors to valid parse\r\n        this.assertValidInfixTokens(tokens, AssertType.NOT_THROW, errors);\r\n        const rpn: ExprToken[] = this.toRPN(tokens);\r\n        const raTree: RATreeNode = this.rpnToRATree(rpn, false, errors);\r\n        // tries to find whispers inside RA operations with parameters\r\n        const innerResult: {whispers: string[], errors: ErrorWithTextRange[]} = raTree.fakeEval(cursorIndex);\r\n        errors.push(...innerResult.errors);\r\n        // if there are whispers from inner operators, returns them\r\n        if (innerResult.whispers.length > 0) {\r\n            return {whispers: innerResult.whispers, errors: errors};\r\n        }\r\n        // otherwise returns outer whispers (or empty array if no were found)\r\n        return {whispers: whispers, errors: errors};\r\n    }\r\n\r\n    /**\r\n     * Given expression string is expected to be without comment lines and not empty.\r\n     *\r\n     * @param expr IndexedString to parse the expression from\r\n     * @param selectionExpected true if next part \"(...)\" should be treated as a selection = last part\r\n     * was a relation or an unary operator (default false)\r\n     */\r\n    public parseTokens(expr: string | IndexedString, selectionExpected: boolean = false): ExprToken[] {\r\n        let tokens: ExprToken[] = [];\r\n        // alternative solution in case of finding \"[...]\"\r\n        let alternativeTokens: ExprToken[] = [];\r\n        let rest: string | IndexedString = expr;\r\n\r\n        while (!isEmpty(rest)) {\r\n            rest = rest.trim();\r\n            // '(' can be a selection or a parentheses\r\n            if (rest.startsWith(\"(\")) {\r\n                const split = nextBorderedPart(rest, '(', ')');\r\n                // whole \"(...)\" part pushed as selection\r\n                if (selectionExpected) {\r\n                    tokens.push(UnaryOperatorToken.selection(split.first));\r\n                }\r\n                // inner of \"(...)\" part parsed as parentheses structure\r\n                else {\r\n                    tokens.push(new OpeningParentheses(split.first.slice(0, 1)));\r\n                    tokens.push(...this.parseTokens(split.first.slice(1, -1)));\r\n                    tokens.push(new ClosingParentheses(split.first.slice(-1)));\r\n                    selectionExpected = true;\r\n                }\r\n                rest = split.second;\r\n            }\r\n            // '[' can be a projection, theta join, or right theta semi join\r\n            else if (rest.startsWith(\"[\")) {\r\n                const split = nextBorderedPart(rest, '[', ']>');\r\n                // right theta semijoin found\r\n                if (split.first.endsWith('>')) {\r\n                    tokens.push(BinaryOperatorToken.rightThetaSemijoin(split.first));\r\n                    selectionExpected = false;\r\n                    rest = split.second;\r\n                }\r\n                // the expression cannot end with a theta join (right source expected)\r\n                else if (isEmpty(split.second)) {\r\n                    tokens.push(UnaryOperatorToken.projection(split.first));\r\n                    break;\r\n                }\r\n                // it is no known yet whether it is a projection or a theta join, recursively tries both possibilities\r\n                else {\r\n                    let errorAlternative: Error | undefined;\r\n                    let error: Error | undefined;\r\n\r\n                    // 1: treat as Theta join (it must copy tokens first)\r\n                    try {\r\n                        alternativeTokens.push(...tokens);\r\n                        alternativeTokens.push(BinaryOperatorToken.thetaJoin(split.first));\r\n                        alternativeTokens.push(...this.parseTokens(split.second, false));\r\n                    }\r\n                    catch (err) {\r\n                        if (err instanceof CodeError) {\r\n                            throw err;\r\n                        }\r\n                        errorAlternative = err;\r\n                    }\r\n\r\n                    // 2: treat as Projection\r\n                    try {\r\n                        tokens.push(UnaryOperatorToken.projection(split.first));\r\n                        tokens.push(...this.parseTokens(split.second, true));\r\n                    }\r\n                    catch (err) {\r\n                        if (err instanceof CodeError) {\r\n                            throw err;\r\n                        }\r\n                        error = err;\r\n                    }\r\n\r\n                    // both branches have error - reports it to user\r\n                    if (errorAlternative !== undefined && error !== undefined) {\r\n                        // when errors were the same, throws one of them\r\n                        if (errorAlternative.message === error.message) {\r\n                            throw error;\r\n                        }\r\n                        // when errors were different, joins them\r\n                        throw ErrorFactory.syntaxError(SyntaxErrorCodes.exprParser_parseTokens_bothBranchesError,\r\n                            undefined, split.first.toString(), error.message, errorAlternative.message);\r\n                    }\r\n                    // does not use alternative tokens after error\r\n                    if (errorAlternative !== undefined) {\r\n                        alternativeTokens = [];\r\n                    }\r\n                    // uses alternative tokens after error in second branch\r\n                    if (error !== undefined) {\r\n                        tokens = alternativeTokens;\r\n                        alternativeTokens = [];\r\n                    }\r\n                    // breaks the while - the rest was parsed recursively\r\n                    break;\r\n                }\r\n            }\r\n            // BINARY OPERATORS\r\n            else if (rest.startsWith(\"*F*\") || rest.startsWith(\"*L*\") || rest.startsWith(\"*R*\")) {\r\n                if (!this.nullValuesSupport) {\r\n                    let errorRange: {start: number, end: number} | undefined = undefined;\r\n                    if (rest instanceof IndexedString && rest.getFirstNonNaNIndex() !== undefined) {\r\n                        // @ts-ignore\r\n                        errorRange = {start: rest.getFirstNonNaNIndex(), end: rest.getFirstNonNaNIndex() + 2};\r\n                    }\r\n                    throw ErrorFactory.syntaxError(SyntaxErrorCodes.exprParser_parseTokens_outerJoinWhenNullNotSupported,\r\n                        errorRange, \"*F*\");\r\n                }\r\n                if (rest.startsWith(\"*F\")) {\r\n                    tokens.push(BinaryOperatorToken.fullOuterJoin(rest.slice(0, 3)));\r\n                }\r\n                else if (rest.startsWith(\"*L\")) {\r\n                    tokens.push(BinaryOperatorToken.leftOuterJoin(rest.slice(0, 3)));\r\n                }\r\n                else {\r\n                    tokens.push(BinaryOperatorToken.rightOuterJoin(rest.slice(0, 3)));\r\n                }\r\n                rest = rest.slice(3);\r\n                selectionExpected = false;\r\n            }\r\n            else if (rest.startsWith(\"<*\")) {\r\n                tokens.push(BinaryOperatorToken.leftSemijoin(rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n                selectionExpected = false;\r\n            }\r\n            else if (rest.startsWith(\"*>\")) {\r\n                tokens.push(BinaryOperatorToken.rightSemijoin(rest.slice(0, 2)));\r\n                rest = rest.slice(2);\r\n                selectionExpected = false;\r\n            }\r\n            else if (rest.startsWith(\"*\")) {\r\n                tokens.push(BinaryOperatorToken.naturalJoin(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n                selectionExpected = false;\r\n            }\r\n            else if (rest.startsWith(\"\\u2a2f\")) {\r\n                tokens.push(BinaryOperatorToken.cartesianProduct(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n                selectionExpected = false;\r\n            }\r\n            else if (rest.startsWith(\"\\u222a\")) {\r\n                tokens.push(BinaryOperatorToken.union(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n                selectionExpected = false;\r\n            }\r\n            else if (rest.startsWith(\"\\u2229\")) {\r\n                tokens.push(BinaryOperatorToken.intersection(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n                selectionExpected = false;\r\n            }\r\n            else if (rest.startsWith(\"\\\\\")) {\r\n                tokens.push(BinaryOperatorToken.difference(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n                selectionExpected = false;\r\n            }\r\n            else if (rest.startsWith(\"\\u22b3\")) {\r\n                tokens.push(BinaryOperatorToken.leftAntijoin(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n                selectionExpected = false;\r\n            }\r\n            else if (rest.startsWith(\"\\u22b2\")) {\r\n                tokens.push(BinaryOperatorToken.rightAntijoin(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n                selectionExpected = false;\r\n            }\r\n            else if (rest.startsWith(\"\\u00f7\")) {\r\n                tokens.push(BinaryOperatorToken.division(rest.slice(0, 1)));\r\n                rest = rest.slice(1);\r\n                selectionExpected = false;\r\n            }\r\n            // '<' can be a rename or left theta semi join - this \"if\" must be after <* and *>\r\n            else if (rest.startsWith('<')) {\r\n                const split = nextBorderedPart(rest, '<', '>]', '-');\r\n                if (split.first.endsWith('>')) {\r\n                    tokens.push(UnaryOperatorToken.rename(split.first));\r\n                    selectionExpected = true;\r\n                }\r\n                else {\r\n                    tokens.push(BinaryOperatorToken.leftThetaSemijoin(split.first));\r\n                    selectionExpected = false;\r\n                }\r\n                rest = split.second;\r\n            }\r\n            // RELATION REFERENCE\r\n            else if (Parser.isLetter(rest.charAt(0)) || rest.charAt(0) === '_') {\r\n                const split = (rest instanceof IndexedString) ? ParserIndexed.nextName(rest) : Parser.nextName(rest);\r\n                tokens.push(new RelationToken(split.first));\r\n                rest = split.second;\r\n                selectionExpected = true;\r\n            }\r\n            // UNEXPECTED PART\r\n            else {\r\n                const split = (rest instanceof IndexedString) ? ParserIndexed.nextNonWhitespacePart(rest) : Parser.nextNonWhitespacePart(rest);\r\n                throw ErrorFactory.syntaxError(SyntaxErrorCodes.exprParser_parseTokens_unexpectedPart,\r\n                    getRange(split.first), split.first.toString());\r\n            }\r\n        }\r\n        // checks whether alternative tokens are valid when used\r\n        if (alternativeTokens.length > 0) {\r\n            try {\r\n                // assert not strict validity (because this can be in nested recursion call where some rules are not held)\r\n                this.assertValidInfixTokens(alternativeTokens, AssertType.THROW_NOT_STRICT, []);\r\n                // if error not thrown, returns alternative tokens\r\n                return alternativeTokens;\r\n            }\r\n            catch (ignored) {}\r\n        }\r\n        // when alternative tokens are not set or valid, returns tokens\r\n        return tokens;\r\n    }\r\n\r\n    /**\r\n     * Parses given expression to ExprToken array. While parsing, it tries to find cursor index and returns whispers.\r\n     * Parsing errors are not thrown but stored in errors array.\r\n     *\r\n     * @param expr IndexedString to parse the expression from\r\n     * @param cursorIndex\r\n     * @param selectionExpected true if next part \"(...)\" should be treated as a selection = last part\r\n     * was a relation or an unary operator (default false)\r\n     */\r\n    public fakeParseTokens(expr: IndexedString, cursorIndex: number, selectionExpected: boolean = false):\r\n        { tokens: ExprToken[], whispers: string[], errors: ErrorWithTextRange[] } {\r\n        let whispers: string[] = [];\r\n        let tokens: ExprToken[] = [];\r\n        let errors: ErrorWithTextRange[] = [];\r\n\r\n        let rest: IndexedString = expr;\r\n        while (!rest.isEmpty()) {\r\n            // checks whether the cursor was reached\r\n            const restStartIndex: number | undefined = rest.getFirstNonNaNIndex();\r\n            if (restStartIndex === cursorIndex) {\r\n                whispers = [...this.relations.keys()];\r\n            }\r\n\r\n            //rest = rest.trim();\r\n            // '(' can be a selection or a parentheses\r\n            if (rest.startsWith(\"(\")) {\r\n                let split: {first: IndexedString, second: IndexedString};\r\n                try {\r\n                    split = ParserIndexed.nextBorderedPart(rest, '(', ')');\r\n                }\r\n                // catches error from nextBorderedPart\r\n                catch (err) {\r\n                    // saves error\r\n                    if (err instanceof ErrorWithTextRange) {\r\n                        errors.push(err);\r\n                    }\r\n\r\n                    if (selectionExpected) {\r\n                        // it fakes the unclosed expression part as a selection operator\r\n                        // pushes space with valid index and parentheses with NaN index for expected behavior (error\r\n                        // indexing) in fakeEval in selection/theta join nodes and fakeEval in ValueParser\r\n                        tokens.push(UnaryOperatorToken.selection(rest.concat(IndexedString.newFromArray([\r\n                            {char: ' ', index: rest.getNextIndexOrNaN()}, {char: ')', index: NaN}]))));\r\n                    }\r\n                    else {\r\n                        // checks whether the cursor was reached after the opening parentheses\r\n                        if (restStartIndex === cursorIndex - 1) {\r\n                            whispers = [...this.relations.keys()];\r\n                        }\r\n\r\n                        // it fakes the unclosed expression as nested expression in parentheses\r\n                        tokens.push(new OpeningParentheses(rest.slice(0, 1)));\r\n                        // parses inner part between parentheses\r\n                        const recursiveReturn = this.fakeParseTokens(rest.slice(1), cursorIndex);\r\n                        errors.push(...recursiveReturn.errors);\r\n                        whispers.push(...recursiveReturn.whispers);\r\n                        tokens.push(...recursiveReturn.tokens);\r\n                        // gives invalid index (NaN for not reporting errors with this imaginary parentheses\r\n                        tokens.push(new ClosingParentheses(IndexedString.new(')', NaN)));\r\n                    }\r\n                    // breaks the while cycle because rest was parsed recursively\r\n                    break;\r\n                }\r\n\r\n                // whole \"(...)\" part pushed as selection\r\n                if (selectionExpected) {\r\n                    tokens.push(UnaryOperatorToken.selection(split.first));\r\n                }\r\n                // inner of \"(...)\" part parsed as parentheses structure\r\n                else {\r\n                    tokens.push(new OpeningParentheses(split.first.slice(0, 1)));\r\n                    const recursiveReturn = this.fakeParseTokens(split.first.slice(1, -1), cursorIndex);\r\n                    errors.push(...recursiveReturn.errors);\r\n                    whispers.push(...recursiveReturn.whispers);\r\n                    tokens.push(...recursiveReturn.tokens);\r\n                    tokens.push(new ClosingParentheses(split.first.slice(-1)));\r\n                    selectionExpected = true;\r\n                }\r\n                rest = split.second;\r\n            }\r\n            // '[' can be a projection, theta join, or right theta semi join\r\n            else if (rest.startsWith(\"[\")) {\r\n                let split: {first: IndexedString, second: IndexedString};\r\n                let error: boolean = false;\r\n                try {\r\n                    split = ParserIndexed.nextBorderedPart(rest, '[', ']>');\r\n                }\r\n                // catches error from nextBorderedPart\r\n                catch (err) {\r\n                    error = true;\r\n                    // saves error\r\n                    if (err instanceof ErrorWithTextRange) {\r\n                        errors.push(err);\r\n                    }\r\n                    // it fakes the unclosed expression part as a projection operator\r\n                    split = {first: rest.concat(IndexedString.new(']', rest.getNextIndexOrNaN())), second: IndexedString.empty()};\r\n                }\r\n\r\n                // checks whether the cursor was reached\r\n                const operatorEndIndex: number | undefined = split.first.getLastNonNaNIndex();\r\n                if (!error && operatorEndIndex === cursorIndex - 1) {\r\n                    whispers = [...this.relations.keys()];\r\n                }\r\n\r\n                // right theta semijoin found \"[...>\"\r\n                if (split.first.endsWith('>')) {\r\n                    tokens.push(BinaryOperatorToken.rightThetaSemijoin(split.first));\r\n                    selectionExpected = false;\r\n                    rest = split.second;\r\n                }\r\n                // if the next part contains any character from =<>+/*&|~\"()! it cannot be a valid Projection\r\n                else if (containsAny(split.first, '=<>+/*&|~\"()!')) {\r\n                    tokens.push(BinaryOperatorToken.thetaJoin(split.first));\r\n                    selectionExpected = false;\r\n                    rest = split.second;\r\n                }\r\n                // else suppose it is a projection\r\n                else {\r\n                    tokens.push(UnaryOperatorToken.projection(split.first));\r\n                    selectionExpected = true;\r\n                    rest = split.second;\r\n                }\r\n            }\r\n            // BINARY OPERATORS\r\n            else if (rest.startsWith(\"*F*\") || rest.startsWith(\"*L*\") || rest.startsWith(\"*R*\")) {\r\n                const operator: IndexedString = rest.slice(0, 3);\r\n                // checks whether the cursor was reached\r\n                const operatorEndIndex: number | undefined = operator.getLastNonNaNIndex();\r\n                if (operatorEndIndex === cursorIndex - 1) {\r\n                    whispers = [...this.relations.keys()];\r\n                }\r\n\r\n                if (rest.startsWith(\"*F\")) {\r\n                    tokens.push(BinaryOperatorToken.fullOuterJoin(operator));\r\n                }\r\n                else if (rest.startsWith(\"*L\")) {\r\n                    tokens.push(BinaryOperatorToken.leftOuterJoin(operator));\r\n                }\r\n                else {\r\n                    tokens.push(BinaryOperatorToken.rightOuterJoin(operator));\r\n                }\r\n                rest = rest.slice(3);\r\n                selectionExpected = false;\r\n            }\r\n            // operators of 2 characters\r\n            else if (rest.startsWith(\"<*\") || rest.startsWith(\"*>\")) {\r\n                const operator: IndexedString = rest.slice(0, 2);\r\n                // checks whether the cursor was reached\r\n                const operatorEndIndex: number | undefined = operator.getLastNonNaNIndex();\r\n                if (operatorEndIndex === cursorIndex - 1) {\r\n                    whispers = [...this.relations.keys()];\r\n                }\r\n\r\n                if (rest.startsWith(\"<*\")) {\r\n                    tokens.push(BinaryOperatorToken.leftSemijoin(operator));\r\n                }\r\n                else {\r\n                    tokens.push(BinaryOperatorToken.rightSemijoin(operator));\r\n                }\r\n                rest = rest.slice(2);\r\n                selectionExpected = false;\r\n            }\r\n            // operators of 1 character\r\n            else if (\"*\\u2a2f\\u222a\\u2229\\\\\\u22b3\\u22b2\\u00f7\".indexOf(rest.charAt(0)) > -1) {\r\n                const operator: IndexedString = rest.slice(0, 1);\r\n                // checks whether the cursor was reached\r\n                const operatorEndIndex: number | undefined = operator.getLastNonNaNIndex();\r\n                if (operatorEndIndex === cursorIndex - 1) {\r\n                    whispers = [...this.relations.keys()];\r\n                }\r\n\r\n                if (rest.startsWith(\"*\")) {\r\n                    tokens.push(BinaryOperatorToken.naturalJoin(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\u2a2f\")) {\r\n                    tokens.push(BinaryOperatorToken.cartesianProduct(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\u222a\")) {\r\n                    tokens.push(BinaryOperatorToken.union(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\u2229\")) {\r\n                    tokens.push(BinaryOperatorToken.intersection(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\\\\")) {\r\n                    tokens.push(BinaryOperatorToken.difference(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\u22b3\")) {\r\n                    tokens.push(BinaryOperatorToken.leftAntijoin(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\u22b2\")) {\r\n                    tokens.push(BinaryOperatorToken.rightAntijoin(operator));\r\n                }\r\n                else if (rest.startsWith(\"\\u00f7\")) {\r\n                    tokens.push(BinaryOperatorToken.division(operator));\r\n                }\r\n                rest = rest.slice(1);\r\n                selectionExpected = false;\r\n            }\r\n            // '<' can be a rename or left theta semi join - this \"if\" must be after <*\r\n            else if (rest.startsWith('<')) {\r\n                try {\r\n                    const split = ParserIndexed.nextBorderedPart(rest, '<', '>]', '-');\r\n                    // checks whether the cursor was reached\r\n                    const operatorEndIndex: number | undefined = split.first.getLastNonNaNIndex();\r\n                    if (operatorEndIndex === cursorIndex - 1) {\r\n                        whispers = [...this.relations.keys()];\r\n                    }\r\n                    // found rename\r\n                    if (split.first.endsWith('>')) {\r\n                        tokens.push(UnaryOperatorToken.rename(split.first));\r\n                        selectionExpected = true;\r\n                    }\r\n                    // found left theta semi join\r\n                    else {\r\n                        tokens.push(BinaryOperatorToken.leftThetaSemijoin(split.first));\r\n                        selectionExpected = false;\r\n                    }\r\n                    rest = split.second;\r\n                }\r\n                    // catches error from nextBorderedPart\r\n                catch (e) {\r\n                    // it fakes the unclosed expression part as a rename operator\r\n                    tokens.push(UnaryOperatorToken.rename(rest.concat(IndexedString.new('>', rest.getNextIndexOrNaN()))));\r\n                    // breaks the while cycle as all was used\r\n                    break;\r\n                }\r\n            }\r\n            // RELATION REFERENCE\r\n            else if (Parser.isLetter(rest.charAt(0)) || rest.charAt(0) === '_') {\r\n                const split = ParserIndexed.nextName(rest);\r\n\r\n                // checks whether the cursor was reached in the relation reference string\r\n                const relationStartIndex: number | undefined = split.first.getFirstNonNaNIndex();\r\n                const relationEndIndex: number | undefined = split.first.getLastNonNaNIndex();\r\n                if (typeof relationStartIndex === \"number\" && typeof relationEndIndex === \"number\" &&\r\n                    relationStartIndex <= cursorIndex - 1 && cursorIndex - 1 <= relationEndIndex) {\r\n                    whispers = [...this.relations.keys()];\r\n                }\r\n\r\n                tokens.push(new RelationToken(split.first));\r\n                rest = split.second;\r\n                selectionExpected = true;\r\n            }\r\n            // WHITE SPACE\r\n            else if (rest.charAt(0).match(/\\s/)) {\r\n                let i = 0;\r\n                while (i < rest.length() && rest.charAt(i).match(/\\s/)) {\r\n                    if (rest.indexAt(i) === cursorIndex - 1) {\r\n                        whispers = [...this.relations.keys()];\r\n                    }\r\n                    ++i;\r\n                }\r\n                rest = rest.slice(i);\r\n            }\r\n            // UNEXPECTED PART\r\n            else {\r\n                const split = ParserIndexed.nextNonWhitespacePart(rest);\r\n                errors.push(ErrorFactory.syntaxError(SyntaxErrorCodes.exprParser_parseTokens_unexpectedPart,\r\n                    getRange(split.first), split.first.toString()));\r\n                // tries to skip first unexpected character\r\n                rest = rest.slice(split.first.length());\r\n            }\r\n        }\r\n        return { tokens, whispers, errors };\r\n    }\r\n\r\n    /**\r\n     * Checks the validity of the given infix token array.\r\n     * If the type is THROW_STRICT or THROW_NOT_STRICT, it throws found errors. Strict version checks the first\r\n     * token in the array, not strict version does not. In both throw version is the errors parameter ignored.\r\n     * If the type is NOT_THROW, it adds fake tokens if the array is not valid.\r\n     * Fake tokens are relations with empty name \"\", or natural joins \"*\", their error ranges are undefined.\r\n     * All faked errors are reported pushed in given errors array.\r\n     * Expects validly nested parentheses: yes \"(()())\", no \")()\", \")(\". Expects not empty array.\r\n     *\r\n     * @param tokens token array to check\r\n     * @param type type of the assertion\r\n     * @param errors array for pushing faked errors for NOT_THROW type\r\n     */\r\n    public assertValidInfixTokens(tokens: ExprToken[], type: AssertType, errors: ErrorWithTextRange[] = []): void {\r\n        /**\r\n         * Handles the error described by given error code, params and range. If doThrow is true, throws the described\r\n         * error. Otherwise, fakes it by inserting a new token at given index. The token is binary (natural join) if\r\n         * missing is \"binary\", otherwise, it is a relation with empty name.\r\n         */\r\n        const handleError = (index: number, missing: \"binary\" | \"relation\",\r\n                             code: SyntaxErrorCodes, range: {start: number, end: number} | undefined, ...params: string[]) => {\r\n            const error = ErrorFactory.syntaxError(code, range, ...params);\r\n            if (type !== AssertType.NOT_THROW) {\r\n                throw error;\r\n            }\r\n            else if (missing === \"binary\") {\r\n                errors.push(error);\r\n                tokens.splice(index, 0, BinaryOperatorToken.naturalJoin(\"*\"));\r\n            }\r\n            else {\r\n                errors.push(error);\r\n                tokens.splice(index, 0, new RelationToken(\"\"));\r\n            }\r\n        }\r\n\r\n        if (type !== AssertType.THROW_NOT_STRICT) {\r\n            // checks start of an array: it must start with '(' or relation\r\n            if (tokens[0] instanceof UnaryOperatorToken || tokens[0] instanceof BinaryOperatorToken || tokens[0] instanceof ClosingParentheses) {\r\n                handleError(0, \"relation\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_invalidStart,\r\n                    tokens[0].getRange(), tokens[0].str.toString());\r\n            }\r\n        }\r\n\r\n        // checks end of an array: it must end with ')', relation or an unary operator\r\n        if (tokens[tokens.length - 1] instanceof OpeningParentheses || tokens[tokens.length - 1] instanceof BinaryOperatorToken) {\r\n            handleError(tokens.length, \"relation\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_invalidEnd,\r\n                tokens[tokens.length - 1].getRange(), tokens[tokens.length - 1].str.toString());\r\n        }\r\n\r\n        // checks adjacent pairs of tokens\r\n        let i2: number = 1;\r\n        while (i2 < tokens.length) {\r\n            const token1: ExprToken = tokens[i2 - 1];\r\n            const token2: ExprToken = tokens[i2];\r\n\r\n            // valid predecessors: binary operator or '('\r\n            if (token2 instanceof RelationToken) {\r\n                if (token1 instanceof RelationToken) {\r\n                    handleError(i2, \"binary\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_relationAfterRelation,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString());\r\n                }\r\n                if (token1 instanceof UnaryOperatorToken) {\r\n                    handleError(i2, \"binary\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_relationAfterUnary,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString());\r\n                }\r\n                if (token1 instanceof ClosingParentheses) {\r\n                    handleError(i2, \"binary\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_relationAfterClosing,\r\n                        token2.getRange(), token2.str.toString());\r\n                }\r\n            }\r\n            // valid predecessors: relation, unary operator or ')'\r\n            else if (token2 instanceof UnaryOperatorToken) {\r\n                if (token1 instanceof BinaryOperatorToken) {\r\n                    handleError(i2, \"relation\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_unaryAfterBinary,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString());\r\n                }\r\n                if (token1 instanceof OpeningParentheses) {\r\n                    handleError(i2, \"relation\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_unaryAfterOpening,\r\n                        token2.getRange(), token2.str.toString());\r\n                }\r\n            }\r\n            // valid predecessors: relation, unary operator or ')'\r\n            else if (token2 instanceof BinaryOperatorToken) {\r\n                if (token1 instanceof BinaryOperatorToken) {\r\n                    handleError(i2, \"relation\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_binaryAfterBinary,\r\n                        token2.getRange(), token2.str.toString(), token1.str.toString());\r\n                }\r\n                if (token1 instanceof OpeningParentheses) {\r\n                    handleError(i2, \"relation\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_binaryAfterOpening,\r\n                        token2.getRange(), token2.str.toString());\r\n                }\r\n            }\r\n            // valid predecessors: binary operator or '('\r\n            else if (token2 instanceof OpeningParentheses) {\r\n                if (token1 instanceof RelationToken) {\r\n                    handleError(i2, \"binary\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_openingAfterRelation,\r\n                        token2.getRange(), token1.str.toString());\r\n                }\r\n                if (token1 instanceof UnaryOperatorToken) {\r\n                    handleError(i2, \"binary\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_openingAfterUnary,\r\n                        token2.getRange(), token1.str.toString());\r\n                }\r\n                if (token1 instanceof ClosingParentheses) {\r\n                    handleError(i2, \"binary\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_openingAfterClosing,\r\n                        token2.getRange());\r\n                }\r\n            }\r\n            // valid predecessors: relation, unary operator or ')'\r\n            else if (token2 instanceof ClosingParentheses) {\r\n                if (token1 instanceof BinaryOperatorToken) {\r\n                    handleError(i2, \"relation\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_closingAfterBinary,\r\n                        token2.getRange(), token1.str.toString());\r\n                }\r\n                if (token1 instanceof OpeningParentheses) {\r\n                    handleError(i2, \"relation\", SyntaxErrorCodes.exprParser_assertValidInfixTokens_closingAfterOpening,\r\n                        token2.getRange());\r\n                }\r\n            }\r\n            else {\r\n                throw ErrorFactory.codeError(CodeErrorCodes.exprParser_isValidSequence_unexpectedToken, JSON.stringify(token2));\r\n            }\r\n            ++i2;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transforms given infix relation algebra expression into postfix (reverse polish) form.\r\n     * Throws error when invalid parentheses structure is given.\r\n     *\r\n     * @param tokens infix relational algebra expression as Token array\r\n     * @return postfix (reverse polish) form of given array\r\n     */\r\n    public toRPN(tokens: ExprToken[]): ExprToken[] {\r\n        const rpnQueue: ExprToken[] = [];\r\n        const operatorsStack: Array<BinaryOperatorToken | ParenthesisToken> = [];\r\n        tokens.forEach(token => {\r\n            if (token instanceof RelationToken || token instanceof UnaryOperatorToken) {\r\n                rpnQueue.push(token);\r\n            }\r\n            else if (token instanceof BinaryOperatorToken) {\r\n                while (operatorsStack.length > 0 && operatorsStack[operatorsStack.length - 1] instanceof BinaryOperatorToken) {\r\n                    // @ts-ignore (token must be of BinaryOperatorToken class)\r\n                    let other: BinaryOperatorToken = operatorsStack[operatorsStack.length - 1];\r\n                    // all used operators have left associativity\r\n                    if (token.precedence <= other.precedence) {\r\n                        // @ts-ignore (token must be present)\r\n                        rpnQueue.push(operatorsStack.pop());\r\n                    }\r\n                    else {\r\n                        break;\r\n                    }\r\n                }\r\n                operatorsStack.push(token);\r\n            }\r\n            else if (token instanceof OpeningParentheses) {\r\n                operatorsStack.push(token);\r\n            }\r\n            else if (token instanceof ClosingParentheses) {\r\n                while (true) {\r\n                    if (operatorsStack.length === 0) {\r\n                        throw ErrorFactory.syntaxError(SyntaxErrorCodes.exprParser_assertValidInfixTokens_invalidParentheses,\r\n                            undefined);\r\n                    }\r\n                    if (operatorsStack[operatorsStack.length - 1] instanceof OpeningParentheses) {\r\n                        operatorsStack.pop();\r\n                        break;\r\n                    }\r\n                    // @ts-ignore (token must be present)\r\n                    rpnQueue.push(operatorsStack.pop());\r\n                }\r\n            }\r\n        });\r\n        while (operatorsStack.length > 0) {\r\n            // @ts-ignore (token must be present)\r\n            const curToken: ExprToken = operatorsStack.pop();\r\n            if (curToken instanceof OpeningParentheses) {\r\n                throw ErrorFactory.syntaxError(SyntaxErrorCodes.exprParser_assertValidInfixTokens_invalidParentheses,\r\n                    undefined);\r\n            }\r\n            else {\r\n                rpnQueue.push(curToken);\r\n            }\r\n        }\r\n        return rpnQueue;\r\n    }\r\n\r\n    /**\r\n     * Creates a RA expression evaluating tree from the given array of tokens in reverse polish form.\r\n     * Wraps recursive function rpnToRATreeRecursive(tokens).\r\n     * Possible errors:\r\n     * - not all tokens were used (invalid RPN structure was given, should not happen if the previous infix structure\r\n     * was asserted/faked) - if doThrow = false, returns a RelationNode with an empty relation\r\n     * - reference to a relation which does not exist found - if doThrow = false, replaces it with an empty relation\r\n     *\r\n     * @param tokens value-evaluating expression in reverse polish form\r\n     * @param doThrow if true and an error occurs, throws an error, if false and an error occurs, fakes it and does\r\n     * not throw\r\n     * @param errors\r\n     * @return RATreeNode tree (its root)\r\n     */\r\n    public rpnToRATree(tokens: ExprToken[], doThrow: boolean, errors: ErrorWithTextRange[] = []): RATreeNode {\r\n        const ret: RATreeNode = this.rpnToRATreeRecursive(tokens, doThrow, errors);\r\n        // not all tokens were used\r\n        if (tokens.length > 0) {\r\n            if (doThrow) {\r\n                throw ErrorFactory.syntaxError(SyntaxErrorCodes.exprParser_rpnToVETree_invalidExpression, undefined);\r\n            }\r\n            else {\r\n                return new RelationNode(new Relation(\"\"));\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    public rpnToRATreeRecursive(tokens: ExprToken[], doThrow: boolean, errors: ErrorWithTextRange[]): RATreeNode {\r\n        if (tokens.length === 0) {\r\n            throw ErrorFactory.syntaxError(SyntaxErrorCodes.exprParser_rpnToVETree_invalidExpression, undefined);\r\n        }\r\n        // @ts-ignore (there must be a token)\r\n        const token: ExprToken = tokens.pop();\r\n        // RELATION REFERENCE\r\n        if (token instanceof RelationToken) {\r\n            const relation: Relation | undefined = this.relations.get(token.str.toString());\r\n            // when the relation does not exist, throws or fakes it with an empty relation\r\n            if (relation === undefined) {\r\n                const error = ErrorFactory.semanticError(SemanticErrorCodes.exprParser_parse_relationNotDefined,\r\n                    token.getRange(), token.str.toString());\r\n                if (doThrow) {\r\n                    throw error;\r\n                }\r\n                else {\r\n                    errors.push(error);\r\n                    return new RelationNode(new Relation(\"\"));\r\n                }\r\n            }\r\n            return new RelationNode(relation);\r\n        }\r\n        // UNARY OPERATORS\r\n        if (token instanceof UnaryOperatorToken) {\r\n            const subtree: RATreeNode = this.rpnToRATreeRecursive(tokens, doThrow, errors);\r\n            return RATreeFactory.createUnary(token.type, subtree, this.nullValuesSupport, token.str);\r\n        }\r\n        // BINARY OPERATORS\r\n        if (token instanceof BinaryOperatorToken) {\r\n            const right: RATreeNode = this.rpnToRATreeRecursive(tokens, doThrow, errors);\r\n            const left: RATreeNode = this.rpnToRATreeRecursive(tokens, doThrow, errors);\r\n            return RATreeFactory.createBinary(token.type, left, right, this.nullValuesSupport, token.str);\r\n        }\r\n        // should never happen\r\n        throw ErrorFactory.codeError(CodeErrorCodes.exprParser_rpnToVETreeRecursive_unexpectedToken, JSON.stringify(token));\r\n    }\r\n}\r\n","import RATreeNode from \"./raTreeNode\";\r\nimport ProjectionNode from \"./projectionNode\";\r\nimport RenameNode from \"./renameNode\";\r\nimport SelectionNode from \"./selectionNode\";\r\nimport UnaryNode, {UnaryNodeClass} from \"./unaryNode\";\r\nimport AntijoinNode, {AntijoinType} from \"./antijoinNode\";\r\nimport CartesianProductNode from \"./cartesianProductNode\";\r\nimport DivisionNode from \"./divisionNode\";\r\nimport OuterJoinNode, {OuterJoinType} from \"./outerJoinNode\";\r\nimport NaturalJoinNode, {NaturalJoinType} from \"./naturalJoinNode\";\r\nimport SetOperationNode, {SetOperationType} from \"./setOperationNode\";\r\nimport BinaryNode, {BinaryNodeClass} from \"./binaryNode\";\r\nimport {getRange, IndexedString} from \"../tools/indexedString\";\r\nimport ThetaJoinNode, {ThetaJoinType} from \"./thetaJoinNode\";\r\n\r\n/**\r\n * Factory for creating unary and binary nodes of given class.\r\n */\r\nexport default class RATreeFactory {\r\n\r\n    /**\r\n     * Creates new unary node of given class.\r\n     *\r\n     * @param unaryClass wanted class\r\n     * @param subtree source subtree for a node\r\n     * @param nullValuesSupport whether null values are supported\r\n     * @param expr expression used to specify node's behavior\r\n     */\r\n    public static createUnary(unaryClass: UnaryNodeClass, subtree: RATreeNode,\r\n                              nullValuesSupport: boolean, expr: string | IndexedString): UnaryNode {\r\n        switch (unaryClass) {\r\n            case \"projection\":\r\n                return new ProjectionNode(expr, subtree);\r\n            case \"rename\":\r\n                return new RenameNode(expr, subtree);\r\n            case \"selection\":\r\n                return new SelectionNode(expr, subtree, nullValuesSupport);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates new binary node of given class.\r\n     *\r\n     * @param binaryClass wanted class\r\n     * @param left left source subtree for a node\r\n     * @param right right source subtree for a node\r\n     * @param nullValuesSupport whether null values are supported\r\n     * @param expr expression used to specify node's behavior\r\n     */\r\n    public static createBinary(binaryClass: BinaryNodeClass, left: RATreeNode, right: RATreeNode,\r\n                               nullValuesSupport: boolean, expr: string | IndexedString): BinaryNode {\r\n        switch (binaryClass) {\r\n            case \"left antijoin\":\r\n                return new AntijoinNode(AntijoinType.left, left, right);\r\n            case \"right antijoin\":\r\n                return new AntijoinNode(AntijoinType.right, left, right);\r\n            case \"cartesian product\":\r\n                return new CartesianProductNode(left, right, getRange(expr));\r\n            case \"division\":\r\n                return new DivisionNode(left, right, getRange(expr));\r\n            case \"natural join\":\r\n                return new NaturalJoinNode(NaturalJoinType.natural, left, right);\r\n            case \"left outer join\":\r\n                return new OuterJoinNode(OuterJoinType.left, left, right);\r\n            case \"right outer join\":\r\n                return new OuterJoinNode(OuterJoinType.right, left, right);\r\n            case \"full outer join\":\r\n                return new OuterJoinNode(OuterJoinType.full, left, right);\r\n            case \"left semijoin\":\r\n                return new NaturalJoinNode(NaturalJoinType.leftSemi, left, right);\r\n            case \"right semijoin\":\r\n                return new NaturalJoinNode(NaturalJoinType.rightSemi, left, right);\r\n            case \"union\":\r\n                return new SetOperationNode(SetOperationType.union, left, right, getRange(expr));\r\n            case \"intersection\":\r\n                return new SetOperationNode(SetOperationType.intersection, left, right, getRange(expr));\r\n            case \"difference\":\r\n                return new SetOperationNode(SetOperationType.difference, left, right, getRange(expr));\r\n            case \"theta join\":\r\n                return new ThetaJoinNode(ThetaJoinType.full, expr, left, right, nullValuesSupport);\r\n            case \"left theta semijoin\":\r\n                return new ThetaJoinNode(ThetaJoinType.left, expr, left, right, nullValuesSupport);\r\n            case \"right theta semijoin\":\r\n                return new ThetaJoinNode(ThetaJoinType.right, expr, left, right, nullValuesSupport);\r\n        }\r\n    }\r\n}","import React from \"react\";\r\n\r\ninterface TextInputProps {\r\n    // label before the input\r\n    label: string,\r\n    // initial value for the input\r\n    value: string,\r\n    // text on the submit button\r\n    buttonText: string,\r\n    // handler of input submit\r\n    onSubmit: (text: string) => void,\r\n    // function which returns true for forbidden inputs which cannot be submitted\r\n    forbidden: (text: string) => boolean,\r\n\r\n    // id of the input\r\n    id: string\r\n}\r\n\r\ninterface TextInputState {\r\n    value: string,\r\n    buttonDisable: boolean\r\n}\r\n\r\n/**\r\n * Basic text input with submit button. The input cannot be submit if the current value is forbidden.\r\n * All inserted tabulators are replaced by 4 spaces.\r\n */\r\nexport class TextInput extends React.Component<TextInputProps, TextInputState> {\r\n\r\n    private readonly inputRef: React.RefObject<HTMLInputElement>;\r\n\r\n    constructor(props: TextInputProps) {\r\n        super(props);\r\n        this.state = {\r\n            value: this.props.value,\r\n            buttonDisable: this.props.forbidden(this.props.value)\r\n        }\r\n        this.inputRef = React.createRef();\r\n    }\r\n\r\n    componentDidUpdate(prevProps: Readonly<TextInputProps>) {\r\n        if (prevProps.value !== this.props.value) {\r\n            this.setState({value: this.props.value});\r\n        }\r\n    }\r\n\r\n    private handleChange = (value: string): void => {\r\n        value = value.replace(/\\t/g, \"    \");\r\n        const disable: boolean = this.props.forbidden(value);\r\n        this.setState({\r\n            value: value,\r\n            buttonDisable: disable\r\n        });\r\n    }\r\n\r\n    private handleKeyDown = (event: React.KeyboardEvent<HTMLInputElement>): void => {\r\n        if (event.key === \"Enter\") {\r\n            if (!this.state.buttonDisable) {\r\n                this.handleSubmit();\r\n            }\r\n        }\r\n        else if (event.key === \"Escape\" || event.key === \"Esc\") {\r\n            if (this.inputRef.current !== null) {\r\n                this.inputRef.current.blur();\r\n            }\r\n        }\r\n    }\r\n\r\n    private handleSubmit = (): void => {\r\n        this.props.onSubmit(this.state.value);\r\n    }\r\n\r\n    public render() {\r\n        return (\r\n            <>\r\n                <label htmlFor={this.props.id}>{this.props.label}</label>\r\n                <input\r\n                    ref={this.inputRef}\r\n                    type='text'\r\n                    id={this.props.id}\r\n                    spellCheck={false}\r\n                    autoComplete={\"off\"}\r\n                    value={this.state.value}\r\n                    onChange={event => this.handleChange(event.target.value)}\r\n                    onKeyDown={this.handleKeyDown}\r\n                    className={'text-input'}\r\n                />\r\n                <button\r\n                    onClick={this.handleSubmit}\r\n                    disabled={this.state.buttonDisable}\r\n                >{this.props.buttonText}</button>\r\n            </>\r\n        );\r\n    }\r\n}","import \"./css/messageBox.css\"\r\n\r\n// @ts-ignore\r\nconst cssConstants: CSSStyleDeclaration = getComputedStyle(document.querySelector(':root'));\r\nconst boxMargin: number = Number(cssConstants.getPropertyValue('--message-box-margin-num'));\r\n\r\nexport class MessageBox {\r\n\r\n    private static readonly hideTimeout: number = 5000;\r\n\r\n    private static box: HTMLDivElement = MessageBox.init();\r\n    private static hideIntervalId: NodeJS.Timeout;\r\n\r\n    private static init(): HTMLDivElement {\r\n        const box = document.createElement(\"div\");\r\n        box.classList.add(\"message-box\");\r\n        box.style.visibility = \"hidden\";\r\n        box.onmouseenter = () => {\r\n            MessageBox.clearHideTimeout();\r\n        }\r\n        box.onmouseleave = () => {\r\n            MessageBox.setHideTimeout();\r\n        }\r\n\r\n        const paragraph = document.createElement(\"p\");\r\n        box.appendChild(paragraph);\r\n\r\n        const button = document.createElement(\"button\");\r\n        button.innerText = \"\\u2716\";\r\n        button.onclick = () => {\r\n            MessageBox.hideBox();\r\n        }\r\n        box.appendChild(button);\r\n\r\n        window.addEventListener('resize', () => {\r\n            MessageBox.moveBox();\r\n        });\r\n\r\n        document.body.appendChild(box);\r\n        return box;\r\n    }\r\n\r\n    private static setHideTimeout = () => {\r\n        // clears previous hide interval\r\n        MessageBox.clearHideTimeout();\r\n        MessageBox.hideIntervalId = setTimeout(MessageBox.hideBox, MessageBox.hideTimeout);\r\n    }\r\n\r\n    private static clearHideTimeout = () => {\r\n        clearTimeout(MessageBox.hideIntervalId);\r\n    }\r\n\r\n    private static hideBox = () => {\r\n        MessageBox.box.style.visibility = \"hidden\";\r\n    }\r\n\r\n    private static moveBox = () => {\r\n        if (MessageBox.box.style.visibility === \"visible\") {\r\n            MessageBox.box.style.width = (document.body.clientWidth - 2 * boxMargin) + \"px\";\r\n        }\r\n    }\r\n\r\n    private static display(msg: string, error: boolean): void {\r\n        const box = MessageBox.box;\r\n        // @ts-ignore - first element is paragraph\r\n        box.firstElementChild.innerText = msg;\r\n        box.style.visibility = \"visible\";\r\n        box.classList.toggle(\"message-box-message\", !error);\r\n        box.classList.toggle(\"message-box-error\", error);\r\n        MessageBox.moveBox();\r\n        MessageBox.setHideTimeout();\r\n    }\r\n\r\n    /**\r\n     * Displays given message in a message box fixed on the page bottom.\r\n     */\r\n    public static message(msg: string): void {\r\n        MessageBox.display(msg, false);\r\n    }\r\n\r\n    /**\r\n     * Displays given error in a message box fixed on the page bottom.\r\n     */\r\n    public static error(msg: string): void {\r\n        MessageBox.display(msg, true);\r\n    }\r\n}","import React from \"react\";\r\nimport \"./css/expressionSection.css\"\r\nimport Relation from \"../relation/relation\";\r\nimport {TooltipButton} from \"./tooltipButton\";\r\nimport RASyntaxError from \"../error/raSyntaxError\";\r\nimport RASemanticError from \"../error/raSemanticError\";\r\nimport {XTextArea} from \"./xTextArea\";\r\nimport {ExprParser} from \"../expression/exprParser\";\r\nimport {getStartOfWordBeforeIndex, sortWhispers} from \"../tools/whisper\";\r\nimport {Expression} from \"../expression/expression\";\r\nimport {TextInput} from \"./textInput\";\r\nimport ErrorWithTextRange from \"../error/errorWithTextRange\";\r\nimport RATreeNode from \"../ratree/raTreeNode\";\r\nimport {MessageBox} from \"./messageBox\";\r\n\r\ninterface ExpressionSectionProps {\r\n    // available expressions\r\n    expressions: Expression[],\r\n    // index of the current selected expression in the expression list\r\n    currentExpressionIndex: number,\r\n\r\n    // loaded relations user as sources for expression evaluation\r\n    relations: Map<string, Relation>,\r\n\r\n    // handler of selecting different expression as current\r\n    onSelectDifferentExpression: (newIndex: number) => void,\r\n    // handler of creating the new expression\r\n    onNewExpression: () => void,\r\n    // handler of deleting the current expression\r\n    onDeleteExpression: (onDone: () => void) => void,\r\n    // handler of saving the expressions\r\n    onExportExpressions: (onDone: (msg: string) => void) => void,\r\n    // handler of loading the expressions\r\n    onImportExpressions: (onDone: (msg: string) => void) => void,\r\n\r\n    // handler of change in the current selected expression\r\n    onChange: (name: string, text: string) => void,\r\n    // handler of evaluation, it accepts the parsed tree from the expression text\r\n    onEval: (tree: RATreeNode) => void,\r\n    // handler of unexpected errors\r\n    onUnexpectedError: (e: Error) => void,\r\n\r\n    // whether to support null values\r\n    nullValuesSupport: boolean,\r\n    // true if dark theme should be applied\r\n    darkTheme: boolean\r\n}\r\n\r\ninterface ExpressionSectionState {\r\n    sectionClicked: boolean,\r\n    whispers: string[],\r\n    errors: {start: number, end: number, msg: string}[],\r\n    cursorIndex: number\r\n}\r\n\r\ninterface OpButtonProps {\r\n    // key for React DOM\r\n    key: string,\r\n    // characters to be added on click\r\n    char: string,\r\n    // text to display on the button\r\n    text: string,\r\n    // tooltip ti show on mouse move\r\n    tooltip: string,\r\n    // shift to left of the cursor after adding the characters\r\n    shift: number\r\n}\r\n\r\n/**\r\n * Section to edit, manage, and eval relational algebra expressions.\r\n */\r\nexport class ExpressionSection extends React.Component<ExpressionSectionProps, ExpressionSectionState> {\r\n\r\n    private readonly unaryButtons: Array<OpButtonProps> = [\r\n        {key: 'unary_a', char: '()',        text: '()', tooltip: 'Selection',   shift: 1},\r\n        {key: 'unary_b', char: '[]',        text: '[]', tooltip: 'Projection',  shift: 1},\r\n        {key: 'unary_c', char: '< -> >',    text: '<>', tooltip: 'Rename',      shift: 5}\r\n    ];\r\n    private readonly setOperatorsButtons: Array<OpButtonProps> = [\r\n        {key: 'set_a', char: '\\u222a',  text: '\\u222a', tooltip: 'Union',         shift: 0},\r\n        {key: 'set_b', char: '\\u2229',  text: '\\u2229', tooltip: 'Intersection',  shift: 0},\r\n        {key: 'set_c', char: '\\\\',      text: '\\\\',     tooltip: 'Difference',    shift: 0},\r\n    ];\r\n    private readonly innerJoinsButtons: Array<OpButtonProps> = [\r\n        {key: 'inner_a', char: '*',       text: '*',      tooltip: 'Natural join',            shift: 0},\r\n        {key: 'inner_b', char: '\\u2a2f',  text: '\\u2a2f', tooltip: 'Cartesian product',       shift: 0},\r\n        {key: 'inner_c', char: '<*',      text: '<*',     tooltip: 'Left semijoin',           shift: 0},\r\n        {key: 'inner_d', char: '*>',      text: '*>',     tooltip: 'Right semijoin',          shift: 0},\r\n        {key: 'inner_e', char: '\\u22b3',  text: '\\u22b3', tooltip: 'Left antijoin',           shift: 0},\r\n        {key: 'inner_f', char: '\\u22b2',  text: '\\u22b2', tooltip: 'Right antijoin',          shift: 0},\r\n        {key: 'inner_g', char: '[]',      text: '[]',     tooltip: 'Theta join',              shift: 1},\r\n        {key: 'inner_h', char: '<]',      text: '<]',     tooltip: 'Left theta semijoin',     shift: 1},\r\n        {key: 'inner_i', char: '[>',      text: '[>',     tooltip: 'Right theta semijoin',    shift: 1},\r\n    ];\r\n    private readonly outerJoinsButtons: Array<OpButtonProps> = [\r\n        {key: 'outer_a', char: '*F*', text: '*F*', tooltip: 'Full outer join',  shift: 0},\r\n        {key: 'outer_b', char: '*L*', text: '*L*', tooltip: 'Left outer join',  shift: 0},\r\n        {key: 'outer_c', char: '*R*', text: '*R*', tooltip: 'Right outer join', shift: 0}\r\n    ];\r\n    private readonly divisionButton: Array<OpButtonProps> = [\r\n        {key: 'division', char: '\\u00f7',  text: '\\u00f7', tooltip: 'Division', shift: 0}\r\n    ];\r\n    private readonly specialButtons: Array<OpButtonProps> = [\r\n        {key: 'special_a', char: '//',  text: '//', tooltip: 'Comment', shift: 0}\r\n    ];\r\n\r\n    // reference to child textarea element\r\n    private readonly textAreaRef: React.RefObject<XTextArea>;\r\n    // timestamp of last expression text change\r\n    private lastChange: number = 0;\r\n    // timestamp of last display of whispers and errors\r\n    private lastWhisperAndErrorsUpdate: number = 0;\r\n    // update rate of whispers and errors (in ms)\r\n    private readonly whispersAndErrorsUpdateRate: number = 200;\r\n\r\n    constructor(props: ExpressionSectionProps) {\r\n        super(props);\r\n        this.state = {\r\n            sectionClicked: false,\r\n            whispers: [],\r\n            errors: [],\r\n            cursorIndex: 0\r\n        }\r\n        this.textAreaRef = React.createRef<XTextArea>();\r\n        setInterval(() => this.updateWhispersAndErrors(), this.whispersAndErrorsUpdateRate);\r\n    }\r\n\r\n    /**\r\n     * Updates displayed errors in the text area input.\r\n     */\r\n    public updateErrors = () => {\r\n        const text = this.getCurExpr().text;\r\n        const exprParser: ExprParser = new ExprParser(this.props.relations, this.props.nullValuesSupport);\r\n        const { errors } = exprParser.fakeParse(text, this.state.cursorIndex);\r\n        this.setState({\r\n            errors: errors.filter(err => err.range !== undefined)\r\n                // @ts-ignore\r\n                .map(err => {return {start: err.range.start, end: err.range.end + 1, msg: err.message}})\r\n        });\r\n    }\r\n\r\n    private getCurExpr(): Expression {\r\n        return this.props.expressions[this.props.currentExpressionIndex];\r\n    }\r\n\r\n    private handleSelectDifferentExpression(index: number): void {\r\n        this.setState({errors: []});\r\n        this.props.onSelectDifferentExpression(index);\r\n    }\r\n\r\n    private evalExpr = (): void => {\r\n        try {\r\n            const exprParser: ExprParser = new ExprParser(this.props.relations, this.props.nullValuesSupport);\r\n            const tree = exprParser.indexedParse(this.props.expressions[this.props.currentExpressionIndex].text);\r\n            tree.eval();\r\n            this.setState({errors: []});\r\n            this.props.onEval(tree);\r\n        }\r\n        catch (err) {\r\n            if (err instanceof ErrorWithTextRange) {\r\n                if (err.range !== undefined) {\r\n                    // change end to also highlight the last char\r\n                    err.range.end += 1;\r\n                    this.setState(state => {\r\n                        const errorRanges = state.errors;\r\n                        // does not push duplicate error range\r\n                        if (errorRanges.every(er => er.start !== err.range.start || er.end !== err.range.end)) {\r\n                            errorRanges.push({...err.range, msg: err.message});\r\n                        }\r\n                        return {errors: errorRanges}\r\n                    });\r\n                }\r\n            }\r\n            this.showError(err);\r\n        }\r\n    }\r\n\r\n    private newExpression = (): void => {\r\n        this.props.onNewExpression();\r\n    }\r\n\r\n    private deleteExpression = (): void => {\r\n        this.props.onDeleteExpression(this.updateErrors);\r\n    }\r\n\r\n    private saveExpressions = (): void => {\r\n        this.props.onExportExpressions(MessageBox.message);\r\n    }\r\n\r\n    private loadExpressions = (): void => {\r\n        this.setState({errors: []});\r\n        this.props.onImportExpressions((msg) => {\r\n            MessageBox.message(msg);\r\n            this.updateErrors();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds given special string into RA expression at the current cursor position.\r\n     *\r\n     * @param str string to be added\r\n     * @param shift move of the cursor from added string end position (to the beginning)\r\n     */\r\n    private addSpecialString = (str: string, shift: number): void => {\r\n        // @ts-ignore\r\n        const {start, end} = this.textAreaRef.current.getSelection();\r\n        const firstPart: string = this.getCurExpr().text.substring(0, start);\r\n        const secondPart: string = this.getCurExpr().text.substring(end);\r\n        const newPosition: number = firstPart.length + str.length - shift;\r\n        const newStr: string = firstPart + str + secondPart;\r\n        // updates text in textarea\r\n        this.handleExprChange(newStr, newPosition, () => {\r\n            // @ts-ignore - moves cursor to expected position\r\n            this.textAreaRef.current.setSelection(newPosition);\r\n            // @ts-ignore\r\n            this.textAreaRef.current.focus();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handles change of expression text. Updates text and notifies the parent.\r\n     *\r\n     * @param text\r\n     * @param cursorIndex\r\n     * @param onDone callback after updating the state\r\n     */\r\n    private handleExprChange = (text: string, cursorIndex: number, onDone: () => void = () => {}): void => {\r\n        this.props.onChange(this.getCurExpr().name, text);  // must be called before setState for proper functionality of XTextArea\r\n        this.setState({cursorIndex: cursorIndex}, onDone);\r\n        this.lastChange = Date.now();\r\n    }\r\n\r\n    /**\r\n     * Handles input with Ctrl key pressed from textarea.\r\n     */\r\n    private handleCtrlInput = (ev: KeyboardEvent): void => {\r\n        if (ev.key === \"Enter\") {\r\n            this.evalExpr();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Shows current whispers and errors, if the text area is focused and there was a text change after last update.\r\n     */\r\n    private updateWhispersAndErrors = () => {\r\n        const textArea = this.textAreaRef.current;\r\n        if (textArea !== null && textArea.isFocused() && this.lastChange > this.lastWhisperAndErrorsUpdate) {\r\n            const text = this.getCurExpr().text;\r\n            const exprParser: ExprParser = new ExprParser(this.props.relations, this.props.nullValuesSupport);\r\n            const fakeParseResult = exprParser.fakeParse(text, this.state.cursorIndex);\r\n            const wordBeforeCursor: string = text.slice(getStartOfWordBeforeIndex(text, this.state.cursorIndex), this.state.cursorIndex);\r\n            const whispers = sortWhispers(fakeParseResult.whispers, wordBeforeCursor);\r\n            this.setState({\r\n                whispers: whispers,\r\n                errors: fakeParseResult.errors.filter(err => err.range !== undefined)\r\n                    // @ts-ignore\r\n                    .map(err => {return {start: err.range.start, end: err.range.end + 1, msg: err.message}})\r\n            });\r\n            this.lastWhisperAndErrorsUpdate = Date.now();\r\n        }\r\n    }\r\n\r\n    private handleExprNameChange = (name: string) => {\r\n        this.props.onChange(name, this.getCurExpr().text);\r\n    }\r\n\r\n    /**\r\n     * Handles and shows the given error. If the error is not of RASyntaxError or RASemanticError class, it is passed\r\n     * to the parent as unexpected error.\r\n     *\r\n     * @param err the error to handle\r\n     */\r\n    private showError = (err: Error) => {\r\n        // common user's errors\r\n        if (err instanceof RASyntaxError || err instanceof RASemanticError) {\r\n            MessageBox.error(err.message);\r\n        }\r\n        else {\r\n            this.props.onUnexpectedError(err);\r\n            MessageBox.error(\"UNEXPECTED ERROR: \" + err.message + \"\\n\" +\r\n                \"Please, report it with your last actions, thank you!\");\r\n        }\r\n    }\r\n\r\n    public render() {\r\n        const createExprMenuButtons = () => {\r\n            return this.props.expressions.map((expr, i) => {\r\n                const className: string = (this.props.currentExpressionIndex === i ? \"button-clicked\" : \"\");\r\n                return (<button\r\n                    key={i}\r\n                    onClick={() => this.handleSelectDifferentExpression(i)}\r\n                    className={className}\r\n                >{expr.name}</button>);\r\n            });\r\n        }\r\n\r\n        const createButton = (text: string, onClick: () => void, tooltip: string, style?: React.CSSProperties) => {\r\n            return (<TooltipButton\r\n                key={text}\r\n                text={text}\r\n                onClick={onClick}\r\n                className={\"\"}\r\n                style={style}\r\n                tooltip={tooltip}\r\n                tooltipClassName={\"tooltip\"}\r\n            />);\r\n        }\r\n\r\n        /**\r\n         * Creates buttons for inserting given operators and adds margin after them.\r\n         */\r\n        const createOpButtons = (buttonProps: Array<OpButtonProps>) => {\r\n            return buttonProps.map((prop, i) => {\r\n                const style = i === buttonProps.length - 1 ? {marginRight: \"10px\"} : undefined;\r\n                return (<TooltipButton\r\n                    key={prop.key}\r\n                    text={prop.text}\r\n                    onClick={() => this.addSpecialString(prop.char, prop.shift)}\r\n                    className={\"\"}\r\n                    tooltip={prop.tooltip}\r\n                    tooltipClassName={\"tooltip\"}\r\n                    style={style}\r\n                />);\r\n            });\r\n        }\r\n\r\n        return (\r\n            <section className=\"page-section\">\r\n                <header>\r\n                    <h2>Expressions</h2>\r\n                    {createButton(\"Import\", this.loadExpressions, \"Loads expressions from a file\")}\r\n                    {createButton(\"Export\", this.saveExpressions, \"Saves expressions to a file\")}\r\n                </header>\r\n\r\n                <menu className=\"page-section-tab-menu\">\r\n                    {createExprMenuButtons()}\r\n                    <button onClick={this.newExpression}\r\n                        style={{minWidth: \"0\", marginLeft: \"10px\", padding: \"2px 6px 1px 6px\"}}>\r\n                        <strong>+</strong>\r\n                    </button>\r\n                </menu>\r\n\r\n                <XTextArea\r\n                    ref={this.textAreaRef}\r\n                    id=\"expression-section-textarea\"\r\n                    text={this.getCurExpr().text}\r\n                    placeholder=\"Write RA expression here...\"\r\n                    errors={this.state.errors}\r\n                    whispers={this.state.whispers}\r\n\r\n                    onChange={this.handleExprChange}\r\n                    onCtrlInput={this.handleCtrlInput}\r\n\r\n                    darkTheme={this.props.darkTheme}\r\n                />\r\n\r\n                <menu className=\"expressions-operators-menu\">\r\n                    {createOpButtons(this.unaryButtons)}\r\n                    {createOpButtons(this.setOperatorsButtons)}\r\n                    {createOpButtons(this.innerJoinsButtons)}\r\n                    {this.props.nullValuesSupport ? createOpButtons(this.outerJoinsButtons) : null}\r\n                    {createOpButtons(this.divisionButton)}\r\n                    {createOpButtons(this.specialButtons)}\r\n                </menu>\r\n\r\n                <menu className=\"page-section-management-menu\">\r\n                    <TooltipButton\r\n                        key=\"Evaluate\"\r\n                        text=\"Evaluate\"\r\n                        onClick={this.evalExpr}\r\n                        className={\"action-button\"}\r\n                        style={{marginRight: \"40px\"}}\r\n                        tooltip=\"Evaluates given RA expression\"\r\n                        tooltipClassName={\"tooltip\"}\r\n                    />\r\n                    <TextInput\r\n                        label=\"\"\r\n                        value={this.getCurExpr().name}\r\n                        buttonText=\"Rename\"\r\n                        onSubmit={this.handleExprNameChange}\r\n                        forbidden={() => false}\r\n                        id=\"expression-name-input\"\r\n                    />\r\n                    {createButton(\"Delete\", this.deleteExpression, \"Deletes current RA expression\")}\r\n                </menu>\r\n            </section>\r\n        );\r\n    }\r\n}","import React from \"react\";\r\nimport Relation from \"../relation/relation\";\r\nimport './css/resultRelationTable.css'\r\nimport Row from \"../relation/row\";\r\n\r\ninterface RelationTableProps {\r\n    // relation to be shown\r\n    relation: Relation\r\n}\r\n\r\ninterface RelationTableState {\r\n    // index of the column which is used to order the table (or -1 if none is used)\r\n    orderBy: number,\r\n    // 1 = ascending, -1 = descending\r\n    orderDir: number\r\n}\r\n\r\n/**\r\n * Table which shows given relation. The relation cannot be edited\r\n * Rows can be ordered by column values when the column header is clicked.\r\n * When the same column header is clicked for the second time, the order direction is changed (asc, des, asc, des, ...).\r\n */\r\nexport class ResultRelationTable extends React.Component<RelationTableProps, RelationTableState> {\r\n\r\n    constructor(props: RelationTableProps) {\r\n        super(props);\r\n        this.state = {\r\n            orderBy: -1,\r\n            orderDir: 1\r\n        }\r\n    }\r\n\r\n    componentDidUpdate(prevProps: Readonly<RelationTableProps>, prevState: Readonly<RelationTableState>, snapshot?: any) {\r\n        if (prevProps.relation !== this.props.relation) {\r\n            this.setState({\r\n                orderDir: 1,\r\n                orderBy: -1\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates ordering column or direction. If the given orderBy index is already selected, switches ASC/DESC order.\r\n     * Otherwise, sets ASC ordering by new orderBy column index.\r\n     */\r\n    private updateOrderBy(orderBy: number): void {\r\n        this.setState(state => {\r\n            if (state.orderBy === orderBy) {\r\n                return {\r\n                    orderDir: -state.orderDir,\r\n                    orderBy: orderBy\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    orderDir: 1,\r\n                    orderBy: orderBy\r\n                };\r\n            }\r\n        });\r\n    }\r\n\r\n    private getOrderByText = (): string => {\r\n        return this.state.orderDir === 1 ? \" ▼\" : \" ▲\";\r\n    }\r\n\r\n    /**\r\n     * Creates a header row for a table (with given column names).\r\n     *\r\n     * @param columns\r\n     */\r\n    private createHeaderRow(columns: string[]) {\r\n        return (\r\n            <tr>\r\n                <td className=\"row-number-td\"/>\r\n                {columns.map((columnName, index) => {\r\n                    const text: string = this.state.orderBy === index ?\r\n                        (columnName + this.getOrderByText()) : columnName;\r\n                    return <th key={index} onClick={() => this.updateOrderBy(index)}>{text}</th>\r\n                })}\r\n            </tr>\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates rows for a table. If there is no row in a resultRelation, returns one cell \"<<NO ROWS>>\".\r\n     *\r\n     * @param columns\r\n     */\r\n    private createRows(columns: string[]) {\r\n        // creates default row if no exists\r\n        if (this.props.relation.getRowsCount() === 0) {\r\n            return (\r\n                <tr key='1'>\r\n                    <td className=\"row-number-td\"/>\r\n                    <td key='1' colSpan={columns.length}>{'<<NO ROWS>>'}</td>\r\n                </tr>\r\n            );\r\n        }\r\n        const rows: Row[] = this.props.relation.getRows();\r\n        // sorts rows if orderBy is given (null values are after other values)\r\n        if (this.state.orderBy > -1 && this.state.orderBy < columns.length) {\r\n            const sortCol: string = columns[this.state.orderBy];\r\n            // @ts-ignore cannot be undefined\r\n            const type: \"string\" | \"number\" | \"boolean\" = rows[0].getType(sortCol);\r\n            if (type === \"number\") {\r\n                rows.sort((a, b) => {\r\n                    // @ts-ignore\r\n                    let aValue: number | null = a.getValue(sortCol);\r\n                    // @ts-ignore\r\n                    let bValue: number | null = b.getValue(sortCol);\r\n                    // a is null\r\n                    if (aValue === null && bValue !== null) {\r\n                        return this.state.orderDir * Number.MAX_SAFE_INTEGER;\r\n                    }\r\n                    // b is null\r\n                    if (aValue !== null && bValue === null) {\r\n                        return this.state.orderDir * Number.MIN_SAFE_INTEGER;\r\n                    }\r\n                    // no is null - compares as numbers\r\n                    if (aValue !== null && bValue !== null) {\r\n                        // @ts-ignore\r\n                        return this.state.orderDir * (a.getValue(sortCol) - b.getValue(sortCol));\r\n                    }\r\n                    // both are null\r\n                    return 0;\r\n                });\r\n            }\r\n            else {\r\n                rows.sort((a, b) => {\r\n                    // @ts-ignore\r\n                    let aValue: string | boolean | null = a.getValue(sortCol);\r\n                    // @ts-ignore\r\n                    let bValue: string | boolean | null = b.getValue(sortCol);\r\n                    // a is null\r\n                    if (aValue === null && bValue !== null) {\r\n                        return this.state.orderDir * Number.MAX_SAFE_INTEGER;\r\n                    }\r\n                    // b is null\r\n                    if (aValue !== null && bValue === null) {\r\n                        return this.state.orderDir * Number.MIN_SAFE_INTEGER;\r\n                    }\r\n                    // no is null - compares as strings\r\n                    if (aValue !== null && bValue !== null) {\r\n                        return this.state.orderDir * String(a.getValue(sortCol)).localeCompare(String(b.getValue(sortCol)));\r\n                    }\r\n                    // both are null\r\n                    return 0;\r\n                });\r\n            }\r\n        }\r\n        // creates all rows if any\r\n        return rows.map((row, index) => (\r\n            <tr key={index}>\r\n                <td className=\"row-number-td\">{index + 1}</td>\r\n                {row.getOrderedPrintValues(columns).map((value, index) => (\r\n                    <td key={index}>{value}</td>\r\n                ))}\r\n            </tr>\r\n        ));\r\n    }\r\n\r\n    render(){\r\n        // creates header row\r\n        const columns: string[] = this.props.relation.getColumnNames();\r\n        const headerRow = this.createHeaderRow(columns);\r\n        const rows = this.createRows(columns);\r\n\r\n        return (\r\n            <div className=\"result-table-container\">\r\n                <table className=\"result-table\">\r\n                    <thead>\r\n                    {headerRow}\r\n                    </thead>\r\n                    <tbody>\r\n                    {rows}\r\n                    </tbody>\r\n                </table>\r\n            </div>\r\n        );\r\n    }\r\n}","import React from \"react\";\r\nimport { Group } from '@visx/group';\r\nimport { hierarchy, Tree } from '@visx/hierarchy';\r\nimport { HierarchyPointNode, HierarchyPointLink } from '@visx/hierarchy/lib/types';\r\nimport { LinkVertical } from '@visx/shape';\r\nimport ParentSize from \"@visx/responsive/lib/components/ParentSize\";\r\nimport {useTooltip} from '@visx/tooltip';\r\nimport './css/evaluationTree.css';\r\nimport RATreeNode from \"../ratree/raTreeNode\";\r\nimport UnaryNode from \"../ratree/unaryNode\";\r\nimport BinaryNode from \"../ratree/binaryNode\";\r\nimport {getTreeDepth} from \"../ratree/raTreeTools\";\r\nimport {computeFontSizeInPx} from \"../tools/font\";\r\n\r\nexport const evalTreeSVGId: string = \"eval-tree-svg\";\r\n\r\ninterface EvaluationTreeProps {\r\n    // root of the evaluation tree to be displayed\r\n    tree: RATreeNode,\r\n    // index of the current selected node (with respect to depth first search)\r\n    selected: number,\r\n    // handler of click on nodes, it receives the index of the clicked node (with respect to depth first search)\r\n    onClick: (index: number) => void,\r\n    // true if dark theme should be applied\r\n    darkTheme: boolean\r\n}\r\n\r\n/**\r\n * Component displaying an evaluation tree. The tree is interactive and handles clicking on the nodes.\r\n */\r\nexport class EvaluationTree extends React.Component<EvaluationTreeProps, {}> {\r\n    render() {\r\n        return (\r\n            <ParentSize>{({ width }) =>\r\n                <TreeComponent\r\n                    raTree={this.props.tree}\r\n                    selected={this.props.selected}\r\n                    width={width}\r\n                    onClick={this.props.onClick}\r\n                    darkTheme={this.props.darkTheme}\r\n                />}\r\n            </ParentSize>\r\n        );\r\n    }\r\n}\r\n\r\n// @ts-ignore\r\nconst cssConstants: CSSStyleDeclaration = getComputedStyle(document.querySelector(':root'));\r\n\r\nconst fontSize: string = cssConstants.getPropertyValue('--eval-tree-font-size');\r\nconst fontFamily: string = cssConstants.getPropertyValue('--eval-tree-font-family');\r\nconst {fontWidth, fontHeight} = computeFontSizeInPx(fontFamily, fontSize);\r\nconst nodePaddingX2: number = 24;\r\nconst nodeHeight = 2 * fontHeight + nodePaddingX2;\r\nconst maxNodeTextLength = 30;\r\n\r\nconst backgroundColorLight = cssConstants.getPropertyValue('--light-color-a');\r\nconst backgroundColorDark = cssConstants.getPropertyValue('--dark-color-a');\r\nconst textColorLight = cssConstants.getPropertyValue('--text-color-light');\r\nconst textColorDark = cssConstants.getPropertyValue('--text-color-dark');\r\nconst selectedNodeColorLight = cssConstants.getPropertyValue('--light-color-c');\r\nconst unselectedNodeColorLight = cssConstants.getPropertyValue('--light-color-b');\r\nconst selectedNodeColorDark = cssConstants.getPropertyValue('--dark-color-d');\r\nconst unselectedNodeColorDark = cssConstants.getPropertyValue('--dark-color-c');\r\n\r\ninterface DisplayTreeNode {\r\n    title: string;\r\n    symbol: string,\r\n    index: number;\r\n    children?: this[];\r\n}\r\n\r\n/**\r\n * Creates a DisplayTreeNode tree from the given RATreeNode tree.\r\n *\r\n * @param tree RATreeNode tree to parse to DisplayTreeNode tree\r\n * @return parsed DisplayTreeNode tree\r\n */\r\nfunction parseTreeForDisplay(tree: RATreeNode): DisplayTreeNode {\r\n    let indexes = 0;\r\n    function parseTreeForDisplayHelper(node: RATreeNode): DisplayTreeNode {\r\n        let symbol: string = node.getOperationSymbol();\r\n        if (symbol.length > maxNodeTextLength) {\r\n            symbol = symbol.slice(0, maxNodeTextLength - 4) + \"...\" + symbol.charAt(symbol.length - 1);\r\n        }\r\n\r\n        if (node instanceof UnaryNode) {\r\n            return {\r\n                title: node.getOperationName(),\r\n                symbol: symbol,\r\n                index: indexes++,\r\n                children: [\r\n                    parseTreeForDisplayHelper(node.getSubtree())\r\n                ]\r\n            }\r\n        }\r\n        else if (node instanceof BinaryNode) {\r\n            return {\r\n                title: node.getOperationName(),\r\n                symbol: symbol,\r\n                index: indexes++,\r\n                children: [\r\n                    parseTreeForDisplayHelper(node.getLeftSubtree()),\r\n                    parseTreeForDisplayHelper(node.getRightSubtree())\r\n                ]\r\n            }\r\n        }\r\n        else /* (tree instanceof RelationNode) */ {\r\n            return {\r\n                title: node.getOperationName(),\r\n                symbol: symbol,\r\n                index: indexes++\r\n            };\r\n        }\r\n    }\r\n    return parseTreeForDisplayHelper(tree);\r\n}\r\n\r\n/**\r\n * Component representing individual nodes of the displayed tree.\r\n *\r\n * Props:\r\n * - node: HierarchyPointNode<DisplayTreeNode>: node to be displayed wrapped as visx HierarchyPointNode.\r\n * - selected: boolean: boolean whether the given node is currently selected by the user\r\n * - onClick: (index: number) => void: handler of click on the node, it receives the index of the node (with\r\n * respect to depth first search)\r\n */\r\nfunction TreeNodeComponent({ node, selected, onClick, darkTheme }:\r\n                               { node: HierarchyPointNode<DisplayTreeNode>, selected: boolean, onClick: (index: number) => void, darkTheme: boolean }): JSX.Element {\r\n    const {\r\n        tooltipOpen, // true when mouse is over\r\n        showTooltip,\r\n        hideTooltip\r\n    } = useTooltip();\r\n\r\n    const handleMouseOver = () => {\r\n        showTooltip({ tooltipLeft: 0, tooltipTop: 0 });\r\n    };\r\n\r\n    // computes node width with respect to the text length and asserts it wider than taller\r\n    let nodeWidth = Math.max(node.data.title.length, node.data.symbol.length) * fontWidth + nodePaddingX2;\r\n    if (nodeWidth < nodeHeight) {\r\n        nodeWidth = nodeHeight;\r\n    }\r\n\r\n    return (\r\n        // top=y, left=x for vertical layout; top=x, left=y for horizontal layout\r\n        <Group top={node.y} left={node.x}>\r\n            <rect\r\n                height={nodeHeight} width={nodeWidth}\r\n                y={-nodeHeight / 2} x={-nodeWidth / 2} rx={20}\r\n                fill={darkTheme ?\r\n                    (selected ? selectedNodeColorDark : (tooltipOpen ? selectedNodeColorDark : unselectedNodeColorDark)) :\r\n                    (selected ? selectedNodeColorLight : (tooltipOpen ? selectedNodeColorLight : unselectedNodeColorLight))}\r\n                onClick={() => {\r\n                    onClick(node.data.index);\r\n                }}\r\n                cursor=\"pointer\"\r\n                onMouseOver={handleMouseOver}\r\n                onMouseOut={hideTooltip}\r\n            />\r\n            <text\r\n                y=\"-4px\"\r\n                dy=\".2em\"\r\n                fontSize={fontSize}\r\n                fontFamily={fontFamily}\r\n                textAnchor=\"middle\"\r\n                style={{ pointerEvents: \"none\"}}\r\n                fill={darkTheme ? textColorDark : textColorLight}\r\n            >\r\n                {node.data.symbol === \"\" ?\r\n                    <tspan x=\"0\" dy=\".5em\">{node.data.title}</tspan> :\r\n                    (<>\r\n                        <tspan x=\"0\" dy=\"0\">{node.data.title}</tspan>\r\n                        <tspan x=\"0\" dy=\"1.2em\">{node.data.symbol}</tspan>\r\n                    </>)}\r\n            </text>\r\n        </Group>\r\n    );\r\n}\r\n\r\n/**\r\n * Internal component for displaying the evaluation tree. It uses visx Tree component.\r\n *\r\n * Props:\r\n * - tree: RATreeNode: root of the evaluation tree to be displayed\r\n * - selected: number: index of the current selected node (with respect to depth first search)\r\n * - width: number: width of the parent container\r\n * - onClick: (index: number) => void: handler of click on nodes, it receives the index of the clicked node (with\r\n * respect to depth first search)\r\n */\r\nfunction TreeComponent({raTree, selected, width, onClick, darkTheme}:\r\n                           {raTree: RATreeNode, selected: number, width: number, onClick: (index: number) => void, darkTheme: boolean}): JSX.Element | null {\r\n    const treeDepth: number = getTreeDepth(raTree);\r\n    // height = \"nodes height\" + \"gaps between nodes\" + \"margin up and under\"\r\n    const height = (treeDepth + 1) * nodeHeight + treeDepth * nodeHeight / 2 + nodeHeight;\r\n    const margin = { top: nodeHeight, left: 0 / 2, right: 0 / 2, bottom: nodeHeight };\r\n    const yMax = height - margin.top - margin.bottom;\r\n    const xMax = width - margin.left - margin.right;\r\n\r\n    const tree: DisplayTreeNode = parseTreeForDisplay(raTree);\r\n    const data = hierarchy<DisplayTreeNode>(tree);\r\n\r\n    return width < 10 ? null : (\r\n        <svg id=\"eval-tree-svg\" width={width} height={height}>\r\n            <rect width={width} height={height} rx={14} fill={darkTheme ? backgroundColorDark : backgroundColorLight} />\r\n            <Tree<DisplayTreeNode> root={data} size={[xMax, yMax]}>\r\n                {tree => (\r\n                    <Group top={margin.top} left={margin.left}>\r\n                        {tree.links().map((link, i) => (\r\n                            <LinkVertical<HierarchyPointLink<DisplayTreeNode>, HierarchyPointNode<DisplayTreeNode>>\r\n                                key={`cluster-link-${i}`}\r\n                                data={link}\r\n                                stroke={darkTheme ? textColorDark : textColorLight}\r\n                                strokeWidth=\"1\"\r\n                                strokeOpacity={1}\r\n                                fill=\"none\"\r\n                            />\r\n                        ))}\r\n                        {tree.descendants().map((node) => (\r\n                            <TreeNodeComponent\r\n                                key={`node-${node.data.index}`}\r\n                                node={node}\r\n                                selected={node.data.index === selected}\r\n                                onClick={onClick}\r\n                                darkTheme={darkTheme}\r\n                            />\r\n                        ))}\r\n                    </Group>\r\n                )}\r\n            </Tree>\r\n        </svg>\r\n    );\r\n}","export interface File {\r\n    name: string,\r\n    text: string | null\r\n}\r\n\r\n/**\r\n * FileDialog for loading files to the application.\r\n */\r\nexport class FileDialog {\r\n\r\n    /**\r\n     * Loads asynchronously a textual content from one file selected by the user in the file browser.\r\n     *\r\n     * @param accept comma-separated list of extensions for filter (default are all extensions)\r\n     */\r\n    public static openFile(accept: string = \"*\"): Promise<File> {\r\n        return new Promise<File>(resolve => {\r\n            let element = document.createElement('div');\r\n            element.innerHTML = `<input type=\"file\" accept=${accept}>`;\r\n            let fileInput = element.firstChild;\r\n            // @ts-ignore\r\n            fileInput.addEventListener('change', function() {\r\n                // @ts-ignore\r\n                let file = fileInput.files[0];\r\n                let reader = new FileReader();\r\n                reader.onload = function() {\r\n                    // @ts-ignore\r\n                    resolve({name: file.name, text: reader.result});\r\n                };\r\n                reader.readAsText(file);\r\n            });\r\n            // @ts-ignore\r\n            fileInput.click();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Asynchronously loads textual content from multiple files selected by the user in the file browser.\r\n     *\r\n     * @param accept comma-separated list of extensions for filter (default are all extensions)\r\n     */\r\n    public static openFiles(accept: string = \"*\"): Promise<File[]> {\r\n        return new Promise<File[]>(resolve => {\r\n            FileDialog.openFilesHelper(resolve, accept);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Loads textual content from multiple files selected by the user in the file browser.\r\n     * Multiple file input handling inspired by xaedes on https://stackoverflow.com/a/13975217.\r\n     *\r\n     * @param resolve - function called when the loading is done, it should accept an array of file information\r\n     * {name: string, text: string | null}[] where name contains the filename and text contains the content of the file.\r\n     * @param accept comma-separated list of extensions for filter\r\n     */\r\n    private static openFilesHelper(resolve: (files: File[]) => void, accept: string): void {\r\n        let element = document.createElement('div');\r\n        element.innerHTML = `<input type=\"file\" accept=${accept} multiple>`;\r\n        // @ts-ignore\r\n        let fileInput: HTMLInputElement = element.firstChild;\r\n        const fileInfo: {name: string, text: string | null}[] = [];\r\n        fileInput.addEventListener('change', function() {\r\n            // @ts-ignore\r\n            const files: FileList = fileInput.files;\r\n            function readFile(index: number) {\r\n                if (index === files.length) {\r\n                    return resolve(fileInfo);\r\n                }\r\n                const file = files[index];\r\n                const reader = new FileReader();\r\n                reader.onload = function(e) {\r\n                    // @ts-ignore\r\n                    fileInfo.push({name: file.name, text: e.target.result});\r\n                    readFile(index+1);\r\n                    console.log('File ' + (index+1) + '/' + files.length + ' loaded');\r\n                }\r\n                reader.readAsText(file);\r\n            }\r\n            readFile(0);\r\n        });\r\n        fileInput.click();\r\n    }\r\n}\r\n","/**\r\n * Wrapper of JavaScript Map object to provide usage of object {row: number | \"name\", column: number} as a key.\r\n */\r\nexport class RCToStringMap {\r\n    private map: Map<string, string> = new Map<string, string>();\r\n\r\n    public get(row: number | \"name\", column: number): string | undefined {\r\n        return this.map.get(row + \":\" + column);\r\n    }\r\n\r\n    public set(row: number | \"name\", column: number, value: string): void {\r\n        this.map.set(row + \":\" + column, value);\r\n    }\r\n\r\n    public delete(row: number | \"name\", column: number): boolean {\r\n        return this.map.delete(row + \":\" + column);\r\n    }\r\n\r\n    public clear(): void {\r\n        this.map.clear();\r\n    }\r\n\r\n    public size(): number {\r\n        return this.map.size;\r\n    }\r\n\r\n    public forEach(f: (value: string, row: number | \"name\", column: number, index?: number) => void): void {\r\n        [...this.map.entries()]\r\n            .map((entry) => {return {value: entry[1], key: RCToStringMap.parseKey(entry[0])}})\r\n            .forEach((entry, index) => f(entry.value, entry.key.row, entry.key.column, index));\r\n    }\r\n\r\n    private static parseKey(key: string): {row: number | \"name\", column: number} {\r\n        const split = key.split(':');\r\n        return {row: Number(split[0]), column: Number(split[1])};\r\n    }\r\n}","import {isSupportedColumnType, SupportedColumnType} from \"./columnType\";\r\nimport Parser from \"../tools/parser\";\r\nimport {RCToStringMap} from \"../tools/rcToStringMap\";\r\nimport Relation from \"./relation\";\r\nimport Row from \"./row\";\r\nimport {isForbiddenColumnName} from \"../tools/keywords\";\r\n\r\n/**\r\n * Plain object representation of the stored relation.\r\n */\r\nexport interface StoredRelationData {\r\n    name: string;\r\n    columnNames: string[];\r\n    columnTypes: SupportedColumnType[];\r\n    rows: string[][];\r\n    columnCount: number;\r\n    rowCount: number;\r\n}\r\n\r\n/**\r\n * Creates a copy of the given stored relation data.\r\n */\r\nexport function copyStoredRelationData(data: StoredRelationData): StoredRelationData {\r\n    return {\r\n        name: data.name,\r\n        columnNames: [...data.columnNames],\r\n        columnTypes: [...data.columnTypes],\r\n        rows: data.rows.map(row => [...row]),\r\n        columnCount: data.columnCount,\r\n        rowCount: data.rowCount\r\n    }\r\n}\r\n\r\n/**\r\n * String representation of the relation for its storing. The relation may happen to be in inconsistent state.\r\n */\r\nexport class StoredRelation {\r\n\r\n    /**\r\n     * Creates a new stored relation with given name, one column and no rows.\r\n     */\r\n    static new(name: string, nullValuesSupport: boolean): StoredRelation {\r\n        return new StoredRelation(name, [\"Column1\"], [\"number\"], [], nullValuesSupport);\r\n    }\r\n\r\n    /**\r\n     * Creates a new stored relation from given plain relation object. If the object is not a valid StoredRelationData,\r\n     * throws error.\r\n     */\r\n    static fromData(data: any, nullValuesSupport: boolean): StoredRelation {\r\n        if (isStoredRelationData(data)) {\r\n            const d: StoredRelationData = data as StoredRelationData;\r\n            return new StoredRelation(d.name, d.columnNames, d.columnTypes, d.rows, nullValuesSupport);\r\n        }\r\n        throw new Error(\"Given object is not a valid relation.\");\r\n    }\r\n\r\n    /**\r\n     * Creates a new stored relation from given full relation representation.\r\n     */\r\n    static fromRelation(name: string, relation: Relation, nullValuesSupport: boolean): StoredRelation {\r\n        const columnNames: string[] = [];\r\n        const columnTypes: SupportedColumnType[] = [];\r\n        relation.getColumns().forEach((type, name) => {\r\n            columnNames.push(name);\r\n            columnTypes.push(type);\r\n        });\r\n        const rows: string[][] = relation.getRows().map(row => {\r\n            return row.getOrderedPrintValues(columnNames);\r\n        });\r\n        return new StoredRelation(name, columnNames, columnTypes, rows, nullValuesSupport);\r\n    }\r\n\r\n    /**\r\n     * Creates a new relation with the same name, columns, rows a null values support.\r\n     */\r\n    static copy(relation: StoredRelation): StoredRelation {\r\n        const name = relation.name;\r\n        const columnNames = [...relation.columnNames];\r\n        const columnTypes = [...relation.columnTypes];\r\n        const rows = relation.rows.map(row => [...row]);\r\n        const nullValuesSupport = relation.nullValuesSupport;\r\n        return new StoredRelation(name, columnNames, columnTypes, rows, nullValuesSupport);\r\n    }\r\n\r\n    private name: string;\r\n    private columnNames: string[];\r\n    private columnTypes: SupportedColumnType[];\r\n    private rows: string[][];\r\n    private columnCount: number;\r\n    private rowCount: number;\r\n    private readonly errors: RCToStringMap;\r\n    private nullValuesSupport: boolean;\r\n    private actual: boolean;\r\n    private revertState: StoredRelationData;\r\n\r\n    /**\r\n     * Creates new relation with given name, one default column and no rows.\r\n     */\r\n    constructor(name: string, columnNames: string[], columnTypes: SupportedColumnType[],\r\n                        rows: string[][], nullValuesSupport: boolean) {\r\n        this.name = name;\r\n        this.columnNames = columnNames;\r\n        this.columnTypes = columnTypes;\r\n        this.rows = rows;\r\n        this.columnCount = columnNames.length;\r\n        this.rowCount = rows.length;\r\n        this.errors = new RCToStringMap();\r\n        this.nullValuesSupport = nullValuesSupport;\r\n        this.actual = false;\r\n        this.revertState = this.toDataObject();\r\n        this.recomputeErrors();\r\n    }\r\n\r\n    /**\r\n     * Checks all possible errors in the relation.\r\n     */\r\n    private recomputeErrors(): void {\r\n        this.errors.clear();\r\n        this.checkColumnNames();\r\n        for (let c = 0; c < this.columnCount; ++c) {\r\n            [...new Array(this.rowCount).keys()].forEach(r => this.checkRowInput(c, r));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks whether the column name on given index is valid and not duplicit and updates error map.\r\n     */\r\n    private checkColumnNames(): void {\r\n        for (let columnIndex = 0; columnIndex < this.columnCount; ++columnIndex) {\r\n            const columnName: string = this.columnNames[columnIndex].trim();\r\n            if (columnName === \"\") {\r\n                this.errors.set(\"name\", columnIndex, \"Column name cannot be empty\");\r\n                continue;\r\n            }\r\n            const nameCount: number = this.columnNames.reduce((agg, name) => {\r\n                return (name === columnName) ? (agg + 1) : agg;\r\n            }, 0);\r\n            if (nameCount > 1) {\r\n                this.errors.set(\"name\", columnIndex, \"Duplicit column name\");\r\n                continue;\r\n            }\r\n            if (isForbiddenColumnName(columnName)) {\r\n                this.errors.set(\"name\", columnIndex, \"Column name cannot be a keyword\");\r\n                continue;\r\n            }\r\n            if (!Parser.isName(columnName)) {\r\n                this.errors.set(\"name\", columnIndex, \"Invalid characters in column name\");\r\n                continue;\r\n            }\r\n            this.errors.delete(\"name\", columnIndex);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks whether the row input on given index is valid and updates error map.\r\n     */\r\n    private checkRowInput(columnIndex: number, rowIndex: number): void {\r\n        this.errors.delete(rowIndex, columnIndex);\r\n        const input: string = this.rows[rowIndex][columnIndex].trim();\r\n        // empty input = null\r\n        if (input === \"\") {\r\n            if (this.nullValuesSupport) {\r\n                this.errors.delete(rowIndex, columnIndex);\r\n            }\r\n            else {\r\n                this.errors.set(rowIndex, columnIndex, \"Null values are not supported\");\r\n            }\r\n        }\r\n        else if (this.columnTypes[columnIndex] === \"number\") {\r\n            if (!Parser.isNumber(input.replace(/\\s/g, \"\"))) {\r\n                this.errors.set(rowIndex, columnIndex, \"Given string is not a number\");\r\n            }\r\n        }\r\n        else if (this.columnTypes[columnIndex] === \"boolean\") {\r\n            const lower = input.toLowerCase();\r\n            if (lower !== \"true\" && lower !== \"t\" && lower !== \"false\" && lower !== \"f\") {\r\n                this.errors.set(rowIndex, columnIndex, \"Given string is not a boolean\");\r\n            }\r\n        }\r\n        /* STRING COLUMNS CANNOT BE INVALID */\r\n    }\r\n\r\n    /**\r\n     * Checks whether all row inputs on given column index are valid and updates error map.\r\n     */\r\n    private checkColumnTypes(columnIndex: number): void {\r\n        this.rows.forEach((_, i) => this.checkRowInput(columnIndex, i));\r\n    }\r\n\r\n    /**\r\n     * Creates a relation with full schema.\r\n     * WARNING: It expects that there are no errors in the stored relation before call.\r\n     */\r\n    public createRelation(): Relation {\r\n        const relation: Relation = new Relation(this.name);\r\n        for (let c = 0; c < this.columnCount; ++c) {\r\n            relation.addColumn(this.columnNames[c], this.columnTypes[c]);\r\n        }\r\n        this.rows.forEach(rowInput => {\r\n            const row: Row = new Row(relation.getColumns());\r\n            rowInput.forEach((input, c) => {\r\n                input = input.trim();\r\n                if (input === \"\" || input === \"null\") {\r\n                    row.addValue(this.columnNames[c], null);\r\n                }\r\n                else if (this.columnTypes[c] === \"string\") {\r\n                    // changes input representation to expected in inner relations\r\n                    // replaces all used '\\' by two '\\\\' and all used '\"' by '\\\"'\r\n                    input = input.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"');\r\n                    row.addValue(this.columnNames[c], input);\r\n                }\r\n                else if (this.columnTypes[c] === \"number\") {\r\n                    row.addValue(this.columnNames[c], Number(input.replace(/\\s/g, \"\")));\r\n                }\r\n                else /* this.columnTypes[c] === \"boolean\" */ {\r\n                    const lower = input.toLowerCase();\r\n                    row.addValue(this.columnNames[c], lower === \"t\" || lower === \"true\");\r\n                }\r\n            });\r\n            relation.addRow(row);\r\n        });\r\n        relation.finishSchema();\r\n        return relation;\r\n    }\r\n\r\n    /**\r\n     * Creates plain object representation of the stored relation.\r\n     */\r\n    public toDataObject(): StoredRelationData {\r\n        return {\r\n            name: this.name,\r\n            columnNames: [...this.columnNames],\r\n            columnTypes: [...this.columnTypes],\r\n            rows: this.rows.map(row => [...row]),\r\n            columnCount: this.columnCount,\r\n            rowCount: this.rowCount\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns map \"row/column => error\". Numeric row keys are for relation rows, row key \"name\" is for column name row.\r\n     */\r\n    public getErrors(): RCToStringMap {\r\n        return this.errors;\r\n    }\r\n\r\n    /**\r\n     * Returns true if there are no errors in the relation.\r\n     */\r\n    public isValid(): boolean {\r\n        return this.errors.size() === 0;\r\n    }\r\n\r\n    /**\r\n     * Sets null values support to check null errors in the relation.\r\n     */\r\n    public setNullValuesSupport(nullValuesSupport: boolean): void {\r\n        if (nullValuesSupport !== this.nullValuesSupport) {\r\n            this.nullValuesSupport = nullValuesSupport;\r\n            this.recomputeErrors();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a new column with default name \"Column n\", default type \"number\", and empty inputs \"\" in all rows.\r\n     */\r\n    public addNewColumn(): void {\r\n        let i = (this.columnNames.length + 1);\r\n        let name = \"Column\" + i;\r\n        while (this.columnNames.indexOf(name) > -1) {\r\n            name = \"Column\" + ++i;\r\n        }\r\n        this.columnNames.push(name);\r\n        this.columnTypes.push(\"number\");\r\n        if (this.nullValuesSupport) {\r\n            this.rows.forEach(r => r.push(\"\"));\r\n        }\r\n        else {\r\n            this.rows.forEach(r => r.push(\"0\"));\r\n        }\r\n        ++this.columnCount;\r\n        this.checkColumnNames();\r\n        this.actual = false;\r\n    }\r\n\r\n    /**\r\n     * Adds a new row with empty inputs \"\" in all columns.\r\n     */\r\n    public addNewRow(): void {\r\n        if (this.nullValuesSupport) {\r\n            this.rows.push([...new Array(this.columnCount).keys()].map(_ => \"\"));\r\n        }\r\n        else {\r\n            this.rows.push([...new Array(this.columnCount).keys()].map(i => {\r\n                if (this.columnTypes[i] === \"number\") {\r\n                    return \"0\";\r\n                }\r\n                else if (this.columnTypes[i] === \"boolean\") {\r\n                    return \"false\";\r\n                }\r\n                return '\"\"';\r\n            }));\r\n        }\r\n        ++this.rowCount;\r\n        this.actual = false;\r\n    }\r\n\r\n    /**\r\n     * Deletes a column with the given index. If the last column was deleted, removes all rows and creates\r\n     * new default column.\r\n     *\r\n     * @param columnIndex\r\n     */\r\n    public deleteColumn(columnIndex: number): void {\r\n        this.columnNames.splice(columnIndex, 1);\r\n        this.columnTypes.splice(columnIndex, 1);\r\n        this.rows.forEach(row => row.splice(columnIndex, 1));\r\n        --this.columnCount;\r\n        // if last column was deleted, removes all rows and creates new default column\r\n        if (this.columnCount === 0) {\r\n            this.rows = [];\r\n            this.addNewColumn();\r\n        }\r\n        this.errors.forEach((value, row, column) => {\r\n            // removes errors for given row\r\n            if (column === columnIndex) {\r\n                this.errors.delete(row, column);\r\n            }\r\n            // updates row index for errors in rows under deleted one\r\n            else if (column > columnIndex) {\r\n                this.errors.delete(row, column);\r\n                this.errors.set(row, column, value);\r\n            }\r\n        });\r\n        this.actual = false;\r\n    }\r\n\r\n    /**\r\n     * Deletes a row with given index.\r\n     *\r\n     * @param rowIndex\r\n     */\r\n    public deleteRow(rowIndex: number): void {\r\n        this.rows.splice(rowIndex, 1);\r\n        --this.rowCount;\r\n        this.errors.forEach((value, row, column) => {\r\n            // removes errors for given row\r\n            if (row === rowIndex) {\r\n                this.errors.delete(row, column);\r\n            }\r\n            // updates row index for errors in rows under deleted one\r\n            else if (typeof row === \"number\" && row > rowIndex) {\r\n                this.errors.delete(row, column);\r\n                this.errors.set(row - 1, column, value);\r\n            }\r\n        });\r\n        this.actual = false;\r\n    }\r\n\r\n    public getRowCount(): number {\r\n        return this.rowCount;\r\n    }\r\n\r\n    public getColumnCount(): number {\r\n        return this.columnCount;\r\n    }\r\n\r\n    public setName(name: string): void {\r\n        this.name = name;\r\n        this.actual = false;\r\n    }\r\n\r\n    public getName(): string {\r\n        return this.name;\r\n    }\r\n\r\n    public getColumnNames(): string[] {\r\n        return this.columnNames;\r\n    }\r\n\r\n    public setColumnName(columnName: string, columnIndex: number): void {\r\n        this.columnNames[columnIndex] = columnName;\r\n        this.checkColumnNames();\r\n        this.actual = false;\r\n    }\r\n\r\n    public getColumnTypes(): SupportedColumnType[] {\r\n        return this.columnTypes;\r\n    }\r\n\r\n    public setColumnType(columnType: SupportedColumnType, columnIndex: number): void {\r\n        this.columnTypes[columnIndex] = columnType;\r\n        this.checkColumnTypes(columnIndex);\r\n        this.actual = false;\r\n    }\r\n\r\n    public getRows(): string[][] {\r\n        return this.rows;\r\n    }\r\n\r\n    public setRowInput(input: string, rowIndex: number, columnIndex: number): void {\r\n        this.rows[rowIndex][columnIndex] = input;\r\n        this.checkRowInput(columnIndex, rowIndex);\r\n        this.actual = false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if no changes were made after last setActual(true) call.\r\n     * The StoredRelation is created with isActual() = false.\r\n     */\r\n    public isActual(): boolean {\r\n        return this.actual;\r\n    }\r\n\r\n    /**\r\n     * Sets current StoredRelation state as actual. Any change sets the state as not actual automatically.\r\n     * If it is set to actual, the current state is saved as the revert state.\r\n     */\r\n    public setActual(actual: boolean): void {\r\n        this.actual = actual;\r\n        if (actual) {\r\n            this.revertState = this.toDataObject();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if the relation has saved previous state.\r\n     */\r\n    public canRevert(): boolean {\r\n        return this.revertState !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Returns name of the saved relation state to revert or empty string.\r\n     */\r\n    public getRevertName(): string {\r\n        if (this.revertState !== undefined) {\r\n            return this.revertState.name;\r\n        }\r\n        else {\r\n            return \"\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reverts the current relation to its last loaded state (if any exists, call canRevert() to check).\r\n     * The relation is set as not actual, null values support and saved revert state is not reverted.\r\n     */\r\n    public revert(): void {\r\n        if (this.revertState !== undefined) {\r\n            this.name = this.revertState.name;\r\n            this.columnNames = [...this.revertState.columnNames];\r\n            this.columnTypes = [...this.revertState.columnTypes];\r\n            this.rows = this.revertState.rows.map(row => [...row]);\r\n            this.columnCount = this.revertState.columnCount;\r\n            this.rowCount = this.revertState.rowCount;\r\n            this.actual = false;\r\n            this.recomputeErrors();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Returns true if the relation relation object has at least one column, and all rows has the same length.\r\n */\r\nexport function isStoredRelationData(obj: any): boolean {\r\n    if (typeof obj !== \"object\") {\r\n        return false;\r\n    }\r\n    if (!(\"name\" in obj) || typeof obj.name !== \"string\") {\r\n        return false;\r\n    }\r\n    if (!(\"columnCount\" in obj) || typeof obj.columnCount !== \"number\" || obj.columnCount < 1) {\r\n        return false;\r\n    }\r\n    if (!(\"rowCount\" in obj) || typeof obj.rowCount !== \"number\") {\r\n        return false;\r\n    }\r\n    if (!(\"columnNames\" in obj) || !Array.isArray(obj.columnNames) || obj.columnNames.length !== obj.columnCount ||\r\n        obj.columnNames.some((o: any) => typeof o !== \"string\")) {\r\n        return false;\r\n    }\r\n    if (!(\"columnTypes\" in obj) || !Array.isArray(obj.columnTypes) || obj.columnTypes.length !== obj.columnCount ||\r\n        obj.columnTypes.some((o: any) => !isSupportedColumnType(o))) {\r\n        return false;\r\n    }\r\n    return (\"rows\" in obj && Array.isArray(obj.rows) && obj.rows.every((o: any) => {\r\n        return Array.isArray(o) && o.length === obj.columnCount && o.every((d: any) => typeof d === \"string\");\r\n    }));\r\n}","/**\r\n * Specifies supported column types in the application. When changed, update the keywords.ts file.\r\n */\r\n\r\n/**\r\n * Supported string names of types of columns for a relational schema.\r\n */\r\nexport type SupportedColumnType = \"string\" | \"number\" | \"boolean\";\r\n\r\n/**\r\n * Possible types of the content of columns (null values included).\r\n */\r\nexport type ColumnContent = string | number | boolean | null;\r\n\r\n/**\r\n * Returns true if the given obj is string with value SupportedColumnType value.\r\n */\r\nexport function isSupportedColumnType(obj: any): boolean {\r\n    if (typeof obj !== \"string\") {\r\n        return false;\r\n    }\r\n    return obj === \"string\" || obj === \"number\" || obj === \"boolean\";\r\n}","import {FileDialog} from \"../tools/fileDialog\";\r\nimport {\r\n    CsvValueSeparatorChar,\r\n    findValueSeparatorChar\r\n} from \"../tools/csvSupport\";\r\nimport {StoredRelation} from \"./storedRelation\";\r\nimport {SupportedColumnType} from \"./columnType\";\r\nimport {saveAs} from \"file-saver\";\r\nimport JSZip from \"jszip\";\r\nimport Parser from \"../tools/parser\";\r\n\r\n/**\r\n * Class for loading and saving relation definitions.\r\n */\r\nexport class RelationStoreManager {\r\n\r\n    /**\r\n     * Loads textual relation representations from multiple csv files selected by the user. If the csv does not have\r\n     * valid stricture, it is skipped. Loaded csv are parsed to StoredRelations and returned in a promise.\r\n     *\r\n     * @param nullValuesSupport null values support to set in created StoredRelations\r\n     */\r\n    public static load(nullValuesSupport: boolean): Promise<{relations: StoredRelation[], skipped: number}> {\r\n        return new Promise<{relations: StoredRelation[], skipped: number}>(resolve => {\r\n            FileDialog.openFiles(\".csv\").then(files => {\r\n                let relations: StoredRelation[] = [];\r\n                let skipped: number = 0;\r\n                files.forEach(file => {\r\n                    if (file.name.match(/\\.csv$/)) {\r\n                        try {\r\n                            relations.push(this.csvToRelation(RelationStoreManager.createValidName(file.name.slice(0, -4)),\r\n                                file.text, nullValuesSupport));\r\n                        }\r\n                        catch (err) {\r\n                            console.log('File ' + file.name + ' skipped for bad format of csv');\r\n                            skipped += 1;\r\n                        }\r\n                    }\r\n                    else {\r\n                        console.log('Unsupported filetype: ' + file.name);\r\n                        skipped += 1;\r\n                    }\r\n                });\r\n                resolve({relations: relations, skipped: skipped});\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Saves given relations into csv files (in one csv file each relation). Uses given value separator.\r\n     *\r\n     * @param relations map of the relations to be saved\r\n     * @param filename name of the downloaded file (without .zip/.csv extension)\r\n     * @param valueSeparator the separator of values\r\n     */\r\n    public static save(relations: StoredRelation[], filename: string, valueSeparator: CsvValueSeparatorChar): void {\r\n        if (relations.length === 0) {\r\n            return;\r\n        }\r\n        if (relations.length === 1) {\r\n            const blob = new Blob([this.relationToCsv(relations[0], valueSeparator)], {type: \"text/plain;charset=utf-8\"});\r\n            saveAs(blob, relations[0].getName() + '.csv');\r\n            return;\r\n        }\r\n        const zip: JSZip = JSZip();\r\n        relations.forEach(relation => {\r\n            zip.file(relation.getName() + '.csv', this.relationToCsv(relation, valueSeparator));\r\n        });\r\n        zip.generateAsync({type: \"blob\"}).then(content => {\r\n            saveAs(content, filename + \".zip\");\r\n        }).catch(err => {\r\n            throw err;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Parses a StoredRelation from given csv text. If the text is invalid, throws error.\r\n     *\r\n     * @param name name of the relation\r\n     * @param text csv content to parse a relation from\r\n     * @param nullValuesSupport null values support to set in created StoredRelation\r\n     */\r\n    private static csvToRelation(name: string, text: string | null, nullValuesSupport: boolean): StoredRelation {\r\n        if (text === null || text === \"\") {\r\n            console.log(\"null or empty string read from file \" + name);\r\n            throw Error();\r\n        }\r\n\r\n        text = text.trim().replace(/\\r\\n/g, '\\n')\r\n            .replace(/\\r/g, '\\n').replace(/\\t/g, \"    \");\r\n\r\n        const lines: string[] = text.split('\\n');\r\n\r\n        if (lines.length < 2) {\r\n            console.log(\"file \" + name + \" has only one line\");\r\n            throw Error();  // at least two lines are expected (names and types)\r\n        }\r\n\r\n        lines[0] = lines[0].replace(/\\s/g, '');\r\n        lines[1] = lines[1].replace(/\\s/g, '');\r\n\r\n        let separator = findValueSeparatorChar(lines[1]);\r\n        // if no separator is found, only one column is expected - sets separator to not defined value to unify the\r\n        // following process\r\n        if (separator === undefined) {\r\n            separator = ';';\r\n        }\r\n\r\n        const columnNames: string[] = lines[0].split(separator);\r\n        const columnTypes: SupportedColumnType[] = lines[1].split(separator).map(str => {\r\n            const lower = str.toLowerCase();\r\n            if (lower === \"string\" || lower === \"str\" || lower === \"s\") {\r\n                return \"string\";\r\n            }\r\n            else if (lower === \"number\" || lower === \"num\" || lower === \"n\") {\r\n                return \"number\";\r\n            }\r\n            return \"boolean\";\r\n        });\r\n        const rows: string[][] = lines.slice(2).map(line => {\r\n            const row: string[] = []\r\n            line = line.trim();\r\n            while (true) {\r\n                // @ts-ignore - separator cannot be undefined now\r\n                const split = RelationStoreManager.nextRowInput(line, separator);\r\n                row.push(split.input);\r\n                if (split.rest === undefined) {\r\n                    break;\r\n                }\r\n                line = split.rest;\r\n            }\r\n            return row;\r\n        });\r\n\r\n        // all rows must have equal column count\r\n        const columnCount = columnNames.length;\r\n        if (columnTypes.length !== columnCount || rows.some(row => row.length !== columnCount)) {\r\n            console.log(\"rows in file \" + name + \" do not have the same number of columns\");\r\n            throw new Error();\r\n        }\r\n\r\n        return new StoredRelation(name, columnNames, columnTypes, rows, nullValuesSupport);\r\n    }\r\n\r\n    /**\r\n     * Removes invalid characters for name. If the filtered name is empty, returns string \"relation\".\r\n     */\r\n    private static createValidName(name: string): string {\r\n        name = name.split('').filter(char => Parser.isNameChar(char)).join('');\r\n        if (name === \"\") {\r\n            return \"relation\";\r\n        }\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * Returns next part of the line before separator. Separators in string literals are ignored.\r\n     */\r\n    private static nextRowInput(line: string, separator: string): {input: string, rest: string | undefined} {\r\n        let inString = false;\r\n        let backslashes = 0;\r\n        let i = 0;\r\n        while (i < line.length) {\r\n            const char = line.charAt(i);\r\n            // separator found not in the string literal\r\n            if (!inString && char === separator) {\r\n                return {input: line.slice(0, i), rest: line.slice(i + 1)};\r\n            }\r\n            // next backslash found in a row\r\n            if (char === '\\\\') {\r\n                ++backslashes;\r\n            }\r\n            // resets backslashes in a row\r\n            else {\r\n                backslashes = 0;\r\n            }\r\n            // not escaped quotes found\r\n            if (char === '\"' && (backslashes % 2) === 0) {\r\n                inString = !inString;\r\n            }\r\n            ++i;\r\n        }\r\n        return {input: line, rest: undefined}\r\n    }\r\n\r\n    /**\r\n     * Creates a csv representation for the given relation.\r\n     */\r\n    private static relationToCsv(relation: StoredRelation, valueSeparator: CsvValueSeparatorChar): string {\r\n        const names: string = relation.getColumnNames().join(valueSeparator);\r\n        const types: string = relation.getColumnTypes().join(valueSeparator);\r\n        const rows: string[] = relation.getRows().map(row => row.join(valueSeparator));\r\n        return [names, types, ...rows].join('\\n');\r\n    }\r\n}","/**\r\n * Two possible CSV value separators: comma (,) and semicolon (;).\r\n */\r\nexport type CsvValueSeparatorChar = \",\" | \";\";\r\n\r\nexport function findValueSeparatorChar(str: string): string | undefined {\r\n    for (let i = 0; i < str.length; ++i) {\r\n        const char: string = str.charAt(i);\r\n        if (char === \",\") {\r\n            return \",\";\r\n        }\r\n        if (char === \";\") {\r\n            return \";\";\r\n        }\r\n    }\r\n    return undefined;\r\n}","import React from \"react\";\r\n// @ts-ignore - type declaration is not needed for its short usage\r\nimport downloadSVG from \"export-svg-with-styles\";\r\nimport Relation from \"../relation/relation\";\r\nimport {ResultRelationTable} from \"./resultRelationTable\";\r\nimport {TooltipButton} from \"./tooltipButton\";\r\nimport RATreeNode from \"../ratree/raTreeNode\";\r\nimport {CsvValueSeparatorChar} from \"../tools/csvSupport\";\r\nimport {evalTreeSVGId, EvaluationTree} from \"./evaluationTree\";\r\nimport {depthSearch} from \"../ratree/raTreeTools\";\r\nimport {CodeErrorCodes, ErrorFactory} from \"../error/errorFactory\";\r\nimport {RelationStoreManager} from \"../relation/relationStoreManager\";\r\nimport {StoredRelation} from \"../relation/storedRelation\";\r\nimport \"./css/resultSection.css\"\r\n\r\ninterface ResultSectionProps {\r\n    // the root of the current evaluation tree to display\r\n    evaluationTreeRoot: RATreeNode,\r\n    // name of the evaluated expression\r\n    expressionName: string,\r\n\r\n    // handler of adding the given relation to defined relations\r\n    onAddResult: (relation: Relation) => void,\r\n\r\n    // handler of unexpected errors\r\n    onUnexpectedError: (e: Error) => void,\r\n\r\n    // current selected value separator in csv files\r\n    csvValueSeparator: CsvValueSeparatorChar\r\n    // true if dark theme should be applied\r\n    darkTheme: boolean,\r\n}\r\n\r\ninterface ResultSectionState {\r\n    selectedIndex: number\r\n}\r\n\r\n/**\r\n * Section to show the evaluation result. It contains a table with a result and text input and buttons to save it.\r\n * The component is hidden if given resultRelation is null.\r\n */\r\nexport class ResultSection extends React.Component<ResultSectionProps, ResultSectionState> {\r\n\r\n    // reference to this section element\r\n    private readonly sectionRef: React.RefObject<HTMLDivElement>;\r\n\r\n    constructor(props: ResultSectionProps) {\r\n        super(props);\r\n        this.state = {\r\n            selectedIndex: 0\r\n        }\r\n        this.sectionRef = React.createRef<HTMLDivElement>();\r\n    }\r\n\r\n    componentDidUpdate(prevProps: Readonly<ResultSectionProps>) {\r\n        if (prevProps.evaluationTreeRoot !== this.props.evaluationTreeRoot) {\r\n            this.setState({selectedIndex: 0});\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the result relation for the current selected node.\r\n     */\r\n    private getCurrentRelation = (): Relation | null => {\r\n        let currentNode: RATreeNode | null = depthSearch(this.props.evaluationTreeRoot, this.state.selectedIndex);\r\n        if (currentNode === null) {\r\n            currentNode = depthSearch(this.props.evaluationTreeRoot, 0);\r\n            if (currentNode === null) {\r\n                this.props.onUnexpectedError(ErrorFactory.codeError(CodeErrorCodes.resultSection_getCurrentRelation_nodeIndexNotFound));\r\n                return null;\r\n            }\r\n        }\r\n        try {\r\n            return currentNode.getResult();\r\n        }\r\n        catch (err) {\r\n            // errors should be handled in expression section\r\n            this.props.onUnexpectedError(ErrorFactory.codeError(CodeErrorCodes.resultSection_getCurrentRelation_evalError, err.message));\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private handleSelectedNodeChange = (index: number): void => {\r\n        this.setState({selectedIndex: index});\r\n    }\r\n\r\n    /**\r\n     * Saves the displayed evaluation tree as png picture.\r\n     */\r\n    private exportEvalTreeAsPng = (): void => {\r\n        const svg = document.getElementById(evalTreeSVGId);\r\n        if (svg !== null) {\r\n            const rect = svg.getBoundingClientRect();\r\n            const options = {\r\n                width: rect.width * 3,\r\n                height: rect.height * 3,\r\n                svg: svg,\r\n                filename: this.props.expressionName + \" - evaluation tree.png\"\r\n            }\r\n            downloadSVG(options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Saves the current selected relation to a file.\r\n     */\r\n    private exportRelation = (): void => {\r\n        if (this.getCurrentRelation() === null) {\r\n            this.props.onUnexpectedError(ErrorFactory.codeError(CodeErrorCodes.resultSection_saveResultRelation_nullRelationToSave));\r\n            return;\r\n        }\r\n        try {\r\n            RelationStoreManager.save(\r\n                [StoredRelation.fromRelation(\"rachel_result\", this.getCurrentRelation() as Relation, true)],\r\n                \"rachel_result\", this.props.csvValueSeparator);\r\n        }\r\n        catch (err) {\r\n            console.warn(\"Saving error: \" + err, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Passes the current selected relation with the given name to the parent.\r\n     */\r\n    private addRelation = (): void => {\r\n        if (this.getCurrentRelation() === null) {\r\n            this.props.onUnexpectedError(ErrorFactory.codeError(CodeErrorCodes.resultSection_handleAddRelation_nullRelationToAdd));\r\n            return;\r\n        }\r\n        // @ts-ignore\r\n        this.props.onAddResult(this.getCurrentRelation());\r\n    }\r\n\r\n    render() {\r\n        // does not show null result\r\n        if (this.getCurrentRelation() === null) {\r\n            return null;\r\n        }\r\n        const relationType: string = this.state.selectedIndex === 0 ? \"Result\" : \"Intermediate\"\r\n        const selectedNode: RATreeNode | null = depthSearch(this.props.evaluationTreeRoot, this.state.selectedIndex);\r\n        const tableTitle: string | null = selectedNode === null ? null : selectedNode.printInLine();\r\n\r\n        return (\r\n            <section\r\n                ref={this.sectionRef}\r\n                className=\"page-section result-section\">\r\n                <header>\r\n                    <h2>Result</h2>\r\n                    <TooltipButton\r\n                        text=\"Export\"\r\n                        onClick={this.exportEvalTreeAsPng}\r\n                        className={\"\"}\r\n                        tooltip={\"Saves the evaluation tree as png\"}\r\n                        tooltipClassName={\"tooltip\"}\r\n                    />\r\n                </header>\r\n\r\n                <p className=\"upper-p\">\r\n                    <strong>{'Evaluation tree of ' + this.props.evaluationTreeRoot.printInLine() + ':'}</strong>\r\n                </p>\r\n\r\n                <EvaluationTree\r\n                    tree={this.props.evaluationTreeRoot}\r\n                    selected={this.state.selectedIndex}\r\n                    onClick={this.handleSelectedNodeChange}\r\n                    darkTheme={this.props.darkTheme}\r\n                />\r\n\r\n                <p className=\"lower-p\"><strong>{relationType} relation {tableTitle}:</strong></p>\r\n\r\n                <menu className=\"page-section-tab-menu\">\r\n                    <TooltipButton\r\n                        text=\"Add\"\r\n                        onClick={this.addRelation}\r\n                        className={\"\"}\r\n                        tooltip={\"Adds given relation to stored ones\"}\r\n                        tooltipClassName={\"tooltip\"}\r\n                    />\r\n                    <TooltipButton\r\n                        text=\"Export\"\r\n                        onClick={this.exportRelation}\r\n                        className={\"\"}\r\n                        tooltip={\"Saves given relation to a file\"}\r\n                        tooltipClassName={\"tooltip\"}\r\n                    />\r\n                </menu>\r\n\r\n                <ResultRelationTable\r\n                    relation={this.getCurrentRelation() as Relation}\r\n                />\r\n            </section>\r\n        );\r\n    }\r\n}","import {FileDialog} from \"../tools/fileDialog\";\r\nimport {saveAs} from \"file-saver\";\r\nimport {Expression} from \"./expression\";\r\n\r\n/**\r\n * Promised relation in ExpressionStoreManager.load() function. Contains:\r\n * - expressions: Expression[] - successfully parsed expressions\r\n * - skippedExpressions: number - number of skipped expressions (from successfully loaded files)\r\n * - loadedFiles: number - number of successfully loaded files\r\n * - skippedFiles: number - number of skipped files (not .txt, null loaded...)\r\n */\r\nexport interface ExpressionLoadData {\r\n    expressions: Expression[],\r\n    skippedExpressions: number,\r\n    loadedFiles: number,\r\n    skippedFiles: number\r\n}\r\n\r\n/**\r\n * Class for loading and saving expressions.\r\n */\r\nexport class ExpressionStoreManager {\r\n\r\n    /**\r\n     * Loads expressions from multiple textual files selected by the user. Each file can contain multiple expressions,\r\n     * split by '\\n###\\n'. When different line separator is used (\\r, \\r\\n), it is replaced by \\n before return.\r\n     * All tabulators are replaces by 4 spaces.\r\n     */\r\n    public static load(): Promise<ExpressionLoadData> {\r\n        return new Promise<ExpressionLoadData>(resolve => {\r\n            FileDialog.openFiles(\".txt\").then(files =>{\r\n                let expressions: Expression[] = [];\r\n                let skippedExpressions: number = 0;\r\n                let loadedFiles: number = 0;\r\n                let skippedFiles: number = 0;\r\n                files.forEach(file => {\r\n                    if (file.text === null) {\r\n                        console.log('Null read from file ' + file.name);\r\n                        skippedFiles += 1;\r\n                    }\r\n                    else if (file.name.match(/\\.txt$/)) {\r\n                        // replaces line separators to expected '\\n' and tabulators to four spaces\r\n                        file.text = file.text.replace(/\\r\\n/g, '\\n')\r\n                            .replace(/\\r/g, '\\n').replace(/\\t/g, \"    \");\r\n                        // prepends newline for first expected splitting of the first expression\r\n                        ('\\n'.concat(file.text)).split('\\n### ').forEach(part => {\r\n                            try {\r\n                                if (part.trim().length !== 0) {\r\n                                    expressions.push(this.splitExpressionNameAndText(part));\r\n                                }\r\n                            }\r\n                            catch (err) {\r\n                                skippedExpressions += 1;\r\n                            }\r\n                        });\r\n                        loadedFiles += 1;\r\n                    }\r\n                    else {\r\n                        console.log('Unsupported filetype: ' + file.name);\r\n                        skippedFiles += 1;\r\n                    }\r\n                });\r\n                resolve({expressions, skippedExpressions, loadedFiles, skippedFiles});\r\n            });\r\n        });\r\n    }\r\n\r\n    private static splitExpressionNameAndText(expr: string): Expression {\r\n        const firstNewLineIndex: number = expr.indexOf('\\n');\r\n        if (firstNewLineIndex === -1) {\r\n            console.log(\"Expression does not contain first name line.\");\r\n            throw Error();\r\n        }\r\n        const firstRow: string = expr.slice(0, firstNewLineIndex).trim();\r\n        if (!firstRow.endsWith(' ###')) {\r\n            console.log(\"Expression does not contain name between hashes.\");\r\n            throw Error();\r\n        }\r\n        const name: string = firstRow.slice(0, -4);\r\n        const text: string = expr.slice(firstNewLineIndex).trim();\r\n        return {name: name, text: text};\r\n    }\r\n\r\n    /**\r\n     * Saves given expressions to a textual file. Each expression starts with \"### Expression name ###\\n\" line.\r\n     *\r\n     * @param expressions array of expressions to be saved\r\n     * @param filename name of the downloaded file (without extension)\r\n     */\r\n    public static save(expressions: Expression[], filename: string): void {\r\n        const textContent: string = expressions.map(e => {\r\n            return \"### \" + e.name + \" ###\\n\\n\" + e.text;\r\n        }).join('\\n\\n');\r\n        const blob = new Blob([textContent], {type: \"text/plain;charset=utf-8\"});\r\n        saveAs(blob, filename + '.txt');\r\n    }\r\n}","import {Project} from \"./project\";\r\n\r\nexport interface ProjectSample {\r\n    name: string,\r\n    project: Project\r\n}\r\n\r\nconst samples: ProjectSample[] = [\r\n    {\r\n        name: \"Cars and Owners\",\r\n        project: {\r\n            relations: [\r\n                {\r\n                    name: \"Car\",\r\n                    columnNames: [\"Id\", \"Owner\", \"Color\", \"Electric\", \"Weight\"],\r\n                    columnTypes: [\"number\", \"number\", \"string\", \"boolean\", \"number\"],\r\n                    rows: [\r\n                        ['1', '1', 'Blue', 'True', '1000'],\r\n                        ['2', '1', 'Green', 'false', '1 200'],\r\n                        ['3', '2', 'Blue', 'F', '850.42'],\r\n                        ['4', '3', 'Black', 't', '1 111.111 111']\r\n                    ],\r\n                    columnCount: 5,\r\n                    rowCount: 4\r\n                },\r\n                {\r\n                    name: \"Owner\",\r\n                    columnNames: [\"Id\", \"Name\"],\r\n                    columnTypes: [\"number\", \"string\"],\r\n                    rows: [\r\n                        ['1', 'George Smith'],\r\n                        ['2', 'Adam \"Driver /\\\\\" Jackson'],\r\n                        ['3', 'Michael Trueman'],\r\n                        ['Fix errors', 'before loading'],\r\n                        ['Or delete', 'invalid rows']\r\n                    ],\r\n                    columnCount: 2,\r\n                    rowCount: 3\r\n                }\r\n            ],\r\n            expressions: [\r\n                {\r\n                    name: \"Relation only\",\r\n                    text:\r\n                        \"// You can use comments until the line end after '//'\\n\" +\r\n                        \"// You must load relations before using them in expressions\\n\" +\r\n                        \"\\n\" +\r\n                        \"Car\\n\" +\r\n                        \"\\n\" +\r\n                        \"// After evaluation, you will see the evaluation tree\\n\" +\r\n                        \"// and the result relation at the bottom of the page\\n\" +\r\n                        \"\"\r\n                },\r\n                {\r\n                    name: \"Unary operator\",\r\n                    text:\r\n                        \"// Unary operator comes after the source relation\\n\" +\r\n                        \"// If the relation is still not defined, go check its definition\\n\" +\r\n                        \"// This expression returns all owners with id 1\\n\" +\r\n                        \"\\n\" +\r\n                        \"Owner(Id = 1)\\n\" +\r\n                        \"\"\r\n                },\r\n                {\r\n                    name: \"Binary operator\",\r\n                    text:\r\n                        \"// Binary operator comes between source relations\\n\" +\r\n                        \"// This expression returns natural join of cars and owners\\n\" +\r\n                        \"\\n\" +\r\n                        \"Car*Owner\\n\" +\r\n                        \"\"\r\n                },\r\n                {\r\n                    name: \"Escapes\",\r\n                    text:\r\n                        \"// Strings in expressions are enclosed in quotes\\n\" +\r\n                        \"// To use quotes inside a string, you must escape them by a backslash '\\\\\\\"'\\n\" +\r\n                        \"// To use backslash inside a string, you must escape it with second one '\\\\\\\\'\\n\" +\r\n                        \"\\n\" +\r\n                        'Owner(Name == \"Adam \\\\\"Driver /\\\\\\\\\\\\\" Jackson\")\\n' +\r\n                        '\\n' +\r\n                        '// This does not work: Owner(Name == \"Adam \"Driver /\\\\\" Jackson\")\\n' +\r\n                        \"\"\r\n                },\r\n                {\r\n                    name: \"Example\",\r\n                    text:\r\n                        \"// Errors are highlighted by red underline - hover mouse over it to see details\\n\" +\r\n                        \"// While typing, Rachel shows you available relations or columns\\n\" +\r\n                        \"// (if relations are loaded in the application)\\n\" +\r\n                        \"// Try to write a query for: all cars' ids and their owners' names\\n\" +\r\n                        \"\\n\" +\r\n                        \"TODO...\\n\" +\r\n                        \"\"\r\n                },\r\n                {\r\n                    name: \"Example result\",\r\n                    text:\r\n                        \"// One possible expression is like this...\\n\" +\r\n                        \"\\n\" +\r\n                        \"(\\n\" +\r\n                        \"  Car\\n\" +\r\n                        \"  *\\n\" +\r\n                        \"  Owner< Id -> Owner >\\n\" +\r\n                        \")[Id, Name]\\n\" +\r\n                        \"\\n\" +\r\n                        \"// For more detailed manual click 'About' button in the page header\\n\" +\r\n                        \"\"\r\n                }\r\n            ],\r\n            nullValuesSupport: true\r\n        }\r\n    }\r\n];\r\n\r\n/**\r\n * Returns prepared project samples.\r\n */\r\nexport function getSamples(): ProjectSample[] {\r\n    return samples;\r\n}","import React from \"react\";\r\nimport {CsvValueSeparatorChar} from \"../tools/csvSupport\";\r\nimport {SupportedLanguage} from \"../tools/supportedLanguage\";\r\nimport \"./css/managementSection.css\"\r\nimport {getSamples} from \"../project/samples\";\r\nimport {Project} from \"../project/project\";\r\n\r\ninterface ManagementSectionProps {\r\n    // handler of batch processing\r\n    onBatch: () => void,\r\n\r\n    // handler of project loading\r\n    onLoadProject: () => void,\r\n    // handler of project saving\r\n    onSaveProject: () => void,\r\n\r\n    // handler of loading the selected sample project\r\n    onLoadSample: (sample: Project) => void,\r\n\r\n    // current selected value separator in csv files\r\n    csvValueSeparator: CsvValueSeparatorChar,\r\n    // current selected language of the application\r\n    language: SupportedLanguage,\r\n    // current selected null values support\r\n    nullValuesSupport: boolean,\r\n    // true if dark theme should be applied\r\n    darkTheme: boolean,\r\n\r\n    // handler of change of the current selected value separator in csv files\r\n    onCsvValueSeparatorChange: (csvValueSeparator: CsvValueSeparatorChar) => void,\r\n    // handler of change of the current selected language of the application\r\n    onLanguageChange: (language: SupportedLanguage) => void,\r\n    // handler of change of the current selected null values support\r\n    onNullValuesSupportChange: (nullValuesSupport: boolean) => void,\r\n    // handler of change of the current selected theme\r\n    onDarkModeChange: (darkTheme: boolean) => void\r\n}\r\n\r\ninterface ManagementSectionState {\r\n    sectionClicked: boolean\r\n}\r\n\r\n/**\r\n * Section to manage batch processing, importing/exporting the project, and settings.\r\n */\r\nexport class ManagementSection extends React.Component<ManagementSectionProps, ManagementSectionState> {\r\n\r\n    constructor(props: ManagementSectionProps) {\r\n        super(props);\r\n        this.state = {\r\n            sectionClicked: false\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const createBatchButton = () => {\r\n            return (<button onClick={this.props.onBatch}>Batch</button>);\r\n        }\r\n        const createLoadProjectButton = () => {\r\n            return (<button onClick={this.props.onLoadProject} >Load</button>);\r\n        }\r\n        const createSaveProjectButton = () => {\r\n            return (<button onClick={this.props.onSaveProject} >Save</button>);\r\n        }\r\n        const createSettingsButton = () => {\r\n            const settingsMenu = (\r\n                <ul className=\"list-menu\">\r\n                    <li>\r\n                        <span>Null values:</span>\r\n                        <input\r\n                            type=\"radio\"\r\n                            name=\"null_values_support\"\r\n                            value=\"allowed\"\r\n                            id=\"null_values_support_allowed\"\r\n                            checked={this.props.nullValuesSupport}\r\n                            onChange={() => this.props.onNullValuesSupportChange(true)} />\r\n                        <label htmlFor=\"null_values_support_allowed\">allowed</label>\r\n                        <input\r\n                            type=\"radio\"\r\n                            name=\"null_values_support\"\r\n                            value=\"forbidden\"\r\n                            id=\"null_values_support_forbid\"\r\n                            checked={!this.props.nullValuesSupport}\r\n                            onChange={() => this.props.onNullValuesSupportChange(false)} />\r\n                        <label htmlFor=\"null_values_support_forbid\">forbidden</label>\r\n                    </li>\r\n                    <li>\r\n                        <span>CSV separator:</span>\r\n                        <input\r\n                            type=\"radio\"\r\n                            name=\"value_separator\"\r\n                            value=\"semicolon\"\r\n                            id=\"value_separator_semi\"\r\n                            checked={this.props.csvValueSeparator === \";\"}\r\n                            onChange={() => this.props.onCsvValueSeparatorChange(\";\")}/>\r\n                        <label htmlFor=\"value_separator_semi\">semicolon</label>\r\n                        <input\r\n                            type=\"radio\"\r\n                            name=\"value_separator\"\r\n                            value=\"comma\"\r\n                            id=\"value_separator_comma\"\r\n                            checked={this.props.csvValueSeparator === \",\"}\r\n                            onChange={() => this.props.onCsvValueSeparatorChange(\",\")}/>\r\n                        <label htmlFor=\"value_separator_comma\">comma</label>\r\n                    </li>\r\n                    <li>\r\n                        <span>Theme:</span>\r\n                        <input\r\n                            type=\"radio\"\r\n                            name=\"dark_mode\"\r\n                            value=\"on\"\r\n                            id=\"dark_mode_on\"\r\n                            checked={!this.props.darkTheme}\r\n                            onChange={() => this.props.onDarkModeChange(false)} />\r\n                        <label htmlFor=\"dark_mode_on\">light</label>\r\n                        <input\r\n                            type=\"radio\"\r\n                            name=\"dark_mode\"\r\n                            value=\"off\"\r\n                            id=\"dark_mode_off\"\r\n                            checked={this.props.darkTheme}\r\n                            onChange={() => this.props.onDarkModeChange(true)} />\r\n                        <label htmlFor=\"dark_mode_off\">dark</label>\r\n                    </li>\r\n                </ul>\r\n            );\r\n            return (<div className={\"button-like\"}>Settings{settingsMenu}</div>);\r\n        }\r\n        const createSamplesButton = () => {\r\n            const settingsMenu = (\r\n            <ul className=\"list-menu\">\r\n                {\"Prepared sample projects\"}\r\n                {getSamples().map((sample, i) => {\r\n                    return (\r\n                        <li key={i}>\r\n                            {\"- \"}\r\n                            <button onClick={() => this.props.onLoadSample(sample.project)}\r\n                            >{sample.name}</button>\r\n                        </li>\r\n                    );\r\n                })}\r\n            </ul>\r\n            );\r\n            return (<div className={\"button-like\"} >Samples{settingsMenu}</div>);\r\n        }\r\n        const createAboutButton = () => {\r\n            return (\r\n                <a  href=\"https://github.com/kotliluk/rachel\"\r\n                    target=\"_blank\"\r\n                    rel=\"noreferrer\"\r\n                    className={\"button-like\"}\r\n                >About</a>\r\n            );\r\n        }\r\n\r\n        return (\r\n            <header className=\"management-section\">\r\n                <h1>RACHEL</h1>\r\n                {/*createBatchButton()*/}\r\n                {createLoadProjectButton()}\r\n                {createSaveProjectButton()}\r\n                {createSamplesButton()}\r\n                {createSettingsButton()}\r\n                {createAboutButton()}\r\n            </header>\r\n        );\r\n    }\r\n}","import {copyExpression, Expression, isExpression} from \"../expression/expression\";\r\nimport {copyStoredRelationData, isStoredRelationData, StoredRelationData} from \"../relation/storedRelation\";\r\n\r\n/**\r\n * Project interface to store information about project relations and expressions relation.\r\n * Does not store custom settings about saving file types etc.\r\n */\r\nexport interface Project {\r\n    relations: StoredRelationData[],\r\n    expressions: Expression[],\r\n    nullValuesSupport: boolean\r\n}\r\n\r\n/**\r\n * Checks whether the given value is Project (i.e., has all required fields of required types).\r\n *\r\n * @param obj value to be checked\r\n * @return \"OK\" string if the given obj is Project or string description of found error in the structure\r\n */\r\nexport function isProjectObject(obj: any): string {\r\n    if (typeof obj !== \"object\") {\r\n        return 'The file cannot be parsed to an object.';\r\n    }\r\n    if (!(\"relations\" in obj) || !Array.isArray(obj.relations) || obj.relations.length === 0 ||\r\n        obj.relations.some((o: any) => !isStoredRelationData(o))) {\r\n        return 'The file must contain the field \"relations: StoredRelationData[]\" of length at least one';\r\n    }\r\n    if (!(\"expressions\" in obj) || !Array.isArray(obj.expressions) || obj.expressions.length === 0 ||\r\n        obj.expressions.some((o: any) => !isExpression(o))) {\r\n        return 'The file must contain the field \"expressions: Expression[]\" of length at least one';\r\n    }\r\n    if (!(\"nullValuesSupport\" in obj) || typeof obj.nullValuesSupport !== \"boolean\") {\r\n        return 'The file must contain the field \"nullValuesSupport: boolean\"';\r\n    }\r\n    return 'OK';\r\n}\r\n\r\n/**\r\n * Creates a copy of the given project.\r\n */\r\nexport function copyProject(proj: Project): Project {\r\n    return {\r\n        relations: proj.relations.map(rel => copyStoredRelationData(rel)),\r\n        expressions: proj.expressions.map(expr => copyExpression(expr)),\r\n        nullValuesSupport: proj.nullValuesSupport\r\n    }\r\n}","/**\r\n * Representation of named RA expression.\r\n */\r\nexport interface Expression {\r\n    name: string,\r\n    text: string\r\n}\r\n\r\n/**\r\n * Checks whether the given obj is an Expression.\r\n *\r\n * @param obj\r\n */\r\nexport function isExpression(obj: any): boolean {\r\n    if (typeof obj !== \"object\") {\r\n        return false;\r\n    }\r\n    return (\"name\" in obj) && (typeof obj.name === \"string\") && (\"text\" in obj) && (typeof obj.text === \"string\");\r\n}\r\n\r\n/**\r\n * Creates a copy of the given expression.\r\n */\r\nexport function copyExpression(exp: Expression): Expression {\r\n    return {name: exp.name, text: exp.text};\r\n}","import {isProjectObject, Project} from \"./project\";\r\nimport {FileDialog} from \"../tools/fileDialog\";\r\nimport {saveAs} from \"file-saver\";\r\n\r\n/**\r\n * Class for loading and saving project relations and expressions relation.\r\n */\r\nexport class ProjectStoreManager {\r\n\r\n    /**\r\n     * Loads asynchronously the project from a .rachel (JSON) file selected by the user.\r\n     * The file must contain the representation of the project object: {\r\n     * relations: StoredRelationData[],\r\n     * expressionTexts: string[],\r\n     * nullValuesSupport: boolean\r\n     * }.\r\n     * Returned string values always use '\\n' as line separator.\r\n     */\r\n    public static load(): Promise<Project> {\r\n        return new Promise<Project>((resolve, reject) => {\r\n            FileDialog.openFile(\".rachel\").then(file => {\r\n                if (file.text === null) {\r\n                    reject(\"Reading of the content of the file \" + file.name + \" failed.\");\r\n                }\r\n                else if (file.name.match(/\\.rachel$/)) {\r\n                    // replaces line separators to expected '\\n'\r\n                    file.text = file.text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n')\r\n                        .replace(/\\t/g, \"    \");\r\n                    let obj = JSON.parse(file.text);\r\n                    const result: string = isProjectObject(obj);\r\n                    if (result === \"OK\") {\r\n                        const project: Project = obj;\r\n                        resolve(project);\r\n                    }\r\n                    else {\r\n                        reject(\"Invalid structure of the JSON file. \" + result)\r\n                    }\r\n                }\r\n                else {\r\n                    reject(\"Please select a JSON file to load a project relation from.\");\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Saves the given Project into the .rachel (JSON) file.\r\n     *\r\n     * @param project the Project object with all project relation\r\n     * @param filename name of the downloaded file (without extension)\r\n     */\r\n    public static save(project: Project, filename: string): void {\r\n        const blob = new Blob([JSON.stringify(project)], {type: \"text/plain;charset=utf-8\"});\r\n        saveAs(blob, filename + '.rachel');\r\n    }\r\n}","import {CsvValueSeparatorChar} from \"./csvSupport\";\r\nimport {isSupportedLanguage, SupportedLanguage} from \"./supportedLanguage\";\r\n\r\nconst defaultCsvValueSeparator: CsvValueSeparatorChar = \";\";\r\nconst defaultLanguage: SupportedLanguage = \"ENG\";\r\nconst defaultDarkMode: string = \"false\";\r\n\r\n/**\r\n * Static class for maintaining the access to local storage of the browser. It handles user settings:\r\n * saving file type, csv value separator, language, light/dark theme of the application.\r\n * If the local storage is not used, it uses the application memory and the default values.\r\n */\r\nexport class LocalStorage {\r\n\r\n    private static isInit: boolean = false;\r\n    private static storageSupported: boolean = typeof(Storage) !== \"undefined\";\r\n\r\n    private static csvValueSeparator: CsvValueSeparatorChar;\r\n    private static language: SupportedLanguage;\r\n    private static darkTheme: string;\r\n\r\n    /**\r\n     * Initializes the LocalStorage. If there are the requested values, loads them to application memory.\r\n     * If the local storage is not supported, uses the default values.\r\n     */\r\n    private static init(): void {\r\n        if (LocalStorage.storageSupported) {\r\n            const storedSeparator = localStorage.getItem(\"csvValueSeparator\");\r\n            if (storedSeparator !== \";\" && storedSeparator !== \",\") {\r\n                console.log(\"csvValueSeparator not found in localStorage and set to default\");\r\n                localStorage.setItem(\"csvValueSeparator\", defaultCsvValueSeparator);\r\n                LocalStorage.csvValueSeparator = defaultCsvValueSeparator;\r\n            }\r\n            else {\r\n                // @ts-ignore\r\n                LocalStorage.csvValueSeparator = localStorage.getItem(\"csvValueSeparator\");\r\n            }\r\n            if (!isSupportedLanguage(localStorage.getItem(\"language\"))) {\r\n                console.log(\"language not found in localStorage and set to default\");\r\n                localStorage.setItem(\"language\", defaultLanguage);\r\n                LocalStorage.language = defaultLanguage;\r\n            }\r\n            else {\r\n                // @ts-ignore\r\n                LocalStorage.language = localStorage.getItem(\"language\");\r\n            }\r\n\r\n            if (localStorage.getItem(\"darkTheme\") !== \"true\" && localStorage.getItem(\"darkTheme\") !== \"false\") {\r\n                console.log(\"darkTheme not found in localStorage and set to default\");\r\n                localStorage.setItem(\"darkTheme\", defaultDarkMode);\r\n                LocalStorage.darkTheme = defaultDarkMode;\r\n            }\r\n            else {\r\n                // @ts-ignore\r\n                LocalStorage.darkTheme = localStorage.getItem(\"darkTheme\");\r\n            }\r\n        }\r\n        else {\r\n            console.warn(\"LocalStorage not supported in the browser. Default values used.\");\r\n            LocalStorage.csvValueSeparator = defaultCsvValueSeparator;\r\n            LocalStorage.language = defaultLanguage;\r\n            LocalStorage.darkTheme = defaultDarkMode;\r\n        }\r\n        LocalStorage.isInit = true;\r\n    }\r\n\r\n    public static getCsvValueSeparator(): CsvValueSeparatorChar {\r\n        if (!LocalStorage.isInit) {\r\n            LocalStorage.init();\r\n        }\r\n        return LocalStorage.csvValueSeparator;\r\n    }\r\n\r\n    public static setCsvValueSeparator(csvValueSeparator: CsvValueSeparatorChar): void {\r\n        LocalStorage.csvValueSeparator = csvValueSeparator;\r\n        if (LocalStorage.storageSupported) {\r\n            localStorage.setItem(\"csvValueSeparator\", csvValueSeparator);\r\n        }\r\n    }\r\n\r\n    public static getLanguage(): SupportedLanguage {\r\n        if (!LocalStorage.isInit) {\r\n            LocalStorage.init();\r\n        }\r\n        return LocalStorage.language;\r\n    }\r\n\r\n    public static setLanguage(language: SupportedLanguage): void {\r\n        LocalStorage.language = language;\r\n        if (LocalStorage.storageSupported) {\r\n            localStorage.setItem(\"language\", language);\r\n        }\r\n    }\r\n\r\n    public static getDarkMode(): boolean {\r\n        if (!LocalStorage.isInit) {\r\n            LocalStorage.init();\r\n        }\r\n        return LocalStorage.darkTheme === \"true\";\r\n    }\r\n\r\n    public static setDarkMode(darkTheme: boolean): void {\r\n        LocalStorage.darkTheme = String(darkTheme);\r\n        if (LocalStorage.storageSupported) {\r\n            localStorage.setItem(\"darkTheme\", String(darkTheme));\r\n        }\r\n    }\r\n}","/**\r\n * Textual description of supported value separators.\r\n */\r\nexport type SupportedLanguage = \"ENG\" | \"CZE\";\r\n\r\nexport function isSupportedLanguage(x: any): boolean {\r\n    return x === \"ENG\" || x === \"CZE\";\r\n}","import {FileDialog} from \"./fileDialog\";\r\nimport JSZip from \"jszip\";\r\nimport {saveAs} from \"file-saver\";\r\nimport Relation from \"../relation/relation\";\r\nimport RATreeNode from \"../ratree/raTreeNode\";\r\nimport UnaryNode from \"../ratree/unaryNode\";\r\nimport ProjectionNode from \"../ratree/projectionNode\";\r\nimport RenameNode from \"../ratree/renameNode\";\r\nimport SelectionNode from \"../ratree/selectionNode\";\r\nimport BinaryNode from \"../ratree/binaryNode\";\r\nimport AntijoinNode from \"../ratree/antijoinNode\";\r\nimport CartesianProductNode from \"../ratree/cartesianProductNode\";\r\nimport DivisionNode from \"../ratree/divisionNode\";\r\nimport OuterJoinNode from \"../ratree/outerJoinNode\";\r\nimport NaturalJoinNode, {NaturalJoinType} from \"../ratree/naturalJoinNode\";\r\nimport SetOperationNode from \"../ratree/setOperationNode\";\r\nimport {formatDate} from \"./date\";\r\nimport ThetaJoinNode, {ThetaJoinType} from \"../ratree/thetaJoinNode\";\r\nimport {isProjectObject, Project} from \"../project/project\";\r\nimport {ExprParser} from \"../expression/exprParser\";\r\nimport {StoredRelation, StoredRelationData} from \"../relation/storedRelation\";\r\nimport {Expression} from \"../expression/expression\";\r\n\r\n/**\r\n * Class for processing multiple input .txt files with expressions.\r\n */\r\nexport class BatchProcessor {\r\n\r\n    /**\r\n     * Opens file dialog and processes files selected by the user. For each .rachel file creates a textual evaluation\r\n     * report. Files are expected to contain valid project data. Returns promise with string message about process.\r\n     */\r\n    public process(filename: string): Promise<string> {\r\n        return new Promise<string>((resolve, reject) => {\r\n            FileDialog.openFiles(\".rachel\").then(files => {\r\n                console.log(files.length + ' files loaded to BatchProcessor');\r\n                console.time(\"Batch duration\");\r\n                let reports: {name: string, text: string}[] = [];\r\n                let processed: number = 0;\r\n                let skipped: number = 0;\r\n                files.forEach(file => {\r\n                    if (file.text === null) {\r\n                        reports.push({\r\n                            name: file.name + '-eval-report.txt',\r\n                            text: \"ERROR: Source file cannot be loaded.\"\r\n                        });\r\n                        skipped += 1;\r\n                        console.warn('Null read from ' + file.name);\r\n                    }\r\n                    else if (file.name.match(/\\.rachel$/)) {\r\n                        // @ts-ignore - file.text cannot be null now\r\n                        reports.push(this.processFile(file));\r\n                        processed += 1;\r\n                    }\r\n                    else {\r\n                        reports.push({\r\n                            name: file.name + '-eval-report.txt',\r\n                            text: \"ERROR: Source file is not a .rachel file, but: \" + file.name\r\n                        });\r\n                        skipped += 1;\r\n                        console.warn('Unsupported filetype: ' + file.name);\r\n                    }\r\n                    console.log(\"Batch in progress... \" + (processed + skipped) + \"/\" + files.length);\r\n                });\r\n                console.timeEnd(\"Batch duration\");\r\n                if (reports.length === 0) {\r\n                    resolve(\"Batch finished: \" + processed + \" files processed, \" + skipped + \" skipped.\");\r\n                }\r\n                const zip: JSZip = JSZip();\r\n                reports.forEach(report => {\r\n                    zip.file(report.name, report.text);\r\n                });\r\n                zip.generateAsync({type: \"blob\"}).then(content => {\r\n                    saveAs(content, filename + \".zip\");\r\n                    console.log(\"Batch finished: \" + processed + \" files processed, \" + skipped + \" skipped.\");\r\n                    resolve(\"Batch finished: \" + processed + \" files processed, \" + skipped + \" skipped.\");\r\n                }).catch(err => {\r\n                    reject(\"Results saving error: \" + err.message);\r\n                });\r\n            });\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Tries to parse Project object from given file.text. If successful, parses relations in the project, evaluates\r\n     * expressions in the project and generates textual report: header (see reportHeader()),\r\n     * formatted relations (see formatRelations()) and formatted expressions (see processExpression()).\r\n     */\r\n    private processFile = (file: {name: string, text: string}): {name: string, text: string} => {\r\n        const project: Project = JSON.parse(file.text);\r\n        const status = isProjectObject(project);\r\n        if (status !== \"OK\") {\r\n            return {name: file.name.slice(0, -4) + '-eval-report.txt', text: \"Invalid JSON file: \" + status};\r\n        }\r\n        const relations: Map<string, Relation> = this.parseRelations(project.relations, project.nullValuesSupport);\r\n        const exprParser: ExprParser = new ExprParser(relations, project.nullValuesSupport);\r\n\r\n        const exprCount: number = project.expressions.length;\r\n        const reports = project.expressions.map(e => this.processExpression(e, exprParser));\r\n        const ops: OperationsCount = addOperations(...reports.map(r => r.counts));\r\n        const errors: number = reports.reduce((agg, report) => agg + report.error, 0);\r\n\r\n        return {\r\n            name: file.name.slice(0, -5) + '-eval-report.txt',\r\n            text: this.reportHeader(exprCount, errors, ops, project.nullValuesSupport) +\r\n                  this.formatRelations(project.relations) +\r\n                  reports.map(r => r.text).join('')\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Creates full Relation representation for given StoredRelationData array.\r\n     */\r\n    private parseRelations(storedData: StoredRelationData[], nullValuesSupport: boolean): Map<string, Relation> {\r\n        const map: Map<string, Relation> = new Map();\r\n        storedData.forEach(data => {\r\n            try {\r\n                const storedRelation: StoredRelation = StoredRelation.fromData(data, nullValuesSupport);\r\n                if (storedRelation.isValid()) {\r\n                    map.set(storedRelation.getName(), storedRelation.createRelation());\r\n                }\r\n            }\r\n            catch (err) {\r\n                console.log(\"Definition of relation \" + data.name + \" has errors, skipping.\");\r\n            }\r\n        })\r\n        return map;\r\n    }\r\n\r\n    /**\r\n     * Processes given expression in context of given parser. Returns formatted expression and its result (or error),\r\n     * count of used RA operations and 0/1 error indicator.\r\n     */\r\n    private processExpression = (expr: Expression, parser: ExprParser): {text: string, counts: OperationsCount, error: number} => {\r\n        try {\r\n            const evaluationTree = parser.parse(expr.text);\r\n            const counts: OperationsCount = operationsOfTree(evaluationTree);\r\n            const relation: Relation = evaluationTree.getResult();\r\n            return {\r\n                text: '### ' + expr.name + ' ###\\n\\n' + expr.text + '\\n\\n# Result #\\n\\n' + relation.contentString() + '\\n\\n',\r\n                counts: counts,\r\n                error: 0\r\n            };\r\n        }\r\n        catch (err) {\r\n            return {\r\n                text: '### ' + expr.name + ' ###\\n\\n' + expr.text + '\\n\\n# Error #\\n\\n' + err.message + '\\n\\n',\r\n                counts: zeroOperations(),\r\n                error: 1\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates the header of the report. The header contains the time of the report, count of expressions and errors,\r\n     * count of used operations and null values support info.\r\n     *\r\n     * @param expressions count of expressions\r\n     * @param errors count of errors\r\n     * @param operations count of operations\r\n     * @param nullValuesSupport\r\n     */\r\n    private reportHeader = (expressions: number, errors: number, operations: OperationsCount, nullValuesSupport: boolean): string => {\r\n        const total: number = totalOperations(operations);\r\n        const binary: number = binaryOperations(operations);\r\n        const unary: number = unaryOperations(operations);\r\n        return 'Rachel project report from ' + formatDate(new Date()) + '\\n\\n' +\r\n            'Expressions: ' + expressions + '    Errors: ' + errors + '\\n\\n' +\r\n            'Used operations (' + total + ' in total: ' + binary + ' binary, ' + unary + ' unary):\\n' +\r\n            '    Antijoin: ' + operations.antijoin + '\\n' +\r\n            '    Cartesian product: ' + operations.cartesian + '\\n' +\r\n            '    Division: ' + operations.division + '\\n' +\r\n            '    Natural join: ' + operations.natural + '\\n' +\r\n            '    Outer Join: ' + operations.outerJoin + '\\n' +\r\n            '    Projection: ' + operations.projection + '\\n' +\r\n            '    Rename: ' + operations.rename + '\\n' +\r\n            '    Selection: ' + operations.selection + '\\n' +\r\n            '    Semijoin: ' + operations.semijoin + '\\n' +\r\n            '    Set Operations: ' + operations.setOperation + '\\n' +\r\n            '    Theta Join: ' + operations.thetaJoin + '\\n' +\r\n            '    Theta Semijoin: ' + operations.thetaSemijoin + '\\n\\n' +\r\n            (nullValuesSupport ? 'Null values ALLOWED.\\n\\n' : 'Null values FORBIDDEN.\\n\\n');\r\n    }\r\n\r\n    /**\r\n     * Returns formatted string for given StoredRelationsData array.\r\n     */\r\n    private formatRelations = (storedData: StoredRelationData[]): string => {\r\n        return \"### Defined relations ###\\n\\n\" + storedData.map(data => {\r\n            return '# ' + data.name + ' #\\n' +\r\n                data.columnNames.join(', ') + '\\n' +\r\n                data.columnTypes.join(', ') + '\\n' +\r\n                data.rows.map(row => row.join(', ')).join('\\n') + '\\n\\n';\r\n        }).join('');\r\n    }\r\n}\r\n\r\n/**\r\n * Counts of all supported relational algebra operations.\r\n */\r\ninterface OperationsCount {\r\n    antijoin: number,\r\n    cartesian: number,\r\n    division: number,\r\n    natural: number,\r\n    outerJoin: number,\r\n    projection: number,\r\n    rename: number,\r\n    selection: number,\r\n    semijoin: number,\r\n    setOperation: number,\r\n    thetaJoin: number,\r\n    thetaSemijoin: number,\r\n}\r\n\r\n/**\r\n * @return zero count of all operations\r\n */\r\nfunction zeroOperations(): OperationsCount {\r\n    return addOperations();\r\n}\r\n\r\n/**\r\n * @return adds given OperationsCounts together\r\n */\r\nfunction addOperations(...counts: OperationsCount[]): OperationsCount {\r\n    return {\r\n        antijoin: counts.reduce((agg, count) => agg + count.antijoin, 0),\r\n        cartesian: counts.reduce((agg, count) => agg + count.cartesian, 0),\r\n        division: counts.reduce((agg, count) => agg + count.division, 0),\r\n        natural: counts.reduce((agg, count) => agg + count.natural, 0),\r\n        outerJoin: counts.reduce((agg, count) => agg + count.outerJoin, 0),\r\n        projection: counts.reduce((agg, count) => agg + count.projection, 0),\r\n        rename: counts.reduce((agg, count) => agg + count.rename, 0),\r\n        selection: counts.reduce((agg, count) => agg + count.selection, 0),\r\n        semijoin: counts.reduce((agg, count) => agg + count.semijoin, 0),\r\n        setOperation: counts.reduce((agg, count) => agg + count.setOperation, 0),\r\n        thetaJoin: counts.reduce((agg, count) => agg + count.thetaJoin, 0),\r\n        thetaSemijoin: counts.reduce((agg, count) => agg + count.thetaSemijoin, 0),\r\n    }\r\n}\r\n\r\n/**\r\n * @return sum of all operation counts\r\n */\r\nfunction totalOperations(o: OperationsCount): number {\r\n    return binaryOperations(o) + unaryOperations(o);\r\n}\r\n\r\n/**\r\n * @return sum of all binary operation counts\r\n */\r\nfunction binaryOperations(o: OperationsCount): number {\r\n    return o.antijoin + o.cartesian + o.division + o.natural + o.outerJoin + o.semijoin + o.setOperation + o.thetaJoin + o.thetaSemijoin;\r\n}\r\n\r\n/**\r\n * @return sum of all unary operation counts\r\n */\r\nfunction unaryOperations(o: OperationsCount): number {\r\n    return o.projection + o.rename + o.selection;\r\n}\r\n\r\n/**\r\n * @return counts all operations used in the given tree.\r\n */\r\nfunction operationsOfTree(tree: RATreeNode): OperationsCount {\r\n    if (tree instanceof UnaryNode) {\r\n        return addOperations(operationOfUnaryNode(tree), operationsOfTree(tree.getSubtree()));\r\n    }\r\n    if (tree instanceof BinaryNode) {\r\n        return addOperations(operationOfBinaryNode(tree), operationsOfTree(tree.getLeftSubtree()), operationsOfTree(tree.getRightSubtree()));\r\n    }\r\n    // no subtree - relation node\r\n    return zeroOperations();\r\n}\r\n\r\n/**\r\n * @return OperationsCount with one given unary operation count set to 1, other 0\r\n */\r\nfunction operationOfUnaryNode(node: UnaryNode): OperationsCount {\r\n    let ret: OperationsCount = zeroOperations();\r\n    if (node instanceof ProjectionNode) {\r\n        ret.projection = 1;\r\n        return ret;\r\n    }\r\n    if (node instanceof RenameNode) {\r\n        ret.rename = 1;\r\n        return ret;\r\n    }\r\n    if (node instanceof SelectionNode) {\r\n        ret.selection = 1;\r\n        return ret;\r\n    }\r\n    return ret;\r\n}\r\n\r\n/**\r\n * @return OperationsCount with one given binary operation count set to 1, other 0\r\n */\r\nfunction operationOfBinaryNode(node: BinaryNode): OperationsCount {\r\n    let ret: OperationsCount = zeroOperations();\r\n    if (node instanceof AntijoinNode) {\r\n        ret.antijoin = 1;\r\n        return ret;\r\n    }\r\n    if (node instanceof CartesianProductNode) {\r\n        ret.cartesian = 1;\r\n        return ret;\r\n    }\r\n    if (node instanceof DivisionNode) {\r\n        ret.division = 1;\r\n        return ret;\r\n    }\r\n    if (node instanceof OuterJoinNode) {\r\n        ret.outerJoin = 1;\r\n        return ret;\r\n    }\r\n    if (node instanceof NaturalJoinNode) {\r\n        if (node.getType() === NaturalJoinType.natural) {\r\n            ret.natural = 1;\r\n        }\r\n        else {\r\n            ret.semijoin = 1;\r\n        }\r\n        return ret;\r\n    }\r\n    if (node instanceof SetOperationNode) {\r\n        ret.setOperation = 1;\r\n        return ret;\r\n    }\r\n    if (node instanceof ThetaJoinNode) {\r\n        if (node.getType() === ThetaJoinType.full) {\r\n            ret.thetaJoin = 1;\r\n        }\r\n        else {\r\n            ret.thetaSemijoin = 1;\r\n        }\r\n        return ret;\r\n    }\r\n    return ret;\r\n}","/**\r\n * Formats given date to: dd.mm.yyyy hh:mm.\r\n *\r\n * @param date date to format\r\n */\r\nexport function formatDate(date: Date): string {\r\n    return String(date.getDate()).padStart(2, '0') + '.' + String(date.getMonth() + 1).padStart(2, '0') + '.' +\r\n        String(date.getFullYear()) + ' ' +\r\n        String(date.getHours()).padStart(2, '0') + ':' + String(date.getMinutes()).padStart(2, '0');\r\n}","import React from \"react\";\r\nimport './css/editRelationTable.css';\r\nimport {StoredRelation} from \"../relation/storedRelation\";\r\nimport {SupportedColumnType} from \"../relation/columnType\";\r\nimport {RCToStringMap} from \"../tools/rcToStringMap\";\r\n\r\ninterface EditRelationTableProps {\r\n    // storing representation of the relation to be edited\r\n    relation: StoredRelation,\r\n\r\n    // handler of column name change\r\n    onColumnNameChange: (columnName: string, columnIndex: number) => void,\r\n    // handler of column type change\r\n    onColumnTypeChange: (columnType: SupportedColumnType, columnIndex: number) => void,\r\n    // handler of row input change\r\n    onRowInputChange: (input: string, columnIndex: number, rowIndex: number) => void,\r\n    // handler of adding new row\r\n    onNewRow: (onDone: () => void) => void,\r\n    // handler of adding new column\r\n    onNewColumn: (onDone: () => void) => void,\r\n    // handler of deleting the row of given index\r\n    onDeleteRow: (rowIndex: number) => void,\r\n    // handler of deleting the column of given index\r\n    onDeleteColumn: (columnIndex: number) => void,\r\n\r\n    // handler of input with Ctrl key\r\n    onCtrlInput: (ev: React.KeyboardEvent) => void\r\n}\r\n\r\ninterface EditRelationTableState {\r\n    selectedColumn: number | undefined,\r\n    selectedRow: \"names\" | \"types\" | number | undefined\r\n}\r\n\r\n// @ts-ignore\r\nconst cssConstants: CSSStyleDeclaration = getComputedStyle(document.querySelector(':root'));\r\nconst cellPaddingSides: number = Number(cssConstants.getPropertyValue('--cell-padding-sides-num'));\r\nconst inputMarginSides: number = Number(cssConstants.getPropertyValue('--input-margin-sides-num'));\r\n\r\n/**\r\n * Table for editing a relation relation. It supports adding new columns and rows and editing all relation (column names,\r\n * column types and row inputs).\r\n */\r\nexport default class EditRelationTable extends React.Component<EditRelationTableProps, EditRelationTableState> {\r\n\r\n    private readonly containerRef: React.RefObject<HTMLDivElement>;\r\n    // reference to the head row with columns names\r\n    private readonly tableHeadRowRef: React.RefObject<HTMLTableRowElement>;\r\n    // width of cells in head (with deducted padding) to set proper inputs width to not resize the table\r\n    private columnWidths: number[] = [];\r\n\r\n    constructor(props: EditRelationTableProps) {\r\n        super(props);\r\n        this.state = {\r\n            selectedColumn: undefined,\r\n            selectedRow: undefined\r\n        }\r\n        this.containerRef = React.createRef<HTMLDivElement>();\r\n        this.tableHeadRowRef = React.createRef<HTMLTableRowElement>();\r\n    }\r\n\r\n    componentDidMount() {\r\n        // clicking in the window blurs the selected input (if clicked into a cell, event propagation is stopped to not blur\r\n        window.addEventListener('click', () => {\r\n            this.setSelectedInput(undefined, undefined);\r\n        });\r\n    }\r\n\r\n    componentDidUpdate() {\r\n        const headRow = this.tableHeadRowRef.current;\r\n        if (headRow !== null) {\r\n            // cells without the first (line number) and last (add column button)\r\n            const cells = [...headRow.cells].slice(1, -1);\r\n            this.columnWidths = cells.map(cell => cell.clientWidth - 2 * (cellPaddingSides + inputMarginSides));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Changes column width if the resized input element does not fit in it anymore.\r\n     */\r\n    private handleInputResize = (inputElement: EventTarget & HTMLInputElement, column: number) => {\r\n        // handles larger width\r\n        if (inputElement.scrollWidth > this.columnWidths[column]) {\r\n            this.columnWidths[column] = inputElement.scrollWidth;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns error of the relation to edit.\r\n     */\r\n    private getErrors = (): RCToStringMap => {\r\n        return this.props.relation.getErrors();\r\n    }\r\n\r\n    /**\r\n     * Sets selected input column and row to given values.\r\n     */\r\n    private setSelectedInput = (column: number | undefined, row: \"names\" | \"types\" | number | undefined): void => {\r\n        this.setState({\r\n            selectedColumn: column,\r\n            selectedRow: row\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Moves selected input to right if it is defined and not in the last column.\r\n     */\r\n    private moveSelectedInputRight = (): void => {\r\n        const selectedColumn = this.state.selectedColumn;\r\n        const selectedRow = this.state.selectedRow;\r\n        if (selectedColumn !== undefined && selectedRow !== undefined) {\r\n            // if not last column was selected\r\n            if (selectedColumn < this.props.relation.getColumnCount() - 1) {\r\n                this.setState({selectedColumn: selectedColumn + 1});\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves selected input to left if it is defined and not in the first column.\r\n     */\r\n    private moveSelectedInputLeft = (): void => {\r\n        const selectedColumn = this.state.selectedColumn;\r\n        const selectedRow = this.state.selectedRow;\r\n        if (selectedColumn !== undefined && selectedRow !== undefined) {\r\n            // if not first column was selected\r\n            if (selectedColumn > 0) {\r\n                this.setState({selectedColumn: selectedColumn - 1});\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves selected input up if it is defined and not in the first row.\r\n     */\r\n    private moveSelectedInputUp = (): void => {\r\n        const selectedColumn = this.state.selectedColumn;\r\n        const selectedRow = this.state.selectedRow;\r\n        if (selectedColumn !== undefined && selectedRow !== undefined) {\r\n            // if not first row was selected\r\n            if (typeof selectedRow === \"number\") {\r\n                if (selectedRow === 0) {\r\n                    this.setState({selectedRow: \"names\"});\r\n                }\r\n                else {\r\n                    this.setState({selectedRow: selectedRow - 1});\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves selected input down if it is defined and not in the last row.\r\n     */\r\n    private moveSelectedInputDown = (): void => {\r\n        const selectedColumn = this.state.selectedColumn;\r\n        const selectedRow = this.state.selectedRow;\r\n        if (selectedColumn !== undefined && selectedRow !== undefined) {\r\n            if (selectedRow === \"names\" && this.props.relation.getRowCount() > 0) {\r\n                this.setState({selectedRow: 0});\r\n            }\r\n            // if not last row was selected\r\n            if (typeof selectedRow === \"number\" && selectedRow < this.props.relation.getRowCount() - 1) {\r\n                this.setState({selectedRow: selectedRow + 1});\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Catches key inputs with special effects in tht table.\r\n     */\r\n    private handleKeyDown = (event: React.KeyboardEvent): void => {\r\n        if (event.key === \"Enter\" || event.key === \"Esc\" || event.key === \"Escape\") {\r\n            this.setSelectedInput(undefined, undefined);\r\n        }\r\n        else if (event.key === \"Tab\" || (event.ctrlKey && event.key === \"ArrowRight\")) {\r\n            this.moveSelectedInputRight();\r\n            event.preventDefault();\r\n        }\r\n        else if (event.ctrlKey && event.key === \"ArrowLeft\") {\r\n            this.moveSelectedInputLeft();\r\n            event.preventDefault();\r\n        }\r\n        else if (event.ctrlKey && event.key === \"ArrowUp\") {\r\n            this.moveSelectedInputUp();\r\n            event.preventDefault();\r\n        }\r\n        else if (event.ctrlKey && event.key === \"ArrowDown\") {\r\n            this.moveSelectedInputDown();\r\n            event.preventDefault();\r\n        }\r\n        if (event.ctrlKey) {\r\n            this.props.onCtrlInput(event);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Passes the change of the column name, column type or row input to the parent element.\r\n     * When row = \"types\", it is expected that value is of SupportedColumnType type.\r\n     * Tabulators are replaced by 4 spaces.\r\n     */\r\n    private handleChange = (value: string, column: number, row: \"names\" | \"types\" | number): void => {\r\n        value = value.replace(/\\t/g, \"    \");\r\n        if (row === \"names\") {\r\n            this.props.onColumnNameChange(value, column);\r\n        }\r\n        else if (row === \"types\") {\r\n            // @ts-ignore - should be ensured before method call\r\n            this.props.onColumnTypeChange(value, column);\r\n        }\r\n        else {\r\n            this.props.onRowInputChange(value, column, row);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a new column to the relation and scrolls to it.\r\n     */\r\n    private handleNewColumn = (): void => {\r\n        this.props.onNewColumn(() => {\r\n            // @ts-ignore\r\n            this.containerRef.current.scrollTo(this.containerRef.current.clientWidth, this.containerRef.current.scrollTop)\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds a new row to the relation and scrolls to it.\r\n     */\r\n    private handleNewRow = (): void => {\r\n        this.props.onNewRow(() => {\r\n            // @ts-ignore\r\n            this.containerRef.current.scrollTo(this.containerRef.current.scrollLeft, this.containerRef.current.clientHeight)\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deletes the column at given index.\r\n     */\r\n    private handleDeleteColumn = (column: number): void => {\r\n        this.props.onDeleteColumn(column);\r\n    }\r\n\r\n    /**\r\n     * Deletes the row at given index.\r\n     */\r\n    private handleDeleteRow = (row: number): void => {\r\n        this.props.onDeleteRow(row);\r\n    }\r\n\r\n    /**\r\n     * Creates a text input bind to handling change of given column and row.\r\n     */\r\n    private createInput = (value: string, column: number, row: \"names\" | \"types\" | number) => {\r\n        return (\r\n            <input\r\n                type='text'\r\n                className={'text-input'}\r\n                spellCheck={false}\r\n                value={value}\r\n                onChange={(e) => {\r\n                    this.handleChange(e.target.value, column, row);\r\n                    this.handleInputResize(e.target, column);\r\n                }}\r\n                autoFocus={true}\r\n                style={{width: this.columnWidths[column] + \"px\"}}\r\n            />\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Creates a tooltip with given text.\r\n     */\r\n    private createTooltip(text: string, style?: React.CSSProperties) {\r\n        return (<span className={\"tooltip\"} style={style}>{text}</span>)\r\n    }\r\n\r\n    /**\r\n     * Creates a button for deleting rows or columns.\r\n     */\r\n    private createDeleteButton = (callback: () => void) => {\r\n        return (<button className=\"delete-row-or-column-button\" onClick={callback}>&#10006;</button>);\r\n    }\r\n\r\n    /**\r\n     * Creates content of the first row of the table with column names.\r\n     * If the table is editable, additional blank column is added for \"add column\" button in next rows.\r\n     */\r\n    private createNamesRow() {\r\n        const rowData = this.props.relation.getColumnNames().map((columnName, columnIndex) => {\r\n            let content: string | JSX.Element = columnName;\r\n            if (this.state.selectedColumn === columnIndex && this.state.selectedRow === \"names\") {\r\n                content = this.createInput(columnName, columnIndex, \"names\");\r\n            }\r\n            let span: null | JSX.Element = null;\r\n            let className: string = \"name-th\";\r\n            const error = this.getErrors().get(\"name\", columnIndex);\r\n            if (error !== undefined) {\r\n                span = this.createTooltip(error, {top: \"90%\", bottom: \"auto\"});\r\n                className += \" error-input\";\r\n            }\r\n            return (\r\n                <th key={columnIndex}\r\n                    className={className}\r\n                    onClick={ev => {\r\n                        this.setSelectedInput(columnIndex, \"names\");\r\n                        ev.stopPropagation();\r\n                    }}\r\n                >{content}{span}</th>\r\n            )});\r\n        // pushes \"add column\" button in last column\r\n        rowData.push(\r\n            <td key='add-column'\r\n                rowSpan={2}\r\n                style={{width: \"24px\", border: \"none\", padding: \"1px\"}}>\r\n                <button onClick={this.handleNewColumn}\r\n                    style={{width: \"100%\", height: \"100%\"}}><strong>+</strong></button>\r\n            </td>);\r\n        return (\r\n            <><td className=\"row-number-td\"/>{rowData}</>\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates content of the second row of the table with column types.\r\n     * If the table is editable, \"add column\" button is added in the last column with row span to the end of the table.\r\n     */\r\n    private createTypesRow() {\r\n        const rowData = this.props.relation.getColumnTypes().map((columnType, columnIndex) => {\r\n            const content = (\r\n                <select value={columnType}\r\n                    onChange={(e) => this.handleChange(e.target.value, columnIndex, \"types\")}>\r\n                    <option>number</option>\r\n                    <option>string</option>\r\n                    <option>boolean</option>\r\n                </select>\r\n            );\r\n            return (\r\n                <th key={columnIndex}\r\n                    className=\"type-th\"\r\n                >{content}{this.createDeleteButton(() => this.handleDeleteColumn(columnIndex))}</th>\r\n            )});\r\n        return (\r\n            <><td className=\"row-number-td\"/>{rowData}</>\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a data rows of the table.\r\n     */\r\n    private createRows() {\r\n        // creates default row if no exists\r\n        if (this.props.relation.getRows().length === 0) {\r\n            return null;\r\n        }\r\n        const rows: string[][] = this.props.relation.getRows();\r\n        // creates all rows if any\r\n        return rows.map((row, rowIndex) => (\r\n            <tr key={rowIndex}>\r\n                <td className=\"row-number-td\">\r\n                    {rowIndex + 1}\r\n                    {this.createDeleteButton(() => this.handleDeleteRow(rowIndex))}\r\n                </td>\r\n                {row.map((value, columnIndex) => {\r\n                    let content: string | JSX.Element = value;\r\n                    if (this.state.selectedColumn === columnIndex && this.state.selectedRow === rowIndex) {\r\n                        content = this.createInput(value, columnIndex, rowIndex);\r\n                    }\r\n                    let span: null | JSX.Element = null;\r\n                    let className: string = \"\";\r\n                    const error = this.getErrors().get(rowIndex, columnIndex);\r\n                    if (error !== undefined) {\r\n                        span = this.createTooltip(error);\r\n                        className = \"error-input\";\r\n                    }\r\n                    return (\r\n                        <td key={columnIndex}\r\n                            className={className}\r\n                            onClick={ev => {\r\n                                this.setSelectedInput(columnIndex, rowIndex);\r\n                                ev.stopPropagation();\r\n                            }}\r\n                        >{content}{span}</td>\r\n                    )})}\r\n            </tr>\r\n        ));\r\n    }\r\n\r\n    /**\r\n     * Creates the last row of the table with button for adding rows.\r\n     */\r\n    private createAddRow() {\r\n        return (\r\n            <tr key='add-row'>\r\n                <td key='add-row-column'\r\n                    className=\"add-row-td\">\r\n                    <button onClick={this.handleNewRow}><strong>+</strong></button>\r\n                </td>\r\n            </tr>\r\n        );\r\n    }\r\n\r\n    public render() {\r\n        let divClassName: string = \"edit-table-container cursor-container\";\r\n        let tableClassName: string = \"edit-table\";\r\n\r\n        return (\r\n            <div\r\n                className={divClassName}\r\n                ref={this.containerRef}\r\n                onKeyDown={this.handleKeyDown}>\r\n                <table className={tableClassName}>\r\n                    <thead>\r\n                        <tr ref={this.tableHeadRowRef}>{this.createNamesRow()}</tr>\r\n                        <tr>{this.createTypesRow()}</tr>\r\n                    </thead>\r\n                    <tbody>\r\n                        {this.createRows()}\r\n                        {this.createAddRow()}\r\n                    </tbody>\r\n                </table>\r\n            </div>\r\n        );\r\n    }\r\n}","import React from \"react\";\r\nimport Relation from \"../relation/relation\";\r\nimport {TooltipButton} from \"./tooltipButton\";\r\nimport {SupportedColumnType} from \"../relation/columnType\";\r\nimport EditRelationTable from \"./editRelationTable\";\r\nimport {StoredRelation} from \"../relation/storedRelation\";\r\nimport {TextInput} from \"./textInput\";\r\nimport {getForbiddenRelationNames} from \"../tools/keywords\";\r\nimport Parser from \"../tools/parser\";\r\nimport {MessageBox} from \"./messageBox\";\r\n\r\ninterface RelationsSectionProps {\r\n    // all stored relations\r\n    storedRelations: StoredRelation[],\r\n    // index of the current selected relation\r\n    storedRelationIndex: number,\r\n\r\n    // all currently loaded relations in the application\r\n    loadedRelations: Relation[],\r\n\r\n    // handler of change of the name of the current selected relation\r\n    onRelationNameChange: (newName: string) => void,\r\n    // handler of change of the name of the column at given index in the current selected relation\r\n    onColumnNameChange: (columnName: string, columnIndex: number) => void,\r\n    // handler of change of the type of the column at given index in the current selected relation\r\n    onColumnTypeChange: (columnType: SupportedColumnType, columnIndex: number) => void,\r\n    // handler of change of the row input at given column/row index in the current selected relation\r\n    onRowInputChange: (input: string, columnIndex: number, rowIndex: number) => void,\r\n    // handler of adding a new row in the current selected relation\r\n    onNewRow: (onDone: () => void) => void,\r\n    // handler of adding a new column in the current selected relation\r\n    onNewColumn: (onDone: () => void) => void,\r\n    // handler of deleting the row on given index\r\n    onDeleteRow: (rowIndex: number) => void,\r\n    // handler of deleting the column on given index\r\n    onDeleteColumn: (columnIndex: number) => void,\r\n\r\n    // handler of selecting a different relation as current\r\n    onSelectDifferentRelation: (newIndex: number) => void,\r\n    // handler of creating a new relation\r\n    onNewRelation: () => void,\r\n    // handler of loading the current selected relation into the application\r\n    onLoadRelation: (onDone: (msg: string) => void) => void,\r\n    // handler of deleting the current stored relation\r\n    onDeleteStoredRelation: () => void,\r\n\r\n    onRevertRelation: () => void,\r\n\r\n    // handler of loading all valid relations into the application\r\n    onLoadAllRelations: (onDone: (msg: string) => void) => void,\r\n    // handler of deleting the loaded relations\r\n    onDeleteLoadedRelations: (onDone: (msg: string) => void) => void,\r\n    // handler of saving the stored relations into the files\r\n    onExportRelations: (onDone: (msg: string) => void) => void,\r\n    // handler of loading new relations from files\r\n    onImportRelations: (onDone: (msg: string) => void) => void,\r\n\r\n    // whether to support null values\r\n    nullValuesSupport: boolean\r\n}\r\n\r\ninterface RelationsSectionState {\r\n    sectionClicked: boolean\r\n}\r\n\r\n/**\r\n * Section to type the RA expression. It contains textarea for relations definition and control buttons.\r\n */\r\nexport class RelationsSection extends React.Component<RelationsSectionProps, RelationsSectionState> {\r\n\r\n    constructor(props: RelationsSectionProps) {\r\n        super(props);\r\n        this.state = {\r\n            sectionClicked: false\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns selected stored relation.\r\n     */\r\n    private getCurRel = (): StoredRelation => {\r\n        return this.props.storedRelations[this.props.storedRelationIndex];\r\n    }\r\n\r\n    /**\r\n     * Passes change to the parent element if isShowingStored = true. Otherwise, changes the state.loadedRelationIndex.\r\n     */\r\n    private handleSelectDifferentRelation(index: number): void {\r\n        this.props.onSelectDifferentRelation(index);\r\n    }\r\n\r\n    /**\r\n     * Passes change of the relation name to the parent element.\r\n     */\r\n    private handleRelationNameChange = (name: string) => {\r\n        this.props.onRelationNameChange(name);\r\n    }\r\n\r\n    /**\r\n     * Loads the selected relation to the application if there are no errors in it. Otherwise, displays a message to user.\r\n     */\r\n    private loadRelation = () => {\r\n        if (this.getCurRel().isValid()) {\r\n            this.props.onLoadRelation(MessageBox.message);\r\n        }\r\n        else {\r\n            MessageBox.error(\"Cannot use the invalid relation. Check errors and try again.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Passes the load all relations call to the parent.\r\n     */\r\n    private loadAllRelations = () => {\r\n        this.props.onLoadAllRelations(MessageBox.message);\r\n    }\r\n\r\n    /**\r\n     * Passes the export stored relations call to the parent.\r\n     */\r\n    private exportRelations = () => {\r\n        this.props.onExportRelations(MessageBox.message);\r\n    }\r\n\r\n    /**\r\n     * Passes the import stored relations call to the parent.\r\n     */\r\n    private importRelations = () => {\r\n        this.props.onImportRelations(MessageBox.message);\r\n    }\r\n\r\n    /**\r\n     * Passes the call to delete current selected stored relation.\r\n     */\r\n    private deleteRelation = () => {\r\n        this.props.onDeleteStoredRelation();\r\n    }\r\n\r\n    private revertRelation = () => {\r\n        this.props.onRevertRelation();\r\n    }\r\n\r\n    /**\r\n     * Passes the import create new stored relation to the parent.\r\n     */\r\n    private newRelation = () => {\r\n        this.props.onNewRelation();\r\n    }\r\n\r\n    /**\r\n     * Passes the delete all loaded relations call to the parent.\r\n     */\r\n    private deleteAllLoadedRelations = () => {\r\n        this.props.onDeleteLoadedRelations(MessageBox.message);\r\n    }\r\n\r\n    /**\r\n     * Handles input with Ctrl key pressed from relation table.\r\n     */\r\n    private handleCtrlInput = (event: React.KeyboardEvent) => {\r\n        if (event.key === \"Enter\") {\r\n            this.loadRelation();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates menu buttons. Buttons for relations with errors are highlighted.\r\n     */\r\n    private createRelationMenuButtons = () => {\r\n        return this.props.storedRelations.map((rel, i) => {\r\n            const className: string = (this.props.storedRelationIndex === i ? \"button-clicked\" : \"\");\r\n            const actuality: string = rel.isActual() ? \"\" : \"*\";\r\n            const style = rel.isValid() ? {} : {border: \"2px solid #fd3030\"};\r\n            return (\r\n                <button\r\n                    key={i}\r\n                    onClick={() => this.handleSelectDifferentRelation(i)}\r\n                    className={className}\r\n                    style={style}\r\n                >{actuality + rel.getName()}</button>\r\n            );\r\n        });\r\n    }\r\n\r\n    public render() {\r\n        const createButton = (text: string, onClick: () => void, tooltip: string, style?: React.CSSProperties) => {\r\n            return (<TooltipButton\r\n                key={text}\r\n                text={text}\r\n                onClick={onClick}\r\n                className={\"\"}\r\n                style={style}\r\n                tooltip={tooltip}\r\n                tooltipClassName={\"tooltip\"}\r\n            />);\r\n        }\r\n\r\n        // the relation cannot be renamed to forbidden relation names and other currently used relation names\r\n        const forbiddenRelationNames: string[] = this.props.storedRelations\r\n            .filter((sr, i) => i !== this.props.storedRelationIndex)\r\n            .map(sr => sr.getName());\r\n        forbiddenRelationNames.push(...getForbiddenRelationNames());\r\n        const forbiddenNamesFunction = (text: string): boolean => {\r\n            if (forbiddenRelationNames.indexOf(text) > -1) {\r\n                return true;\r\n            }\r\n            return !Parser.isName(text);\r\n        }\r\n\r\n        return (\r\n            <section className=\"page-section\">\r\n                <header>\r\n                    <h2>Relations</h2>\r\n                    {createButton(\"Load all\", this.loadAllRelations, \"Loads all valid relations into the application\")}\r\n                    {createButton(\"Delete loaded\", this.deleteAllLoadedRelations, \"Deletes relations loaded in the application\")}\r\n                    {createButton(\"Import\", this.importRelations, \"Adds new relations from files\")}\r\n                    {createButton(\"Export\", this.exportRelations, \"Saves stored relations to files\")}\r\n                </header>\r\n\r\n                <menu className=\"page-section-tab-menu\">\r\n                    {this.createRelationMenuButtons()}\r\n                    <button onClick={this.newRelation}\r\n                        style={{minWidth: \"0\", marginLeft: \"10px\", padding: \"2px 6px 1px 6px\"}}>\r\n                        <strong>+</strong>\r\n                    </button>\r\n                </menu>\r\n\r\n                <EditRelationTable\r\n                    relation={this.getCurRel()}\r\n\r\n                    onColumnNameChange={this.props.onColumnNameChange}\r\n                    onColumnTypeChange={this.props.onColumnTypeChange}\r\n                    onRowInputChange={this.props.onRowInputChange}\r\n                    onNewRow={this.props.onNewRow}\r\n                    onNewColumn={this.props.onNewColumn}\r\n                    onDeleteRow={this.props.onDeleteRow}\r\n                    onDeleteColumn={this.props.onDeleteColumn}\r\n\r\n                    onCtrlInput={this.handleCtrlInput}\r\n                />\r\n\r\n                <menu className=\"page-section-management-menu\">\r\n                    <TooltipButton\r\n                        key=\"Load\"\r\n                        text=\"Load\"\r\n                        onClick={this.loadRelation}\r\n                        className={\"action-button\"}\r\n                        style={{marginRight: \"40px\"}}\r\n                        tooltip=\"Loads the relation into the application\"\r\n                        tooltipClassName={\"tooltip\"}\r\n                    />\r\n                    <TextInput\r\n                        label=\"\"\r\n                        value={this.getCurRel().getName()}\r\n                        buttonText=\"Rename\"\r\n                        onSubmit={this.handleRelationNameChange}\r\n                        forbidden={forbiddenNamesFunction}\r\n                        id=\"relation-name-input\"\r\n                    />\r\n                    {createButton(\"Delete\", this.deleteRelation,\"Deletes the relation\")}\r\n                    {this.getCurRel().canRevert() && createButton(\"Revert\", this.revertRelation,\r\n                        \"Reverts to last loaded state (\" + this.getCurRel().getRevertName() + \")\")}\r\n                </menu>\r\n            </section>\r\n        );\r\n    }\r\n}","interface SendData {\r\n    access_token: string,\r\n    subject: string,\r\n    text: string\r\n}\r\n\r\n/**\r\n * Class for sending emails. Powered by https://postmail.invotes.com/.\r\n * My TypeScript version of JavaScript Copy & Paste Example from PostMail webpage.\r\n */\r\nexport class PostMail {\r\n\r\n    /**\r\n     * Creates a mailer with given PostMail access token.\r\n     *\r\n     * @param accessToken token which specifies PostMail receiver of mails\r\n     */\r\n    constructor(readonly accessToken: string) {}\r\n\r\n    /**\r\n     * Sends given subject and body of the email to the PostMail receiver.\r\n     *\r\n     * @param subject subject of the mail\r\n     * @param body body of the mail\r\n     */\r\n    public send(subject: string, body: string): void {\r\n        const data_js: SendData = {\r\n            access_token: this.accessToken,\r\n            subject: subject,\r\n            text: body\r\n        };\r\n\r\n        const request = new XMLHttpRequest();\r\n        request.onreadystatechange = function() {\r\n            if (request.readyState === 4 && request.status === 200) {\r\n            } else if(request.readyState === 4) {\r\n                console.log(\"failed creating XMLHttpRequest in PostMail.send: \" + request.response);\r\n            }\r\n        };\r\n\r\n        let params = PostMail.toParams(data_js);\r\n        request.open(\"POST\", \"https://postmail.invotes.com/send\", true);\r\n        request.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\r\n        request.send(params);\r\n    }\r\n\r\n    private static toParams(data: SendData): string {\r\n        return encodeURIComponent(\"access_token\") + \"=\" + encodeURIComponent(data.access_token) + \"&\" +\r\n            encodeURIComponent(\"subject\") + \"=\" + encodeURIComponent(data.subject) + \"&\" +\r\n                encodeURIComponent(\"text\") + \"=\" + encodeURIComponent(data.text);\r\n    }\r\n}","import React, {Component} from 'react';\r\nimport Relation from '../relation/relation';\r\nimport RATreeNode from \"../ratree/raTreeNode\";\r\nimport {ExpressionSection} from \"./expressionSection\";\r\nimport {ResultSection} from \"./resultSection\";\r\nimport {ExpressionStoreManager} from \"../expression/expressionStoreManager\";\r\nimport {ManagementSection} from \"./managementSection\";\r\nimport {CsvValueSeparatorChar} from \"../tools/csvSupport\";\r\nimport {ProjectStoreManager} from \"../project/projectStoreManager\";\r\nimport {SupportedLanguage} from \"../tools/supportedLanguage\";\r\nimport {LocalStorage} from \"../tools/localStorage\";\r\nimport {BatchProcessor} from \"../tools/batchProcessor\";\r\nimport {Expression} from \"../expression/expression\";\r\nimport {RelationsSection} from \"./relationsSection\";\r\nimport {StoredRelation} from \"../relation/storedRelation\";\r\nimport {SupportedColumnType} from \"../relation/columnType\";\r\nimport {RelationStoreManager} from \"../relation/relationStoreManager\";\r\nimport {PostMail} from \"../tools/postMail\";\r\nimport {copyProject, Project} from \"../project/project\";\r\nimport {getSamples} from \"../project/samples\";\r\n\r\ninterface MainScreenProps {}\r\n\r\ninterface MainScreenState {\r\n    samples: { name: string, project: Project }[],\r\n\r\n    loadedRelations: Map<string, Relation>,\r\n    storedRelations: StoredRelation[],\r\n    selectedRelation: number,\r\n\r\n    expressions: Expression[],\r\n    selectedExpression: number,\r\n\r\n    evaluationTreeRoot: RATreeNode | null,\r\n    evaluatedExpressionName: string,\r\n\r\n    nullValuesSupport: boolean,\r\n    csvValueSeparator: CsvValueSeparatorChar,\r\n    language: SupportedLanguage,\r\n    darkTheme: boolean\r\n}\r\n\r\n/**\r\n * Main component of Rachel web page. It wraps all page sections and passes messages between them.\r\n */\r\nexport default class MainScreen extends Component<MainScreenProps, MainScreenState> {\r\n\r\n    private readonly expressionSectionRef: React.RefObject<ExpressionSection>;\r\n\r\n    constructor(props: MainScreenProps) {\r\n        super(props);\r\n\r\n        // sets body template by settings from local storage\r\n        document.body.classList.toggle('body-dark', LocalStorage.getDarkMode());\r\n        document.body.classList.toggle('body-light', !LocalStorage.getDarkMode());\r\n\r\n        const initRelationData = {\r\n            name: \"Relation\",\r\n            columnNames: [\"Column1\", \"Column2\", \"Column3\"],\r\n            columnTypes: [\"number\", \"string\", \"boolean\"],\r\n            rows: [\r\n                ['', '', '']\r\n            ],\r\n            columnCount: 3,\r\n            rowCount: 1\r\n        };\r\n\r\n        this.state = {\r\n            samples: getSamples(),\r\n\r\n            loadedRelations: new Map<string, Relation>(),\r\n            storedRelations: [ StoredRelation.fromData(initRelationData, true) ],\r\n            selectedRelation: 0,\r\n\r\n            expressions: [ {name: \"Expression 1\", text: \"\"} ],\r\n            selectedExpression: 0,\r\n\r\n            evaluationTreeRoot: null,\r\n            evaluatedExpressionName: \"\",\r\n\r\n            nullValuesSupport: true,\r\n            csvValueSeparator: LocalStorage.getCsvValueSeparator(),\r\n            language: LocalStorage.getLanguage(),\r\n            darkTheme: LocalStorage.getDarkMode()\r\n        }\r\n        this.expressionSectionRef = React.createRef();\r\n    }\r\n\r\n    /**\r\n     * Reports an error to the author of the application via email.\r\n     *\r\n     * @param err unexpected error\r\n     */\r\n    private reportUnexpectedError = (err: Error): void => {\r\n        const postMail: PostMail = new PostMail(\"5uog26ex8q9qu7sqib8ea0qd\");\r\n        let body: string = \"Unexpected error \" + err.name + \" in Rachel application.\" +\r\n            \"\\n\\nMessage:\\n\" + err.message +\r\n            \"\\n\\nDate:\\n\" + new Date().toString() +\r\n            \"\\n\\nStack trace:\\n\" + err.stack +\r\n\r\n            \"\\n\\nLoaded relations: ----------------------------\\n\" +\r\n            [...this.state.loadedRelations.values()].map(relation => {\r\n                return relation.getName() + \"\\n\" + relation.contentString();\r\n            }).join(\"\\n\\n\") +\r\n\r\n            \"\\n\\nStored relations: ----------------------------\" +\r\n            \"\\nSelected relation (1-index): \" + (this.state.selectedRelation + 1) + \"\\n\\n\" +\r\n            this.state.storedRelations.map(relation => {\r\n                return relation.getName() + \"\\n\" +\r\n                    relation.getColumnNames().join(\", \") + \"\\n\" +\r\n                    relation.getColumnTypes().join(\", \") + \"\\n\" +\r\n                    relation.getRows().map(row => row.join(\", \")).join(\"\\n\");\r\n            }).join(\"\\n\\n\") +\r\n\r\n            \"\\n\\nExpressions: ----------------------------\" +\r\n            \"\\nSelected expression (1-index): \" + (this.state.selectedExpression + 1) + \"\\n\\n\" +\r\n            this.state.expressions.map(expr => expr.text).join(\"\\n\\n###\\n\\n\") +\r\n\r\n            \"\\n\\nEvaluation tree:\\n\" + this.state.evaluationTreeRoot?.printInLine() +\r\n\r\n            \"\\n\\nOther state: ----------------------------\" +\r\n            \"\\ncsvValueSeparator: \" + this.state.csvValueSeparator +\r\n            \"\\nlanguage:          \" + this.state.language +\r\n            \"\\nnullValuesSupport: \" + this.state.nullValuesSupport +\r\n            \"\\ndarkTheme:         \" + this.state.darkTheme;\r\n\r\n        postMail.send(\"Rachel application unexpected error\", body);\r\n        console.error('Unexpected error: ' + err.stack);\r\n    }\r\n\r\n    /**\r\n     * Overwrites the current project data with the given one.\r\n     *\r\n     * @param project\r\n     */\r\n    private loadProject = (project: Project): void => {\r\n        this.setState({\r\n            loadedRelations: new Map<string, Relation>(),\r\n            storedRelations: project.relations.map(r => StoredRelation.fromData(r, project.nullValuesSupport)),\r\n            selectedRelation: 0,\r\n            expressions: project.expressions,\r\n            nullValuesSupport: project.nullValuesSupport,\r\n            selectedExpression: 0,\r\n            evaluationTreeRoot: null,\r\n            evaluatedExpressionName: \"\"\r\n        }, () => {\r\n            console.log(\"Project loaded.\");\r\n            this.updateExpressionsErrors();\r\n        });\r\n    }\r\n\r\n    // TODO - extract hledani volneho jmena\r\n\r\n    /****************************************** MANAGEMENT SECTION HANDLERS ******************************************/\r\n\r\n    /**\r\n     * Processes multiple selected files with expressions by the user and saves the reports of the evaluation in textual\r\n     * files.\r\n     */\r\n    private handleBatch = () => {\r\n        const processor: BatchProcessor = new BatchProcessor();\r\n        processor.process('rachel-eval-results').then(console.log).catch(console.warn);\r\n    }\r\n\r\n    /**\r\n     * Opens a file dialog and lets the user choose a .rachel (JSON) file with project to load.\r\n     */\r\n    private handleLoadProject = (): void => {\r\n        ProjectStoreManager.load().then(this.loadProject).catch(console.warn);\r\n    }\r\n\r\n    /**\r\n     * Saves the project relation to the .rachel (JSON) file.\r\n     */\r\n    private handleSaveProject = (): void => {\r\n        try {\r\n            ProjectStoreManager.save({\r\n                relations: this.state.storedRelations.map(sr => sr.toDataObject()),\r\n                expressions: this.state.expressions,\r\n                nullValuesSupport: this.state.nullValuesSupport\r\n                }, \"rachel_project\");\r\n            console.log(\"Project saved.\");\r\n        }\r\n        catch (err) {\r\n            console.warn(\"Project saving failed: \" + err.message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles loading a sample project.\r\n     */\r\n    private handleLoadSampleProject = (sample: Project): void => {\r\n        this.loadProject(copyProject(sample));\r\n    }\r\n\r\n    /**\r\n     * Changes the support of the null values in relations.\r\n     *\r\n     * @param nullValuesSupport new support of the null values in relations\r\n     */\r\n    private handleNullValuesSupportChange = (nullValuesSupport: boolean): void => {\r\n        this.state.storedRelations.forEach(sr => sr.setNullValuesSupport(nullValuesSupport));\r\n        // null values change can change validity of the relations, therefore set as not actual\r\n        this.setState({nullValuesSupport: nullValuesSupport}, this.updateExpressionsErrors);\r\n    }\r\n\r\n    /**\r\n     * Changes the value separator used in generated CSV files.\r\n     *\r\n     * @param csvValueSeparator new value separator used in generated CSV files\r\n     */\r\n    private handleCsvValueSeparatorChange = (csvValueSeparator: CsvValueSeparatorChar): void => {\r\n        LocalStorage.setCsvValueSeparator(csvValueSeparator);\r\n        this.setState({csvValueSeparator: csvValueSeparator});\r\n    }\r\n\r\n    /**\r\n     * Changes the language of the application.\r\n     *\r\n     * @param language new language of the application\r\n     */\r\n    private handleLanguageChange = (language: SupportedLanguage): void => {\r\n        LocalStorage.setLanguage(language);\r\n        this.setState({language: language});\r\n    }\r\n\r\n    /**\r\n     * Changes the dark/light mode of the application.\r\n     *\r\n     * @param darkTheme true if dark theme is on\r\n     */\r\n    private handleDarkModeChange = (darkTheme: boolean) => {\r\n        LocalStorage.setDarkMode(darkTheme);\r\n        this.setState({darkTheme: darkTheme});\r\n        document.body.classList.toggle( 'body-dark', darkTheme);\r\n        document.body.classList.toggle( 'body-light', !darkTheme);\r\n    }\r\n\r\n    /******************************************* RELATION SECTION HANDLERS *******************************************/\r\n\r\n    private handleRelationNameChange = (name: string): void => {\r\n        this.setState(state => {\r\n            const storedRelations = state.storedRelations;\r\n            storedRelations[this.state.selectedRelation].setName(name);\r\n            return {storedRelations: storedRelations};\r\n        });\r\n    }\r\n\r\n    private handleRelationColumnNameChange = (columnName: string, columnIndex: number): void => {\r\n        this.setState(state => {\r\n            const storedRelations = state.storedRelations;\r\n            storedRelations[this.state.selectedRelation].setColumnName(columnName, columnIndex);\r\n            return {storedRelations: storedRelations};\r\n        });\r\n    }\r\n\r\n    private handleRelationColumnTypeChange = (columnType: SupportedColumnType, columnIndex: number): void => {\r\n        this.setState(state => {\r\n            const storedRelations = state.storedRelations;\r\n            storedRelations[this.state.selectedRelation].setColumnType(columnType, columnIndex);\r\n            return {storedRelations: storedRelations};\r\n        });\r\n    }\r\n\r\n    private handleRelationRowInputChange = (input: string, columnIndex: number, rowIndex: number): void => {\r\n        this.setState(state => {\r\n            const storedRelations = state.storedRelations;\r\n            storedRelations[this.state.selectedRelation].setRowInput(input, rowIndex, columnIndex);\r\n            return {storedRelations: storedRelations};\r\n        });\r\n    }\r\n\r\n    private handleRelationNewRow = (onDone: () => void): void => {\r\n        this.state.storedRelations[this.state.selectedRelation].addNewRow();\r\n        // forces update\r\n        this.setState({}, onDone);\r\n    }\r\n\r\n    private handleRelationNewColumn = (onDone: () => void): void => {\r\n        this.state.storedRelations[this.state.selectedRelation].addNewColumn();\r\n        // forces update\r\n        this.setState({}, onDone);\r\n    }\r\n\r\n    private handleRelationDeleteRow = (rowIndex: number): void => {\r\n        this.state.storedRelations[this.state.selectedRelation].deleteRow(rowIndex);\r\n        // forces update\r\n        this.setState({});\r\n    }\r\n\r\n    private handleRelationDeleteColumn = (columnIndex: number): void => {\r\n        this.state.storedRelations[this.state.selectedRelation].deleteColumn(columnIndex);\r\n        // forces update\r\n        this.setState({});\r\n    }\r\n\r\n    /**\r\n     * Selects a new relation from the relations list as the current one.\r\n     */\r\n    private handleSelectDifferentRelation = (newIndex: number): void => {\r\n        this.setState({selectedRelation: newIndex});\r\n    }\r\n\r\n    /**\r\n     * Creates a new empty relation and adds it in the relation list.\r\n     */\r\n    private handleCreateNewRelation = (): void => {\r\n        // inserts a new empty relation in the array\r\n        const newIndex: number = this.state.selectedRelation + 1;\r\n        let name: string = \"NewRelation\";\r\n        for (let i = 1; true; ++i) {\r\n            if (this.state.storedRelations.map(sr => sr.getName()).indexOf(name + i) === -1) {\r\n                name += i;\r\n                break;\r\n            }\r\n        }\r\n        this.state.storedRelations.splice(newIndex, 0,\r\n            StoredRelation.new(name, this.state.nullValuesSupport));\r\n        this.setState({selectedRelation: newIndex});\r\n    }\r\n\r\n    /**\r\n     * Deletes the current relation from the relations list (or clears it if it is the last relation in the list).\r\n     */\r\n    private handleDeleteRelation = (): void => {\r\n        // if there is the last relation, only clears it\r\n        if (this.state.storedRelations.length === 1) {\r\n            this.setState({storedRelations: [StoredRelation.new(\"Relation\", this.state.nullValuesSupport)]});\r\n            return;\r\n        }\r\n        const selected: number = this.state.selectedRelation;\r\n        this.state.storedRelations.splice(selected, 1);\r\n        if (selected === this.state.storedRelations.length) {\r\n            this.setState({selectedRelation: selected - 1}, this.updateExpressionsErrors);\r\n        }\r\n        else {\r\n            // forces update\r\n            this.setState({}, this.updateExpressionsErrors);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reverts the current selected stored relation to its last loaded state.\r\n     */\r\n    private handleRevertRelation = (): void => {\r\n        this.setState(state => {\r\n            const storedRelations = state.storedRelations;\r\n            storedRelations[this.state.selectedRelation].revert();\r\n            return {storedRelations};\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deletes all relations loaded in the application.\r\n     */\r\n    private handleDeleteLoadedRelations = (onDone: (msg: string) => void): void => {\r\n        this.state.loadedRelations.clear();\r\n        this.state.storedRelations.forEach(sr => sr.setActual(false));\r\n        onDone(\"All loaded relations deleted.\");\r\n        // forces update\r\n        this.setState({}, this.updateExpressionsErrors);\r\n    }\r\n\r\n    /**\r\n     * Saves the relations list in a textual file.\r\n     *\r\n     * @param onDone\r\n     */\r\n    private handleExportRelations = (onDone: (msg: string) => void): void => {\r\n        try {\r\n            RelationStoreManager.save(this.state.storedRelations, \"rachel_relations\", this.state.csvValueSeparator);\r\n            onDone(this.state.storedRelations.length + \" relations saved.\");\r\n        }\r\n        catch (err) {\r\n            onDone(\"Saving error: \" + err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads the relations list from the textual file selected by the user.\r\n     *\r\n     * @param onDone\r\n     */\r\n    private handleImportRelations = (onDone: (msg: string) => void): void => {\r\n        RelationStoreManager.load(this.state.nullValuesSupport).then(info => {\r\n            const countBefore: number = this.state.storedRelations.length;\r\n            // loads relations to application\r\n            info.relations.forEach(relation => {\r\n                let name = relation.getName();\r\n                // renames existing names\r\n                if (this.state.storedRelations.map(sr => sr.getName()).indexOf(name) > -1) {\r\n                    for (let i = 2; true; ++i) {\r\n                        if (this.state.storedRelations.map(sr => sr.getName()).indexOf(name + i) === -1) {\r\n                            relation.setName(name + i);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                this.state.storedRelations.push(relation);\r\n            });\r\n            if (info.relations.length > 0) {\r\n                // shows first loaded relation\r\n                this.setState({selectedRelation: countBefore});\r\n            }\r\n            onDone(info.relations.length + \" relations loaded, \" + info.skipped + \" files skipped.\")\r\n        });\r\n    }\r\n\r\n    private handleLoadRelation = (onDone: (msg: string) => void): void => {\r\n        const currRelation: StoredRelation = this.state.storedRelations[this.state.selectedRelation];\r\n        currRelation.setActual(true);\r\n        this.state.loadedRelations.set(currRelation.getName(), currRelation.createRelation());\r\n        const msgPart2: string = this.state.loadedRelations.size === 0 ?\r\n            \"No relations loaded in the application at the moment.\" :\r\n            \"All current loaded relations (\" + this.state.loadedRelations.size + \"): \" +\r\n            [...this.state.loadedRelations.keys()].join(', ') + \".\";\r\n        onDone(\"Relation loaded to application.\\n\" + msgPart2);\r\n        // forces update\r\n        this.setState({}, this.updateExpressionsErrors);\r\n    }\r\n\r\n    private handleLoadAllRelations = (onDone: (msg: string) => void): void => {\r\n        let loaded: number = 0;\r\n        let skipped: number = 0;\r\n        this.state.storedRelations.forEach(sr => {\r\n            if (sr.isValid()) {\r\n                sr.setActual(true);\r\n                this.state.loadedRelations.set(sr.getName(), sr.createRelation());\r\n                ++loaded;\r\n            }\r\n            else {\r\n                ++skipped;\r\n            }\r\n        });\r\n        const msgPart2: string = this.state.loadedRelations.size === 0 ?\r\n            \"No relations loaded in the application at the moment.\" :\r\n            \"All current loaded relations (\" + this.state.loadedRelations.size + \"): \" +\r\n            [...this.state.loadedRelations.keys()].join(', ') + \".\";\r\n        onDone(loaded + \" relations loaded to application, \" + skipped + \" skipped for errors.\\n\" + msgPart2);\r\n        // forces update\r\n        this.setState({}, this.updateExpressionsErrors);\r\n    }\r\n\r\n    /****************************************** EXPRESSION SECTION HANDLERS ******************************************/\r\n\r\n    private updateExpressionsErrors = (): void => {\r\n        const expressionSection = this.expressionSectionRef.current;\r\n        if (expressionSection !== null) {\r\n            expressionSection.updateErrors();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Saves evaluation tree for the evaluated RA expression.\r\n     */\r\n    private handleExprEval = (tree: RATreeNode): void => {\r\n        this.setState({\r\n            evaluationTreeRoot: tree,\r\n            evaluatedExpressionName: this.state.expressions[this.state.selectedExpression].name\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates the text of the current expression and sets it as not actual.\r\n     */\r\n    private handleExprTextChange = (name: string, text: string): void => {\r\n        this.setState(state => {\r\n            let expressions: Expression[] = state.expressions;\r\n            expressions[state.selectedExpression] = {name: name, text: text};\r\n            return { expressions: expressions }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Selects a new expression from the expression list as the current one.\r\n     */\r\n    private handleSelectDifferentExpression = (newIndex: number): void => {\r\n        this.setState({ selectedExpression: newIndex }, this.updateExpressionsErrors);\r\n    }\r\n\r\n    /**\r\n     * Creates a new empty expression and adds it in the expression list.\r\n     */\r\n    private handleCreateNewExpression = (): void => {\r\n        // inserts a new empty expression in the array\r\n        const newIndex: number = this.state.selectedExpression + 1;\r\n        this.state.expressions.splice(newIndex, 0, {name: \"New expression\", text: \"\"});\r\n        this.setState({selectedExpression: newIndex});\r\n    }\r\n\r\n    /**\r\n     * Deletes the current expression from the expression list (or clears it if it is the last expression in the list).\r\n     */\r\n    private handleDeleteExpression = (onDone: () => void): void => {\r\n        // if there is the last expression, only clears it\r\n        if (this.state.expressions.length === 1) {\r\n            return this.handleExprTextChange(\"Expression 1\", \"\");\r\n        }\r\n        const selected: number = this.state.selectedExpression;\r\n        this.state.expressions.splice(selected, 1);\r\n        if (selected === this.state.expressions.length) {\r\n            this.setState({selectedExpression: selected - 1}, onDone);\r\n        }\r\n        else {\r\n            // forces update\r\n            this.setState({}, onDone);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Saves the expression list in a textual file.\r\n     *\r\n     * @param onDone\r\n     */\r\n    private handleExportExpressions = (onDone: (msg: string) => void): void => {\r\n        try {\r\n            ExpressionStoreManager.save(this.state.expressions, 'rachel_expressions');\r\n            onDone(\"Expressions saved in a textual file.\");\r\n        }\r\n        catch (err) {\r\n            onDone(\"Expressions saving failed: \" + err.message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads the expression list from the textual file selected by the user.\r\n     *\r\n     * @param onDone\r\n     */\r\n    private handleImportExpressions = (onDone: (msg: string) => void): void => {\r\n        ExpressionStoreManager.load().then(info => {\r\n            this.state.expressions.push(...info.expressions);\r\n            this.setState({});\r\n            onDone(info.expressions.length + \" expressions loaded from \" + info.loadedFiles + \" files (\" +\r\n                + info.skippedExpressions + \" expressions skipped, \" + info.skippedFiles + \" files skipped).\");\r\n        });\r\n    }\r\n\r\n    /******************************************** RESULT SECTION HANDLERS ********************************************/\r\n\r\n    /**\r\n     * Adds the given relation to defined relations.\r\n     *\r\n     * @return message and its color (red for errors, black for information)\r\n     */\r\n    private addResultRelation = (relation: Relation): void => {\r\n        let name = \"Evaluated\";\r\n        const storedRelation = StoredRelation.fromRelation(name, relation, this.state.nullValuesSupport);\r\n        // renames existing names\r\n        if (this.state.storedRelations.map(sr => sr.getName()).indexOf(name) > -1) {\r\n            for (let i = 2; true; ++i) {\r\n                if (this.state.storedRelations.map(sr => sr.getName()).indexOf(name + i) === -1) {\r\n                    storedRelation.setName(name + i);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        this.state.storedRelations.push(storedRelation);\r\n        this.setState({selectedRelation: this.state.storedRelations.length - 1});\r\n    }\r\n\r\n    /***************************************************** RENDER *****************************************************/\r\n\r\n    public render() {\r\n        let resultSection = null;\r\n        if (this.state.evaluationTreeRoot !== null) {\r\n            resultSection = (\r\n                <ResultSection\r\n                    evaluationTreeRoot={this.state.evaluationTreeRoot}\r\n                    expressionName={this.state.evaluatedExpressionName}\r\n\r\n                    onAddResult={this.addResultRelation}\r\n                    onUnexpectedError={this.reportUnexpectedError}\r\n\r\n                    csvValueSeparator={this.state.csvValueSeparator}\r\n                    darkTheme={this.state.darkTheme}\r\n                />\r\n            );\r\n        }\r\n\r\n        return (\r\n            <main>\r\n                <ManagementSection\r\n                    onBatch={this.handleBatch}\r\n                    onLoadProject={this.handleLoadProject}\r\n                    onSaveProject={this.handleSaveProject}\r\n                    onLoadSample={this.handleLoadSampleProject}\r\n\r\n                    csvValueSeparator={this.state.csvValueSeparator}\r\n                    language={this.state.language}\r\n                    nullValuesSupport={this.state.nullValuesSupport}\r\n                    darkTheme={this.state.darkTheme}\r\n\r\n                    onCsvValueSeparatorChange={this.handleCsvValueSeparatorChange}\r\n                    onLanguageChange={this.handleLanguageChange}\r\n                    onNullValuesSupportChange={this.handleNullValuesSupportChange}\r\n                    onDarkModeChange={this.handleDarkModeChange}\r\n                />\r\n\r\n                <RelationsSection\r\n                    storedRelations={this.state.storedRelations}\r\n                    storedRelationIndex={this.state.selectedRelation}\r\n\r\n                    loadedRelations={[...this.state.loadedRelations.values()]}\r\n\r\n                    onRelationNameChange={this.handleRelationNameChange}\r\n                    onColumnNameChange={this.handleRelationColumnNameChange}\r\n                    onColumnTypeChange={this.handleRelationColumnTypeChange}\r\n                    onRowInputChange={this.handleRelationRowInputChange}\r\n                    onNewRow={this.handleRelationNewRow}\r\n                    onNewColumn={this.handleRelationNewColumn}\r\n                    onDeleteRow={this.handleRelationDeleteRow}\r\n                    onDeleteColumn={this.handleRelationDeleteColumn}\r\n\r\n                    onSelectDifferentRelation={this.handleSelectDifferentRelation}\r\n                    onNewRelation={this.handleCreateNewRelation}\r\n                    onLoadRelation={this.handleLoadRelation}\r\n                    onDeleteStoredRelation={this.handleDeleteRelation}\r\n                    onRevertRelation={this.handleRevertRelation}\r\n\r\n                    onLoadAllRelations={this.handleLoadAllRelations}\r\n                    onDeleteLoadedRelations={this.handleDeleteLoadedRelations}\r\n                    onExportRelations={this.handleExportRelations}\r\n                    onImportRelations={this.handleImportRelations}\r\n\r\n                    nullValuesSupport={this.state.nullValuesSupport}\r\n                />\r\n\r\n                <ExpressionSection\r\n                    ref={this.expressionSectionRef}\r\n\r\n                    expressions={this.state.expressions}\r\n                    currentExpressionIndex={this.state.selectedExpression}\r\n                    relations={this.state.loadedRelations}\r\n\r\n                    onChange={this.handleExprTextChange}\r\n                    onEval={this.handleExprEval}\r\n\r\n                    onSelectDifferentExpression={this.handleSelectDifferentExpression}\r\n                    onNewExpression={this.handleCreateNewExpression}\r\n                    onDeleteExpression={this.handleDeleteExpression}\r\n                    onExportExpressions={this.handleExportExpressions}\r\n                    onImportExpressions={this.handleImportExpressions}\r\n\r\n                    onUnexpectedError={this.reportUnexpectedError}\r\n                    nullValuesSupport={this.state.nullValuesSupport}\r\n                    darkTheme={this.state.darkTheme}\r\n                />\r\n\r\n                {resultSection}\r\n            </main>\r\n        );\r\n    }\r\n}","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport * as serviceWorker from './serviceWorker';\r\nimport MainScreen from \"./components/mainScreen\";\r\n\r\n/**\r\n * @license The software is Licensed under the MIT License\r\n *\r\n * Copyright (c) Lukáš Kotlík\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\r\n * documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\r\n * to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions\r\n * of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO\r\n * THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\r\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n * ********* Used, Licensed third party code: *********\r\n *\r\n * JSZIP - Create, read and edit .zip files with Javascript\r\n * Version: 3.5.0\r\n * https://github.com/Stuk/jszip\r\n * MIT License - Copyright (c) 2009-2016 Stuart Knightley, David Duponchel, Franz Buchinger, António Afonso\r\n *\r\n * visx - visualization components\r\n * visx/group - version: 1.0.0\r\n * visx/hierarchy - version: 1.0.0\r\n * visx/shape - version: 1.4.0\r\n * visx/responsive - version: 1.3.0\r\n * visx/tooltip - version: 1.3.0\r\n * https://github.com/airbnb/visx\r\n * MIT License - Copyright (c) 2017-2018 Harrison Shoff\r\n *\r\n * export-svg-with-styles - Turn your SVGs to PNGs\r\n * Version: 0.0.4\r\n * https://www.npmjs.com/package/export-svg-with-styles\r\n * MIT License - Copyright (c) 2019 Mathew Leland\r\n *\r\n * FileSaver.js - An HTML5 saveAs() FileSaver implementation\r\n * Version: 2.0.5\r\n * https://github.com/eligrey/FileSaver.js\r\n * MIT License - Copyright (c) 2016 Eli Grey\r\n *\r\n * Lodash - A modern JavaScript utility library delivering modularity, performance, & extras.\r\n * Version: 4.17.20\r\n * https://github.com/lodash/lodash\r\n * MIT License - Copyright JS Foundation and other contributors <https://js.foundation/>\r\n * Based on Underscore.js, copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors <http://underscorejs.org/>\r\n * This software consists of voluntary contributions made by many individuals. For exact contribution history, see the revision history available at https://github.com/lodash/lodash\r\n *\r\n * React - A declarative, efficient, and flexible JavaScript library for building user interfaces.\r\n * Version: 16.13.1\r\n * https://github.com/facebook/react\r\n * MIT License - Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * Jest - Delightful JavaScript Testing.\r\n * Version: 26.6.0\r\n * https://github.com/facebook/jest\r\n * MIT License - Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * create-react-app - Set up a modern web app by running one command.\r\n * Version: 3.4.1\r\n * https://github.com/facebook/create-react-app\r\n * MIT License - Copyright (c) 2013-present, Facebook, Inc.\r\n *\r\n * TypeScript - TypeScript is a superset of JavaScript that compiles to clean JavaScript output.\r\n * Version: 3.7.5\r\n * https://github.com/microsoft/TypeScript\r\n * Apache License 2.0\r\n *\r\n * ********* Used, not Licensed, free to use code and services: *********\r\n *\r\n * PostMail - Send email from JavaScript or static HTML without backend code\r\n * https://postmail.invotes.com/\r\n */\r\nReactDOM.render(\r\n    <React.StrictMode>\r\n        <MainScreen/>\r\n    </React.StrictMode>,\r\n    document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.register();\r\n"],"sourceRoot":""}
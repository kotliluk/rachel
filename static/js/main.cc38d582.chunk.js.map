{"version":3,"sources":["components/tooltipButton.tsx","error/errorWithTextRange.ts","utils/localStorage.ts","language/language.ts","language/en.ts","language/cs.ts","error/raSyntaxError.ts","error/raSemanticError.ts","utils/fontUtils.ts","utils/whisperUtils.ts","components/xTextArea.tsx","utils/math.ts","relation/relation.ts","error/codeError.ts","error/errorFactory.ts","expression/exprTokens.ts","utils/stringUtils.ts","ratree/raTreeNode.ts","ratree/relationNode.ts","types/indexedString.ts","utils/indexedStringUtils.ts","ratree/unaryNode.ts","relation/row.ts","ratree/projectionNode.ts","utils/keywords.ts","types/isToISMap.ts","vetree/comparingOperator.ts","ratree/renameNode.ts","vetree/veTreeNode.ts","vetree/logicalOperator.ts","vetree/computingOperator.ts","vetree/literalValue.ts","vetree/referenceValue.ts","expression/valueTokens.ts","expression/valueParser.ts","ratree/binaryNode.ts","ratree/raTreeTools.ts","ratree/selectionNode.ts","ratree/antijoinNode.ts","ratree/outerJoinNode.ts","ratree/cartesianProductNode.ts","ratree/divisionNode.ts","ratree/naturalJoinNode.ts","ratree/setOperationNode.ts","ratree/thetaJoinNode.ts","ratree/raTreeFactory.ts","expression/exprParser.ts","components/textInput.tsx","components/messageBox.ts","components/expressionSection.tsx","components/resultRelationTable.tsx","components/evaluationTree.tsx","utils/fileDialog.ts","types/csvSupport.ts","types/nnToSMap.ts","relation/storedRelation.ts","relation/columnType.ts","relation/relationStoreManager.ts","components/resultSection.tsx","expression/expressionStoreManager.ts","project/samples.ts","components/managementSection.tsx","project/project.ts","expression/expression.ts","project/projectStoreManager.ts","batch/operationsCount.ts","batch/configUtils.ts","batch/batchProcessor.ts","components/editRelationTable.tsx","components/relationsSection.tsx","utils/mail.ts","components/mainScreen.tsx","postMailAccessToken.ts","index.tsx","serviceWorker.ts"],"names":["TooltipButton","className","this","props","onClick","style","text","undefined","tooltipClassName","tooltipStyle","event","stopPropagation","preventDefault","tooltip","React","Component","ErrorWithTextRange","msg","range","Error","insertRangeIfUndefined","err","defaultLanguage","defaultDarkTheme","LocalStorage","storageSupported","storedSeparator","localStorage","getItem","console","log","setItem","csvValueSeparator","lan","allSupportedLanguages","includes","language","darkTheme","warn","isInit","init","String","Storage","EN","abbr","relationErrors","emptyColumn","duplicitColumn","keywordColumn","invalidColumn","unsupportedNull","invalidNumber","invalidBoolean","codeErrors","resultSection_nodeIndexNotFound","resultSection_evalError","resultSection_nullRelationToSave","resultSection_nullRelationToAdd","row_absentColumn","valueParser_unexpectedToken","exprParser_unexpectedToken","exprParser_thetaJoinBranchError","exprParser_projectionBranchError","semanticErrors","exprParser_relationNotDefined","binaryNode_commonColumns","setOperationNode_notEqualColumns","divisionNode_rightColumnsNotSubset","divisionNode_rightColumnsNotProperSubset","renameNode_absentOriginalColumn","renameNode_changeToDuplicit","projectionNode_absentColumn","projectionNode_emptyProjection","referenceValue_absentColumn","semanticError","syntaxErrors","exprParser_emptyStringGiven","exprParser_outerJoinWhenNullNotSupported","exprParser_unexpectedPart","exprParser_bothBranchesError","exprParser_invalidExpression","exprParser_invalidParentheses","exprParser_invalidStart","exprParser_invalidEnd","exprParser_relationAfterRelation","exprParser_relationAfterUnary","exprParser_relationAfterClosing","exprParser_unaryAfterBinary","exprParser_unaryAfterOpening","exprParser_binaryAfterBinary","exprParser_binaryAfterOpening","exprParser_openingAfterRelation","exprParser_openingAfterUnary","exprParser_openingAfterClosing","exprParser_closingAfterBinary","exprParser_closingAfterOpening","valueParser_emptyInput","valueParser_unsupportedNull","valueParser_unexpectedPart","valueParser_missingOpeningParenthesis","valueParser_missingClosingParenthesis","valueParser_invalidExpression","valueParser_invalidStart","valueParser_invalidEnd","valueParser_literalAfterLiteral","valueParser_literalAfterReference","valueParser_literalAfterClosing","valueParser_referenceAfterLiteral","valueParser_referenceAfterReference","valueParser_referenceAfterClosing","valueParser_notAfterLiteral","valueParser_notAfterReference","valueParser_notAfterClosing","valueParser_binaryAfterOperator","valueParser_binaryAfterOpening","valueParser_openingAfterLiteral","valueParser_openingAfterReference","valueParser_openingAfterClosing","valueParser_closingAfterOperator","valueParser_closingAfterOpening","stringUtils_missingClosingChar","stringUtils_charNotFound","renameNode_missingArrow","renameNode_invalidNewName","renameNode_keywordNewName","renameNode_multipleRenameOfTheColumn","selectionNode_resultNotBoolean","thetaJoinNode_resultNotBoolean","comparingOperator_differentInputTypes","computingOperator_inputTypesNotNumbers","logicalOperator_leftInputNotBoolean","logicalOperator_rightInputNotBoolean","syntaxError","userMessages","loadedRelationsTotalNo","loadedRelationsTotalSome","loadRelationNew","loadAllRelationsNew","deleteLoadedRelations","relationsExportOK","relationsExportErr","relationsImport","expressionsExportOK","expressionsExportErr","expressionsImport","operations","selection","projection","rename","union","intersection","difference","naturalJoin","cartesianProduct","leftSemiJoin","rightSemiJoin","leftAntijoin","rightAntijoin","thetaJoin","leftThetaSemiJoin","rightThetaSemiJoin","fullOuterJoin","leftOuterJoin","rightOuterJoin","division","managementSection","batchTitle","batchLoad","batchConfig","batchConfigInfo","batchNoConfig","loadButton","saveButton","samplesButton","samplesMenuTitle","settingsButton","settingsNullValues","settingsNullValuesAllowed","settingsNullValuesForbidden","settingsCSVSeparator","settingsCSVSeparatorSemicolon","settingsCSVSeparatorComma","settingsTheme","settingsThemeLight","settingsThemeDark","settingsLanguage","aboutButton","relationSection","relationSectionHeader","loadAllButton","loadAllButtonTooltip","removeLoadedButton","removeLoadedButtonTooltip","importButton","importButtonTooltip","exportButton","exportButtonTooltip","loadButtonTooltip","renameButton","deleteButton","deleteButtonTooltip","revertButton","revertButtonTooltip","expressionSection","expressionSectionHeader","evaluateButton","evaluateButtonTooltip","expressionTextareaPlaceholder","lineComment","blockComment","resultSection","resultSectionHeader","exportEvalTreeButton","exportEvalTreeButtonTooltip","evalTreeTitle","resultRelationTitle","intermediateRelationTitle","addButton","addButtonTooltip","exportRelationButton","exportRelationButtonTooltip","languageMap","Map","lang","get","getLanguage","RASyntaxError","captureStackTrace","name","RASemanticError","computeFontSizeInPx","fontFamily","fontSize","div","document","createElement","setAttribute","innerText","documentElement","appendChild","divWidth","clientWidth","divHeight","clientHeight","remove","fontWidth","length","fontHeight","getStartOfWordBeforeIndex","str","index","prefixText","slice","i","charAt","match","cssConstants","getComputedStyle","querySelector","getPropertyValue","lineHeight","Number","numsBackgroundLight","numsBackgroundDark","numsColorLight","numsColorDark","XTextArea","textarea","start","selectionStart","end","selectionEnd","setSelectionRange","activeElement","id","focus","placeholder","getElementById","table","classList","add","tr","td1","td2","ta","mouseIsDown","value","canvas","width","canvasWidth","canvasLines","whisperDiv","isShown","selectedIndex","changeSelected","indexDiff","setSelected","newIndex","n","m","childElementCount","children","getSelectedWhisper","paintLineNumbers","height","ctx","getContext","fillStyle","fillRect","scrollHeight","font","linesCount","fillText","e","update","lines","updateParentheses","createWhisper","whispers","hideWhisper","innerHTML","forEach","whisper","onclick","ondblclick","insertCurrentSelectedWhisper","notAutoShowWhisper","moveWhisper","cursorLineAndColumn","getPositionLineAndColumn","cursorDistanceFromTATotalTop","line","cursorDistanceFromTATotalLeft","column","yPos","scrollTop","xPos","scrollLeft","getBoundingClientRect","y","window","innerHeight","currWhisper","beforeAdd","afterAdd","newCursorPos","onChange","errorDivs","moveErrors","highlight","startLine","rangeLength","startColumn","x","innerWidth","messageSpan","updateErrors","ranges","pushHighlight","parentElement","push","createHighlightDiv","getLineLength","parentheses","parenthesesDivs","c1","c2","around","filter","p","first","div1","createParenthesesDiv","div2","toggle","moveParentheses","insertPairSymbol","second","before","between","after","checkPairSymbolDelete","prevI","nextI","prev","next","addEventListener","onscroll","onmousedown","setTimeout","onmouseup","onmousemove","oninput","ev","target","onkeydown","key","ctrlKey","cursor","onCtrlInput","errors","prevProps","position","textBeforeCursor","lastNewLine","lastIndexOf","newLinesFound","lineStart","lineEnd","newEvent","MouseEvent","type","dispatchEvent","span","Relation","columns","columnNames","rows","finishedSchema","hasColumn","hasFinishedSchema","set","some","cn","f","row","isEqual","getTypes","finishSchema","finish","r","equals","map","s","join","columnTypes","getOrderedPrintValues","longest","d","pad","ss","padEnd","repeat","other","Set","CodeError","ErrorFactory","params","assertParamsCount","joinStringArrays","expectedCount","a","b","aLen","toConcat","Array","concat","ExprToken","getRange","ParenthesisToken","OpeningParenthesis","ClosingParenthesis","RelationToken","UnaryOperatorToken","BinaryOperatorToken","precedence","precedenceLevelA","precedenceLevelB","StringUtils","split","every","c","isLetter","isNameChar","res","exec","toLowerCase","toUpperCase","isDigit","test","substring","char","digitFound","dotFound","backslashes","curChar","error","escape","depth","inQuotes","nesting","escapeCount","indexOf","charFound","RATreeNode","resultRelation","eval","RelationNode","relation","cursorIndex","result","getName","IndexedString","chars","startIndex","arr","ic","isEmpty","NaN","RangeError","separator","empty","sepLen","strSplit","prefixSum","_start","_end","newFromArray","trimStr","trim","strings","is","searchString","startsWith","endPosition","endsWith","searchValue","replaceValue","replace","IndexedStringUtils","isWord","toString","isName","isWhitespacesOnly","isNumber","strParts","nextWord","nextName","nextNonWhitespacePart","nextNumber","nextQuotedString","getFirstIndex","nextBorderedPart","copy","getChars","inLineComment","blockCommentStart","errStart","skippedStr","skipWhitespacesAndChar","UnaryNode","subtree","Row","types","values","finished","keys","has","orderedColumns","ret","codeError","ProjectionNode","stringRange","projStart","isEvaluated","source","getResult","projectedIndexed","parseProjection","proj","projected","forEachColumn","addColumn","getRows","newRow","getColumns","getValues","addValue","addRow","fakeEval","getColumnNames","absent","strName","printInLine","getOperationSymbol","forbiddenColumnNames","forbiddenRelationNames","isForbiddenColumnName","ComparingOperatorType","ISToISMap","keyValue","delete","clear","size","RenameNode","doThrow","handleError","parts","part","words","w","beforeError","afterError","changes","parseChanges","toChange","newName","returned","duplicit","beforeStr","afterStr","VETreeNode","LogicalOperatorType","ComparingOperator","operator","left","right","equal","nonEqual","less","more","lessOrEqual","moreOrEqual","leftResult","rightResult","ComputingOperatorType","LogicalOperator","and","or","not","LiteralValue","ReferenceValue","columnName","getValue","getType","ComputingOperator","plus","minus","multiplication","ValueToken","OperatorToken","LogicalNotToken","LogicalAndToken","LogicalOrToken","ComputingMultiplicationToken","ComputingDivisionToken","ComputingPlusToken","ComputingMinusToken","ComparingToken","OpeningParentheses","ClosingParentheses","LiteralToken","ReferenceToken","ValueParser","nullValuesSupport","tokens","parseTokens","assertValidInfixTokens","simplify","rpn","toRPN","rpnToVETree","token","rest","i2","token1","token2","notIndexes","indexesToRemove","t","rpnQueue","operatorsStack","pop","curToken","rpnToVETreeRecursive","deduct","multiply","divide","JSON","stringify","BinaryNode","leftSubtree","rightSubtree","depthSearch","root","findIndexInTree","node","getSubtree","leftSearch","getLeftSubtree","getRightSubtree","getTreeDepth","Math","max","isInRangeAndNotInQuotes","len","cursorIndexInStr","insideQuotes","AntijoinType","SelectionNode","boolExpr","parse","bool","newResult","fakeParse","OuterJoinType","AntijoinNode","rowsToKeep","rowsToHelp","leftSource","rightSource","commonColumns","lc","keptRow","helpRow","fakeEvalBinary","CartesianProductNode","leftRow","rightRow","leftColumn","DivisionNode","leftColumns","rightColumns","getSchemaString","resultColumns","getNamesSchemaString","leftRows","rightRows","testRow","lr","entries","NaturalJoinType","OuterJoinNode","full","SetOperationType","NaturalJoinNode","leftSemi","natural","rightSemi","ThetaJoinType","SetOperationNode","typeStr","getOperationName","rr","ThetaJoinNode","condition","bothSourceColumns","booleanResult","sourceColumns","RATreeFactory","unaryClass","expr","binaryClass","ExprParser","relations","deleteAllComments","new","rpnToRATree","innerResult","pushParentheses","getLastIndex","selectionExpected","restStartIndex","recursiveReturn","rightThetaSemijoin","containsAny","leftSemijoin","rightSemijoin","leftThetaSemijoin","indexAt","missing","splice","rpnToRATreeRecursive","createUnary","createBinary","TextInput","inputRef","handleChange","disable","forbidden","setState","buttonDisable","handleKeyDown","state","handleSubmit","current","blur","onSubmit","createRef","ref","spellCheck","autoComplete","onKeyDown","disabled","buttonText","boxMargin","MessageBox","box","visibility","onmouseenter","clearHideTimeout","onmouseleave","setHideTimeout","paragraph","button","hideBox","moveBox","body","firstElementChild","display","hideTimeout","hideIntervalId","clearTimeout","ExpressionSection","textAreaRef","lastChange","lastWhisperAndErrorsUpdate","whispersAndErrorsUpdateRate","updateErrorsAndParentheses","getCurExpr","isNaN","message","evalExpr","tree","expressions","currentExpressionIndex","onEval","errorRanges","er","showError","newExpression","onNewExpression","deleteExpression","onDeleteExpression","exportExpressions","onExportExpressions","importExpressions","onImportExpressions","addSpecialString","shift","getSelection","firstPart","secondPart","newPosition","newStr","handleExprChange","setSelection","onDone","Date","now","handleCtrlInput","updateWhispersAndErrors","textArea","isFocused","fakeParseResult","wordBeforeCursor","helpArray","likelihood","wordStart","wordEnd","sort","help","sortWhispers","handleExprNameChange","onUnexpectedError","handleDragDrop","data","dataTransfer","getData","fromIndex","onDragExpression","sectionClicked","setInterval","setPlaceholder","onSelectDifferentExpression","ops","createButton","createOpButton","buttonGroupMargin","marginRight","handleSelectDifferentExpression","draggable","onDragStart","setData","onDragOver","onDrop","minWidth","marginLeft","padding","ResultRelationTable","getOrderByText","orderDir","orderBy","prevState","snapshot","updateOrderBy","getRowsCount","colSpan","sortCol","aValue","bValue","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","localeCompare","headerRow","createHeaderRow","createRows","EvaluationTree","TreeComponent","raTree","selected","nodeHeight","backgroundColorLight","backgroundColorDark","textColorLight","textColorDark","selectedNodeColorLight","unselectedNodeColorLight","selectedNodeColorDark","unselectedNodeColorDark","TreeNodeComponent","useTooltip","tooltipOpen","showTooltip","hideTooltip","nodeWidth","title","symbol","Group","top","rx","fill","onMouseOver","tooltipLeft","tooltipTop","onMouseOut","dy","textAnchor","pointerEvents","treeDepth","margin","bottom","yMax","xMax","indexes","parseTreeForDisplayHelper","maxNodeTextLength","parseTreeForDisplay","hierarchy","Tree","links","link","LinkVertical","stroke","strokeWidth","strokeOpacity","descendants","FileDialog","Promise","resolve","element","fileInput","firstChild","files","click","accept","file","reader","FileReader","onload","readAsText","openFilesHelper","fileInfo","readFile","splitCSVLine","partStart","NNToSMap","entry","parseKey","StoredRelation","columnCount","rowCount","actual","revertState","toDataObject","recomputeErrors","isStoredRelationData","rel","checkColumnNames","checkRowInput","columnIndex","reduce","agg","rowIndex","input","lower","_","rowInput","addNewColumn","columnType","checkColumnTypes","obj","isArray","o","isSupportedColumnType","RelationStoreManager","openFiles","then","skipped","csvToRelation","createValidName","filename","valueSeparator","zip","JSZip","relationToCsv","generateAsync","content","saveAs","catch","blob","Blob","findValueSeparator","names","getColumnTypes","ResultSection","sectionRef","getCurrentRelation","currentNode","evaluationTreeRoot","handleSelectedNodeChange","exportEvalTreeAsPng","svg","rect","options","expressionName","downloadSVG","exportRelation","save","fromRelation","addRelation","onAddResult","relationType","selectedNode","tableTitle","ExpressionStoreManager","skippedExpressions","loadedFiles","skippedFiles","splitExpressionNameAndText","firstNewLineIndex","firstRow","textContent","samples","project","getSamples","ManagementSection","onLoadProject","onSaveProject","samplesMenu","sample","onLoadSample","createSamplesButton","settingsMenu","checked","onNullValuesSupportChange","htmlFor","onCsvValueSeparatorChange","onDarkThemeChange","onLanguageChange","createSettingsButton","batchMenu","onBatchConfig","batchConfigurationInfo","onBatchLoad","createBatchButton","href","isProjectObject","isExpression","copyProject","exp","ProjectStoreManager","reject","openFile","OperationsTypes","zeroOperations","addOperations","counts","antijoin","count","cartesian","outerJoin","semijoin","thetaSemijoin","binaryOperations","unaryOperations","operationsOfTree","operationOfUnaryNode","operationOfBinaryNode","createCountComparator","comparators","field","countValue","comparator","createOperationsCounter","op","_ops","cur","getDescription","ruleDef","description","createCountOperationRule","unique","counter","sign","createOperationsIndicator","removeExtension","lastDotIndex","identityReportNameModifier","createReportNameModifier","config","modifier","usePathParts","joinPathParts","prefix","suffix","fieldName","previousModifier","BatchProcessor","loadType","configurationFileName","reportNameModifier","operationRules","tableRules","queryRules","loaded","ruleName","rule","createRule","resultFilename","fields","subRules","each","sr","createEachOperationRule","tables","createTableRule","queries","createQueryRule","processFiles","openZip","loadAsync","createFolders","zippedFiles","Object","dir","zippedFile","async","storedData","storedRelation","fromData","isValid","createRelation","ignored","time","reports","processed","downloadReports","report","timeEnd","processNext","processFile","status","parseRelations","exprParser","exprCount","processExpression","reportHeader","formatRelations","sectionLine","parser","evaluationTree","contentLine","contentString","rels","exprs","errs","nvs","total","binary","unary","ruleErrors","rulesCount","errorsCount","toLocaleString","inlines","format","cellPaddingSides","inputMarginSides","EditRelationTable","containerRef","tableHeadRowRef","columnWidths","handleInputResize","inputElement","scrollWidth","getErrors","setSelectedInput","selectedColumn","selectedRow","moveSelectedInputRight","getColumnCount","moveSelectedInputLeft","moveSelectedInputUp","moveSelectedInputDown","getRowCount","onColumnNameChange","onColumnTypeChange","onRowInputChange","handleNewColumn","onNewColumn","scrollTo","handleNewRow","onNewRow","handleDeleteColumn","onDeleteColumn","handleDeleteRow","onDeleteRow","createInput","autoFocus","createDeleteButton","callback","componentDidUpdate","headRow","cells","cell","rowData","createTooltip","rowSpan","border","createNamesRow","createTypesRow","createAddRow","RelationsSection","getCurRel","storedRelations","storedRelationIndex","handleRelationNameChange","onRelationNameChange","loadRelation","onLoadRelation","loadAllRelations","onLoadAllRelations","exportRelations","onExportRelations","importRelations","onImportRelations","deleteRelation","onDeleteStoredRelation","revertRelation","onRevertRelation","newRelation","onNewRelation","removeLoadedRelations","onRemoveLoadedRelations","createRelationMenuButtons","actuality","isActual","handleSelectDifferentRelation","onDragRelation","onSelectDifferentRelation","getRevertName","Mail","accessToken","subject","data_js","access_token","request","XMLHttpRequest","onreadystatechange","readyState","response","toParams","open","setRequestHeader","send","encodeURIComponent","MainScreen","expressionSectionRef","reportUnexpectedError","postMail","stack","loadedRelations","selectedRelation","selectedExpression","loadProject","evaluatedExpressionName","updateExpressionsErrors","ensureUniqueRelationName","handleBatchConfig","configInfo","getConfigInfo","handleBatchLoad","process","handleLoadProject","load","handleSaveProject","handleLoadSampleProject","handleNullValuesSupportChange","setNullValuesSupport","handleCsvValueSeparatorChange","setCsvValueSeparator","handleLanguageChange","setLanguage","handleDarkThemeChange","setDarkTheme","setName","handleRelationColumnNameChange","setColumnName","handleRelationColumnTypeChange","setColumnType","handleRelationRowInputChange","setRowInput","handleRelationNewRow","addNewRow","handleRelationNewColumn","handleRelationDeleteRow","deleteRow","handleRelationDeleteColumn","deleteColumn","handleDragRelation","from","to","moved","fromValue","newArray","handleCreateNewRelation","handleDeleteRelation","handleRevertRelation","revert","handleRemoveLoadedRelations","previous","setActual","handleExportRelations","handleImportRelations","info","countBefore","handleLoadRelation","currRelation","msgPart2","handleLoadAllRelations","handleExprEval","handleExprTextChange","handleDragExpression","handleCreateNewExpression","handleDeleteExpression","handleExportExpressions","handleImportExpressions","addResultRelation","getDarkTheme","getCsvValueSeparator","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.cc38d582.chunk.js","sourcesContent":["import React from \"react\";\n\n/**\n * Props of TooltipButton component.\n * @category Components\n * @public\n */\ninterface TooltipButtonProps {\n    /**\n     * text on the button\n     * @type string\n     * @public\n     */\n    text: string,\n    /**\n     * handler of the button click\n     * @type function\n     * @public\n     */\n    onClick: () => void,\n    /**\n     * css class of the button\n     * @type string?\n     * @public\n     */\n    className?: string,\n    /**\n     * inline styling for button\n     * @type React.CSSProperties?\n     * @public\n     */\n    style?: React.CSSProperties,\n    /**\n     * text of the tooltip\n     * @type string\n     * @public\n     */\n    tooltip: string,\n    /**\n     * css class of the tooltip (it always has default .tooltip class)\n     * @type string?\n     * @public\n     */\n    tooltipClassName?: string,\n    /**\n     * inline styling for tooltip\n     * @type React.CSSProperties?\n     * @public\n     */\n    tooltipStyle?: React.CSSProperties,\n}\n\ninterface TooltipButtonState {\n}\n\n/**\n * Button with a tooltip text.\n * Accepts {@link TooltipButtonProps} props.\n * @category Components\n * @public\n */\nexport class TooltipButton extends React.Component<TooltipButtonProps, TooltipButtonState> {\n\n    render() {\n        return (\n            <button\n                className={this.props.className}\n                onClick={this.props.onClick}\n                style={this.props.style}\n                >{this.props.text}\n                <span\n                    className={\"tooltip \" + (this.props.tooltipClassName !== undefined ? this.props.tooltipClassName : \"\")}\n                    style={this.props.tooltipStyle}\n                    onClick={event => {\n                        event.stopPropagation();\n                        event.preventDefault();\n                    }}\n                >{this.props.tooltip}</span>\n            </button>\n        );\n    }\n}","import {StartEndPair} from \"../types/startEndPair\";\n\n/**\n * Error with optional text range of the error.\n * @extends Error\n * @category Errors\n * @public\n */\nexport class ErrorWithTextRange extends Error {\n    /**\n     * @param msg error message {@type string}\n     * @param range optional text range of the error {@type StartEndPair?}\n     * @public\n     */\n    constructor(msg: string, public range?: StartEndPair | undefined) {\n        super(msg);\n    }\n}\n\n/**\n * If the given error is ErrorWithTextRange instance and has undefined range, sets its range to given value.\n * Returns (possibly modified) input error.\n *\n * @param err error tu be inserted in {@type ErrorWithTextRange}\n * @param range inserted range {@type StartEndPair?}\n * @category Errors\n * @public\n */\nexport function insertRangeIfUndefined<T>(err: T, range: StartEndPair | undefined): T {\n    if (err instanceof ErrorWithTextRange && err.range === undefined) {\n        err.range = range;\n    }\n    return err;\n}","import {CsvValueSeparator} from \"../types/csvSupport\";\nimport {isSupportedLanguage, SupportedLanguage} from \"../language/language\";\n\nconst defaultCsvValueSeparator: CsvValueSeparator = \";\";\nconst defaultLanguage: SupportedLanguage = \"EN\";\nconst defaultDarkTheme: string = \"false\";\n\n/**\n * Static class for maintaining the access to local storage of the browser. It handles user settings:\n * saving file type, csv value separator, language, light/dark theme of the application.\n * If the local storage is not used, it uses the application memory and the default values.\n * @category Utils\n * @public\n */\nexport class LocalStorage {\n\n    private static isInit: boolean = false;\n    private static storageSupported: boolean = typeof(Storage) !== \"undefined\";\n\n    private static csvValueSeparator: CsvValueSeparator;\n    private static language: SupportedLanguage;\n    private static darkTheme: string;\n\n    /**\n     * Initializes the LocalStorage. If there are the requested values, loads them to application memory.\n     * If the local storage is not supported, uses the default values.\n     */\n    private static init(): void {\n        if (LocalStorage.storageSupported) {\n            const storedSeparator = localStorage.getItem(\"csvValueSeparator\");\n            if (storedSeparator !== \";\" && storedSeparator !== \",\") {\n                console.log(\"csvValueSeparator not found in localStorage and set to default\");\n                localStorage.setItem(\"csvValueSeparator\", defaultCsvValueSeparator);\n                LocalStorage.csvValueSeparator = defaultCsvValueSeparator;\n            }\n            else {\n                // @ts-ignore\n                LocalStorage.csvValueSeparator = localStorage.getItem(\"csvValueSeparator\");\n            }\n            if (!isSupportedLanguage(localStorage.getItem(\"language\"))) {\n                console.log(\"language not found in localStorage and set to default\");\n                localStorage.setItem(\"language\", defaultLanguage);\n                LocalStorage.language = defaultLanguage;\n            }\n            else {\n                // @ts-ignore\n                LocalStorage.language = localStorage.getItem(\"language\");\n            }\n\n            if (localStorage.getItem(\"darkTheme\") !== \"true\" && localStorage.getItem(\"darkTheme\") !== \"false\") {\n                console.log(\"darkTheme not found in localStorage and set to default\");\n                localStorage.setItem(\"darkTheme\", defaultDarkTheme);\n                LocalStorage.darkTheme = defaultDarkTheme;\n            }\n            else {\n                // @ts-ignore\n                LocalStorage.darkTheme = localStorage.getItem(\"darkTheme\");\n            }\n        }\n        else {\n            console.warn(\"LocalStorage not supported in the browser. Default values used.\");\n            LocalStorage.csvValueSeparator = defaultCsvValueSeparator;\n            LocalStorage.language = defaultLanguage;\n            LocalStorage.darkTheme = defaultDarkTheme;\n        }\n        LocalStorage.isInit = true;\n    }\n\n    /**\n     * Returns stored CSV value separator.\n     *\n     * @return stored CSV value separator {@type CsvValueSeparator}\n     * @public\n     */\n    public static getCsvValueSeparator(): CsvValueSeparator {\n        if (!LocalStorage.isInit) {\n            LocalStorage.init();\n        }\n        return LocalStorage.csvValueSeparator;\n    }\n\n    /**\n     * Stores the given CSV value separator.\n     *\n     * @param csvValueSeparator CSV value separator to store {@type CsvValueSeparator}\n     * @public\n     */\n    public static setCsvValueSeparator(csvValueSeparator: CsvValueSeparator): void {\n        LocalStorage.csvValueSeparator = csvValueSeparator;\n        if (LocalStorage.storageSupported) {\n            localStorage.setItem(\"csvValueSeparator\", csvValueSeparator);\n        }\n    }\n\n    /**\n     * Returns stored language settings.\n     *\n     * @return stored language {@type SupportedLanguage}\n     * @public\n     */\n    public static getLanguage(): SupportedLanguage {\n        if (!LocalStorage.isInit) {\n            LocalStorage.init();\n        }\n        return LocalStorage.language;\n    }\n\n    /**\n     * Stores the given language settings.\n     *\n     * @param language language settings to store {@type SupportedLanguage}\n     * @public\n     */\n    public static setLanguage(language: SupportedLanguage): void {\n        LocalStorage.language = language;\n        if (LocalStorage.storageSupported) {\n            localStorage.setItem(\"language\", language);\n        }\n    }\n\n    /**\n     * Returns stored theme settings: true if the stored theme is dark, false if light.\n     *\n     * @return true if the stored theme is dark, false if light {@type boolean}\n     * @public\n     */\n    public static getDarkTheme(): boolean {\n        if (!LocalStorage.isInit) {\n            LocalStorage.init();\n        }\n        return LocalStorage.darkTheme === \"true\";\n    }\n\n    /**\n     * Stores the given theme settings: true if the stored theme is dark, false if light.\n     *\n     * @param darkTheme theme settings to store {@type boolean}\n     * @public\n     */\n    public static setDarkTheme(darkTheme: boolean): void {\n        LocalStorage.darkTheme = String(darkTheme);\n        if (LocalStorage.storageSupported) {\n            localStorage.setItem(\"darkTheme\", String(darkTheme));\n        }\n    }\n}","import {LocalStorage} from \"../utils/localStorage\";\nimport {EN} from \"./en\";\nimport {CS} from \"./cs\";\nimport {CodeErrorMessages} from \"../error/codeError\";\nimport {SemanticErrorMessages} from \"../error/raSemanticError\";\nimport {SyntaxErrorMessages} from \"../error/raSyntaxError\";\n\n/**\n * IF YOU WANT TO ADD A NEW LANGUAGE, READ THIS:\n *\n * Adding a language is simple, follow these steps:\n * 1) Copy the \"en.ts\" file in this package and name it as the lowercase new language abbreviation, e.g., \"cs.ts\"\n * 2) Rename the language definition object to the uppercase language abbreviation, e.g., \"CS\"\n * 3) Translate the messages in the new file. Some messages are split into an array - if you are not sure what to\n * write in each part, see its usage or other languages.\n * 4) Add the uppercase language abbreviation, e.g., \"CS\", in the allSupportedLanguages array in this file.\n * 5) Import your language definition in this file, e.g., \"import {CS} from \"./cs\";\"\n * 6) Add the imported language definition into languageMap map in this file, e.g., \"[\"CS\", CS],\"\n * 7) (voluntary) Create a project sample in your language in /project/samples.ts - you can translate existing samples.\n * 8) Test whether the application works.\n */\n\n/**\n * All languages supported in the application.\n * NOTE FOR NEW LANGUAGES: If you define a new language file \"lang.ts\", add \"LANG\" to this array.\n * @type string[]\n * @category Language\n * @public\n */\nexport const allSupportedLanguages: string[] = (<L extends string>(arr: L[]) => arr)([\"EN\", \"CS\"]);\n\n/**\n * Abbreviation of supported languages in the application.\n * @category Language\n * @public\n */\nexport type SupportedLanguage = (typeof allSupportedLanguages)[number];\n\n/**\n * Definition of a language for Rachel.\n * NOTE FOR NEW LANGUAGES: If you want to define a new language, it must be through this interface in a new file in\n * this package (see en.ts file as an example of English language definition).\n * @category Language\n * @public\n */\nexport interface LanguageDef {\n    /**\n     * Abbreviation of the language\n     * @public\n     */\n    abbr: SupportedLanguage,\n    /**\n     * Description of errors in relation definitions.\n     * @public\n     */\n    relationErrors: {\n        emptyColumn: string,\n        duplicitColumn: string,\n        keywordColumn: string,\n        invalidColumn: string,\n\n        unsupportedNull: string,\n        invalidNumber: string,\n        invalidBoolean: string,\n    },\n    /**\n     * Description of unexpected errors.\n     * @public\n     */\n    codeErrors: CodeErrorMessages,\n    /**\n     * Description of semantic errors in expressions.\n     * @public\n     */\n    semanticErrors: SemanticErrorMessages,\n    /**\n     * Default semantic error message.\n     * @public\n     */\n    semanticError: string,\n    /**\n     * Description of syntactic errors in expressions.\n     * @public\n     */\n    syntaxErrors: SyntaxErrorMessages,\n    /**\n     * Default syntax error message.\n     * @public\n     */\n    syntaxError: string,\n    /**\n     * Info messages for the user in pop-up message box.\n     * @public\n     */\n    userMessages: {\n        loadedRelationsTotalNo: string,\n        loadedRelationsTotalSome: string,\n        loadRelationNew: string,\n        // 2 parts expected - see English language as an example\n        loadAllRelationsNew: string[],\n        deleteLoadedRelations: string,\n\n        relationsExportOK: string,\n        relationsExportErr: string,\n        // 2 parts expected - see English language as an example\n        relationsImport: string[],\n\n        expressionsExportOK: string,\n        expressionsExportErr: string,\n        // 4 parts expected - see English language as an example\n        expressionsImport: string[]\n    },\n    /**\n     * Names of RA operations.\n     * @public\n     */\n    operations: {\n        selection: string,\n        projection: string,\n        rename: string,\n        union: string,\n        intersection: string,\n        difference: string,\n        naturalJoin: string,\n        cartesianProduct: string,\n        leftSemiJoin: string,\n        rightSemiJoin: string,\n        leftAntijoin: string,\n        rightAntijoin: string,\n        thetaJoin: string,\n        leftThetaSemiJoin: string,\n        rightThetaSemiJoin: string,\n        fullOuterJoin: string,\n        leftOuterJoin: string,\n        rightOuterJoin: string,\n        division: string\n    }\n    /**\n     * Description of elements in management section.\n     * @public\n     */\n    managementSection: {\n        batchTitle: string,\n        batchLoad: string,\n        batchConfig: string,\n        batchConfigInfo: string[],\n        batchNoConfig: string,\n\n        loadButton: string,\n        saveButton: string,\n\n        samplesButton: string,\n        samplesMenuTitle: string,\n\n        settingsButton: string,\n        settingsNullValues: string,\n        settingsNullValuesAllowed: string,\n        settingsNullValuesForbidden: string,\n        settingsCSVSeparator: string,\n        settingsCSVSeparatorSemicolon: string,\n        settingsCSVSeparatorComma: string,\n        settingsTheme: string,\n        settingsThemeLight: string,\n        settingsThemeDark: string,\n        settingsLanguage: string,\n\n        aboutButton: string\n    },\n    /**\n     * Description of elements in relation section.\n     * @public\n     */\n    relationSection: {\n        relationSectionHeader: string,\n\n        loadAllButton: string,\n        loadAllButtonTooltip: string,\n        removeLoadedButton: string,\n        removeLoadedButtonTooltip: string,\n        importButton: string,\n        importButtonTooltip: string,\n        exportButton: string,\n        exportButtonTooltip: string,\n\n        loadButton: string,\n        loadButtonTooltip: string,\n        renameButton: string,\n        deleteButton: string,\n        deleteButtonTooltip: string,\n        revertButton: string,\n        revertButtonTooltip: string\n    },\n    /**\n     * Description of elements in expression section.\n     * @public\n     */\n    expressionSection: {\n        expressionSectionHeader: string,\n\n        importButton: string,\n        importButtonTooltip: string,\n        exportButton: string,\n        exportButtonTooltip: string,\n\n        evaluateButton: string,\n        evaluateButtonTooltip: string,\n        renameButton: string,\n        deleteButton: string,\n        deleteButtonTooltip: string,\n\n        expressionTextareaPlaceholder: string,\n\n        lineComment: string,\n        blockComment: string\n    }\n    /**\n     * Description of elements in result section.\n     * @public\n     */\n    resultSection: {\n        resultSectionHeader: string,\n\n        exportEvalTreeButton: string,\n        exportEvalTreeButtonTooltip: string,\n        evalTreeTitle: string,\n\n        resultRelationTitle: string,\n        intermediateRelationTitle: string,\n        addButton: string,\n        addButtonTooltip: string,\n        exportRelationButton: string,\n        exportRelationButtonTooltip: string,\n    }\n}\n\n/**\n * Map of supported languages to their definition.\n * NOTE FOR NEW LANGUAGES: If you define a new language, add its definition mapping here.\n */\nconst languageMap: Map<SupportedLanguage, LanguageDef> = new Map<SupportedLanguage, LanguageDef>([\n    [\"EN\", EN],\n    [\"CS\", CS],\n]);\n\n/**\n * Returns true if the given value is a supported language.\n * @param lan checked value {@type any}\n * @return true if the given value is a supported language {@type boolean}\n * @category Language\n * @public\n */\nexport function isSupportedLanguage(lan: any): boolean {\n    return allSupportedLanguages.includes(lan);\n}\n\n/**\n * Returns definition of the current selected language.\n * @return definition of the current selected language {@type LanguageDef}\n * @category Language\n * @public\n */\nexport function language(): LanguageDef {\n    const lang = languageMap.get(LocalStorage.getLanguage());\n    if (lang === undefined) {\n        return EN;\n    }\n    return lang;\n}","import {LanguageDef} from \"./language\";\nimport {CodeErrorMessages} from \"../error/codeError\";\nimport {SemanticErrorMessages} from \"../error/raSemanticError\";\nimport {SyntaxErrorMessages} from \"../error/raSyntaxError\";\n\n/**\n * English messages for CodeErrors mapped by their error codes.\n */\nconst codeErrors: CodeErrorMessages = {\n    resultSection_nodeIndexNotFound:\n        [\"ResultSection.getCurrentRelation: Selected node index in the evaluation tree was not found.\"],\n    resultSection_evalError:\n        [\"ResultSection.getCurrentRelation: Evaluation error in result section: \", /* error */ \".\"],\n    resultSection_nullRelationToSave:\n        [\"ResultSection.saveResultRelation: Resulting relation is null when trying to save it.\"],\n    resultSection_nullRelationToAdd:\n        [\"ResultSection.handleAddRelation: Resulting relation is null when trying to add it.\"],\n\n    row_absentColumn:\n        [\"Row.getOrderedValues: Column \", /* column */ \" is missing in a row with columns: \", /* column */ \".\"],\n\n    valueParser_unexpectedToken:\n        [\"ValueParser.rpnToVETreeRecursive: Unexpected token: \", /* token */ \".\"],\n\n    exprParser_unexpectedToken:\n        [\"ExprParser.isValidSequence: Unexpected token: \", /* token */ \".\"],\n    exprParser_thetaJoinBranchError:\n        [\"ExprParser.parseTokensForWhisper: Error in theta join branch: \", /* error */ \".\"],\n    exprParser_projectionBranchError:\n        [\"ExprParser.parseTokensForWhisper: Error in projection branch: \", /* error */ \".\"]\n};\n\n/**\n * English messages for RASemanticErrors mapped by their error codes.\n */\nconst semanticErrors: SemanticErrorMessages = {\n    exprParser_relationNotDefined: [\"Relation \\\"\", /* relation */ \"\\\" is not defined. Check definitions of relations.\"],\n\n    binaryNode_commonColumns: [\"Source relations for \", /* operator */ \" have common columns \\\"\", /* columns */ \"\\\".\"],\n    setOperationNode_notEqualColumns:\n        [\"Source relations \\\"\", /* left */ \"\\\" and \\\"\", /* right */ \"\\\" for set \", /* operation */ \" do not have the same column sets.\"],\n    divisionNode_rightColumnsNotSubset:\n        [\"Right-hand relation schema \\\"\", /* schema */ \"\\\" is not a subset of the left-hand relation schema \\\"\", /* schema */ \"\\\".\"],\n    divisionNode_rightColumnsNotProperSubset:\n        [\"Right-hand relation schema \\\"\", /* schema */ \"\\\" is not a proper subset of the left-hand relation schema \\\"\",\n        /* schema */ \"\\\". There must exist at least one column in the left relation which is not present in the right relation.\"],\n    renameNode_absentOriginalColumn: [\"Invalid renaming attempt, column \\\"\", /* column */ \"\\\" does not exist in the source relation.\"],\n    renameNode_changeToDuplicit: [\"Invalid renaming attempt, new column name \\\"\", /* column */ \"\\\" is ambiguous in the changed relation.\"],\n    projectionNode_absentColumn: [\"Invalid projection of the column \\\"\", /* column */ \"\\\". It does not exist in the source relation.\"],\n    projectionNode_emptyProjection: [\"Invalid projection attempt, no column to project.\"],\n\n    referenceValue_absentColumn: [\"Column \\\"\", /* column */ \"\\\" is missing in a schema with columns: \", /* columns */ \".\"]\n};\n\n/**\n * English messages for RASyntaxErrors mapped by their error codes.\n */\nconst syntaxErrors: SyntaxErrorMessages = {\n    exprParser_emptyStringGiven: [\"Cannot parse an expression from an empty string.\"],\n    exprParser_outerJoinWhenNullNotSupported: [\"Found \", /* outer join */ \" when null values are not supported.\"],\n    exprParser_unexpectedPart: [\"Unexpected part \\\"\", /* part */ \"\\\" in an expression.\"],\n    exprParser_bothBranchesError: [\"All combinations throw error in \\\"\", /* part */ \"\\\". When treated as projection:\\n\",\n        /* error */ \"\\nWhen treated as theta join:\\n\", /* error */ \"\"],\n    exprParser_invalidExpression: [\"Given string is not a valid relational algebra expression.\"],\n    exprParser_invalidParentheses: [\"Invalid structure of parentheses in the expression.\"],\n    exprParser_invalidStart: [\"Relational algebra expression cannot start with \", /* start */ \".\"],\n    exprParser_invalidEnd: [\"Relational algebra expression cannot end with \", /* end */ \".\"],\n    exprParser_relationAfterRelation: [\"Relation \\\"\", /* relation */ \"\\\" after relation \\\"\", /* relation */\"\\\".\"],\n    exprParser_relationAfterUnary: [\"Relation \\\"\", /* relation */ \"\\\" after unary operator \\\"\", /* unary */ \"\\\".\"],\n    exprParser_relationAfterClosing: [\"Relation \\\"\", /* relation */ \"\\\" after closing parenthesis.\"],\n    exprParser_unaryAfterBinary: [\"Unary operator \\\"\", /* unary */ \"\\\" after binary operator \\\"\", /* binary */ \"\\\".\"],\n    exprParser_unaryAfterOpening: [\"Unary operator \\\"\", /* unary */ \"\\\" after opening parenthesis.\"],\n    exprParser_binaryAfterBinary: [\"Binary operator \\\"\", /* unary */ \"\\\" after binary operator \\\"\", /* binary */ \"\\\".\"],\n    exprParser_binaryAfterOpening: [\"Binary operator \\\"\", /* binary */ \"\\\" after opening parenthesis.\"],\n    exprParser_openingAfterRelation: [\"Opening parenthesis after relation \\\"\", /* relation */ \"\\\".\"],\n    exprParser_openingAfterUnary: [\"Opening parenthesis after unary operator \\\"\", /* unary */ \"\\\".\"],\n    exprParser_openingAfterClosing: [\"Opening parenthesis after closing parenthesis.\"],\n    exprParser_closingAfterBinary: [\"Closing parenthesis after binary operator \\\"\", /* binary */ \"\\\".\"],\n    exprParser_closingAfterOpening: [\"Closing parenthesis after opening parenthesis.\"],\n\n    valueParser_emptyInput: [\"Empty string given as a condition.\"],\n    valueParser_unsupportedNull: [\"Null constant used when null values are not supported.\"],\n    valueParser_unexpectedPart: [\"Unexpected part \\\"\", /* part */ \"\\\" in the expression.\"],\n    valueParser_missingOpeningParenthesis: [\"Missing opening parenthesis '(' in an expression.\"],\n    valueParser_missingClosingParenthesis: [\"Missing closing parenthesis ')' in an expression.\"],\n    valueParser_invalidExpression: [\"Given string is not a valid expression.\"],\n    valueParser_invalidStart: [\"Expression cannot start with \\\"\", /* start */ \"\\\".\"],\n    valueParser_invalidEnd: [\"Expression cannot end with \\\"\", /* end */ \"\\\".\"],\n    valueParser_literalAfterLiteral: [\"Literal \\\"\", /* literal */ \"\\\" after literal \\\"\", /* literal */ \"\\\".\"],\n    valueParser_literalAfterReference: [\"Literal \\\"\", /* literal */ \"\\\" after reference to column \\\"\", /* column */ \"\\\".\"],\n    valueParser_literalAfterClosing: [\"Literal \\\"\", /* literal */ \"\\\" after closing parenthesis.\"],\n    valueParser_referenceAfterLiteral: [\"Reference to column \\\"\", /* column */ \"\\\" after literal \\\"\", /* literal */ \"\\\".\"],\n    valueParser_referenceAfterReference: [\"Reference to column \\\"\", /* column */ \"\\\" after reference to column \\\"\", /* column */ \"\\\".\"],\n    valueParser_referenceAfterClosing: [\"Reference to column \\\"\", /* column */ \"\\\" after closing parenthesis.\"],\n    valueParser_notAfterLiteral: [\"Logical not operator \\\"\", /* not */ \"\\\" after literal \\\"\", /* literal */ \"\\\".\"],\n    valueParser_notAfterReference: [\"Logical not operator \\\"\", /* not */ \"\\\" after reference to column \\\"\", /* column */ \"\\\".\"],\n    valueParser_notAfterClosing: [\"Logical not operator \\\"\", /* not */ \"\\\" after closing parenthesis.\"],\n    valueParser_binaryAfterOperator: [\"Binary operator \\\"\", /* binary */ \"\\\" after binary operator \\\"\", /* binary */ \"\\\".\"],\n    valueParser_binaryAfterOpening: [\"Binary operator \\\"\", /* binary */ \"\\\" after opening parenthesis.\"],\n    valueParser_openingAfterLiteral: [\"Opening parenthesis after literal \\\"\", /* literal */ \"\\\".\"],\n    valueParser_openingAfterReference: [\"Opening parenthesis after reference to column \\\"\", /* column */ \"\\\".\"],\n    valueParser_openingAfterClosing: [\"Opening parenthesis after closing parenthesis.\"],\n    valueParser_closingAfterOperator: [\"Closing parenthesis after binary operator \\\"\", /* binary */ \"\\\".\"],\n    valueParser_closingAfterOpening: [\"Closing parenthesis after opening parenthesis.\"],\n\n    stringUtils_missingClosingChar: [\"Missing '\", /* closing char */ \"' after opening '\", /* opening char */ \"'.\"],\n    stringUtils_charNotFound: [\"Expected \\\"\", /* char */ \"\\\" not found.\"],\n\n    renameNode_missingArrow: [\"Invalid renaming attempt, use the \\\"OldName -> NewName\\\" format separated by commas.\"],\n    renameNode_invalidNewName: [\"Invalid renaming attempt to \\\"\", /* name */\n        \"\\\". New column name must contain letters, numbers and underscores only and start with a letter or an underscore.\"],\n    renameNode_keywordNewName: [\"Invalid renaming attempt to \\\"\", /* name */ \"\\\". New column name cannot be a keyword.\"],\n    renameNode_multipleRenameOfTheColumn: [\"Multiple renaming attempts of column \\\"\", /* name */ \"\\\".\"],\n\n    selectionNode_resultNotBoolean: [\"Result of the selection condition \", /* condition */ \" is not a boolean value, but \", /* type */ \".\"],\n    thetaJoinNode_resultNotBoolean: [\"Result of the theta join condition \", /* condition */ \" is not a boolean value, but \", /* type */ \".\"],\n\n    comparingOperator_differentInputTypes: [\"Inputs for \\\"\", /* operator */ \"\\\"  have different types \", /* type */ \" and \", /* type */ \".\"],\n    computingOperator_inputTypesNotNumbers: [\"Inputs for \\\"\", /* operator */ \"\\\" are not both numbers, they are \", /* type */ \" and \", /* type */ \".\"],\n    logicalOperator_leftInputNotBoolean: [\"Left-hand input value for \\\"\", /* operator */ \"\\\" is not a boolean, but \", /* type */ \".\"],\n    logicalOperator_rightInputNotBoolean: [\"Right-hand input value for \\\"\", /* operator */ \"\\\" is not a boolean, but \", /* type */ \".\"]\n};\n\nexport const EN: LanguageDef = {\n    abbr: \"EN\",\n\n    relationErrors: {\n        emptyColumn: \"Column name cannot be empty\",\n        duplicitColumn: \"Duplicit column name\",\n        keywordColumn: \"Column name cannot be a keyword\",\n        invalidColumn: \"Invalid characters in a column name\",\n\n        unsupportedNull: \"Null values are not supported\",\n        invalidNumber: \"Given string is not a number\",\n        invalidBoolean: \"Given string is not a boolean\"\n    },\n\n    codeErrors: codeErrors,\n\n    semanticErrors: semanticErrors,\n    semanticError: \"Semantic error: \",\n\n    syntaxErrors: syntaxErrors,\n    syntaxError: \"Syntax error: \",\n\n    userMessages: {\n        loadedRelationsTotalNo: \"No relations loaded in the application at the moment.\",\n        loadedRelationsTotalSome: \" relations loaded at the moment: \",\n        loadRelationNew: \"Relation loaded to application.\",\n        loadAllRelationsNew: [/* number of loaded */ \" relations loaded to application, \", /* number of skipped */ \" skipped for errors.\"],\n        deleteLoadedRelations: \" relations deleted.\",\n\n        relationsExportOK: \"Relations saved.\",\n        relationsExportErr: \"Relations saving failed: \",\n        relationsImport: [/* number of loaded */ \" relations loaded, \", /* number of skipped */ \" files skipped.\"],\n\n        expressionsExportOK: \"Expressions saved.\",\n        expressionsExportErr: \"Expressions saving failed: \",\n        expressionsImport: [/* number of expressions */ \" expressions loaded from \", /* number of files */ \" files (\",\n        /* number of skipped expressions */ \" expressions skipped, \", /* number of skipped files */ \" files skipped).\"]\n    },\n\n    operations: {\n        selection: \"Selection\",\n        projection: \"Projection\",\n        rename: \"Rename\",\n        union: \"Union\",\n        intersection: \"Intersection\",\n        difference: \"Difference\",\n        naturalJoin: \"Natural join\",\n        cartesianProduct: \"Cartesian product\",\n        leftSemiJoin: \"Left semijoin\",\n        rightSemiJoin: \"Right semijoin\",\n        leftAntijoin: \"Left antijoin\",\n        rightAntijoin: \"Right antijoin\",\n        thetaJoin: \"Theta join\",\n        leftThetaSemiJoin: \"Left theta semijoin\",\n        rightThetaSemiJoin: \"Right theta semijoin\",\n        fullOuterJoin: \"Full outer join\",\n        leftOuterJoin: \"Left outer join\",\n        rightOuterJoin: \"Right outer join\",\n        division: \"Division\"\n    },\n\n    managementSection: {\n        batchTitle: \"Batch\",\n        batchLoad: \"Load projects\",\n        batchConfig: \"Load config\",\n        batchConfigInfo: [\"Configuration \", /* filename */ \" with \", /* rules count */ \" rules\"],\n        batchNoConfig: \"No configuration loaded\",\n\n        loadButton: \"Load\",\n        saveButton: \"Save\",\n        samplesButton: \"Samples\",\n        samplesMenuTitle: \"Sample projects\",\n        settingsButton: \"Settings\",\n        settingsNullValues: \"Null values\",\n        settingsNullValuesAllowed: \"allowed\",\n        settingsNullValuesForbidden: \"forbidden\",\n        settingsCSVSeparator: \"CSV separator\",\n        settingsCSVSeparatorSemicolon: \"semicolon\",\n        settingsCSVSeparatorComma: \"comma\",\n        settingsTheme: \"Theme\",\n        settingsThemeLight: \"light\",\n        settingsThemeDark: \"dark\",\n        settingsLanguage: \"Language\",\n        aboutButton: \"About\"\n    },\n\n    relationSection: {\n        relationSectionHeader: \"Relations\",\n        loadAllButton: \"Load all\",\n        loadAllButtonTooltip: \"Loads all valid relation into the application\",\n        removeLoadedButton: \"Remove loaded\",\n        removeLoadedButtonTooltip: \"Removes all the currently loaded relations\",\n        importButton: \"Import\",\n        importButtonTooltip: \"Adds new relations from files\",\n        exportButton: \"Export\",\n        exportButtonTooltip: \"Saves all stored relations to files\",\n        loadButton: \"Load\",\n        loadButtonTooltip: \"Loads the selected relation into the application\",\n        renameButton: \"Rename\",\n        deleteButton: \"Delete\",\n        deleteButtonTooltip: \"Deletes the selected relation\",\n        revertButton: \"Revert\",\n        revertButtonTooltip: \"Reverts the selected relation to the last loaded state\"\n    },\n\n    expressionSection: {\n        expressionSectionHeader: \"Expressions\",\n\n        importButton: \"Import\",\n        importButtonTooltip: \"Adds new expressions from a file\",\n        exportButton: \"Export\",\n        exportButtonTooltip: \"Saves expressions to a file\",\n\n        evaluateButton: \"Evaluate\",\n        evaluateButtonTooltip: \"Evaluates the selected expression\",\n        renameButton: \"Rename\",\n        deleteButton: \"Delete\",\n        deleteButtonTooltip: \"Deletes the selected expression\",\n\n        expressionTextareaPlaceholder: \"Write relational algebra expression here...\",\n\n        lineComment: \"Line comment\",\n        blockComment: \"Block comment\"\n    },\n\n    resultSection: {\n        resultSectionHeader: \"Result\",\n\n        exportEvalTreeButton: \"Export\",\n        exportEvalTreeButtonTooltip: \"Saves the evaluation tree as an image\",\n        evalTreeTitle: \"Evaluation tree of\",\n\n        resultRelationTitle: \"Result relation\",\n        intermediateRelationTitle: \"Intermediate relation\",\n        addButton: \"Add\",\n        addButtonTooltip: \"Adds the given relation between the stored ones\",\n        exportRelationButton: \"Export\",\n        exportRelationButtonTooltip: \"Saves the selected relation to a file\",\n    }\n}","import {LanguageDef} from \"./language\";\nimport {EN} from \"./en\";\nimport {SyntaxErrorMessages} from \"../error/raSyntaxError\";\nimport {SemanticErrorMessages} from \"../error/raSemanticError\";\n\n/**\n * Czech messages for RASemanticErrors mapped by their error codes.\n */\nconst semanticErrors: SemanticErrorMessages = {\n    exprParser_relationNotDefined: [\"Relace \\\"\", \"\\\" není definována. Zkontrolujte definice relací.\"],\n\n    binaryNode_commonColumns: [\"Vstupní relace pro \", \" mají společné sloupce \\\"\", \"\\\".\"],\n    setOperationNode_notEqualColumns: [\"Vstupní relace \\\"\", \"\\\" a \\\"\", \"\\\" pro \", \" množin nemají stejné schéma.\"],\n    divisionNode_rightColumnsNotSubset:\n        [\"Schéma pravé vstupní relace \\\"\", \"\\\" není podmnožinou schématu levé vstupní relace \\\"\", \"\\\".\"],\n    divisionNode_rightColumnsNotProperSubset:\n        [\"Schéma pravé vstupní relace \\\"\", \"\\\" není vlastní podmnožinou schématu levé vstupní relace \\\"\",\n        \". V levé relaci musí existovat sloupec, který neexistuje v pravé relaci.\"],\n    renameNode_absentOriginalColumn: [\"Nepovolené přejmenování, sloupec \\\"\", \"\\\" neexistuje ve vstupní relaci.\"],\n    renameNode_changeToDuplicit: [\"Nepovolené přejmenování, nový název sloupce \\\"\", \"\\\" je duplicitní ve změněné relaci.\"],\n    projectionNode_absentColumn: [\"Nepovolená projekce sloupce \\\"\", \"\\\". Tento sloupec neexistuje ve vstupní relaci.\"],\n    projectionNode_emptyProjection: [\"Nepovolená projekce, vždy musí být zachován alespoň jeden sloupec.\"],\n\n    referenceValue_absentColumn: [\"Sloupec \\\"\", \"\\\" neexistuje ve schématu se sloupci \", \".\"]\n};\n\n/**\n * Czech messages for RASyntaxErrors mapped by their error codes.\n */\nconst syntaxErrors: SyntaxErrorMessages = {\n    exprParser_emptyStringGiven: [\"Výraz nelze parsovat z prázdného řetězce.\"],\n    exprParser_outerJoinWhenNullNotSupported: [\"Nalezeno \", \", přestože null hodnoty jsou zakázány.\"],\n    exprParser_unexpectedPart: [\"Nečekaná část \\\"\", \"\\\" v RA výrazu.\"],\n    exprParser_bothBranchesError: [\"Všechny kombinace způsobují chybu v \\\"\", \"\\\". Považováno za projekci:\\n\",\n        \"\\nPovažováno za theta spojení:\\n\", \"\"],\n    exprParser_invalidExpression: [\"Daný výraz není korektní výraz relační algebry.\"],\n    exprParser_invalidParentheses: [\"Chybné uzávorkování ve výrazu.\"],\n    exprParser_invalidStart: [\"RA výraz nemůže začínat na \", \".\"],\n    exprParser_invalidEnd: [\"RA výraz nemůže končit na \", \".\"],\n    exprParser_relationAfterRelation: [\"Relace \\\"\", \"\\\" po relaci \\\"\", \"\\\".\"],\n    exprParser_relationAfterUnary: [\"Relace \\\"\", \"\\\" po unárním operátoru \\\"\", \"\\\".\"],\n    exprParser_relationAfterClosing: [\"Relace \\\"\", \"\\\" po uzavírací závorce.\"],\n    exprParser_unaryAfterBinary: [\"Unární operátor \\\"\", \"\\\" po binárním operátoru \\\"\", \"\\\".\"],\n    exprParser_unaryAfterOpening: [\"Unární operátor \\\"\", \"\\\" po otevírací závorce.\"],\n    exprParser_binaryAfterBinary: [\"Binární operátor \\\"\", \"\\\" po binárním operátoru \\\"\", \"\\\".\"],\n    exprParser_binaryAfterOpening: [\"Binární operátor \\\"\", \"\\\" po otevírací závorce.\"],\n    exprParser_openingAfterRelation: [\"Otevírací závorka po relaci \\\"\", \"\\\".\"],\n    exprParser_openingAfterUnary: [\"Otevírací závorka po unárním operátoru \\\"\", \"\\\".\"],\n    exprParser_openingAfterClosing: [\"Otevírací závorka po uzavírací závorce.\"],\n    exprParser_closingAfterBinary: [\"Uzavírací závorka po binárním operátoru \\\"\", \"\\\".\"],\n    exprParser_closingAfterOpening: [\"Uzavírací závorka po otevírací závorce.\"],\n\n    valueParser_emptyInput: [\"Jako podmínka nemůže být prázdný řetězec.\"],\n    valueParser_unsupportedNull: [\"Nalezena null konstanta, přestože null hodnoty jsou zakázány.\"],\n    valueParser_unexpectedPart: [\"Nečekaná část \\\"\", \"\\\" ve výrazu.\"],\n    valueParser_missingOpeningParenthesis: [\"Chybějící otevírací závorka ve výrazu.\"],\n    valueParser_missingClosingParenthesis: [\"Chybějící uzavírací závorka ve výrazu.\"],\n    valueParser_invalidExpression: [\"Daný výraz není korektní.\"],\n    valueParser_invalidStart: [\"Výraz nemůže začínat na \\\"\", \"\\\".\"],\n    valueParser_invalidEnd: [\"Výraz nemůže končit na \\\"\", \"\\\".\"],\n    valueParser_literalAfterLiteral: [\"Konstanta \\\"\", \"\\\" po konstantě \\\"\", \"\\\".\"],\n    valueParser_literalAfterReference: [\"Konstanta \\\"\", \"\\\" po referenci sloupce \\\"\", \"\\\".\"],\n    valueParser_literalAfterClosing: [\"Konstanta \\\"\", \"\\\" po uzavírací závorce.\"],\n    valueParser_referenceAfterLiteral: [\"Reference sloupce \\\"\", \"\\\" po konstantě \\\"\", \"\\\".\"],\n    valueParser_referenceAfterReference: [\"Reference sloupce \\\"\", \"\\\" po referenci sloupce \\\"\", \"\\\".\"],\n    valueParser_referenceAfterClosing: [\"Reference sloupce \\\"\", \"\\\" po uzavírací závorce.\"],\n    valueParser_notAfterLiteral: [\"Logická negace \\\"\", \"\\\" po konstantě \\\"\", \"\\\".\"],\n    valueParser_notAfterReference: [\"Logická negace \\\"\", \"\\\" po referenci sloupce \\\"\", \"\\\".\"],\n    valueParser_notAfterClosing: [\"Logická negace \\\"\", \"\\\" po uzavírací závorce.\"],\n    valueParser_binaryAfterOperator: [\"Binární operátor \\\"\", \"\\\" po binárním operátoru \\\"\", \"\\\".\"],\n    valueParser_binaryAfterOpening: [\"Binární operátor \\\"\", \"\\\" po otevírací závroce.\"],\n    valueParser_openingAfterLiteral: [\"Otevírací závorka po konstantě \\\"\", \"\\\".\"],\n    valueParser_openingAfterReference: [\"Otevírací závorka po referenci sloupce \\\"\", \"\\\".\"],\n    valueParser_openingAfterClosing: [\"Otevírací závorka po uzavírací závorce.\"],\n    valueParser_closingAfterOperator: [\"Uzavírací závorka po binárním operátoru \\\"\", \"\\\".\"],\n    valueParser_closingAfterOpening: [\"Uzavírací závorka po otevírací závroce.\"],\n\n    stringUtils_missingClosingChar: [\"Chybějící '\", \"' po úvodní '\", \"'.\"],\n    stringUtils_charNotFound: [\"Očekávaný znak \\\"\", \"\\\" nenalezen.\"],\n\n    renameNode_missingArrow: [\"Chybné přejmenování, použijte formát \\\"StarýNázev -> NovýNázev\\\" oddělený čárkami.\"],\n    renameNode_invalidNewName: [\"Chybné přejmenování na \\\"\",\n        \"\\\". Nový název sloupce musí obsahovat pouze písmena, čísla a podtržítka a začínat písmenem nebo podtržítkem.\"],\n    renameNode_keywordNewName: [\"Chybné přejmenování na \\\"\", \"\\\". Nový název nemůže být klíčové slovo.\"],\n    renameNode_multipleRenameOfTheColumn: [\"Vícenásobné přejmenování sloupce \\\"\", \"\\\".\"],\n\n    selectionNode_resultNotBoolean: [\"Výsledek podmínky v selekci \", \" není boolean, ale \", \".\"],\n    thetaJoinNode_resultNotBoolean: [\"Výsledek podmínky v theta joinu \", \" není boolean, ale \", \".\"],\n\n    comparingOperator_differentInputTypes: [\"Vstupy pro \\\"\", \"\\\" nemají stejné typy, ale \", \" a \", \".\"],\n    computingOperator_inputTypesNotNumbers: [\"Vstupy pro \\\"\", \"\\\" nejsou čísla, ale \", \" a \", \".\"],\n    logicalOperator_leftInputNotBoolean: [\"Levý vstup logického operátoru \\\"\", \"\\\" není boolean, ale \", \".\"],\n    logicalOperator_rightInputNotBoolean: [\"Pravý vstup logického operátoru \\\"\", \"\\\" není boolean, ale \", \".\"],\n};\n\nexport const CS: LanguageDef = {\n    abbr: \"CS\",\n\n    relationErrors: {\n        emptyColumn: \"Název sloupce nemůže být prázdný\",\n        duplicitColumn: \"Duplicitní název sloupce\",\n        keywordColumn: \"Název sloupce nemůže být klíčové slovo\",\n        invalidColumn: \"Nepovolené znaky v názvu sloupce\",\n\n        unsupportedNull: \"Null hodonoty nejsou podporovány\",\n        invalidNumber: \"Daný řetězec není číslo\",\n        invalidBoolean: \"Daný řetězec není boolean\",\n    },\n\n    codeErrors: EN.codeErrors,\n\n    semanticErrors: semanticErrors,\n    semanticError: \"Sémantická chyba: \",\n\n    syntaxErrors: syntaxErrors,\n    syntaxError: \"Syntaktická chyba: \",\n\n    userMessages: {\n        loadedRelationsTotalNo: \"Nyní nejsou v aplikaci nahrané žádné relace.\",\n        loadedRelationsTotalSome: \" relací celkově nahráno v aplikaci: \",\n        loadRelationNew: \"Relace nahrána do aplikace.\",\n        loadAllRelationsNew: [/* number of loaded */ \" relací nahráno do aplikace, \", /* number of skipped */ \" přeskočeno kvůli chybám.\"],\n        deleteLoadedRelations: \" relací odebráno.\",\n\n        relationsExportOK: \"Relace staženy.\",\n        relationsExportErr: \"Stahování relací selhalo: \",\n        relationsImport: [\" relací nahráno, \", \" souborů přeskočeno.\"],\n\n        expressionsExportOK: \"Výrazy staženy do souboru.\",\n        expressionsExportErr: \"Stahování výrazů selhalo: \",\n        expressionsImport: [/* number of expressions */ \" výrazů nahráno z \", /* number of files */ \" souborů (\",\n            /* number of skipped expressions */ \" výrazů přeskočeno, \", /* number of skipped files */ \" souborů přeskočeno).\"]\n    },\n\n    operations: {\n        selection: \"Selekce\",\n        projection: \"Projekce\",\n        rename: \"Přejmenování\",\n        union: \"Sjednocení\",\n        intersection: \"Průnik\",\n        difference: \"Rozdíl\",\n        naturalJoin: \"Přirozené spojení\",\n        cartesianProduct: \"Kartézský součin\",\n        leftSemiJoin: \"Levé vnitřní spojení\",\n        rightSemiJoin: \"Pravé vnitřní spojení\",\n        leftAntijoin: \"Levý antijoin\",\n        rightAntijoin: \"Pravý antijoin\",\n        thetaJoin: \"Theta spojení\",\n        leftThetaSemiJoin: \"Levé theta spojení\",\n        rightThetaSemiJoin: \"Pravé theta spojení\",\n        fullOuterJoin: \"Plné vnější spojení\",\n        leftOuterJoin: \"Levé vnější spojení\",\n        rightOuterJoin: \"Pravé vnější spojení\",\n        division: \"Dělení\"\n    },\n\n    managementSection: {\n        batchTitle: \"Batch\",\n        batchLoad: \"Nahrát projekty\",\n        batchConfig: \"Konfigurovat\",\n        batchConfigInfo: [\"Konfigurace \", /* filename */ \" s \", /* rules count */ \" pravidly\"],\n        batchNoConfig: \"Není nahrána žádná konfigurace\",\n\n        loadButton: \"Nahrát\",\n        saveButton: \"Uložit\",\n\n        samplesButton: \"Ukázky\",\n        samplesMenuTitle: \"Připravené vzorové projekty\",\n        settingsButton: \"Nastavení\",\n        settingsNullValues: \"Null hodnoty\",\n        settingsNullValuesAllowed: \"povoleny\",\n        settingsNullValuesForbidden: \"zakázány\",\n        settingsCSVSeparator: \"CSV oddělovač\",\n        settingsCSVSeparatorSemicolon: \"středník\",\n        settingsCSVSeparatorComma: \"čárka\",\n        settingsTheme: \"Režim\",\n        settingsThemeLight: \"světlý\",\n        settingsThemeDark: \"tmavý\",\n        settingsLanguage: \"Jazyk\",\n        aboutButton: \"O aplikaci\"\n    },\n\n    relationSection: {\n        relationSectionHeader: \"Relace\",\n        loadAllButton: \"Nahrát všechny\",\n        loadAllButtonTooltip: \"Nahraje všechny bezchybné relace do aplikace\",\n        removeLoadedButton: \"Odebrat nahrané\",\n        removeLoadedButtonTooltip: \"Odebere všechny nahrané relace z aplikace\",\n        importButton: \"Import\",\n        importButtonTooltip: \"Nahraje nové relace ze souborů\",\n        exportButton: \"Export\",\n        exportButtonTooltip: \"Stáhne editované relace do souborů\",\n        loadButton: \"Nahrát\",\n        loadButtonTooltip: \"Nahraje relaci do aplikace\",\n        renameButton: \"Přejmenovat\",\n        deleteButton: \"Odstranit\",\n        deleteButtonTooltip: \"Odstraní vybranou relaci\",\n        revertButton: \"Obnovit\",\n        revertButtonTooltip: \"Obnoví relaci do posledního nahraného stavu\"\n    },\n\n    expressionSection: {\n        expressionSectionHeader: \"Výrazy\",\n\n        importButton: \"Import\",\n        importButtonTooltip: \"Nahraje nové výrazy ze souboru\",\n        exportButton: \"Export\",\n        exportButtonTooltip: \"Stáhne výrazy do souboru\",\n\n        evaluateButton: \"Vyhodnotit\",\n        evaluateButtonTooltip: \"Vyhodnotí vybraný relační výraz\",\n        renameButton: \"Přejmenovat\",\n        deleteButton: \"Odstranit\",\n        deleteButtonTooltip: \"Odstraní vybraný relační výraz\",\n\n        expressionTextareaPlaceholder: \"Zde napište svůj relační výraz...\",\n\n        lineComment: \"Řádkový komentář\",\n        blockComment: \"Blokový komentář\"\n    },\n\n    resultSection: {\n        resultSectionHeader: \"Výsledek\",\n\n        exportEvalTreeButton: \"Export\",\n        exportEvalTreeButtonTooltip: \"Uloží evaluační strom jako obrázek\",\n        evalTreeTitle: \"Evaluační strom pro\",\n\n        resultRelationTitle: \"Výsledná relace\",\n        intermediateRelationTitle: \"Mezivýsledná relace\",\n        addButton: \"Přidat\",\n        addButtonTooltip: \"Přidá zvolenou relaci mezi editované\",\n        exportRelationButton: \"Export\",\n        exportRelationButtonTooltip: \"Stáhne zvolenou relaci do souboru\",\n    }\n}","import {ErrorWithTextRange} from \"./errorWithTextRange\";\nimport {language} from \"../language/language\";\nimport {StartEndPair} from \"../types/startEndPair\";\n\n/**\n * Messages for {@link RASyntaxError}.\n * The description is a string array - between its members are inserted error parameters (names of invalid relations,\n * invalid input parts, etc.). See english language definition for expected structure of each error description.\n * @category Errors\n * @public\n */\nexport interface SyntaxErrorMessages {\n    // expects 1 part\n    exprParser_emptyStringGiven: string[],\n    // expects 2 parts\n    exprParser_outerJoinWhenNullNotSupported: string[],\n    // expects 2 parts\n    exprParser_unexpectedPart: string[],\n    // expects 4 parts\n    exprParser_bothBranchesError: string[],\n    // expects 1 part\n    exprParser_invalidExpression: string[],\n    // expects 1 part\n    exprParser_invalidParentheses: string[],\n    // expects 2 parts\n    exprParser_invalidStart: string[],\n    // expects 2 parts\n    exprParser_invalidEnd: string[],\n    // expects 3 parts\n    exprParser_relationAfterRelation: string[],\n    // expects 3 parts\n    exprParser_relationAfterUnary: string[],\n    // expects 2 parts\n    exprParser_relationAfterClosing: string[],\n    // expects 3 parts\n    exprParser_unaryAfterBinary: string[],\n    // expects 2 parts\n    exprParser_unaryAfterOpening: string[],\n    // expects 3 parts\n    exprParser_binaryAfterBinary: string[],\n    // expects 2 parts\n    exprParser_binaryAfterOpening: string[],\n    // expects 2 parts\n    exprParser_openingAfterRelation: string[],\n    // expects 2 parts\n    exprParser_openingAfterUnary: string[],\n    // expects 1 part\n    exprParser_openingAfterClosing: string[],\n    // expects 2 parts\n    exprParser_closingAfterBinary: string[],\n    // expects 1 part\n    exprParser_closingAfterOpening: string[],\n\n    // expects 1 part\n    valueParser_emptyInput: string[],\n    // expects 1 part\n    valueParser_unsupportedNull: string[],\n    // expects 2 parts\n    valueParser_unexpectedPart: string[],\n    // expects 1 part\n    valueParser_missingOpeningParenthesis: string[],\n    // expects 1 part\n    valueParser_missingClosingParenthesis: string[],\n    // expects 1 part\n    valueParser_invalidExpression: string[],\n    // expects 2 parts\n    valueParser_invalidStart: string[],\n    // expects 2 parts\n    valueParser_invalidEnd: string[],\n    // expects 3 parts\n    valueParser_literalAfterLiteral: string[],\n    // expects 3 parts\n    valueParser_literalAfterReference: string[],\n    // expects 2 parts\n    valueParser_literalAfterClosing: string[],\n    // expects 3 parts\n    valueParser_referenceAfterLiteral: string[],\n    // expects 3 parts\n    valueParser_referenceAfterReference: string[],\n    // expects 2 parts\n    valueParser_referenceAfterClosing: string[],\n    // expects 3 parts\n    valueParser_notAfterLiteral: string[],\n    // expects 3 parts\n    valueParser_notAfterReference: string[],\n    // expects 2 parts\n    valueParser_notAfterClosing: string[],\n    // expects 3 parts\n    valueParser_binaryAfterOperator: string[],\n    // expects 2 parts\n    valueParser_binaryAfterOpening: string[],\n    // expects 2 parts\n    valueParser_openingAfterLiteral: string[],\n    // expects 2 parts\n    valueParser_openingAfterReference: string[],\n    // expects 1 part\n    valueParser_openingAfterClosing: string[],\n    // expects 2 parts\n    valueParser_closingAfterOperator: string[],\n    // expects 1 part\n    valueParser_closingAfterOpening: string[],\n\n    // expects 3 parts\n    stringUtils_missingClosingChar: string[],\n    // expects 2 parts\n    stringUtils_charNotFound: string[],\n\n    // expects 1 part\n    renameNode_missingArrow: string[],\n    // expects 2 parts\n    renameNode_invalidNewName: string[],\n    // expects 2 parts\n    renameNode_keywordNewName: string[],\n    // expects 2 parts\n    renameNode_multipleRenameOfTheColumn: string[],\n\n    // expects 3 parts\n    selectionNode_resultNotBoolean: string[],\n    // expects 3 parts\n    thetaJoinNode_resultNotBoolean: string[],\n\n    // expects 4 parts\n    comparingOperator_differentInputTypes: string[],\n    // expects 4 parts\n    computingOperator_inputTypesNotNumbers: string[],\n    // expects 3 parts\n    logicalOperator_leftInputNotBoolean: string[],\n    // expects 3 parts\n    logicalOperator_rightInputNotBoolean: string[]\n}\n\n/**\n * Syntax error in an expression structure.\n * @extends ErrorWithTextRange\n * @category Errors\n * @public\n */\nexport class RASyntaxError extends ErrorWithTextRange {\n    /**\n     * Creates a new RASyntaxError with the given message.\n     *\n     * @param msg error message {@type string}\n     * @param range optional text range of the error {@type StartEndPair?}\n     * @public\n     */\n    constructor(msg: string, range: StartEndPair | undefined) {\n        super(language().syntaxError + msg, range);\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, RASyntaxError);\n        }\n        this.name = 'RASyntaxError';\n    }\n}","import {ErrorWithTextRange} from \"./errorWithTextRange\";\nimport {language} from \"../language/language\";\nimport {StartEndPair} from \"../types/startEndPair\";\n\n/**\n * Messages for {@type RASemanticError}.\n * The description is a string array - between its members are inserted error parameters (names of invalid relations,\n * invalid input parts, etc.). See english language definition for expected structure of each error description.\n * @category Errors\n * @public\n */\nexport interface SemanticErrorMessages {\n    // expects 2 parts\n    exprParser_relationNotDefined: string[],\n\n    // expects 3 parts\n    binaryNode_commonColumns: string[],\n    // expects 4 parts\n    setOperationNode_notEqualColumns: string[],\n    // expects 3 parts\n    divisionNode_rightColumnsNotSubset: string[],\n    // expects 3 parts\n    divisionNode_rightColumnsNotProperSubset: string[],\n    // expects 2 parts\n    renameNode_absentOriginalColumn: string[],\n    // expects 2 parts\n    renameNode_changeToDuplicit: string[],\n    // expects 2 parts\n    projectionNode_absentColumn: string[],\n    // expects part\n    projectionNode_emptyProjection: string[],\n\n    // expects 3 parts\n    referenceValue_absentColumn: string[]\n}\n\n/**\n * Semantic error in an expression structure.\n * @extends ErrorWithTextRange\n * @category Errors\n * @public\n */\nexport class RASemanticError extends ErrorWithTextRange {\n    /**\n     * Creates a new RASemanticError with the given message.\n     *\n     * @param msg error message {@type string}\n     * @param range optional text range of the error {@type StartEndPair?}\n     * @public\n     */\n    constructor(msg: string, range: StartEndPair | undefined) {\n        super(language().semanticError + msg, range);\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, RASemanticError);\n        }\n        this.name = 'RASemanticError';\n    }\n}","/**\n * Computes width (average on sample of characters) and its height of the given font with given size in pixels.\n *\n * @param fontFamily font to use {@type string}\n * @param fontSize size to use {@type string}\n * @return average width and height of the given font {@type {{fontWidth: number, fontHeight: number}}}\n * @category Utils\n * @public\n */\nexport function computeFontSizeInPx(fontFamily: string, fontSize: string): {fontWidth: number, fontHeight: number} {\n    const text: string = \"0123456789qwertyuiopasdfghjkllzxcvbnmQWERTYUIOOPASDFGHJKLLZXCVBNM!@#$%^&*()_+[];',./\";\n    const div = document.createElement(\"div\");\n    div.setAttribute('style', `font-family: ${fontFamily}; font-size: ${fontSize}; position: absolute; white-space: nowrap;`);\n    div.innerText = text;\n    document.documentElement.appendChild(div);\n    const divWidth: number = div.clientWidth;\n    const divHeight: number = div.clientHeight;\n    div.remove();\n    return { fontWidth: divWidth / text.length, fontHeight: divHeight };\n}","/**\n * Returns start index of the word before the given index in the given string.\n *\n * @param str string to search in {@type string}\n * @param index index before which the word starts {@type number}\n * @return start index of the word before the given index in the given string {@type number}\n * @category Utils\n * @public\n */\nexport function getStartOfWordBeforeIndex(str: string, index: number): number {\n    const prefixText: string = str.slice(0, index);\n    let i: number = prefixText.length - 1;\n    while (true) {\n        // if non-name-character is reached\n        if (!prefixText.charAt(i).match(/\\w/)) {\n            ++i;\n            break;\n        }\n        if (i === 0) {\n            break;\n        }\n        --i;\n    }\n    return i;\n}\n\n/**\n * Returns sorted given array of whispers with respect to given last word before cursor.\n * Matched word parts in the whispers are highlighted by CSS span. Not-matched words are made grey.\n *\n * @param whispers whispers to sort (not modified) {@type string[]}\n * @param wordBeforeCursor string to use for sorting {@type string}\n * @return sorted whispers {@type string[]}\n * @category Utils\n * @public\n */\nexport function sortWhispers(whispers: string[], wordBeforeCursor: string): string[] {\n    // values for sorting whispers\n    const startsWithWord: number = 2;\n    const containsWord: number = 1;\n    // creates help array with whisper likelihoods and highlighted matched parts\n    const helpArray: {whisper: string, likelihood: number}[] = whispers.map(whisper => {\n        let likelihood = 0;\n        const wordStart = whisper.toLowerCase().indexOf(wordBeforeCursor.toLowerCase());\n        if (wordStart > -1) {\n            likelihood += wordStart === 0 ? startsWithWord : containsWord;\n            const wordEnd = wordStart + wordBeforeCursor.length;\n            whisper = whisper.slice(0, wordStart) + \"<span class='whisper-matched-word'>\" +\n                whisper.slice(wordStart, wordEnd) + \"</span>\" + whisper.slice(wordEnd);\n        }\n        if (likelihood === 0) {\n            whisper = \"<span class='whisper-rejected-word'>\" + whisper + \"</span>\"\n        }\n        return {whisper, likelihood};\n    });\n    if (wordBeforeCursor !== \"\") {\n        helpArray.sort((x, y) => y.likelihood - x.likelihood);\n    }\n    return helpArray.map(help => help.whisper);\n}","import React from \"react\";\nimport './css/xTextArea.css';\nimport {mod} from \"../utils/math\";\nimport {computeFontSizeInPx} from \"../utils/fontUtils\";\nimport {getStartOfWordBeforeIndex} from \"../utils/whisperUtils\";\nimport {StartEndPair} from \"../types/startEndPair\";\n\n/**\n * Description of an error located in the input text.\n * @category Components\n * @public\n */\nexport interface LocatedError {\n    /**\n     * index of the first error character\n     * @type number\n     * @public\n     */\n    start: number,\n    /**\n     * index of the last error character\n     * @type number\n     * @public\n     */\n    end: number,\n    /**\n     * error message\n     * @type string\n     * @public\n     */\n    msg: string\n}\n\n/**\n * Props of XTextArea component.\n * @category Components\n * @public\n */\ninterface XTextAreaProps {\n    /**\n     * id of the component\n     * @type string\n     * @public\n     */\n    id: string;\n    /**\n     * current text content of the textarea\n     * @type string\n     * @public\n     */\n    text: string;\n    /**\n     * text to be shown as textarea placeholder\n     * @type string\n     * @public\n     */\n    placeholder: string;\n    /**\n     * error messages and ranges to be highlighted in text area\n     * @type LocatedError[]\n     * @public\n     */\n    errors: LocatedError[];\n    /**\n     * pairs of parentheses\n     * @type StartEndPair[]\n     * @public\n     */\n    parentheses: StartEndPair[];\n    /**\n     * strings whispered to the user to be added at the current position\n     * @type string[]\n     * @public\n     */\n    whispers: string[];\n    /**\n     * handler of text change\n     * @type function\n     * @public\n     */\n    onChange: (text: string, cursorIndex: number) => void;\n    /**\n     * handler of input with Ctrl key\n     * @type function\n     * @public\n     */\n    onCtrlInput: (ev: KeyboardEvent) => void;\n    /**\n     * true if dark theme should be applied\n     * @type boolean\n     * @public\n     */\n    darkTheme: boolean;\n}\n\ninterface XTextAreaState {}\n\n/**\n * HTMLTextAreaElement extended for painting number lines, inserting strings given from parent and whispering.\n */\ntype ExtendedHTMLTextArea = HTMLTextAreaElement & {\n    /**\n     * (Re)paints line numbers next to textarea.\n     *\n     * @param darkTheme style to be applied to numbers\n     */\n    paintLineNumbers: (darkTheme: boolean) => void,\n    // reference to canvas element used to paint line numbers\n    canvasLines: HTMLCanvasElement,\n    // true when the mouse button is clicked down\n    mouseIsDown: boolean,\n\n    /**\n     * Updates textarea content to the given value. Updates number of lines.\n     */\n    update: (value: string, darkTheme: boolean) => void,\n    // number of lines in the textarea\n    linesCount: number,\n\n    /**\n     * Whispers given array of strings to the user at the current cursor position.\n     *\n     * @param toWhisper\n     */\n    createWhisper: (whispers: string[]) => void,\n    /**\n     * Moves the WhisperDiv to be located next to the current cursor position.\n     * The WhisperDiv is moved only if the whisperDiv.isShown is true.\n     */\n    moveWhisper: () => void,\n    /**\n     * Hides the WhisperDiv (whisperDiv.isShown is set to false).\n     */\n    hideWhisper: () => void,\n    /**\n     * Inserts current selected whisper.\n     *\n     * @param onChange callback to the parent after text change\n     */\n    insertCurrentSelectedWhisper: () => void,\n    // true when the whisper should not be shown automatically (e.g., after pressing Enter)\n    notAutoShowWhisper: boolean,\n    // reference to whisper div\n    whisperDiv: WhisperDiv,\n\n    /**\n     * Creates error div elements for given ranges.\n     */\n    updateErrors: (ranges: LocatedError[]) => void,\n    /**\n     * Moves error div elements to current position.\n     */\n    moveErrors: () => void,\n    // div elements for highlighting errors\n    errorDivs: ErrorDiv[],\n\n    /**\n     * Creates parentheses div elements for parentheses next to the cursor.\n     */\n    updateParentheses: () => void,\n    /**\n     * Moves parentheses div elements to current position.\n     */\n    moveParentheses: () => void,\n    // positions of parentheses pairs in text\n    parentheses: StartEndPair[],\n    // div elements for highlighting parentheses\n    parenthesesDivs: ParenthesesDiv[],\n\n    /**\n     * Insert given pair of symbols at the cursor position. If a part of text is selected, it inserts the first symbol\n     * before it and the second symbol after it.\n     */\n    insertPairSymbol: (first: string, second: string) => void,\n    /**\n     * Deletes characters before and after the cursor if the adjacent characters are pair symbols: (), [], <>, \"\".\n     * If the pair was deleted, returns true, otherwise returns false.\n     */\n    checkPairSymbolDelete: () => boolean\n};\n\n/**\n * HTMLDivElement extended by functions for easy whispering.\n */\ntype WhisperDiv = HTMLDivElement & {\n    // true when the whisper should be shown\n    isShown: boolean,\n    // index of the selected whisper\n    selectedIndex: number,\n    /**\n     * Updates selected whisper by given difference. Removes highlights from previous highlighted whisper and\n     * highlights the new selected. The new index is modulo actual whisper count. The function does nothing, when\n     * there no whispers at the moment.\n     *\n     * @param indexDiff\n     */\n    changeSelected: (indexDiff: number) => void,\n    /**\n     * Updates selected whisper to given index. Removes highlights from previous highlighted whisper and\n     * highlights the new selected. The new index is modulo actual whisper count. The function does nothing, when\n     * there no whispers at the moment.\n     *\n     * @param newIndex\n     */\n    setSelected: (newIndex: number) => void,\n    /**\n     * Returns current selected whisper or undefined, when no whisper is selected.\n     */\n    getSelectedWhisper: () => string | undefined\n};\n\n/**\n * HTMLDivElement extended by data for error highlighting.\n */\ntype ErrorDiv = HTMLDivElement & {\n    startLine: number,\n    startColumn: number,\n    rangeLength: number,\n    messageSpan: HTMLSpanElement\n}\n\n/**\n * HTMLDivElement extended by data for parentheses highlighting.\n */\ntype ParenthesesDiv = HTMLDivElement & {\n    startLine: number,\n    startColumn: number\n}\n\n// @ts-ignore\nconst cssConstants: CSSStyleDeclaration = getComputedStyle(document.querySelector(':root'));\n\nconst fontSize: string = cssConstants.getPropertyValue('--x-textarea-font-size');\nconst fontFamily: string = cssConstants.getPropertyValue('--x-textarea-font-family');\nconst {fontWidth} = computeFontSizeInPx(fontFamily, fontSize);\nconst lineHeight: number = Number(cssConstants.getPropertyValue('--x-textarea-line-height'));\nconst numsBackgroundLight: string = cssConstants.getPropertyValue('--light-color-b');\nconst numsBackgroundDark: string = cssConstants.getPropertyValue('--dark-color-b');\nconst numsColorLight: string = cssConstants.getPropertyValue('--text-color-light');\nconst numsColorDark: string = cssConstants.getPropertyValue('--text-color-dark');\nconst canvasWidth: number = 24;\n\n/**\n * TextArea extended by line numbers and text highlighting. The component is maintained by JavaScript HTML functions,\n * not by React.\n * Accepts {@link XTextAreaProps} props.\n * @category Components\n * @public\n */\nexport class XTextArea extends React.Component<XTextAreaProps, XTextAreaState> {\n    // @ts-ignore - always set before usage in componentDidMount\n    private textarea: ExtendedHTMLTextArea;\n\n    /**\n     * Returns current text area selection start and end.\n     * @return current text area selection start and end {@type StartEndPair}\n     * @public\n     */\n    public getSelection(): StartEndPair {\n        return {start: this.textarea.selectionStart, end: this.textarea.selectionEnd};\n    }\n\n    /**\n     * Sets text area selection start and end. If end is not given, start value is used as end value as well.\n     *\n     * @param start start index {@type number}\n     * @param end end index {@type number}\n     * @public\n     */\n    public setSelection(start: number, end?: number): void {\n        this.textarea.setSelectionRange(start, end ? end : start);\n    }\n\n    /**\n     * Returns true if the textarea has focus.\n     * @return true if the textarea has focus {@type boolean}\n     * @public\n     */\n    public isFocused(): boolean {\n        return document.activeElement !== null && document.activeElement.id === this.props.id + '-ta';\n    }\n\n    /**\n     * The text area gains focus in the window.\n     * @public\n     */\n    public focus(): void {\n        this.textarea.focus();\n    }\n\n    /**\n     * Sets the given placeholder in the textarea.\n     * @param placeholder placeholder to be set\n     * @public\n     */\n    public setPlaceholder(placeholder: string): void {\n        this.textarea.placeholder = placeholder;\n    }\n\n    /**\n     * The component is build by JavaScript HTML functions after mount of the empty div in render function.\n     */\n    componentDidMount() {\n        const props: Readonly<XTextAreaProps> = this.props;\n        // @ts-ignore - gets parent div\n        const div: HTMLDivElement = document.getElementById(props.id);\n\n        // LAYOUT (table with 1 row and 2 columns)\n        const table = document.createElement('table');\n        table.setAttribute('cellspacing','0');\n        table.setAttribute('cellpadding','0');\n        table.classList.add('x-textarea-table');\n        const tr = document.createElement('tr');\n        const td1 = document.createElement('td');\n        td1.setAttribute('id', props.id + '-td1');\n        td1.classList.add('x-textarea-table-td1');\n        const td2 = document.createElement('td');\n        td2.classList.add('x-textarea-table-td2');\n        tr.appendChild(td1);\n        tr.appendChild(td2);\n        table.appendChild(tr);\n\n        // TEXTAREA\n        // @ts-ignore - extended later in componentDidMount\n        const ta: ExtendedHTMLTextArea = document.createElement('textarea');\n        ta.setAttribute('id', props.id + '-ta');\n        ta.setAttribute('spellcheck', 'false');\n        ta.mouseIsDown = false;\n        ta.setAttribute('placeholder', this.props.placeholder);\n        ta.classList.add('x-textarea', 'scrollbar-container');\n        ta.value = props.text;\n\n        // TEXTAREA NUMBERS (Canvas)\n        const canvas = document.createElement('canvas');\n        canvas.width = canvasWidth + 4;    // must not set width & height in css !!!\n        canvas.classList.add('x-textarea-canvas');\n        ta.canvasLines = canvas;\n        td1.appendChild(canvas);\n        td2.appendChild(ta);\n        div.appendChild(table);\n\n        // TEXTAREA WHISPER DIV\n        // @ts-ignore - extended later in componentDidMount\n        const whisperDiv: WhisperDiv = document.createElement('div');\n        whisperDiv.classList.add('whisper-div');\n        whisperDiv.isShown = false;\n        whisperDiv.selectedIndex = -1;\n        whisperDiv.changeSelected = function (indexDiff: number) {\n            this.setSelected(this.selectedIndex + indexDiff);\n        }\n        whisperDiv.setSelected = function (newIndex: number) {\n            if (this.childElementCount > 0) {\n                // removes selected highlight from previous selected whisper (if it is valid)\n                if (this.selectedIndex > -1 && this.selectedIndex < this.childElementCount) {\n                    this.children[this.selectedIndex].classList.remove(\"selected-whisper\");\n                }\n                // updates the index modulo child count\n                this.selectedIndex = mod(newIndex, this.childElementCount);\n                // adds selected highlight\n                this.children[this.selectedIndex].classList.add(\"selected-whisper\");\n            }\n        }\n        whisperDiv.getSelectedWhisper = function (): string | undefined {\n            if (this.selectedIndex > -1 && this.childElementCount > 0) {\n                // @ts-ignore\n                return this.children[this.selectedIndex].innerText;\n            }\n            return undefined;\n        }\n        ta.whisperDiv = whisperDiv;\n        td2.appendChild(whisperDiv);\n\n        // Line numbers rendering inspired by: https://www.w3schools.com/code/tryit.asp?filename=G68VMFWS12UH,\n        // Nikola Bozovic, nigerija@gmail.com\n        ta.paintLineNumbers = function(darkTheme: boolean): void {\n            try {\n                const canvas = this.canvasLines;\n                if (canvas.height !== this.clientHeight) {\n                    canvas.height = this.clientHeight; // on resize\n                }\n                // @ts-ignore\n                const ctx: CanvasRenderingContext2D = canvas.getContext(\"2d\");\n                ctx.fillStyle = darkTheme ? numsBackgroundDark : numsBackgroundLight;\n                ctx.fillRect(0, 0, canvasWidth + 2, this.scrollHeight + 1);\n                ctx.fillStyle = darkTheme ? numsColorDark : numsColorLight;\n                ctx.font = fontSize + \" \" + fontFamily;\n                for (let i = 0; i < this.linesCount; i++) {\n                    const text = \"\" + (i + 1);  // line number\n                    ctx.fillText(text,canvasWidth - (text.length * 8), 19 + (i * lineHeight));\n                }\n            }\n            catch(e) {\n                console.log('XTextArea paintLineNumbers error: ' + e);\n            }\n        };\n\n        ta.update = function (value: string, darkTheme: boolean) {\n            this.value = value;\n            // computes lines count\n            let lines: number = 1;\n            for (let i = 0; i < value.length; ++i) {\n                if (value.charAt(i) === \"\\n\") {\n                    ++lines;\n                }\n            }\n            this.linesCount = lines;\n            // set height to fit all lines\n            this.style.height = (lines * lineHeight + 8) + \"px\";\n            // if the horizontal scrollbar is visible, fits it into the height\n            if (this.scrollHeight > this.clientHeight) {\n                this.style.height = (this.scrollHeight + lineHeight + 10) + \"px\";\n            }\n            this.paintLineNumbers(darkTheme);\n            this.updateParentheses();\n        }\n\n        ta.createWhisper = function (whispers: string[]): void {\n            if (whispers.length === 0) {\n                this.hideWhisper();\n            }\n            else {\n                this.whisperDiv.innerHTML = \"\";\n                whispers.forEach((whisper, i) => {\n                    const div = document.createElement(\"div\");\n                    div.innerHTML = whisper;\n                    div.onclick = event => {\n                        this.focus();\n                        this.whisperDiv.setSelected(i);\n                        event.stopPropagation();\n                    };\n                    div.ondblclick = event => {\n                        this.focus();\n                        this.insertCurrentSelectedWhisper();\n                        this.notAutoShowWhisper = true;\n                        event.stopPropagation();\n                    };\n                    this.whisperDiv.appendChild(div);\n                });\n                // selects the first whisper after change\n                this.whisperDiv.setSelected(0);\n                // needs to be set to true before moveWhisper call\n                this.whisperDiv.isShown = true;\n                // sets the div position\n                this.moveWhisper();\n            }\n        }\n\n        ta.moveWhisper = function () {\n            // updates only if the whisper is shown\n            if (this.whisperDiv.isShown) {\n                // finds cursor position in the whole string\n                const cursorLineAndColumn = getPositionLineAndColumn(this.value, this.selectionEnd);\n                // computes position of the bottom end of the cursor relative to the text\n                const cursorDistanceFromTATotalTop: number = (cursorLineAndColumn.line + 1) * lineHeight;\n                const cursorDistanceFromTATotalLeft: number = cursorLineAndColumn.column * fontWidth;\n                const yPos: number = cursorDistanceFromTATotalTop - this.scrollTop;\n                const xPos: number = cursorDistanceFromTATotalLeft - this.scrollLeft + 4;\n                // shows the div at computed position if the cursor is visible\n                if (0 <= yPos && yPos < this.clientHeight && 0 <= xPos && xPos < this.clientWidth) {\n                    // if the div is in the upper part of the screen, shows it under the cursor\n                    if (this.getBoundingClientRect().y + yPos <= window.innerHeight / 2) {\n                        this.whisperDiv.setAttribute('style', `display: block; top: ${yPos + 4}px; left: ${xPos}px;`);\n                    }\n                    // if the div is in the lower part of the screen, shows it above the cursor\n                    else {\n                        this.whisperDiv.setAttribute('style',\n                            `display: block; bottom: ${this.getBoundingClientRect().height - yPos + lineHeight}px; left: ${xPos}px;`);\n                    }\n                }\n                // hides the div if the cursor is not visible (but DOES NOT SET whisperDiv.isShown to false to re-appear it again)\n                else {\n                    this.whisperDiv.setAttribute('style', `display: none;`);\n                }\n            }\n        }\n\n        ta.hideWhisper = function () {\n            //whisperDiv.innerHTML = '';\n            this.whisperDiv.setAttribute('style', 'display: none;');\n            this.whisperDiv.isShown = false;\n        }\n\n        ta.insertCurrentSelectedWhisper = function () {\n            const currWhisper: string | undefined = this.whisperDiv.getSelectedWhisper();\n            if (currWhisper !== undefined) {\n                const i: number = getStartOfWordBeforeIndex(this.value, this.selectionEnd);\n                const beforeAdd: string = this.value.slice(0, i);\n                const afterAdd: string = this.value.slice(this.selectionEnd);\n                const newCursorPos: number = i + currWhisper.length;\n                props.onChange(beforeAdd + currWhisper + afterAdd, newCursorPos);\n                this.setSelectionRange(newCursorPos, newCursorPos);\n                this.hideWhisper();\n            }\n        }\n\n        ta.notAutoShowWhisper = false;\n\n        // TEXTAREA ERROR RANGE HIGHLIGHTS\n        ta.errorDivs = [];\n\n        ta.moveErrors = function () {\n            this.errorDivs.forEach(highlight => {\n                // computes position of the highlight relative to the text\n                const yPos: number = (highlight.startLine + 1) * lineHeight + 1 - this.scrollTop;\n                // shows the div at computed position if the line is visible\n                if (1 < yPos && yPos < this.clientHeight) {\n                    let width: number = highlight.rangeLength * fontWidth;\n                    let xPos: number = highlight.startColumn * fontWidth + 7 - this.scrollLeft;\n                    // if the whole highlight is out of the width, does not display it\n                    if (xPos > this.clientWidth || xPos + width < 3) {\n                        highlight.setAttribute('style', `display: none;`);\n                    }\n                    else {\n                        // updates position of highlights starting before first visible column\n                        if (xPos < 3) {\n                            width += xPos - 3;\n                            xPos = 3;\n                        }\n                        // updates width of highlights ending after last visible column\n                        if (xPos + width > this.clientWidth) {\n                            width = this.clientWidth - xPos;\n                        }\n                        // updates the position of message span when the highlight is on the right side of the screen\n                        if (this.getBoundingClientRect().x + xPos >= window.innerWidth / 2) {\n                            highlight.messageSpan.setAttribute('style', `right: 50%; left: unset;`);\n                        }\n                        highlight.setAttribute('style', `display: block; top: ${yPos}px; left: ${xPos}px; width: ${width}px`);\n                    }\n                }\n                // hides the div if the line is not visible\n                else {\n                    highlight.setAttribute('style', `display: none;`);\n                }\n            });\n        }\n\n        ta.updateErrors = function (ranges: LocatedError[]) {\n            // removes old highlight divs\n            this.errorDivs.forEach(highlight => {\n                highlight.remove();\n            });\n            this.errorDivs = [];\n\n            // appends the highlight div as textarea child and adds it to highlights array\n            const pushHighlight = (highlight: ErrorDiv) => {\n                // @ts-ignore - adds it to the parent element\n                this.parentElement.appendChild(highlight);\n                this.errorDivs.push(highlight);\n            }\n\n            ranges.forEach(range => {\n                // finds highlight start and end lines and columns\n                const start = getPositionLineAndColumn(this.value, range.start);\n                const end = getPositionLineAndColumn(this.value, range.end);\n                // error on one line only\n                if (start.line === end.line) {\n                    pushHighlight(createHighlightDiv(start.line, start.column, end.column - start.column,\n                        range.msg, this));\n                }\n                // error on multiple lines\n                else {\n                    // pushes first line part - from error start to line end\n                    pushHighlight(createHighlightDiv(start.line, start.column,\n                        getLineLength(this.value, start.line) - start.column, range.msg, this));\n                    // pushes middle lines\n                    for (let line = start.line + 1; line < end.line; ++line) {\n                        pushHighlight(createHighlightDiv(line, 0, getLineLength(this.value, line),\n                            range.msg, this));\n                    }\n                    // pushes last line part - from line start to error end\n                    pushHighlight(createHighlightDiv(end.line, 0, end.column, range.msg, this));\n                }\n            });\n\n            // moves highlight to current positions\n            this.moveErrors();\n        }\n\n        ta.parentheses = [];\n        ta.parenthesesDivs = [];\n\n        ta.updateParentheses = function () {\n            ta.parenthesesDivs.forEach(div => {\n                div.remove();\n            });\n            ta.parenthesesDivs = [];\n            if (ta.selectionStart === ta.selectionEnd) {\n                const c1 = ta.selectionStart;\n                const c2 = c1 - 1;\n                const around = ta.parentheses.filter(p => p.start === c1 || p.start === c2 || p.end === c1 || p.end === c2);\n                // true when the first pair is processed\n                let first = true;\n                around.forEach(parentheses => {\n                    // finds highlight start and end lines and columns\n                    const start = getPositionLineAndColumn(ta.value, parentheses.start);\n                    const end = getPositionLineAndColumn(ta.value, parentheses.end);\n                    const div1 = createParenthesesDiv(start.line, start.column, ta);\n                    const div2 = createParenthesesDiv(end.line, end.column, ta);\n                    // @ts-ignore\n                    ta.parentElement.appendChild(div1);\n                    // @ts-ignore\n                    ta.parentElement.appendChild(div2);\n                    ta.parenthesesDivs.push(div1);\n                    ta.parenthesesDivs.push(div2);\n                    // changes color to distinguish two pairs\n                    div1.classList.toggle('first-pair', first);\n                    div1.classList.toggle('second-pair', !first);\n                    div2.classList.toggle('first-pair', first);\n                    div2.classList.toggle('second-pair', !first);\n                    first = false;\n                });\n                ta.moveParentheses();\n            }\n        }\n\n        ta.moveParentheses = function () {\n            ta.parenthesesDivs.forEach(div => {\n                // computes position of the highlight relative to the text\n                const yPos: number = (div.startLine + 1) * lineHeight + 1 - this.scrollTop;\n                // shows the div at computed position if the line is visible\n                if (1 < yPos && yPos < this.clientHeight) {\n                    let width: number = fontWidth;\n                    let xPos: number = div.startColumn * fontWidth + 7 - this.scrollLeft;\n                    // if the whole highlight is out of the width, does not display it\n                    if (xPos > this.clientWidth || xPos + width < 3) {\n                        div.setAttribute('style', `display: none;`);\n                    }\n                    else {\n                        // updates position of highlights starting before first visible column\n                        if (xPos < 3) {\n                            width += xPos - 3;\n                            xPos = 3;\n                        }\n                        // updates width of highlights ending after last visible column\n                        if (xPos + width > this.clientWidth) {\n                            width = this.clientWidth - xPos;\n                        }\n                        div.setAttribute('style', `display: block; top: ${yPos}px; left: ${xPos}px; width: ${width}px`);\n                    }\n                }\n                // hides the div if the line is not visible\n                else {\n                    div.setAttribute('style', `display: none;`);\n                }\n            });\n        }\n\n        ta.insertPairSymbol = function (first: string, second: string) {\n            const before: string = ta.value.slice(0, this.selectionStart);\n            const between: string = ta.value.slice(this.selectionStart, this.selectionEnd)\n            const after: string = ta.value.slice(this.selectionEnd);\n            const newCursorPos: number = ta.selectionEnd + 1;\n            props.onChange(before + first + between + second + after, newCursorPos);\n            this.setSelectionRange(newCursorPos, newCursorPos);\n            this.hideWhisper();\n        }\n\n        ta.checkPairSymbolDelete = function (): boolean {\n            // only if nothing is selected\n            if (ta.selectionStart === ta.selectionEnd) {\n                const prevI = ta.selectionStart - 1;\n                const nextI = ta.selectionStart;\n                if (0 <= prevI && nextI < ta.value.length) {\n                    const prev = this.value.charAt(prevI);\n                    const next = this.value.charAt(nextI);\n                    // if the cursor is between pair symbol\n                    if ((prev === '(' && next === ')') || (prev === '[' && next === ']') ||\n                      (prev === '\"' && next === '\"' && this.value.charAt(prevI - 1) !== '\\\\')) {\n                        const before: string = ta.value.slice(0, prevI);\n                        const after: string = ta.value.slice(nextI + 1);\n                        props.onChange(before + after, prevI);\n                        this.setSelectionRange(prevI, prevI);\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        // handles whisper div position when scrolling on page\n        window.addEventListener('scroll', () => ta.moveWhisper());\n        window.addEventListener('resize', () => {\n            ta.moveWhisper();\n            ta.moveErrors();\n            ta.moveParentheses();\n        });\n        window.addEventListener('click', () => ta.hideWhisper());\n        ta.onscroll     = () => {\n            ta.paintLineNumbers(this.props.darkTheme);\n            ta.moveWhisper();\n            ta.moveErrors();\n            ta.moveParentheses();\n        };\n        ta.onmousedown  = event => {\n            ta.mouseIsDown = true;\n            setTimeout(ta.updateParentheses, 0);\n            event.stopPropagation();\n        }\n        ta.onmouseup    = () => {\n            ta.mouseIsDown = false;\n            ta.paintLineNumbers(this.props.darkTheme);\n            setTimeout(ta.updateParentheses, 0);\n        };\n        ta.onmousemove  = () => {\n            if (ta.mouseIsDown) ta.paintLineNumbers(this.props.darkTheme);\n        };\n        ta.oninput      = (ev) => {\n            // @ts-ignore\n            this.props.onChange(ev.target.value, ev.target.selectionStart);\n        }\n        // prevents default behavior of special keys input when whisperDiv is shown, passes key event to the parent\n        ta.onkeydown    = (ev) => {\n            if (ta.whisperDiv.isShown) {\n                if (ev.key === \"ArrowDown\") {\n                    ta.whisperDiv.changeSelected(1);\n                    ev.preventDefault();\n                }\n                if (ev.key === \"ArrowUp\") {\n                    ta.whisperDiv.changeSelected(-1);\n                    ev.preventDefault();\n                }\n                if (ev.key === \"PageDown\") {\n                    // moves selected whisper to bottom\n                    ta.whisperDiv.setSelected(-1);\n                    ev.preventDefault();\n                }\n                if (ev.key === \"PageUp\") {\n                    // moves selected whisper to top\n                    ta.whisperDiv.setSelected(0);\n                    ev.preventDefault();\n                }\n                if (ev.key === \"End\" || ev.key === \"Home\") {\n                    ta.hideWhisper();\n                    // keeps default behaviour\n                }\n                if (ev.key === \"Escape\" || ev.key === \"Esc\") {\n                    ta.hideWhisper();\n                    ev.preventDefault();\n                }\n                if (ev.key === \"Enter\" && !ev.ctrlKey) {\n                    ta.insertCurrentSelectedWhisper();\n                    ev.preventDefault();\n                }\n                if (ev.key === \"Enter\" && ev.ctrlKey) {\n                    ta.hideWhisper();\n                    ev.preventDefault();\n                }\n                if (ev.key === \"Tab\") {\n                    ta.insertCurrentSelectedWhisper();\n                    ev.preventDefault();\n                }\n                if (ev.key === \"ArrowLeft\") {\n                    const cursor = (ta.selectionStart === 0) ? 0 : (ta.selectionStart - 1);\n                    // forces update to recompute whispers if needed\n                    this.props.onChange(ta.value, cursor);\n                    // keeps default behaviour\n                }\n                if (ev.key === \"ArrowRight\") {\n                    const cursor = (ta.selectionStart === ta.value.length) ? ta.selectionStart : ta.selectionStart + 1;\n                    // forces update to recompute whispers if needed\n                    this.props.onChange(ta.value, cursor);\n                    // keeps default behaviour\n                }\n            }\n            if (ev.key === \"Enter\" || ev.key === \"Tab\") {\n                // does not show whisper after pressing Enter or Tab\n                ta.notAutoShowWhisper = true;\n            }\n            if (ev.key === \"Backspace\" && !ta.whisperDiv.isShown) {\n                // does not show whisper after pressing Backspace when it is closed\n                ta.notAutoShowWhisper = true;\n            }\n            if (ev.ctrlKey) {\n                if (ev.key === \" \") {\n                    if (ta.whisperDiv.isShown) {\n                        ta.hideWhisper();\n                    }\n                    else {\n                        this.props.onChange(ta.value, ta.selectionStart);\n                    }\n                }\n                this.props.onCtrlInput(ev);\n            }\n            if (ev.key === \"ArrowLeft\" || ev.key === \"ArrowRight\" || ev.key === \"ArrowUp\" || ev.key === \"ArrowDown\" ||\n                ev.key === \"Home\" || ev.key === \"End\" || ev.key === \"PageUp\" || ev.key === \"PageDown\") {\n                setTimeout(ta.updateParentheses, 0);\n            }\n            if (ev.key === \"(\") {\n                ta.insertPairSymbol(\"(\", \")\");\n                ev.preventDefault();\n            }\n            if (ev.key === \"[\") {\n                ta.insertPairSymbol(\"[\", \"]\");\n                ev.preventDefault();\n            }\n            if (ev.key === '\"' && ta.value.charAt(ta.selectionStart - 1) !== \"\\\\\") {\n                ta.insertPairSymbol('\"', '\"');\n                ev.preventDefault();\n            }\n            // if the text area deletes pair symbol, default backspace behavior is prevented\n            if (ev.key === \"Backspace\" && ta.checkPairSymbolDelete()) {\n                ev.preventDefault();\n            }\n        }\n\n        // make sure numbers are painted\n        ta.update(this.props.text, this.props.darkTheme);\n        // shows highlights\n        ta.updateErrors(this.props.errors);\n        this.textarea = ta;\n    }\n\n    /**\n     * Updates text content and component style.\n     */\n    componentDidUpdate(prevProps: Readonly<XTextAreaProps>) {\n        this.textarea.update(this.props.text, this.props.darkTheme);\n        if (prevProps.darkTheme !== this.props.darkTheme) {\n            this.textarea.paintLineNumbers(this.props.darkTheme);\n        }\n        // whispers\n        if (this.props.whispers !== prevProps.whispers) {\n            if (this.textarea.notAutoShowWhisper) {\n                this.textarea.notAutoShowWhisper = false;\n            }\n            else {\n                this.textarea.createWhisper(this.props.whispers);\n            }\n        }\n        // highlights error\n        if (this.props.errors !== undefined) {\n            this.textarea.updateErrors(this.props.errors);\n        }\n        // first undefined highlight removes 'x-textarea-err' from textarea.className to show selection with blue color\n        else if (this.props.errors !== prevProps.errors) {\n            this.textarea.classList.remove('x-textarea-err');\n        }\n        // highlights parentheses\n        if (this.props.parentheses !== prevProps.parentheses) {\n            this.textarea.parentheses = this.props.parentheses;\n            this.textarea.updateParentheses();\n        }\n    }\n\n    /**\n     * Renders only an empty div. Other maintaining is not provided by React.\n     */\n    public render() {\n        return <div id={this.props.id} className=\"x-textarea-div\" />;\n    }\n}\n\n/**\n * Computes line and column number for given position in text.\n */\nfunction getPositionLineAndColumn(text: string, position: number): {line: number, column: number} {\n    const textBeforeCursor: string = text.slice(0, position);\n    const line: number = (textBeforeCursor.match(/\\n/g) || []).length;\n    const lastNewLine: number = textBeforeCursor.lastIndexOf('\\n');\n    const column: number = textBeforeCursor.length - lastNewLine - 1;\n    return {line, column};\n}\n\n/**\n * Returns number of characters on the given line.\n */\nfunction getLineLength(text: string, line: number): number {\n    let newLinesFound = 0;\n    let lineStart = 0;  // index of line-th newline\n    let lineEnd = 0;    // index of (line+1)-th newline\n    for (let i = 0; i < text.length; ++i) {\n        if (text.charAt(i) === '\\n') {\n            ++newLinesFound;\n            if (newLinesFound === line) {\n                lineStart = i;\n            }\n            else if (newLinesFound === line + 1) {\n                lineEnd = i;\n                break;\n            }\n        }\n    }\n    if (lineEnd === 0) {\n        lineEnd = text.length; // handles case of last line in text\n    }\n    return lineEnd - lineStart;\n}\n\n/**\n * Creates a div for highlighting errors in the given textarea.\n */\nfunction createHighlightDiv(startLine: number, startColumn: number, rangeLength: number, msg: string,\n                            textarea: ExtendedHTMLTextArea): ErrorDiv {\n    // @ts-ignore\n    const highlight: ErrorDiv = document.createElement('div');\n    highlight.classList.add(\"x-textarea-highlight\");\n    highlight.startLine = startLine;\n    highlight.startColumn = startColumn;\n    highlight.rangeLength = rangeLength;\n    // dispatches click event to not block textarea underneath highlights\n    highlight.onclick = (ev: MouseEvent) => {\n        const newEvent: MouseEvent = new MouseEvent(ev.type, {...ev});\n        textarea.dispatchEvent(newEvent);\n        ev.stopPropagation();\n    }\n    const span: HTMLSpanElement = document.createElement('span');\n    span.classList.add(\"highlight-tooltip\");\n    span.innerText = msg;\n    highlight.messageSpan = span;\n    highlight.appendChild(span);\n    return highlight;\n}\n\n/**\n * Creates a div for highlighting parentheses in the given textarea.\n */\nfunction createParenthesesDiv(startLine: number, startColumn: number, textarea: ExtendedHTMLTextArea): ParenthesesDiv {\n    // @ts-ignore\n    const div: ParenthesesDiv = document.createElement('div');\n    div.classList.add(\"x-textarea-parentheses\");\n    div.startLine = startLine;\n    div.startColumn = startColumn;\n    // dispatches click event to not block textarea underneath highlights\n    div.onclick = (ev: MouseEvent) => {\n        const newEvent: MouseEvent = new MouseEvent(ev.type, {...ev});\n        textarea.dispatchEvent(newEvent);\n        ev.stopPropagation();\n    }\n    return div;\n}","/**\n * Modulo operation with positive result for negative numbers (as % in JavaScript can give negative results).\n *\n * @param n base number {@type number}\n * @param m dividing number {@type number}\n * @return n modulo m {@type number}\n * @category Utils\n * @public\n */\nexport function mod(n: number, m: number): number {\n    return ((n % m) + m) % m;\n}","import {Row} from \"./row\";\nimport {SupportedColumnType} from \"./columnType\";\nimport {isEqual} from \"lodash\";\n\n/**\n * Formal relational algebra relation. It contains relational schema (set of column names and types)\n * and data tuples (set of rows). For editable representation which may happen to be invalid, use {@link StoredRelation}.\n *\n * @category Relation\n * @public\n */\nexport class Relation {\n\n    public readonly name: string;\n    private columns = new Map<string, SupportedColumnType>();\n    private columnNames: string[] = []; // array to have an ordered printing of columns\n    private rows: Row[] = [];\n    private finishedSchema = false;\n\n    /**\n     * Creates an empty relation of the given name.\n     *\n     * @param name name of the relation {@type string}\n     * @public\n     */\n    constructor(name: string) {\n        this.name = name;\n    }\n\n    /**\n     * Returns name of the relation.\n     *\n     * @return relation name {@type string}\n     * @public\n     */\n    public getName(): string {\n        return this.name;\n    }\n\n    /**\n     * Returns true if the relational schema is finished (no more columns can be added).\n     *\n     * @return true if the relational schema is finished (no more columns can be added) {@type boolean}\n     * @public\n     */\n    public hasFinishedSchema(): boolean {\n        return this.finishedSchema;\n    }\n\n    /**\n     * Sets the relational schema finished (no more columns can be added).\n     * @public\n     */\n    public finishSchema(): void {\n        this.finishedSchema = true;\n    }\n\n    /**\n     * Adds a column to a relational schema if the relational schema is not finished yet.\n     *\n     * @param name name of the column {@type string}\n     * @param type type of the column {@type SupportedColumnType}\n     * @return true if the column was added (relation did not contain a column with the same name before) {@type boolean}\n     * @public\n     */\n    public addColumn(name: string, type: SupportedColumnType): boolean {\n        if (!this.hasColumn(name) && !this.hasFinishedSchema()) {\n            this.columns.set(name, type);\n            this.columnNames.push(name);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the relation has a column with the same name\n     * (NOTE: type of the column does not matter).\n     *\n     * @param name Column name to be checked {@type string}\n     * @return true if the relation has a column with the same name {@type boolean}\n     * @public\n     */\n    public hasColumn(name: string): boolean {\n        return this.columnNames.some(cn => cn === name);\n    }\n\n    /**\n     * Returns map (name -> value) of column values in a relation.\n     *\n     * @return map of column values in a relation {@type Map<String, SupportedColumnType>}\n     * @public\n     */\n    public getColumns(): Map<string, SupportedColumnType> {\n        return this.columns;\n    }\n\n    /**\n     * Applies the given function to each column in the relation.\n     *\n     * @param f function to be applied to each column in the relation {@type function}\n     * @public\n     */\n    public forEachColumn(f: (type: SupportedColumnType, name: string) => void): void {\n        return this.columns.forEach(f);\n    }\n\n    /**\n     * Return column names  in a relation.\n     *\n     * @return array of column names in a relation {@type string[]}\n     * @public\n     */\n    public getColumnNames(): string[] {\n        return this.columnNames;\n    }\n\n    /**\n     * Returns number of columns in a relation.\n     *\n     * @return number of columns in a relation {@type number}\n     * @public\n     */\n    public getColumnsCount(): number {\n        return this.columnNames.length;\n    }\n\n    /**\n     * Adds a row to a relation. The row must have the same column set as the relation. If the row was added,\n     * sets the row finished and returns true. Also the relational schema of this relation\n     * is set finished (no more columns can be added). If the row was not added, returns false.\n     * NOTE: Rows in a relation cannot be duplicit, adding a duplicit row returns true, but only one is kept.\n     *\n     * @param row row to be added {@type Row}\n     * @return true if the row was added, false otherwise {@type boolean}\n     * @public\n     */\n    public addRow(row: Row): boolean {\n        if (isEqual(row.getTypes(), this.columns)) {\n            this.finishSchema();\n            row.finish();\n            if (!this.rows.some(r => r.equals(row))) {\n                this.rows.push(row);\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Returns all rows in a relation.\n     *\n     * @return array of rows in a relation {@type Row[]}\n     * @public\n     */\n    public getRows(): Row[] {\n        return this.rows;\n    }\n\n    /**\n     * Returns the number of rows in a relation.\n     *\n     * @return number of rows in a relation {@type number}\n     * @public\n     */\n    public getRowsCount(): number {\n        return this.rows.length;\n    }\n\n    /**\n     * Returns a relational schema in a format: RelationName(ColumnOneName: ColumnOneType, ...) - both column names\n     * and column types are used.\n     *\n     * @return relational schema as a string {@type string}\n     * @public\n     */\n    public getSchemaString(): string {\n        return this.name + \"(\" + [...this.columns].map(s => s[0] + \": \" + s[1]).join(\", \") + \")\";\n    }\n\n    /**\n     * Returns a relational schema in a format: RelationName(ColumnOneName, ...) - only column names are used.\n     *\n     * @return relational schema as a string {@type string}\n     * @public\n     */\n    public getNamesSchemaString(): string {\n        return this.name + \"(\" + this.columnNames.join(\", \") + \")\";\n    }\n\n    /**\n     * Returns a formatted string representation of the relation content (column names, column types and rows).\n     *\n     * @return string representation of the relation {@type string}\n     * @public\n     */\n    public contentString(): string {\n        // @ts-ignore - prepares array representation of types and rows\n        const columnTypes: SupportedColumnType[] = this.columnNames.map(name => this.columns.get(name));\n        const rows = [...this.rows].map(row => row.getOrderedPrintValues(this.columnNames));\n        // finds longest inputs in each column\n        const longest = this.columnNames.map(n => n.length);\n        columnTypes.forEach((type, i) => {\n            if (type.length > longest[i]) {\n                longest[i] = type.length;\n            }\n        })\n        rows.forEach(r => {\n            r.forEach((d, i) => {\n                if (longest[i] < d.length) {\n                    longest[i] = d.length;\n                }\n            });\n        });\n        // function for end-padding strings with spaces\n        const pad = (ss: string[]) => ss.map((s, i) => s.padEnd(longest[i], \" \")).join(' | ');\n        return pad(this.columnNames) + '\\n' +\n            pad(columnTypes) + '\\n' +\n            longest.map(n => \"-\".repeat(n)).join(\"-+-\") + '\\n' +\n            rows.map(r => pad(r)).join('\\n');\n    }\n\n    /**\n     * Custom equals function for testing purposes.\n     *\n     * @param other an object to compare {@type any}\n     * @return true if this and given objects have same name, columns, and rows {@type boolean}\n     * @public\n     */\n    public equals(other: any): boolean {\n        if (other instanceof Relation) {\n            return this.name === other.name &&\n                isEqual(this.columns, other.columns) &&\n                isEqual(new Set(this.rows), new Set(other.rows));\n        }\n        return false;\n    }\n}","/**\n * Messages for {@link CodeError}.\n * The description is a string array - between its members are inserted error parameters (names of invalid relations,\n * invalid input parts, etc.). See english language definition for expected structure of each error description.\n * @category Errors\n * @public\n */\nexport interface CodeErrorMessages {\n    // expects 1 part\n    resultSection_nodeIndexNotFound: string[],\n    // expects 2 part\n    resultSection_evalError: string[],\n    // expects 1 part\n    resultSection_nullRelationToSave: string[],\n    // expects 1 part\n    resultSection_nullRelationToAdd: string[],\n\n    // expects 3 parts\n    row_absentColumn: string[],\n\n    // expects 2 parts\n    valueParser_unexpectedToken: string[],\n\n    // expects 2 parts\n    exprParser_unexpectedToken: string[],\n    // expects 2 parts\n    exprParser_thetaJoinBranchError: string[],\n    // expects 2 parts\n    exprParser_projectionBranchError: string[]\n}\n\n/**\n * Error caused by an unexpected error in code of the application.\n * @extends Error\n * @category Errors\n * @public\n */\nexport class CodeError extends Error {\n    /**\n     * Creates a new CodeError with the given message.\n     *\n     * @param msg error message {@type string}\n     * @public\n     */\n    constructor(msg: string) {\n        super(msg);\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, CodeError);\n        }\n        this.name = 'CodeError';\n    }\n}","import {RASemanticError} from \"./raSemanticError\";\nimport {RASyntaxError} from \"./raSyntaxError\";\nimport {CodeError} from \"./codeError\";\nimport {StartEndPair} from \"../types/startEndPair\";\n\n/**\n * Factory for creating custom application errors: CodeError, RASemanticError, RASyntaxError.\n * It creates an error message by given error code and string parameters.\n * @category Errors\n * @public\n */\nexport class ErrorFactory {\n\n    /**\n     * Creates a new code error. Params are used to join error messages.\n     *\n     * @param msg predefined error description {@link CodeErrorMessages} {@type string[]}\n     * @param params textual specification {@type ...string}\n     * @public\n     */\n    public static codeError(msg: string[], ...params: string[]): CodeError {\n        assertParamsCount(msg.length - 1, params);\n        return new CodeError(joinStringArrays(msg, params));\n    }\n\n    /**\n     * Creates a new RASemanticError. Params are used to join error messages.\n     *\n     * @param msg predefined error description {@link SemanticErrorMessages} {@type string[]}\n     * @param range text range of the error in the input when defined {@type StartEndPair?}\n     * @param params textual specification {@type ...string}\n     * @public\n     */\n    public static semanticError(msg: string[], range: StartEndPair | undefined, ...params: string[]): RASemanticError {\n        assertParamsCount(msg.length - 1, params);\n        return new RASemanticError(joinStringArrays(msg, params), range);\n    }\n\n    /**\n     * Creates a new RASyntaxError. Params are used to join error messages.\n     *\n     * @param msg predefined error description {@link SyntaxErrorMessages} {@type string[]}\n     * @param range text range of the error in the input when defined {@type StartEndPair?}\n     * @param params textual specification {@type ...string}\n     * @public\n     */\n    public static syntaxError(msg: string[], range: StartEndPair | undefined, ...params: string[]): RASyntaxError {\n        assertParamsCount(msg.length - 1, params);\n        return new RASyntaxError(joinStringArrays(msg, params), range);\n    }\n}\n\n/**\n * Extends the given params array with empty strings to have the length of expectedCount. When the initial length of the\n * given params array is the same or greater, the array is not changed.\n */\nexport function assertParamsCount(expectedCount: number, params: string[]): void {\n    if (params.length !== expectedCount) {\n        console.log(\"Unexpected params count, expected \" + expectedCount + \", given \" + params.length);\n        while (params.length < expectedCount) {\n            params.push(\"\");\n        }\n    }\n}\n\n/**\n * Joins given string arrays [a1, a2, ..., an] and [b1, b2, ..., bn-1] to one string \"a1b1a2b2...an-1bn-1an\".\n * WARNING: a.length is expected to be at least 1. b.length is expected to be at least \"a.length - 1\".\n *\n * @param a array of length at least 1\n * @param b array of length at least \"a.length - 1\"\n */\nexport function joinStringArrays(a: string[], b: string[]): string {\n    const aLen: number = a.length;\n    const toConcat: string[] = Array<string>(2 * aLen - 2);\n    for (let i = 1; i < aLen; i++) {\n        toConcat[2 * i - 2] = b[i - 1];\n        toConcat[2 * i - 1] = a[i];\n    }\n    return a[0].concat(...toConcat);\n}","import {BinaryNodeClass} from \"../ratree/binaryNode\";\nimport {IndexedString} from \"../types/indexedString\";\nimport {UnaryNodeClass} from \"../ratree/unaryNode\";\nimport {StartEndPair} from \"../types/startEndPair\";\n\n/**\n * Abstract parent class for all RATokens.\n */\nexport abstract class ExprToken {\n    protected constructor(public readonly str: IndexedString, public readonly type: string) {}\n\n    /**\n     * Gets token start and end index in the text (if the token has IndexedString representation) or undefined.\n     */\n    public getRange(): StartEndPair | undefined {\n        return this.str.getRange();\n    }\n}\n\n/**\n * Parentheses.\n */\nexport abstract class ParenthesisToken extends ExprToken {}\n\nexport class OpeningParenthesis extends ParenthesisToken {\n    public constructor(str: IndexedString) {\n        super(str, \"OpeningParenthesis\");\n    }\n}\n\nexport class ClosingParenthesis extends ParenthesisToken {\n    public constructor(str: IndexedString) {\n        super(str, \"ClosingParenthesis\");\n    }\n}\n\n/**\n * Relation reference.\n */\nexport class RelationToken extends ExprToken {\n    public constructor(name: IndexedString) {\n        super(name, \"RelationToken\");\n    }\n}\n\n/**\n * Unary operators.\n */\nexport class UnaryOperatorToken extends ExprToken {\n\n    public static selection(selection: IndexedString) {\n        return new UnaryOperatorToken(selection, \"selection\");\n    }\n\n    public static projection(projection: IndexedString) {\n        return new UnaryOperatorToken(projection, \"projection\");\n    }\n\n    public static rename(rename: IndexedString) {\n        return new UnaryOperatorToken(rename, \"rename\");\n    }\n\n    private constructor(str: IndexedString, type: UnaryNodeClass) {\n        super(str, type);\n    }\n}\n\n/**\n * Precedence values for binary operators (highest to lowest).\n */\nconst precedenceLevelA: number = 10;\nconst cartesianPrecedence: number = precedenceLevelA;\nconst naturalPrecedence: number = precedenceLevelA;\nconst thetaPrecedence: number = precedenceLevelA;\nconst semiPrecedence: number = precedenceLevelA;\nconst antiPrecedence: number = precedenceLevelA;\nconst thetaSemiPrecedence: number = precedenceLevelA;\nconst outerPrecedence: number = precedenceLevelA;\nconst divisionPrecedence: number = precedenceLevelA;\n\nconst precedenceLevelB: number = precedenceLevelA - 1;\nconst intersectionPrecedence: number = precedenceLevelB;\n\nconst precedenceLevelC: number = precedenceLevelB - 1;\nconst differencePrecedence: number = precedenceLevelC;\nconst unionPrecedence: number = precedenceLevelC;\n\n/**\n * Binary operators.\n */\nexport class BinaryOperatorToken extends ExprToken {\n\n    static naturalJoin(str: IndexedString): BinaryOperatorToken {\n        return new BinaryOperatorToken(str, naturalPrecedence, \"natural join\");\n    }\n\n    static cartesianProduct(str: IndexedString): BinaryOperatorToken {\n        return new BinaryOperatorToken(str, cartesianPrecedence, \"cartesian product\");\n    }\n\n    static union(str: IndexedString): BinaryOperatorToken {\n        return new BinaryOperatorToken(str, unionPrecedence, \"union\");\n    }\n\n    static intersection(str: IndexedString): BinaryOperatorToken {\n        return new BinaryOperatorToken(str, intersectionPrecedence, \"intersection\");\n    }\n\n    static difference(str: IndexedString): BinaryOperatorToken {\n        return new BinaryOperatorToken(str, differencePrecedence, \"difference\");\n    }\n\n    static leftSemijoin(str: IndexedString): BinaryOperatorToken {\n        return new BinaryOperatorToken(str, semiPrecedence, \"left semijoin\");\n    }\n\n    static rightSemijoin(str: IndexedString): BinaryOperatorToken {\n        return new BinaryOperatorToken(str, semiPrecedence, \"right semijoin\");\n    }\n\n    static leftAntijoin(str: IndexedString): BinaryOperatorToken {\n        return new BinaryOperatorToken(str, antiPrecedence, \"left antijoin\");\n    }\n\n    static rightAntijoin(str: IndexedString): BinaryOperatorToken {\n        return new BinaryOperatorToken(str, antiPrecedence, \"right antijoin\");\n    }\n\n    static thetaJoin(str: IndexedString): BinaryOperatorToken {\n        return new BinaryOperatorToken(str, thetaPrecedence, \"theta join\");\n    }\n\n    static leftThetaSemijoin(str: IndexedString): BinaryOperatorToken {\n        return new BinaryOperatorToken(str, thetaSemiPrecedence, \"left theta semijoin\");\n    }\n\n    static rightThetaSemijoin(str: IndexedString): BinaryOperatorToken {\n        return new BinaryOperatorToken(str, thetaSemiPrecedence, \"right theta semijoin\");\n    }\n\n    static fullOuterJoin(str: IndexedString): BinaryOperatorToken {\n        return new BinaryOperatorToken(str, outerPrecedence, \"full outer join\");\n    }\n\n    static leftOuterJoin(str: IndexedString): BinaryOperatorToken {\n        return new BinaryOperatorToken(str, outerPrecedence, \"left outer join\");\n    }\n\n    static rightOuterJoin(str: IndexedString): BinaryOperatorToken {\n        return new BinaryOperatorToken(str, outerPrecedence, \"right outer join\");\n    }\n\n    static division(str: IndexedString): BinaryOperatorToken {\n        return new BinaryOperatorToken(str, divisionPrecedence, \"division\");\n    }\n\n    private constructor(str: IndexedString, public readonly precedence: number, type: BinaryNodeClass) {\n        super(str, type);\n    }\n}","import {ErrorFactory} from \"../error/errorFactory\";\nimport {RASyntaxError} from \"../error/raSyntaxError\";\nimport {language} from \"../language/language\";\nimport {Pair} from \"../types/pair\";\n\n/**\n * Class providing general helper functions for strings.\n * @category Utils\n * @public\n */\nexport class StringUtils {\n\n    /**\n     * Returns true if the string contains letters only and has length at least 1.\n     *\n     * @param str Checked string {@type string}\n     * @return true if the string contains letters only and has length at least 1 {@type boolean}\n     * @public\n     */\n    public static isWord(str: string): boolean {\n        return str.length > 0 && str.split(\"\").every(c => StringUtils.isLetter(c));\n    }\n\n    /**\n     * Returns true if the string contains letters, numbers and underscores only, has length at least 1 and starts with\n     * a letter or an underscore.\n     *\n     * @param str Checked string {@type string}\n     * @return true if the string contains letters, numbers and underscores only, has length at least 1 and starts with\n     * a letter or an underscore {@type boolean}\n     * @public\n     */\n    public static isName(str: string): boolean {\n        if (str.length === 0) {\n            return false;\n        }\n        if (!StringUtils.isLetter(str.charAt(0)) && str.charAt(0) !== '_') {\n            return false;\n        }\n        return str.split(\"\").every(c => StringUtils.isNameChar(c));\n    }\n\n    /**\n     * Returns true if the string contains whitespaces only.\n     *\n     * @param str Checked string {@type string}\n     * @return true if the string contains whitespaces only {@type boolean}\n     * @public\n     */\n    public static isWhitespacesOnly(str: string): boolean {\n        const regex = /\\s*/;\n        const res = regex.exec(str);\n        return res === null ? false : res[0] === str;\n    }\n\n    /**\n     * Returns true if the given string has length one and the character is a letter.\n     *\n     * @param c Checked character {@type string}\n     * @return true if the given string has length one and the character is a letter {@type boolean}\n     * @public\n     */\n    public static isLetter(c: string): boolean {\n        return c.length === 1 && c.toLowerCase() !== c.toUpperCase();\n    }\n\n    /**\n     * Returns true if the given string has length one and the character is a letter, a number or an underscore.\n     *\n     * @param c Checked character {@type string}\n     * @return true if the given string has length one and the character is a letter, a number or an underscore {@type boolean}\n     * @public\n     */\n    public static isNameChar(c: string): boolean {\n        return StringUtils.isLetter(c) || StringUtils.isDigit(c) || c === '_';\n    }\n\n    /**\n     * Returns true if the given string has length one and the character is a digit.\n     *\n     * @param c Checked character {@type string}\n     * @return true if the given string has length one and the character is a digit {@type boolean}\n     * @public\n     */\n    public static isDigit(c: string): boolean {\n        return c.length === 1 && c.match(/\\d/) !== null;\n    }\n\n    /**\n     * Returns true if the string represents a decimal number.\n     *\n     * @param str Checked string {@type string}\n     * @return true if the string represents a decimal number {@type boolean}\n     * @public\n     */\n    public static isNumber(str: string): boolean {\n        return /^[-]?[\\d]+([.][\\d]+)?$/.test(str);\n    }\n\n    /**\n     * Splits given string to a starting sequence of letters and its rest and returns these parts in a pair.\n     * NOTE: if the string does not start with a letter, as a word is returned an empty string.\n     *\n     * @param str string to be split {@type string}\n     * @return split string in a pair (word, rest) {@type Pair<string>}\n     * @public\n     */\n    public static nextWord(str: string): Pair<string> {\n        if (str === \"\") {\n            return { first: \"\", second: \"\" };\n        }\n        let i: number = 0;\n        while (i < str.length) {\n            if (!StringUtils.isLetter(str.charAt(i))) {\n                return { first: str.substring(0, i), second: str.substring(i)};\n            }\n            ++i;\n        }\n        return { first: str, second: \"\"};\n    }\n\n    /**\n     * Splits given string to a starting sequence of letters, numbers and underscores, which starts with a letter or\n     * an underscore and its rest and returns these parts in a pair.\n     * NOTE: if the string does not start with a letter, or an underscore, as a name is returned an empty string.\n     *\n     * @param str string to be split {@type string}\n     * @return split string in a pair (name, rest) {@type Pair<string>}\n     * @public\n     */\n    public static nextName(str: string): Pair<string> {\n        if (str === \"\") {\n            return { first: \"\", second: \"\" };\n        }\n        if (!StringUtils.isLetter(str.charAt(0)) && str.charAt(0) !== '_') {\n            return { first: \"\", second: str };\n        }\n        let i: number = 0;\n        while (i < str.length) {\n            const char: string = str.charAt(i);\n            if (!StringUtils.isLetter(char) && !StringUtils.isDigit(char) && char !== '_') {\n                return { first: str.substring(0, i), second: str.substring(i)};\n            }\n            ++i;\n        }\n        return { first: str, second: \"\"};\n    }\n\n    /**\n     * Splits given string to a starting sequence of non-whitespace characters and its rest and returns these parts in a pair.\n     *\n     * @param str string to be split {@type string}\n     * @return split string in a pair (start, rest) {@type Pair<string>}\n     * @public\n     */\n    public static nextNonWhitespacePart(str: string): Pair<string> {\n        if (str === \"\") {\n            return { first: \"\", second: \"\" };\n        }\n        let i: number = 0;\n        while (i < str.length) {\n            if (str.charAt(i).match(/\\s/)) {\n                return { first: str.substring(0, i), second: str.substring(i)};\n            }\n            ++i;\n        }\n        return { first: str, second: \"\"};\n    }\n\n    /**\n     * Splits given string to a starting number and its rest and returns these parts in a pair.\n     * NOTE: if the string does not start with a digit, as a number is returned an empty string.\n     *\n     * @param str string to be split {@type string}\n     * @return split string in a pair (word, rest) {@type Pair<string>}\n     * @public\n     */\n    static nextNumber(str: string): Pair<string> {\n        if (str === \"\") {\n            return { first: \"\", second: \"\" };\n        }\n        let i: number = 0;\n        // string starts with '-' sign\n        if (str.charAt(0) === '-') {\n            // if there is a digit after '-', shifts the start\n            if (str.length > 1 && StringUtils.isDigit(str.charAt(1))) {\n                i = 1;\n            }\n            // there is no digit\n            else {\n                return { first: \"\", second: str };\n            }\n        }\n        let digitFound: boolean = false;\n        let dotFound: boolean = false;\n        while (i < str.length) {\n            if (StringUtils.isDigit(str.charAt(i))) {\n                digitFound = true;\n                ++i;\n            }\n            else if (str.charAt(i) === '.') {\n                // second dot or a dot without previous digits\n                if (dotFound || !digitFound) {\n                    break;\n                }\n                else {\n                    dotFound = true;\n                    ++i;\n                }\n            }\n            else {\n                break;\n            }\n        }\n        const numStr = str.substring(0, i);\n        const rest = str.substring(i);\n        return { first: numStr, second: rest };\n    }\n\n    /**\n     * Splits the given string into starting quoted part and the rest. Quotes can be escaped by an odd count of\n     * backslashes.\n     * NOTE: When the closing quote is not found until the rest of the line, unclosed string is returned\n     * => the error is not thrown, it is only added to the return object.\n     * NOTE: First character of the string is expected to be '\"'.\n     *\n     * @param str string to be split {@type string}\n     * @return the starting quoted part, the rest, and optimal error {@type Object}\n     * @public\n     */\n    static nextQuotedString(str: string): { first: string, second: string, error: RASyntaxError | undefined } {\n        let i: number = 1;\n        // backslashes escape the quote character only in odd count\n        let backslashes: number = 0;\n        while (i < str.length) {\n            const curChar = str.charAt(i);\n            // increases index for using \"i\" in slicing\n            ++i;\n            if (curChar === '\"' && (backslashes % 2) === 0) {\n                return { first: str.slice(0, i), second: str.slice(i), error: undefined };\n            }\n            // end of line breaks the string\n            if (curChar === '\\n') {\n                return {\n                    first: str.slice(0, i),\n                    second: str.slice(i),\n                    error: ErrorFactory.syntaxError(language().syntaxErrors.stringUtils_missingClosingChar,\n                        undefined, '\"', '\"')\n                };\n            }\n            // updates backslash count\n            if (curChar === '\\\\') {\n                ++backslashes;\n            }\n            else {\n                backslashes = 0;\n            }\n        }\n        return {\n            first: str,\n            second: \"\",\n            error: ErrorFactory.syntaxError(language().syntaxErrors.stringUtils_missingClosingChar,\n                undefined, '\"', '\"')\n        };\n    }\n\n    /**\n     * Splits the string to the starting bordered part and the rest and returns these parts in a pair.\n     * If there is only one ending character and it differs from the starting one, nested bordering is supported.\n     * Characters after an odd count of escape characters are ignored and cannot start or end a bordered part.\n     * Starting and ending characters in quoted part are ignored, quotes can be escaped by an odd count of backslashes.\n     * NOTE: First character of the string is expected to be 'start'.\n     * NOTE: Should not be used for slicing quoted strings, use nextQuotedString instead.\n     * NOTE: It is expected, that there are no comments in the given string.\n     *\n     * @param str string to be split {@type string}\n     * @param start starting character of the string and also starting character of the bordered part (one character) {@type string}\n     * @param end ending characters of the bordered part (one or more characters) {@type string}\n     * @param escape character which makes next character being ignored (default '\\0') {@type string}\n     * @return pair of the starting bordered part and the rest {@type Pair<string>}\n     * @public\n     */\n    static nextBorderedPart(str: string, start: string, end: string, escape: string = '\\0'): Pair<string> {\n        let depth: number = 1;\n        let i: number = 1;\n        // to ignore special characters\n        let inQuotes: boolean = false;\n        // nested bordering is supported if there is only one ending character\n        const nesting: boolean = end.length === 1;\n        // backslashes escape the quote character only in odd count\n        let backslashes: number = 0;\n        // escape characters escape the end character only in odd count\n        let escapeCount: number = 0;\n        while (i < str.length) {\n            const curChar = str.charAt(i);\n            // checks end of the part (before checking start for a case when start == end)\n            if (end.indexOf(curChar) > -1 && (escapeCount % 2) === 0 && !inQuotes) {\n                --depth;\n            }\n            // checks start of the bordered part (if only one ending character was given)\n            else if (curChar === start && (escapeCount % 2) === 0 && nesting && !inQuotes) {\n                ++depth;\n            }\n            // found quote if even number of backslashes before\n            else if (curChar === '\"' && (backslashes % 2) === 0) {\n                inQuotes = !inQuotes;\n            }\n            // updates escape chars count\n            if (curChar === escape) {\n                ++escapeCount;\n            }\n            else {\n                escapeCount = 0;\n            }\n            // updates backslash count\n            if (curChar === '\\\\') {\n                ++backslashes;\n            }\n            else {\n                backslashes = 0;\n            }\n            // increases index for before slicing\n            ++i;\n            if (depth === 0) {\n                return { first: str.slice(0, i), second: str.slice(i) };\n            }\n        }\n        throw ErrorFactory.syntaxError(language().syntaxErrors.stringUtils_missingClosingChar, undefined,\n            end.split('').join(\"' / '\"), start);\n    }\n\n    /**\n     * Skips all whitespaces and exactly one given character and returns rest of the string.\n     * If the string does not match this pattern, throws error.\n     *\n     * @param str string to be skipped in {@type string}\n     * @param char char to be skipped exactly one time (expected to be string of length 1) {@type string}\n     * @return given string without starting sequence of whitespaces and exactly one char {@type string}\n     * @public\n     */\n    public static skipWhitespacesAndChar(str: string, char: string): string {\n        let charFound: boolean = false;\n        let i: number = 0;\n        while (i < str.length) {\n            if (str.charAt(i).match(/\\s/)) {\n                ++i;\n            }\n            else if (str.charAt(i) === char && !charFound) {\n                charFound = true;\n                ++i;\n            }\n            else {\n                break;\n            }\n        }\n        if (!charFound) {\n            throw ErrorFactory.syntaxError(language().syntaxErrors.stringUtils_charNotFound, undefined, char);\n        }\n        return str.substring(i);\n    }\n}","import {Relation} from \"../relation/relation\";\nimport {ErrorWithTextRange} from \"../error/errorWithTextRange\";\n\n/**\n * Result of fake evaluation of RATreeNode.\n * @category RATree\n * @public\n */\nexport interface NodeFakeEvalResult {\n    /**\n     * Result relation\n     * @type Relation\n     * @public\n     */\n    result: Relation,\n    /**\n     * Found column names to whisper\n     * @type string[]\n     * @public\n     */\n    whispers: string[],\n    /**\n     * Detected errors\n     * @type ErrorWithTextRange[]\n     * @public\n     */\n    errors: ErrorWithTextRange[]\n}\n\n/**\n * Abstract general node of the relational algebra syntactic tree.\n * @category RATree\n * @public\n */\nexport abstract class RATreeNode {\n\n    protected resultRelation: Relation | undefined;\n\n    protected constructor() {}\n\n    /**\n     * Evaluates the RA query in this node and its subtree.\n     * After successful call, this.resultRelation must be set to valid Relation.\n     * @public\n     */\n    public abstract eval(): void;\n\n    /**\n     * Evaluates the RA query in this node and its subtree.\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\n     * Otherwise returns the result relation schema (only column names, no rows).\n     * When an error occurs, it is faked to work, and adds it to the errors array.\n     *\n     * @param cursorIndex index of the cursor in original text input {@type number}\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper {@type NodeFakeEvalResult}\n     * @public\n     */\n    public abstract fakeEval(cursorIndex: number): NodeFakeEvalResult;\n\n    /**\n     * Returns true if this node and its subtree was already evaluated.\n     *\n     * @return true if this node and its subtree was already evaluated {@type boolean}\n     * @public\n     */\n    public isEvaluated(): boolean {\n        return this.resultRelation !== undefined;\n    }\n\n    /**\n     * Returns the resulting relation. The node and its subtree is evaluated if it was not evaluated before.\n     *\n     * @return resulting relation gained by evaluating this node and its subtree {@type Relation}\n     * @public\n     */\n    public getResult(): Relation {\n        if (this.resultRelation === undefined) {\n            this.eval();\n        }\n        // @ts-ignore\n        return this.resultRelation;\n    }\n\n    /**\n     * Creates a string with a structure of the RA tree in one line.\n     *\n     * @return string with a structure of the RA tree in one line {@type string}\n     * @public\n     */\n    public abstract printInLine(): string;\n\n    /**\n     * Return the word name of the RA operation of the node.\n     * Example: returns \"Selection\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n    public abstract getOperationName(): string;\n\n    /**\n     * Return the symbolic representation of the RA operation of the node.\n     * Example: returns \"(some + expr = 15)\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n    public abstract getOperationSymbol(): string;\n}","import {Relation} from \"../relation/relation\";\nimport {RATreeNode} from \"./raTreeNode\";\n\n/**\n * Leave node of the relational algebra syntactic tree with reference to a source relation.\n * @extends RATreeNode\n * @category RATree\n * @public\n */\nexport class RelationNode extends RATreeNode {\n\n    /**\n     * Creates a new RelationNode.\n     *\n     * @param relation source relation {@type Relation}\n     * @public\n     */\n    public constructor(relation: Relation) {\n        super();\n        this.resultRelation = relation;\n    }\n\n    /**\n     * Evaluates the RA query in this node and its subtree.\n     * After successful call, this.resultRelation must be set to valid Relation.\n     * @public\n     */\n    public eval(): void {\n        // nothing to evaluate\n    }\n\n    /**\n     * Evaluates the RA query in this node and its subtree.\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\n     * Otherwise returns the result relation schema (only column names, no rows).\n     * When an error occurs, it is faked to work, and adds it to the errors array.\n     *\n     * @param cursorIndex index of the cursor in original text input {@type number}\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper {@type NodeFakeEvalResult}\n     * @public\n     */\n    public fakeEval(cursorIndex: number) {\n        // @ts-ignore\n        const relation: Relation = this.resultRelation;\n        return {result: relation, whispers: [], errors: []};\n    }\n\n    /**\n     * Creates a string with a structure of the RA tree in one line.\n     *\n     * @return string with a structure of the RA tree in one line {@type string}\n     * @public\n     */\n    public printInLine(): string {\n        // @ts-ignore\n        return this.resultRelation.getName();\n    }\n\n    /**\n     * Return the word name of the RA operation of the node.\n     * Example: returns \"Selection\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n    public getOperationName(): string {\n        // @ts-ignore\n        return this.resultRelation.getName();\n    }\n\n    /**\n     * Return the symbolic representation of the RA operation of the node.\n     * Example: returns \"(some + expr = 15)\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n    public getOperationSymbol(): string {\n        return \"\";\n    }\n}","import {StartEndPair} from \"./startEndPair\";\n\n/**\n * String representation with index of each character. The index is not changed by the mutating the string.\n * Provides some usual string functions. Uses array of {@link IndexedChar}.\n * @category Types\n * @public\n */\nexport class IndexedString {\n\n    /**\n     * Creates a new IndexedString instance representing the given string. StartIndex is used as the offset for indexes.\n     * When the startIndex is omitted, 0 is used. When NaN is given, all indexes are NaN.\n     * Indexes of the characters are (0 + startIndex, ..., str.length - 1 + startIndex).\n     * NOTE: Each character has its own index. That means '\\r\\n' line separator has two indexes. For expected behavior, use\n     * '\\n' separator instead.\n     *\n     * @param str string to store {@type string}\n     * @param startIndex index of the first character {@type number}\n     * @return new IndexedString instance {@type IndexedString}\n     * @public\n     */\n    public static new(str: string, startIndex: number = 0): IndexedString {\n        return new IndexedString(str, str.split('').map((char, index) => {return {char: char, index: index + startIndex}}));\n    }\n\n    /**\n     * Creates a new IndexedString instance representing an empty string \"\".\n     *\n     * @return new IndexedString instance {@type IndexedString}\n     * @public\n     */\n    public static empty(): IndexedString {\n        return new IndexedString('', []);\n    }\n\n    /**\n     * Creates a new IndexedString instance representing the given array of IndexedChars.\n     *\n     * @param arr array of IndexedChars {@type IndexedChar[]}\n     * @return new IndexedString instance {@type IndexedString}\n     * @public\n     */\n    public static newFromArray(arr: IndexedChar[]): IndexedString {\n        return new IndexedString(arr.map(ic => ic.char).join(''), arr);\n    }\n\n    /**\n     * Private constructor to ensure compatible string and IndexCharArray.\n     *\n     * @param str string representation {@type string}\n     * @param chars IndexedChar representation {@type IndexedChar[]}\n     */\n    private constructor(private readonly str: string, private readonly chars: IndexedChar[]) { }\n\n    /**\n     * Returns string representation of the IndexedString.\n     *\n     * @return string representation of the IndexedString {@type string}\n     * @public\n     */\n    public toString(): string {\n        return this.str;\n    }\n\n    /**\n     * Returns length of the string.\n     *\n     * @return length of the string {@type number}\n     * @public\n     */\n    public length(): number {\n        return this.str.length;\n    }\n\n    /**\n     * Returns true if the IndexedString represents an empty string \"\".\n     *\n     * @return true if the IndexedString represents an empty string \"\" {@type boolean}\n     * @public\n     */\n    public isEmpty(): boolean {\n        return this.length() === 0;\n    }\n\n    /**\n     * Returns IndexedChar array representing the IndexedString.\n     * The array is reference to inner IndexedString structure.\n     *\n     * @return IndexedChar array representation {@type IndexedChar[]}\n     * @public\n     */\n    public getChars(): IndexedChar[] {\n        return this.chars;\n    }\n\n    /**\n     * Returns the original index of the first character of the IndexedString. Returns NaN if empty.\n     *\n     * @return original index of the first character {@type number}\n     * @public\n     */\n    public getFirstIndex(): number {\n        if (this.isEmpty()) {\n            return NaN;\n        }\n        return this.chars[0].index;\n    }\n\n    /**\n     * Returns the original index of the last character of the IndexedString. Returns NaN if empty.\n     *\n     * @return original index of the last character {@type number}\n     * @public\n     */\n    public getLastIndex(): number {\n        if (this.isEmpty()) {\n            return NaN;\n        }\n        return this.chars[this.length() - 1].index;\n    }\n\n    /**\n     * Returns indexes of the first and the last character of the IndexedString. Returns undefined if empty.\n     *\n     * @return indexes of the first and the last character {@type StartEndPair?}\n     * @public\n     */\n    public getRange(): StartEndPair | undefined {\n        if (this.isEmpty()) {\n            return undefined;\n        }\n        return { start: this.chars[0].index, end: this.chars[this.length() - 1].index };\n    }\n\n    /**\n     * Returns a string representation of the character at the given current index. Throws RangeError if the index is\n     * out of IndexedString bounds.\n     *\n     * @param index current index {@type number}\n     * @return char at the given index {@type string}\n     * @public\n     */\n    public charAt(index: number): string {\n        if (index < 0 || index >= this.length()) {\n            throw new RangeError();\n        }\n        return this.chars[index].char;\n    }\n\n    /**\n     * Returns an original position index of the character at the given current index. Throws RangeError if the given index is\n     * out of IndexedString bounds.\n     *\n     * @param index current index {@type number}\n     * @return original index {@type number}\n     * @public\n     */\n    public indexAt(index: number): number {\n        if (index < 0 || index >= this.length()) {\n            throw new RangeError();\n        }\n        return this.chars[index].index;\n    }\n\n    /**\n     * Split a string into substrings using the specified separator and return them as an array.\n     * It does not accept RegEx separators and array limit as built-in string.\n     *\n     * @param separator string separator {@type string}\n     * @return separated substrings {@type IndexedString[]}\n     * @public\n     */\n    public split(separator: string): IndexedString[] {\n        if (this.isEmpty()) {\n            if (separator === '') {\n                return [];\n            }\n            return [IndexedString.empty()];\n        }\n        const sepLen: number = separator.length;\n        const strSplit: string[] = this.str.split(separator);\n        const prefixSum: number[] = Array<number>(strSplit.length);\n        prefixSum[0] = 0;\n        for (let i = 1; i < strSplit.length; i++) {\n            prefixSum[i] = prefixSum[i - 1] + strSplit[i - 1].length + sepLen;\n        }\n\n        return strSplit.map((strSplit, index) => {\n            return new IndexedString(strSplit, this.chars.slice(prefixSum[index], prefixSum[index] + strSplit.length));\n        });\n    }\n\n    /**\n     * Returns a section of a IndexedString.\n     *\n     * @param start index of the beginning of the specified portion of stringObj {@type number}\n     * @param end index of the end of the specified portion of IndexedString. The substring includes the characters\n     * up to, but not including, the character indicated by end. If this value is not specified, the substring\n     * continues to the end of IndexedString {@type number}\n     * @return section of a IndexedString {@type IndexedString}\n     * @public\n     */\n    public slice(start: number, end?: number): IndexedString {\n        const _start = start < 0 ? this.length() + start : start;\n        const _end = end !== undefined ? (end < 0 ? this.length() + end : end) : this.length();\n        if (_start > _end || _start < 0 || _end > this.length()) {\n            throw new RangeError();\n        }\n        return IndexedString.newFromArray(this.chars.slice(_start, _end));\n    }\n\n    /**\n     * Removes the leading and trailing white space and line terminator characters from a string.\n     *\n     * @return returns an IndexedString without leading and trailing white space and line terminator characters {@type IndexedString[]}\n     * @public\n     */\n    public trim(): IndexedString {\n        const trimStr: string = this.str.trim();\n        if (trimStr === '') {\n            return new IndexedString('', []);\n        }\n        const start: number = this.str.indexOf(trimStr.charAt(0));\n        return IndexedString.newFromArray(this.chars.slice(start, start + trimStr.length));\n    }\n\n    /**\n     * Returns a string that contains the concatenation of this IndexedString with multiple other.\n     *\n     * @param strings IndexedStrings to append to the end of the string {@type ...IndexedString}\n     * @return string that contains the concatenation of this IndexedString with multiple other {@type IndexedString}\n     * @public\n     */\n    public concat(...strings: IndexedString[]): IndexedString {\n        return IndexedString.newFromArray(this.chars.concat(...strings.map(is => is.chars)));\n    }\n\n    /**\n     * Returns true if the searchString sequence is the same as the corresponding\n     * elements of this object starting at position. Otherwise returns false.\n     *\n     * @param searchString checked value {@type string}\n     * @param position position to start the IndexedString {@type number?}\n     * @return true if the IndexedString starts with the given searchString {@type boolean}\n     * @public\n     */\n    public startsWith(searchString: string, position?: number | undefined): boolean {\n        return this.str.startsWith(searchString, position);\n    }\n\n    /**\n     * Returns true if the searchString sequence is the same as the corresponding\n     * elements of this object starting at endPosition – searchString.length. Otherwise returns false.\n     *\n     * @param searchString checked value {@type string}\n     * @param endPosition position to end the IndexedString {@type number?}\n     * @return true if the IndexedString ends with the given searchString {@type boolean}\n     * @public\n     */\n    public endsWith(searchString: string, endPosition?: number | undefined): boolean {\n        return this.str.endsWith(searchString, endPosition);\n    }\n\n    /**\n     * Replaces text in a string, using a regular expression or search string.\n     * NOTE: Returns built-in string, the IndexedString is not modified.\n     *\n     * @param searchValue string or RegEx to search for {@type string}\n     * @param replaceValue string containing the text to replace for every successful match of searchValue in this string {@type string}\n     * @return built-in string with replaced values {@type string}\n     * @public\n     */\n    public replace(searchValue: string | RegExp, replaceValue: string): string {\n        return this.str.replace(searchValue, replaceValue);\n    }\n\n    /**\n     * Creates a deep copy of this IndexedString.\n     *\n     * @return deep copy of this IndexedString {@type IndexedString}\n     * @public\n     */\n    public copy(): IndexedString {\n        return new IndexedString(this.str, this.chars.map(ic => {return {char: ic.char, index: ic.index}}));\n    }\n\n    /**\n     * Returns true if it contains any of the characters from string chars. Otherwise, returns false.\n     *\n     * @param chars characters to search for {@type string}\n     * @return true if it contains any of the characters from string chars {@type boolean}\n     * @public\n     */\n    public containsAny(chars: string): boolean {\n        for (let i = 0; i < chars.length; ++i) {\n            if (this.str.indexOf(chars[i]) > -1) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n/**\n * Indexed representation of one character in {@link IndexedString}.\n * WARNING: It is always assumed that IndexedChar.char is a string of length 1.\n * @category Types\n * @public\n */\nexport interface IndexedChar {\n    /**\n     * char - string of length 1\n     * @type string\n     * @public\n     */\n    char: string,\n    /**\n     * index\n     * @type number\n     * @public\n     */\n    index: number\n}","import {IndexedString} from \"../types/indexedString\";\nimport {StringUtils} from \"./stringUtils\";\nimport {insertRangeIfUndefined} from \"../error/errorWithTextRange\";\nimport {RASyntaxError} from \"../error/raSyntaxError\";\nimport {ErrorFactory} from \"../error/errorFactory\";\nimport {language} from \"../language/language\";\nimport {Pair} from \"../types/pair\";\n\n/**\n * Class providing general helper functions for IndexedString.\n * @category Utils\n * @public\n */\nexport class IndexedStringUtils {\n\n    /**\n     * Returns true if the string contains letters only and has length at least 1.\n     * \n     * @param str Checked indexed string {@type IndexedString}\n     * @return true if the string contains letters only and has length at least 1 {@type boolean}\n     * @public\n     */\n    public static isWord(str: IndexedString): boolean {\n        return StringUtils.isWord(str.toString());\n    }\n\n    /**\n     * Returns true if the string contains letters, numbers and underscores only, has length at least 1 and starts with\n     * a letter or an underscore.\n     *\n     * @param str Checked string {@type IndexedString}\n     * @return true if the string contains letters, numbers and underscores only, has length at least 1 and starts with\n     * a letter or an underscore {@type boolean}\n     * @public\n     */\n    public static isName(str: IndexedString): boolean {\n        return StringUtils.isName(str.toString());\n    }\n\n    /**\n     * Returns true if the string contains whitespaces only.\n     *\n     * @param str Checked string {@type IndexedString}\n     * @return true if the string contains whitespaces only {@type boolean}\n     * @public\n     */\n    public static isWhitespacesOnly(str: IndexedString): boolean {\n        return StringUtils.isWhitespacesOnly(str.toString());\n    }\n\n    /**\n     * Returns true if the given string has length one and the character is a letter.\n     *\n     * @param c Checked character {@type IndexedString}\n     * @return true if the given string has length one and the character is a letter {@type boolean}\n     * @public\n     */\n    public static isLetter(c: IndexedString): boolean {\n        return StringUtils.isLetter(c.toString());\n    }\n\n    /**\n     * Returns true if the given string has length one and the character is a letter, a number or an underscore.\n     *\n     * @param c Checked character {@type IndexedString}\n     * @return true if the given string has length one and the character is a letter, a number or an underscore {@type boolean}\n     * @public\n     */\n    public static isNameChar(c: IndexedString): boolean {\n        return StringUtils.isNameChar(c.toString());\n    }\n\n    /**\n     * Returns true if the given string has length one and the character is a digit.\n     *\n     * @param c Checked character {@type IndexedString}\n     * @return true if the given string has length one and the character is a digit {@type boolean}\n     * @public\n     */\n    public static isDigit(c: IndexedString): boolean {\n        return StringUtils.isDigit(c.toString());\n    }\n\n    /**\n     * Returns true if the string represents a decimal number.\n     *\n     * @param str Checked string {@type IndexedString}\n     * @return true if the string represents a decimal number {@type boolean}\n     * @public\n     */\n    public static isNumber(str: IndexedString): boolean {\n        return StringUtils.isNumber(str.toString());\n    }\n\n    /**\n     * Splits given indexed string to a starting sequence of letters and its rest and returns these parts in a pair.\n     * NOTE: if the string does not start with a letter, as a word is returned an empty string.\n     *\n     * @param str indexed string to be split {@type IndexedString}\n     * @return split indexed string in a pair (word, rest) {@type Pair<IndexedString>}\n     * @public\n     */\n    public static nextWord(str: IndexedString): Pair<IndexedString> {\n        const strParts: Pair<string> = StringUtils.nextWord(str.toString());\n        return { first: str.slice(0, strParts.first.length), second: str.slice(strParts.first.length)};\n    }\n\n    /**\n     * Splits given indexed string to a starting sequence of letters, numbers and underscores, which starts with a letter or\n     * an underscore and its rest and returns these parts in a pair.\n     * NOTE: if the string does not start with a letter, or an underscore, as a name is returned an empty string.\n     *\n     * @param str string to be split {@type IndexedString}\n     * @return split indexed string in a pair (name, rest) {@type Pair<IndexedString>}\n     * @public\n     */\n    public static nextName(str: IndexedString): Pair<IndexedString> {\n        const strParts: Pair<string> = StringUtils.nextName(str.toString());\n        return { first: str.slice(0, strParts.first.length), second: str.slice(strParts.first.length)};\n    }\n\n    /**\n     * Splits given indexed string to a starting sequence of non-whitespace characters and its rest and returns these\n     * parts in a pair.\n     *\n     * @param str string to be split {@type IndexedString}\n     * @return split indexed string in a pair (name, rest) {@type Pair<IndexedString>}\n     * @public\n     */\n    public static nextNonWhitespacePart(str: IndexedString): Pair<IndexedString> {\n        const strParts: Pair<string> = StringUtils.nextNonWhitespacePart(str.toString());\n        return { first: str.slice(0, strParts.first.length), second: str.slice(strParts.first.length)};\n    }\n\n    /**\n     * Splits given indexed string to a starting number and its rest and returns these parts in a pair.\n     * NOTE: if the string does not start with a digit, as a number is returned an empty string.\n     *\n     * @param str indexed string to be split {@type IndexedString}\n     * @return split indexed string in a pair (word, rest) {@type Pair<IndexedString>}\n     * @public\n     */\n    static nextNumber(str: IndexedString): Pair<IndexedString> {\n        const strParts: Pair<string> = StringUtils.nextNumber(str.toString());\n        return { first: str.slice(0, strParts.first.length), second: str.slice(strParts.first.length)};\n    }\n\n    /**\n     * Splits the given indexed string into starting quoted part and the rest. Quotes can be escaped by an odd count of\n     * backslashes.\n     * NOTE: When the closing quote is not found until the rest of the line, unclosed string is returned\n     * => the error is not thrown, it is only added to the return object.\n     * NOTE: First character of the string is expected to be '\"'.\n     *\n     * @param str string to be split {@type IndexedString}\n     * @return pair of the starting bordered part and the rest {@type Object}\n     * @public\n     */\n    static nextQuotedString(str: IndexedString): { first: IndexedString, second: IndexedString, error: RASyntaxError | undefined } {\n        const strParts: { first: string, second: string, error: RASyntaxError | undefined } = StringUtils.nextQuotedString(str.toString());\n        return {\n            first: str.slice(0, strParts.first.length),\n            second: str.slice(strParts.first.length),\n            error: insertRangeIfUndefined(strParts.error, {start: str.getFirstIndex(), end: str.getFirstIndex()})\n        };\n    }\n\n    /**\n     * Splits the indexed string to the starting bordered part and the rest and returns these parts in a pair.\n     * If there is only one ending character and it differs from the starting one, nested bordering is supported.\n     * Characters after escape character are ignored and cannot start or end a bordered part.\n     * Starting and ending characters in quoted part are ignored.\n     * NOTE: First character of the string is expected to be 'start'.\n     * NOTE: Should not be used for slicing quoted strings, use nextQuotedString instead.\n     * NOTE: It is expected, that there are no comments in the given string.\n     *\n     * @param str indexed string to be split {@type IndexedString}\n     * @param start starting character of the string and also starting character of the bordered part (one character) {@type string}\n     * @param end ending characters of the bordered part (one or more characters) {@type string}\n     * @param escape character which makes next character being ignored (default '\\0') {@type string}\n     * @return pair of the starting bordered part and the rest as indexed strings {@type Pair<IndexedString>}\n     * @public\n     */\n    static nextBorderedPart(str: IndexedString, start: string, end: string, escape: string = '\\0'): Pair<IndexedString> {\n        try {\n            const strParts: Pair<string> = StringUtils.nextBorderedPart(str.toString(), start, end, escape);\n            return { first: str.slice(0, strParts.first.length), second: str.slice(strParts.first.length)};\n        }\n        catch (err) {\n            throw insertRangeIfUndefined(err, {start: str.getFirstIndex(), end: str.getFirstIndex()});\n        }\n    }\n\n    /**\n     * Deletes all line and block comments from the given IndexedString.\n     * If there is unclosed block comment, return the error as well.\n     * Line comment \"//comment\\n\" will be changed to \"\\n\" - new line is kept.\n     * Block comment \"/\\*comment* /\" will be changed to \" \" - it is replaced by a space to ensure splitting of the content around.\n     *\n     * @param str string to delete comments in {@type IndexedString}\n     * @return string with deleted comments and optimal error {@type Object}\n     * @public\n     */\n    public static deleteAllComments(str: IndexedString): {str: IndexedString, err: RASyntaxError | undefined} {\n        const chars = str.copy().getChars();\n        // to ignore special characters\n        let inQuotes: boolean = false;\n        let inLineComment: boolean = false;\n        let blockCommentStart: number = -1;\n        let backslashes: number = 0;\n\n        for (let i = 0; i < chars.length; ++i) {\n            const curChar = chars[i].char;\n            // found quote if even number of backslashes before\n            if (curChar === '\"' && (backslashes % 2) === 0 && !inLineComment && blockCommentStart === -1) {\n                inQuotes = !inQuotes;\n            }\n            // found start of a line comment if it is not in a comment already\n            else if (curChar === '/' && i + 1 < chars.length && chars[i + 1].char === '/' && !inQuotes && !inLineComment && blockCommentStart === -1) {\n                inLineComment = true;\n                chars[i].char = '\\0';\n                ++i;    // skips '/'\n            }\n            // newlines ends the line comment\n            else if (curChar === '\\n') {\n                inLineComment = false;\n            }\n            // found start of a block comment if it is not in a comment already\n            else if (curChar === '/' && i + 1 < chars.length && chars[i + 1].char === '*' && !inQuotes && !inLineComment && blockCommentStart === -1) {\n                blockCommentStart = i;\n                chars[i].char = '\\0';\n                ++i;    // skips '*'\n                chars[i].char = ' ';\n            }\n            // found end of a block comment\n            else if (curChar === '*' && i + 1 < chars.length && chars[i + 1].char === '/' && blockCommentStart !== -1) {\n                blockCommentStart = -1;\n                chars[i].char = '\\0';\n                ++i;    // replaces '/' with space to force splitting of string in the comment place\n                chars[i].char = ' ';\n            }\n            // updates backslash count\n            if (curChar === '\\\\') {\n                ++backslashes;\n            }\n            else {\n                backslashes = 0;\n            }\n            if (inLineComment || blockCommentStart !== -1) {\n                chars[i].char = '\\0';\n            }\n        }\n        let err = undefined;\n        if (blockCommentStart !== -1) {\n            const errStart = chars[blockCommentStart].index;\n            err = ErrorFactory.syntaxError(language().syntaxErrors.stringUtils_missingClosingChar,\n              {start: errStart, end: errStart + 1}, '*/', '/*');\n        }\n        // creates a new string from non-null characters\n        return {str: IndexedString.newFromArray(chars.filter(c => c.char !== '\\0')), err: err};\n    }\n\n    /**\n     * Skips all whitespaces and exactly one given character and returns rest of the string.\n     * If the string does not match this pattern, throws error.\n     *\n     * @param str string to be skipped in {@type IndexedString}\n     * @param char char to be skipped exactly one time (expected to be string of length 1) {@type string}\n     * @return given string without starting sequence of whitespaces and exactly one char {@type IndexedString}\n     * @public\n     */\n    public static skipWhitespacesAndChar(str: IndexedString, char: string): IndexedString {\n        try {\n            const skippedStr: string = StringUtils.skipWhitespacesAndChar(str.toString(), char);\n            return str.slice(str.length() - skippedStr.length);\n        }\n        catch (err) {\n            throw insertRangeIfUndefined(err, str.getRange());\n        }\n    }\n}","import {RATreeNode} from \"./raTreeNode\";\n\n/**\n * Classes extending unary node.\n * @category RATree\n * @public\n */\nexport type UnaryNodeClass = \"rename\" | \"projection\" | \"selection\";\n\n/**\n * Abstract node of the relational algebra syntactic tree with one subtree.\n * @extends RATreeNode\n * @category RATree\n * @public\n */\nexport abstract class UnaryNode extends RATreeNode {\n\n    protected subtree: RATreeNode;\n\n    /**\n     * Creates a new UnaryNode.\n     *\n     * @param subtree subtree of the node {@type RATreeNode}\n     * @public\n     */\n    protected constructor(subtree: RATreeNode) {\n        super();\n        this.subtree = subtree;\n    }\n\n    /**\n     * Returns subtree of the unary node.\n     *\n     * @return subtree of the unary node {@type RATreeNode}\n     * @public\n     */\n    public getSubtree(): RATreeNode {\n        return this.subtree;\n    }\n}","import {ColumnContent, SupportedColumnType} from \"./columnType\";\nimport {isEqual} from \"lodash\";\nimport {ErrorFactory} from \"../error/errorFactory\";\nimport {language} from \"../language/language\";\n\n/**\n * Row stores a set of column values in a formal {@link Relation} representation.\n *\n * @category Relation\n * @public\n */\nexport class Row {\n\n    private readonly types = new Map<string, SupportedColumnType>();\n    private values = new Map<string, ColumnContent>();\n    private finished: boolean;\n\n    /**\n     * Creates a new row with given columns. Given column set is final, no more column can be added.\n     * Given column values are set to null. They can be set to a new value by addColumn function, as long as the row\n     * is not set finished.\n     *\n     * @param columns set of columns in a row {@type Map<String, SupportedColumnType>}\n     * @public\n     */\n    public constructor(columns: Map<string, SupportedColumnType>) {\n        // adds empty columns\n        columns.forEach((value, name) => {\n            this.values.set(name, null);\n        });\n        this.types = columns;\n        this.finished = false;\n    }\n\n    /**\n     * Returns whether the row is finished and no more column change is possible.\n     *\n     * @return true if the row is finished {@type boolean}\n     * @public\n     */\n    public isFinished(): boolean {\n        return this.finished;\n    }\n\n    /**\n     * Sets the row as finished, no more changes in column values are possible.\n     * @public\n     */\n    public finish(): void {\n        this.finished = true;\n    }\n\n    /**\n     * Gets names of all columns in a row.\n     *\n     * @return set of all column names {@type IterableIterator<String>}\n     * @public\n     */\n    public getColumnNames(): IterableIterator<string> {\n        return this.types.keys();\n    }\n\n    /**\n     * Adds a value to the row. If the addition succeeded, returns true. It can fail, if the row is finished,\n     * if there is no column of the given name or if there is a column with the name, but different type.\n     *\n     * @param name name of the column {@type string}\n     * @param value new value of the column {@type ColumnContent}\n     * @return true if addition succeeded {@type boolean}\n     * @public\n     */\n    public addValue(name: string, value: ColumnContent): boolean {\n        // finished row or not present column\n        if (this.finished || !this.types.has(name)) {\n            return false;\n        }\n        let givenType = typeof value;\n        // null can be set all column types\n        if (value !== null && givenType !== this.types.get(name)) {\n            return false;\n        }\n        this.values.set(name, value);\n        return true;\n    }\n\n    /**\n     * Gets the value (possibly null) of the column with the given name. If there is no column with this name, undefined is returned.\n     *\n     * @param name name of the column {@type string}\n     * @return value of the column or undefined if there is no such column {@type ColumnContent?}\n     * @public\n     */\n    public getValue(name: string): ColumnContent | undefined {\n        return this.values.get(name);\n    }\n\n    /**\n     * Returns the type of the given column or undefined if the column is absent.\n     *\n     * @param name name of the column {@type string}\n     * @return the type of the column {@type SupportedColumnType?}\n     * @public\n     */\n    public getType(name: string): SupportedColumnType | undefined {\n        return this.types.get(name);\n    }\n\n    /**\n     * Gets types of all columns.\n     *\n     * @return map of columns {@type Map<String, SupportedColumnType>}\n     * @public\n     */\n    public getTypes(): Map<string, SupportedColumnType> {\n        return this.types;\n    }\n\n    /**\n     * Gets values of all columns.\n     *\n     * @return map of columns {@type Map<String, ColumnContent>}\n     * @public\n     */\n    public getValues(): Map<string, ColumnContent> {\n        return this.values;\n    }\n\n    /**\n     * Returns values of all columns ordered by given array of column names. OrderedColumns are expected to be from the\n     * relation that contains the row. The returned values are converted to string type. String column values are\n     * changed to printing representation - escaped '\\\\' and '\"' are returned without the escape '\\\\'.\n     *\n     * @param orderedColumns order of columns to be returned {@type string[]}\n     * @return ordered array of values {@type string[]}\n     * @public\n     */\n    public getOrderedPrintValues(orderedColumns: string[]): string[] {\n        let ret: string[] = [];\n        orderedColumns.forEach(column => {\n            const value = this.values.get(column);\n            const type = this.types.get(column);\n            // should be handled before call\n            if (value === undefined || type === undefined) {\n                throw ErrorFactory.codeError(language().codeErrors.row_absentColumn, column, [...this.types.values()].join(', '));\n            }\n            if (type === \"string\") {\n                const str = String(value).replace(/\\\\\"/g, '\"').replace(/\\\\\\\\/g, '\\\\');\n                ret.push(str);\n            }\n            else {\n                ret.push(String(value));\n            }\n        });\n        return ret;\n    }\n\n    /**\n     * Custom equals function.\n     *\n     * @param other object to compare to {@type any}\n     * @return whether this and given object has the same values and types\n     * @public\n     */\n    public equals(other: Object): boolean {\n        if (other instanceof Row) {\n            return isEqual(this.types, other.types) && isEqual(this.values, other.values);\n        }\n        return false;\n    }\n}\n","import {UnaryNode} from \"./unaryNode\";\nimport {RATreeNode} from \"./raTreeNode\";\nimport {Relation} from \"../relation/relation\";\nimport {Row} from \"../relation/row\";\nimport {IndexedString} from \"../types/indexedString\";\nimport {ErrorFactory} from \"../error/errorFactory\";\nimport {language} from \"../language/language\";\nimport {StartEndPair} from \"../types/startEndPair\";\n\n/**\n * Projection node of the relational algebra syntactic tree.\n * @extends UnaryNode\n * @category RATree\n * @public\n */\nexport class ProjectionNode extends UnaryNode {\n\n    private readonly projection: IndexedString;\n    private readonly stringRange: StartEndPair;\n\n    /**\n     * Creates a new ProjectionNode.\n     * Expects the projection string to start with '[' and end with ']'.\n     *\n     * @param projection string describing projected columns {@type IndexedString}\n     * @param subtree source subtree {@type RATreeNode}\n     * @public\n     */\n    constructor(projection: IndexedString, subtree: RATreeNode) {\n        super(subtree);\n        this.projection = projection;\n        // @ts-ignore - should never be empty\n        this.stringRange = projection.getRange();\n    }\n\n    /**\n     * Parses projection string to set of projected columns and their ranges.\n     */\n    private parseProjection(): Set<{str: string, range: StartEndPair}> {\n        const ret = new Set<{str: string, range: StartEndPair}>();\n        let str: string = this.projection.toString().replace(/]/g, ',');\n        const projStart: number = this.stringRange.start;\n        let start: number = 1;\n        for (let i = 1; i < this.projection.length(); ++i) {\n            if (str.charAt(i) === ',') {\n                const range = (start === i) ? {start: projStart + start - 1, end: projStart + i - 1} :\n                  {start: projStart + start, end: projStart + i - 1};\n                ret.add({str: str.slice(start, i).trim(), range});\n                start = i + 1;\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Evaluates the RA query in this node and its subtree.\n     * After successful call, this.resultRelation must be set to valid Relation.\n     * Expectations: projected names are subset of source schema\n     * @public\n     */\n    public eval(): void {\n        if (this.isEvaluated()) {\n            return;\n        }\n        // handles empty projection\n        if (this.projection.toString().slice(1, -1).trim().length === 0) {\n            throw ErrorFactory.semanticError(language().semanticErrors.projectionNode_emptyProjection, this.stringRange);\n        }\n        const source: Relation = this.subtree.getResult();\n        const projectedIndexed: {str: string, range: StartEndPair}[] = [...this.parseProjection()];\n        // checks if projected columns really exist in source relation\n        projectedIndexed.forEach(proj => {\n            if (!source.hasColumn(proj.str)) {\n                throw ErrorFactory.semanticError(language().semanticErrors.projectionNode_absentColumn, proj.range, proj.str);\n            }\n        });\n\n        const projected: string[] = projectedIndexed.map(p => p.str);\n        const result: Relation = new Relation(source.getName() + \"[...]\");\n        // projection of relational schema\n        source.forEachColumn((type, name) => {\n            if (projected.indexOf(name) > -1) {\n                result.addColumn(name, type);\n            }\n        });\n        // projection of relation rows\n        source.getRows().forEach(row => {\n             let newRow: Row = new Row(result.getColumns());\n             row.getValues().forEach((value, name) => {\n                 if (projected.indexOf(name) > -1) {\n                     newRow.addValue(name, value);\n                 }\n             });\n             result.addRow(newRow);\n        });\n        this.resultRelation = result;\n    }\n\n    /**\n     * Evaluates the RA query in this node and its subtree.\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\n     * Otherwise returns the result relation schema (only column names, no rows).\n     * When an error occurs, it is faked to work, and adds it to the errors array.\n     *\n     * Strict expectations: projected names are subset of source schema\n     * Returned schema: intersection of projected names and source schema\n     *\n     * @param cursorIndex index of the cursor in original text input {@type number}\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper {@type NodeFakeEvalResult}\n     * @public\n     */\n    public fakeEval(cursorIndex: number) {\n        let source = this.subtree.fakeEval(cursorIndex);\n        // checks whether the cursor is in this projection block - saves current available columns\n        let whispers = source.whispers;\n        if (this.stringRange !== undefined && this.stringRange.start < cursorIndex && cursorIndex <= this.stringRange.end) {\n            whispers = source.result.getColumnNames();\n        }\n        // adds errors from current expression\n        const errors = source.errors;\n        // creates relational schema - \"projected columns\"\n        const result: Relation = new Relation(source.result.name + \"[...]\");\n        // handles empty projection\n        if (this.projection.toString().slice(1, -1).trim().length === 0) {\n            errors.push(ErrorFactory.semanticError(language().semanticErrors.projectionNode_emptyProjection, this.stringRange));\n            return {result, whispers, errors};\n        }\n        const projected: Set<{str: string, range: StartEndPair}> = this.parseProjection();\n        // adds only projected, which exist in source\n        const absent: {str: string, range: StartEndPair}[] = [];\n        projected.forEach(proj => {\n            const strName = proj.str;\n            if (source.result.hasColumn(strName)) {\n                // @ts-ignore - strName must be in the source now\n                result.addColumn(strName, source.result.getColumns().get(strName));\n            }\n            else {\n                absent.push(proj);\n            }\n        });\n        absent.forEach(proj => {\n            errors.push(ErrorFactory.semanticError(language().semanticErrors.projectionNode_absentColumn, proj.range, proj.str));\n        });\n        return {result, whispers, errors};\n    }\n\n    /**\n     * Creates a string with a structure of the RA tree in one line.\n     *\n     * @return string with a structure of the RA tree in one line {@type string}\n     * @public\n     */\n    public printInLine(): string {\n        return this.subtree.printInLine() + this.getOperationSymbol();\n    }\n\n    /**\n     * Return the word name of the RA operation of the node.\n     * Example: returns \"Selection\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n    public getOperationName(): string {\n        return language().operations.projection;\n    }\n\n    /**\n     * Return the symbolic representation of the RA operation of the node.\n     * Example: returns \"(some + expr = 15)\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n    public getOperationSymbol(): string {\n        return this.projection.replace(/\\s+/g, ' ');\n    }\n}","import {IndexedString} from \"../types/indexedString\";\n\n/**\n * Lowercase reserved keywords which cannot be used for column names. They are:\n * - Null value: null\n * - Boolean values: true, false\n * - Empty string: \"\"\n */\nconst forbiddenColumnNames: string[] = [\"null\", \"true\", \"false\", \"\"];\n\n/**\n * Reserved keywords which cannot be used for relation names. They are:\n * - First characters of outer joins: F, L, R\n * - Empty string: \"\"\n */\nconst forbiddenRelationNames: string[] = [\"F\", \"L\", \"R\", \"\"];\n\n/**\n * Returns lowercase reserved keywords which cannot be used for column names. They are:\n * - Null value: null\n * - Boolean values: true, false\n * - Empty string: \"\"\n *\n * @return lowercase reserved column-keywords {@type string[]}\n * @category Utils\n * @public\n */\nexport function getForbiddenColumnNames(): string[] {\n    return forbiddenColumnNames;\n}\n\n/**\n * Returns reserved keywords which cannot be used for relation names. They are:\n * - First characters of outer joins: F, L, R, f, l, r\n * - Empty string: \"\"\n *\n * @return lowercase reserved relation-keywords {@type string[]}\n * @category Utils\n * @public\n */\nexport function getForbiddenRelationNames(): string[] {\n    return forbiddenRelationNames;\n}\n\n/**\n * Returns true if the given string is forbidden as a column name.\n *\n * @param str string to check {@type (string | IndexedString)}\n * @return true if the given string is forbidden as a column name {@type boolean}\n * @category Utils\n * @public\n */\nexport function isForbiddenColumnName(str: string | IndexedString): boolean {\n    return forbiddenColumnNames.indexOf(str.toString().toLowerCase()) > -1;\n}\n\n/**\n * Returns true if the given string is forbidden as a relation name.\n *\n * @param str string to check {@type (string | IndexedString)}\n * @return true if the given string is forbidden as a relation name {@type boolean}\n * @category Utils\n * @public\n */\nexport function isForbiddenRelationName(str: string | IndexedString): boolean {\n    // does not use to lower because forbidden names are upper\n    return forbiddenRelationNames.indexOf(str.toString()) > -1;\n}","import {IndexedString} from \"./indexedString\";\n\ninterface KeyValue {\n    key: IndexedString,\n    value: IndexedString\n}\n\n/**\n * Wrapper of JavaScript Map object to provide usage of object {@link IndexedString} as a key for {@link IndexedString} values.\n * @category Types\n * @public\n */\nexport class ISToISMap {\n    private map: Map<string, KeyValue> = new Map<string, KeyValue>();\n\n    /**\n     * Gets the value for the given key.\n     *\n     * @param key key of the value to get {@type (string | IndexedString)}\n     * @return value of the given key or undefined {@type IndexedString?}\n     * @public\n     */\n    public get(key: string | IndexedString): IndexedString | undefined {\n        const keyValue = this.map.get(key.toString());\n        return keyValue === undefined ? undefined : keyValue.value;\n    }\n\n    /**\n     * Sets the value for the given key.\n     *\n     * @param key key of the value to set {@type IndexedString}\n     * @param value value to set {@type IndexedString}\n     * @public\n     */\n    public set(key: IndexedString, value: IndexedString): void {\n        this.map.set(key.toString(), {key, value});\n    }\n\n    /**\n     * Deletes the value for the given key.\n     *\n     * @param key key of the value to delete {@type IndexedString}\n     * @return true if an element in the Map object existed and has been removed, or false if the element does not exist {@type boolean}\n     * @public\n     */\n    public delete(key: IndexedString): boolean {\n        return this.map.delete(key.toString());\n    }\n\n    /**\n     * Returns true, if the given key is in the map.\n     *\n     * @param key key to check {@type (string | IndexedString)}\n     * @return true, if the given key is in the map {@type boolean}\n     * @public\n     */\n    public has(key: string | IndexedString): boolean {\n        return this.map.has(key.toString());\n    }\n\n    /**\n     * Removes all values from the map.\n     * @public\n     */\n    public clear(): void {\n        this.map.clear();\n    }\n\n    /**\n     * Returns the size og the map.\n     *\n     * @return size of the map {@type number}\n     * @public\n     */\n    public size(): number {\n        return this.map.size;\n    }\n\n    /**\n     * Performs the given function for each (value, key, index) in the map.\n     *\n     * @param f function to perform {@type function}\n     * @public\n     */\n    public forEach(f: (value: IndexedString, row: IndexedString, index?: number) => void): void {\n        [...this.map.values()].forEach((keyValue, index) => f(keyValue.value, keyValue.key, index));\n    }\n}","import {Row} from \"../relation/row\";\nimport {VEResult, VETreeNode} from \"./veTreeNode\";\nimport {ErrorFactory} from \"../error/errorFactory\";\nimport {IndexedString} from \"../types/indexedString\";\nimport {language} from \"../language/language\";\n\n/**\n * Enum of types of ComparingOperator class.\n * @enum {number}\n * @category VETree\n * @public\n */\nexport enum ComparingOperatorType {\n    equal,\n    nonEqual,\n    less,\n    more,\n    lessOrEqual,\n    moreOrEqual\n}\n\n/**\n * Comparing operator compares two values and returns boolean.\n * @extends VETreeNode\n * @category VETree\n * @public\n */\nexport class ComparingOperator extends VETreeNode {\n\n    /**\n     * Creates new ComparingOperator instance of equality type (type = ComparingOperatorType.equal).\n     *\n     * @param operator used string representation of equality operator {@type IndexedString}\n     * @param left left subtree producing a value {@type VETreeNode}\n     * @param right right subtree producing a value {@type VETreeNode}\n     * @return new ComparingOperator instance of equality type {@type ComparingOperator}\n     * @public\n     */\n    public static equal(operator: IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\n        return new ComparingOperator(ComparingOperatorType.equal, operator, left, right);\n    }\n\n    /**\n     * Creates new ComparingOperator instance of non-equality type (type = ComparingOperatorType.nonEqual).\n     *\n     * @param operator used string representation of non-equality operator {@type IndexedString}\n     * @param left left subtree producing a value {@type VETreeNode}\n     * @param right right subtree producing a value {@type VETreeNode}\n     * @return new ComparingOperator instance of non-equality type {@type ComparingOperator}\n     * @public\n     */\n    public static nonEqual(operator: IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\n        return new ComparingOperator(ComparingOperatorType.nonEqual, operator, left, right);\n    }\n\n    /**\n     * Creates new ComparingOperator instance of less type (type = ComparingOperatorType.less).\n     *\n     * @param operator used string representation of less operator {@type IndexedString}\n     * @param left left subtree producing a value {@type VETreeNode}\n     * @param right right subtree producing a value {@type VETreeNode}\n     * @return new ComparingOperator instance of less type {@type ComparingOperator}\n     * @public\n     */\n    public static less(operator: IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\n        return new ComparingOperator(ComparingOperatorType.less, operator, left, right);\n    }\n\n    /**\n     * Creates new ComparingOperator instance of more type (type = ComparingOperatorType.more).\n     *\n     * @param operator used string representation of more operator {@type IndexedString}\n     * @param left left subtree producing a value {@type VETreeNode}\n     * @param right right subtree producing a value {@type VETreeNode}\n     * @return new ComparingOperator instance of more type {@type ComparingOperator}\n     * @public\n     */\n    public static more(operator: IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\n        return new ComparingOperator(ComparingOperatorType.more, operator, left, right);\n    }\n\n    /**\n     * Creates new ComparingOperator instance of less-or-equal type (type = ComparingOperatorType.lessOrEqual).\n     *\n     * @param operator used string representation of less-or-equal operator {@type IndexedString}\n     * @param left left subtree producing a value {@type VETreeNode}\n     * @param right right subtree producing a value {@type VETreeNode}\n     * @return new ComparingOperator instance of less-or-equal type {@type ComparingOperator}\n     * @public\n     */\n    public static lessOrEqual(operator: IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\n        return new ComparingOperator(ComparingOperatorType.lessOrEqual, operator, left, right);\n    }\n\n    /**\n     * Creates new ComparingOperator instance of more-or-equal type (type = ComparingOperatorType.moreOrEqual).\n     *\n     * @param operator used string representation of more-or-equal operator {@type IndexedString}\n     * @param left left subtree producing a value {@type VETreeNode}\n     * @param right right subtree producing a value {@type VETreeNode}\n     * @return new ComparingOperator instance of more-or-equal type {@type ComparingOperator}\n     * @public\n     */\n    public static moreOrEqual(operator: IndexedString, left: VETreeNode, right: VETreeNode): ComparingOperator {\n        return new ComparingOperator(ComparingOperatorType.moreOrEqual, operator, left, right);\n    }\n\n    /**\n     * Creates new ComparingOperator of the given type.\n     *\n     * @param type ComparingOperator type {@type ComparingOperatorType}\n     * @param operator used string representation of the operator {@type IndexedString}\n     * @param left left subtree producing a value {@type VETreeNode}\n     * @param right right subtree producing a value {@type VETreeNode}\n     * @public\n     */\n    public constructor(private readonly type: ComparingOperatorType, private readonly operator: IndexedString,\n                       private readonly left: VETreeNode, private readonly right: VETreeNode) {\n        super();\n    }\n\n    /**\n     * Evaluate the node and its subtrees and compares their value results to produce a boolean value. It needs to\n     * receive results of the same type from its subtrees.\n     * NOTE: If one of the subtree results is null, only equality and non-equality are valid. Other comparing\n     * operations returns always false.\n     *\n     * @param source row with actual values of columns recursively passed to leaf reference nodes {@type Row}\n     * @return boolean comparing left and right subtree values {@type VEResult}\n     * @public\n     */\n    public eval(source: Row): VEResult {\n        const leftResult: VEResult = this.left.eval(source);\n        const rightResult: VEResult = this.right.eval(source);\n\n        if (leftResult.type !== \"null\" && rightResult.type !== \"null\" && leftResult.type !== rightResult.type) {\n            throw ErrorFactory.syntaxError(language().syntaxErrors.comparingOperator_differentInputTypes,\n                this.operator.getRange(), this.operator.toString(), leftResult.type, rightResult.type);\n        }\n\n        // if both values are null but both types are not null, returns false\n        if (leftResult.value === null && rightResult.value === null && leftResult.type !== \"null\" && rightResult.type !== \"null\") {\n            return {value: false, type: \"boolean\"};\n        }\n        if (this.type === ComparingOperatorType.equal) {\n            return {value: leftResult.value === rightResult.value, type: \"boolean\"};\n        }\n        if (this.type === ComparingOperatorType.nonEqual) {\n            // if any value of non-null type is null, returns false\n            if ((leftResult.value === null && leftResult.type !== \"null\") || (rightResult.value === null && rightResult.type !== \"null\")) {\n                return {value: false, type: \"boolean\"};\n            }\n            return {value: leftResult.value !== rightResult.value, type: \"boolean\"};\n        }\n        if (this.type === ComparingOperatorType.less) {\n            if (leftResult.value === null || rightResult.value === null) {\n                return {value: false, type: \"boolean\"};\n            }\n            return {value: leftResult.value < rightResult.value, type: \"boolean\"};\n        }\n        if (this.type === ComparingOperatorType.more) {\n            if (leftResult.value === null || rightResult.value === null) {\n                return {value: false, type: \"boolean\"};\n            }\n            return {value: leftResult.value > rightResult.value, type: \"boolean\"};\n        }\n        if (this.type === ComparingOperatorType.lessOrEqual) {\n            if (leftResult.value === null || rightResult.value === null) {\n                return {value: false, type: \"boolean\"};\n            }\n            return {value: leftResult.value <= rightResult.value, type: \"boolean\"};\n        }\n        // if (this.type === ComparingOperatorType.moreOrEqual)\n        if (leftResult.value === null || rightResult.value === null) {\n            return {value: false, type: \"boolean\"};\n        }\n        return {value: leftResult.value >= rightResult.value, type: \"boolean\"};\n    }\n\n    /**\n     * Returns string representation of the node.\n     *\n     * @return string representation of the node {@type string}\n     * @public\n     */\n    public toString(): string {\n        return \"(\" + this.left.toString() + \" \" + this.operator.toString() + \" \" + this.right.toString() + \")\";\n    }\n}","import {UnaryNode} from \"./unaryNode\";\nimport {RATreeNode} from \"./raTreeNode\";\nimport {StringUtils} from \"../utils/stringUtils\";\nimport {Relation} from \"../relation/relation\";\nimport {SupportedColumnType} from \"../relation/columnType\";\nimport {Row} from \"../relation/row\";\nimport {IndexedString} from \"../types/indexedString\";\nimport {ErrorFactory} from \"../error/errorFactory\";\nimport {isForbiddenColumnName} from \"../utils/keywords\";\nimport {ErrorWithTextRange} from \"../error/errorWithTextRange\";\nimport {ISToISMap} from \"../types/isToISMap\";\nimport {language} from \"../language/language\";\nimport {StartEndPair} from \"../types/startEndPair\";\n\n/**\n * Renaming node of the relational algebra syntactic tree.\n * @extends UnaryNode\n * @category RATree\n * @public\n */\nexport class RenameNode extends UnaryNode {\n\n    private readonly rename: IndexedString;\n    private readonly stringRange: StartEndPair | undefined;\n\n    /**\n     * Creates a new RenameNode.\n     * The rename string is expected to start with '<' and end with '>'.\n     *\n     * @param rename string describing each renaming {@type IndexedString}\n     * @param subtree source subtree {@type RATreeNode}\n     * @public\n     */\n    public constructor(rename: IndexedString, subtree: RATreeNode) {\n        super(subtree);\n        this.rename = rename;\n        this.stringRange = rename.getRange();\n    }\n\n    private parseChanges(doThrow: boolean, errors: ErrorWithTextRange[] = []): ISToISMap {\n        const handleError = (error: SyntaxError) => {\n            if (doThrow) {\n                throw error;\n            } else {\n                errors.push(error);\n            }\n        }\n        const parts: IndexedString[] = this.rename.slice(1, -1).split(\",\");\n        const ret: ISToISMap = new ISToISMap();\n        for (let part of parts) {\n            // @ts-ignore\n            let words: IndexedString[] = part.split(\"->\").map(w => w.trim());\n            let beforeError = false; // true when there was an error in before in \"before -> after\"\n            let afterError = false;  // true when there was an error in after in \"before -> after\"\n            if (words.length !== 2) {\n                let range = part.getRange();\n                if (part.isEmpty() && this.stringRange !== undefined) {\n                    range = {start: this.stringRange.start, end: this.stringRange.start};\n                }\n                handleError(ErrorFactory.syntaxError(language().syntaxErrors.renameNode_missingArrow, range));\n                beforeError = true;\n                afterError = true;\n            }\n            if (!beforeError && ret.has(words[0])) {\n                handleError(ErrorFactory.syntaxError(language().syntaxErrors.renameNode_multipleRenameOfTheColumn,\n                    words[0].getRange(), words[0].toString()));\n                beforeError = true;\n            }\n            if (!afterError && !StringUtils.isName(words[1].toString())) {\n                handleError(ErrorFactory.syntaxError(language().syntaxErrors.renameNode_invalidNewName,\n                    words[1].getRange(), words[1].toString()));\n                afterError = true;\n            }\n            if (!afterError && isForbiddenColumnName(words[1])) {\n                handleError(ErrorFactory.syntaxError(language().syntaxErrors.renameNode_keywordNewName,\n                    words[1].getRange(), words[1].toString()));\n                afterError = true;\n            }\n            // if no error found, adds original rename pair\n            if (!beforeError && !afterError) {\n                ret.set(words[0], words[1]);\n            }\n            // if no before error, fakes rename \"before -> before\"\n            else if (!beforeError) {\n                ret.set(words[0], words[0]);\n            }\n            // if no after error, fakes rename \"\"\" -> before\", where empty string has undefined range\n            else if (!afterError) {\n                ret.set(IndexedString.empty(), words[0]);\n            }\n            // if both errors, adds nothing\n        }\n        return ret;\n    }\n\n    /**\n     * Evaluates the RA query in this node and its subtree.\n     * After successful call, this.resultRelation must be set to valid Relation.\n     * Expectations: original names in projection pair (original -> new) are subset of the source schema,\n     * new names with rest of the source schema contain no duplicity\n     * @public\n     */\n    public eval(): void {\n        if (this.isEvaluated()) {\n            return;\n        }\n        const changes: ISToISMap = this.parseChanges(true);\n        const source: Relation = this.subtree.getResult();\n        // check whether all columns to rename are in source relation\n        changes.forEach((value, key) => {\n             if (source.getColumnNames().indexOf(key.toString()) === -1) {\n                 throw ErrorFactory.semanticError(language().semanticErrors.renameNode_absentOriginalColumn,\n                     key.getRange(), key.toString());\n             }\n        });\n        // rename of relational schema\n        const result: Relation = new Relation(source.getName() + \"<...>\");\n        const toChange: Map<string, SupportedColumnType> = new Map<string, SupportedColumnType>();\n        // in first loop adds unchanged columns only\n        source.forEachColumn((type, name) => {\n            if (changes.has(name)) {\n                toChange.set(name, type);\n            }\n            else {\n                result.addColumn(name, type);\n            }\n        });\n        // in second loop adds changed columns\n        toChange.forEach((type, name) => {\n            // @ts-ignore (changes must contain 'name' key now)\n            if (!result.addColumn(changes.get(name).toString(), type)) {\n                const newName = changes.get(name);\n                throw ErrorFactory.semanticError(language().semanticErrors.renameNode_changeToDuplicit,\n                    this.rename.getRange(), newName ? newName.toString() : \"\");\n            }\n        });\n        // rename of relation rows\n        source.getRows().forEach(row => {\n            const newRow: Row = new Row(result.getColumns());\n            row.getValues().forEach((value, name) => {\n                const returned = changes.get(name);\n                if (typeof returned === \"undefined\") {\n                    newRow.addValue(name, value);\n                }\n                else {\n                    newRow.addValue(returned.toString(), value);\n                }\n            });\n            result.addRow(newRow);\n        });\n        this.resultRelation = result;\n    }\n    /**\n     * Evaluates the RA query in this node and its subtree.\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\n     * Otherwise returns the result relation schema (only column names, no rows).\n     * When an error occurs, it is faked to work, and adds it to the errors array.\n     *\n     * Strict expectations: original names in projection pair (original -> new) are subset of the source schema,\n     * new names with rest of the source schema contain no duplicity\n     * Returned schema: if the cursor is not after the arrow '->' returns\n     * (source schema minus originals) union (news whose originals were in source schema),\n     * otherwise returns empty array (does not whisper to what the user should rename)\n     *\n     * @param cursorIndex index of the cursor in original text input {@type number}\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper {@type NodeFakeEvalResult}\n     * @public\n     */\n    public fakeEval(cursorIndex: number) {\n        const source = this.subtree.fakeEval(cursorIndex);\n        // checks whether the cursor is in this rename block\n        let whispers = source.whispers;\n        if (this.stringRange !== undefined && this.stringRange.start < cursorIndex && cursorIndex <= this.stringRange.end) {\n            whispers = source.result.getColumnNames();\n        }\n        // adds errors from current expression\n        const errors = source.errors;\n        const changes: ISToISMap = this.parseChanges(false, errors);\n        // creates relational schema - \"(source minus to-rename) union (renamed existing in source)\"\n        const result: Relation = new Relation(source.result.getName() + \"<...>\");\n        // in first loop adds source columns which are not in changes.keys\n        source.result.forEachColumn((type, name) => {\n            if (!changes.has(name)) {\n                result.addColumn(name, type);\n            }\n        });\n        // in second loop adds changes.values whose changes.keys are in source\n        const absent: IndexedString[] = [];\n        const duplicit: IndexedString[] = [];\n        changes.forEach((after, before) => {\n            const beforeStr = before.toString();\n            const afterStr = after.toString();\n            if (!source.result.hasColumn(beforeStr) && !before.isEmpty()) {\n                absent.push(before);\n            }\n            // @ts-ignore source must have beforeStr now\n            else if(!result.addColumn(afterStr, source.result.getColumns().get(beforeStr))) {\n                duplicit.push(after);\n            }\n        });\n        absent.forEach(column => {\n            errors.push(ErrorFactory.semanticError(language().semanticErrors.renameNode_absentOriginalColumn,\n                column.getRange(), column.toString()));\n        });\n        duplicit.forEach(column => {\n            errors.push(ErrorFactory.semanticError(language().semanticErrors.renameNode_changeToDuplicit,\n                column.getRange(), column.toString()));\n        });\n        return {result, whispers, errors};\n    }\n\n    /**\n     * Creates a string with a structure of the RA tree in one line.\n     *\n     * @return string with a structure of the RA tree in one line {@type string}\n     * @public\n     */\n    public printInLine(): string {\n        return this.subtree.printInLine() + this.getOperationSymbol();\n    }\n\n    /**\n     * Return the word name of the RA operation of the node.\n     * Example: returns \"Selection\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n    public getOperationName(): string {\n        return language().operations.rename;\n    }\n\n    /**\n     * Return the symbolic representation of the RA operation of the node.\n     * Example: returns \"(some + expr = 15)\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n    public getOperationSymbol(): string {\n        return this.rename.replace(/\\s+/g, ' ');\n    }\n}","import {Row} from \"../relation/row\";\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\n\n/**\n * Result of the VETreeNode evaluation.\n * @category VETree\n * @public\n */\nexport interface VEResult {\n    /**\n     * result value\n     * @type ColumnContent\n     * @public\n     */\n    value: ColumnContent,\n    /**\n     * result type\n     * @type (SupportedColumnType | \"null\")\n     * @public\n     */\n    type: SupportedColumnType | \"null\"\n}\n\n/**\n * Abstract class for value-evaluating nodes producing new values.\n * @category VETree\n * @public\n */\nexport abstract class VETreeNode {\n\n    /**\n     * Evaluates this value-evaluating tree.\n     *\n     * @param source row with values to be used to reference to {@type Row}\n     * @return evaluated value and its type {@type VEResult}\n     * @public\n     */\n    public abstract eval(source: Row): VEResult;\n\n    /**\n     * Returns string representation of the node.\n     *\n     * @return string representation of the node {@type string}\n     * @public\n     */\n    public abstract toString(): string;\n}","import {Row} from \"../relation/row\";\nimport {VEResult, VETreeNode} from \"./veTreeNode\";\nimport {ErrorFactory} from \"../error/errorFactory\";\nimport {IndexedString} from \"../types/indexedString\";\nimport {language} from \"../language/language\";\n\n/**\n * Enum of types of LogicalOperator class.\n * @category VETree\n * @public\n */\nenum LogicalOperatorType {\n    and,\n    or,\n    not\n}\n\n/**\n * Logical operator chains boolean values and produces new ones.\n * @extends VETreeNode\n * @category VETree\n * @public\n */\nexport class LogicalOperator extends VETreeNode {\n\n    /**\n     * Creates an 'and' logical operator.\n     *\n     * @param operator String representing an 'and' in input (used to printing) {@type IndexedString}\n     * @param left Left subtree evaluating to a boolean value {@type VETreeNode}\n     * @param right Right subtree evaluating to a boolean value {@type VETreeNode}\n     * @return new LogicalOperator instance of and type {@type LogicalOperator}\n     * @public\n     */\n    public static and(operator: IndexedString, left: VETreeNode, right: VETreeNode): LogicalOperator {\n        return new LogicalOperator(LogicalOperatorType.and, operator, left, right);\n    }\n\n    /**\n     * Creates an 'or' logical operator.\n     *\n     * @param operator String representing an 'or' in input (used to printing) {@type IndexedString}\n     * @param left Left subtree evaluating to a boolean value {@type VETreeNode}\n     * @param right Right subtree evaluating to a boolean value {@type VETreeNode}\n     * @return new LogicalOperator instance of and type {@type LogicalOperator}\n     * @public\n     */\n    public static or(operator: IndexedString, left: VETreeNode, right: VETreeNode): LogicalOperator {\n        return new LogicalOperator(LogicalOperatorType.or, operator, left, right);\n    }\n\n    /**\n     * Creates a 'not' logical operator.\n     *\n     * @param operator String representing a 'not' in input (used to printing) {@type IndexedString}\n     * @param subtree Subtree evaluating to a boolean value {@type VETreeNode}\n     * @return new LogicalOperator instance of and type {@type LogicalOperator}\n     * @public\n     */\n    public static not(operator: IndexedString, subtree: VETreeNode): LogicalOperator {\n        return new LogicalOperator(LogicalOperatorType.not, operator, subtree);\n    }\n\n    private constructor(private readonly type: LogicalOperatorType, private readonly operator: IndexedString,\n                        private readonly left: VETreeNode, private readonly right?: VETreeNode) {\n        super();\n    }\n\n    /**\n     * Evaluates recursively subtrees and transforms their boolean results into a new boolean.\n     * If any subtree evaluates to string or number, throws error.\n     *\n     * @param source row with actual values of columns recursively passed to leaf reference nodes {@type Row}\n     * @return boolean comparing left and right subtree values {@type VEResult}\n     * @public\n     */\n    public eval(source: Row): { value: boolean, type: \"boolean\" } {\n        const leftResult: VEResult = this.left.eval(source);\n        if (leftResult.type !== \"boolean\") {\n            throw ErrorFactory.syntaxError(language().syntaxErrors.logicalOperator_leftInputNotBoolean,\n                this.operator.getRange(), this.operator.toString(), leftResult.type);\n        }\n\n        if (this.type === LogicalOperatorType.not) {\n            if (leftResult.value === null) {\n                return { value: false, type: \"boolean\" };\n            }\n            return { value: !leftResult.value, type: \"boolean\" };\n        }\n        else {\n            // @ts-ignore (in and/or operations right subtree must exist)\n            const rightResult: VEResult = this.right.eval(source);\n            if (rightResult.type !== \"boolean\") {\n                throw ErrorFactory.syntaxError(language().syntaxErrors.logicalOperator_rightInputNotBoolean,\n                    this.operator.getRange(), this.operator.toString(), rightResult.type);\n            }\n\n            if (this.type === LogicalOperatorType.and) {\n                if (leftResult.value === null || rightResult.value === null) {\n                    return { value: false, type: \"boolean\" };\n                }\n                // @ts-ignore (they must be both booleans now)\n                return { value: leftResult.value && rightResult.value, type: \"boolean\" };\n            }\n            else /* if (this.type === LogicalOperatorType.or)*/ {\n                if (leftResult.value === null && rightResult.value === null) {\n                    return { value: false, type: \"boolean\" };\n                }\n                if (leftResult.value === null) {\n                    // @ts-ignore (it must be boolean now)\n                    return { value: rightResult.value, type: \"boolean\" };\n                }\n                if (rightResult.value === null) {\n                    // @ts-ignore (it must be boolean now)\n                    return { value: leftResult.value, type: \"boolean\" };\n                }\n                // @ts-ignore (they must be both booleans now)\n                return { value: leftResult.value || rightResult.value, type: \"boolean\" };\n            }\n        }\n    }\n\n    /**\n     * Returns string representation of the node.\n     *\n     * @return string representation of the node {@type string}\n     * @public\n     */\n    public toString(): string {\n        if (this.type === LogicalOperatorType.not) {\n            return this.operator.toString() + \"(\" + this.left.toString() + \")\";\n        }\n        // @ts-ignore (in and, or operations right subtree must exist)\n        return \"(\" + this.left.toString() + \" \" + this.operator.toString() + \" \" + this.right.toString() + \")\";\n    }\n}","import {Row} from \"../relation/row\";\nimport {VEResult, VETreeNode} from \"./veTreeNode\";\nimport {ErrorFactory} from \"../error/errorFactory\";\nimport {language} from \"../language/language\";\nimport {StartEndPair} from \"../types/startEndPair\";\n\n/**\n * Enum of types of ComputingOperator class.\n * @category VETree\n * @public\n */\nenum ComputingOperatorType {\n    plus = \"+\",\n    minus = \"-\",\n    multiplication = \"*\",\n    division = \"/\"\n}\n\n/**\n * Comparing operator takes two number values and returns a new computed number.\n * @extends VETreeNode\n * @category VETree\n * @public\n */\nexport class ComputingOperator extends VETreeNode {\n\n    /**\n     * Creates an addition (+) computing operator.\n     *\n     * @param left Left subtree evaluating to a number value {@type VETreeNode}\n     * @param right Right subtree evaluating to a number value {@type VETreeNode}\n     * @param range Range of the operator in the input string to highlight errors {@type StartEndPair?}\n     * @return new ComputingOperator instance of add type {@type ComputingOperator}\n     * @public\n     */\n    public static add(left: VETreeNode, right: VETreeNode, range: StartEndPair | undefined): ComputingOperator {\n        return new ComputingOperator(ComputingOperatorType.plus, left, right, range);\n    }\n\n    /**\n     * Creates a deduction (-) computing operator.\n     *\n     * @param left Left subtree evaluating to a number value {@type VETreeNode}\n     * @param right Right subtree evaluating to a number value {@type VETreeNode}\n     * @param range Range of the operator in the input string to highlight errors {@type StartEndPair?}\n     * @return new ComputingOperator instance of deduct type {@type ComputingOperator}\n     * @public\n     */\n    public static deduct(left: VETreeNode, right: VETreeNode, range: StartEndPair | undefined): ComputingOperator {\n        return new ComputingOperator(ComputingOperatorType.minus, left, right, range);\n    }\n\n    /**\n     * Creates a multiplication (*) computing operator.\n     *\n     * @param left Left subtree evaluating to a number value {@type VETreeNode}\n     * @param right Right subtree evaluating to a number value {@type VETreeNode}\n     * @param range Range of the operator in the input string to highlight errors {@type StartEndPair?}\n     * @return new ComputingOperator instance of multiply type {@type ComputingOperator}\n     * @public\n     */\n    public static multiply(left: VETreeNode, right: VETreeNode, range: StartEndPair | undefined): ComputingOperator {\n        return new ComputingOperator(ComputingOperatorType.multiplication, left, right, range);\n    }\n\n    /**\n     * Creates a division (/) computing operator.\n     *\n     * @param left Left subtree evaluating to a number value {@type VETreeNode}\n     * @param right Right subtree evaluating to a number value {@type VETreeNode}\n     * @param range Range of the operator in the input string to highlight errors {@type StartEndPair?}\n     * @return new ComputingOperator instance of divide type {@type ComputingOperator}\n     * @public\n     */\n    public static divide(left: VETreeNode, right: VETreeNode, range: StartEndPair | undefined): ComputingOperator {\n        return new ComputingOperator(ComputingOperatorType.division, left, right, range);\n    }\n\n    private constructor(private readonly type: ComputingOperatorType, private readonly left: VETreeNode,\n                        private readonly right: VETreeNode, private readonly range: StartEndPair | undefined) {\n        super();\n    }\n\n    /**\n     * Evaluates recursively subtrees and transforms their number results into a new number.\n     * If any subtree evaluates to string or boolean, throws error.\n     * If any subtree evaluates to null, returns null.\n     *\n     * @param source row with actual values of columns recursively passed to leaf reference nodes {@type Row}\n     * @return number produced from subtrees with given operation, or null if any subtree returned null {@type VEResult}\n     */\n    public eval(source: Row): { value: number | null, type: \"number\" } {\n        const leftResult: VEResult = this.left.eval(source);\n        const rightResult: VEResult = this.right.eval(source);\n\n        if (leftResult.type !== \"number\" || rightResult.type !== \"number\") {\n            throw ErrorFactory.syntaxError(language().syntaxErrors.computingOperator_inputTypesNotNumbers, this.range,\n                this.type, leftResult.type, rightResult.type);\n        }\n\n        if (leftResult.value === null || rightResult.value === null) {\n            return { value: null, type: \"number\" };\n        }\n\n        switch (this.type) {\n            case ComputingOperatorType.plus:\n                // @ts-ignore (ensured by first if)\n                return { value: leftResult.value + rightResult.value, type: \"number\" };\n            case ComputingOperatorType.minus:\n                // @ts-ignore (ensured by first if)\n                return { value: leftResult.value - rightResult.value, type: \"number\" };\n            case ComputingOperatorType.multiplication:\n                // @ts-ignore (ensured by first if)\n                return { value: leftResult.value * rightResult.value, type: \"number\" };\n            case ComputingOperatorType.division:\n                // @ts-ignore (ensured by first if)\n                return { value: leftResult.value / rightResult.value, type: \"number\" };\n        }\n    }\n\n    /**\n     * Returns string representation of the node.\n     *\n     * @return string representation of the node {@type string}\n     * @public\n     */\n    public toString(): string {\n        return \"(\" + this.left.toString() + \" \" + this.type + \" \" + this.right.toString() + \")\";\n    }\n}","import {Row} from \"../relation/row\";\nimport {VEResult, VETreeNode} from \"./veTreeNode\";\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\n\n/**\n * Class storing literal value of number, string or null type.\n * @extends VETreeNode\n * @category VETree\n * @public\n */\nexport class LiteralValue extends VETreeNode {\n\n    /**\n     * Creates a literal storing given value.\n     *\n     * @param value value to be returned by eval(...) function {@type ColumnContent}\n     * @param type type of the literal value {@type (SupportedColumnType | \"null\")}\n     */\n    public constructor(private readonly value: ColumnContent, private readonly type: SupportedColumnType | \"null\") {\n        super();\n    }\n\n    /**\n     * Returns stored value.\n     *\n     * @param source row with actual values of columns (note: not used in literals) {@type Row}\n     * @return stored value and its type {@type VEResult}\n     * @public\n     */\n    public eval(source: Row): VEResult {\n        return { value: this.value, type: this.type };\n    }\n\n    /**\n     * Returns string representation of the node.\n     *\n     * @return string representation of the node {@type string}\n     * @public\n     */\n    public toString(): string {\n        if (this.value === null) {\n            return \"null\";\n        }\n        return this.value.toString();\n    }\n}","import {Row} from \"../relation/row\";\nimport {VETreeNode} from \"./veTreeNode\";\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\nimport {ErrorFactory} from \"../error/errorFactory\";\nimport {IndexedString} from \"../types/indexedString\";\nimport {language} from \"../language/language\";\n\n/**\n * Class storing reference to a column.\n * @extends VETreeNode\n * @category VETree\n * @public\n */\nexport class ReferenceValue extends VETreeNode {\n\n    /**\n     * Creates a reference to the given column.\n     *\n     * @param columnName name of the referenced column {@type IndexedString}\n     * @public\n     */\n    public constructor(private readonly columnName: IndexedString) {\n        super();\n    }\n\n    /**\n     * Returns value (expected to be string, number, or boolean) of the referenced column from given source row.\n     *\n     * @param source row with actual values of columns {@type Row}\n     * @return referenced value and its type {@type VEResult}\n     * @public\n     */\n    public eval(source: Row): { value: ColumnContent, type: SupportedColumnType } {\n        const value: ColumnContent | undefined = source.getValue(this.columnName.toString());\n        const type: SupportedColumnType | undefined = source.getType(this.columnName.toString());\n        if (value === undefined || type === undefined) {\n            throw ErrorFactory.semanticError(language().semanticErrors.referenceValue_absentColumn,\n                this.columnName.getRange(), this.columnName.toString(), [...source.getColumnNames()].join(', '));\n        }\n        return { value: value, type: type };\n    }\n\n    /**\n     * Returns string representation of the node.\n     *\n     * @return string representation of the node {@type string}\n     * @public\n     */\n    public toString(): string {\n        return this.columnName.toString();\n    }\n}","import {ComparingOperatorType} from \"../vetree/comparingOperator\";\nimport {ColumnContent, SupportedColumnType} from \"../relation/columnType\";\nimport {IndexedString} from \"../types/indexedString\";\nimport {StartEndPair} from \"../types/startEndPair\";\n\n/**\n * Precedence value for all token types.\n */\nconst precedenceNot: number = 50;\nconst precedenceMulDiv: number = 30;\nconst precedencePlusMinus: number = 25;\nconst precedenceComparison: number = 20;\nconst precedenceAnd: number = 10;\nconst precedenceOr: number = 5;\n\n/**\n * Tokens used for parsing of string expression to BooleanEvaluating tree.\n */\nexport abstract class ValueToken {\n    protected constructor(public readonly str: IndexedString) {}\n\n    /**\n     * Gets token start and end index in the text (if the token has IndexedString representation) or undefined.\n     */\n    public getRange(): StartEndPair | undefined {\n        return this.str.getRange();\n    }\n}\n\nexport abstract class OperatorToken extends ValueToken {\n    protected constructor(str: IndexedString, readonly precedence: number) {\n        super(str);\n    }\n}\n\nexport class LogicalNotToken extends OperatorToken {\n    constructor(operator: IndexedString) {\n        super(operator, precedenceNot);\n    }\n}\n\nexport class LogicalAndToken extends OperatorToken {\n    constructor(operator: IndexedString) {\n        super(operator, precedenceAnd);\n    }\n}\n\nexport class LogicalOrToken extends OperatorToken {\n    constructor(operator: IndexedString) {\n        super(operator, precedenceOr);\n    }\n}\n\nexport class ComputingMultiplicationToken extends OperatorToken {\n    constructor(operator: IndexedString) {\n        super(operator, precedenceMulDiv);\n    }\n}\n\nexport class ComputingDivisionToken extends OperatorToken {\n    constructor(operator: IndexedString) {\n        super(operator, precedenceMulDiv);\n    }\n}\n\nexport class ComputingPlusToken extends OperatorToken {\n    constructor(operator: IndexedString) {\n        super(operator, precedencePlusMinus);\n    }\n}\n\nexport class ComputingMinusToken extends OperatorToken {\n    constructor(operator: IndexedString) {\n        super(operator, precedencePlusMinus);\n    }\n}\n\nexport class ComparingToken extends OperatorToken {\n    constructor(readonly type: ComparingOperatorType, operator: IndexedString) {\n        super(operator, precedenceComparison);\n    }\n}\n\nexport abstract class ParenthesisToken extends ValueToken {\n    protected constructor(operator: IndexedString) {\n        super(operator);\n    }\n}\n\nexport class OpeningParentheses extends ParenthesisToken {\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n    constructor(operator: IndexedString) {\n        super(operator);\n    }\n}\n\nexport class ClosingParentheses extends ParenthesisToken {\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n    constructor(operator: IndexedString) {\n        super(operator);\n    }\n}\n\nexport class LiteralToken extends ValueToken {\n    constructor(str: IndexedString, readonly value: ColumnContent, readonly type: SupportedColumnType | \"null\") {\n        super(str);\n    }\n}\n\nexport class ReferenceToken extends ValueToken {\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n    constructor(columnName: IndexedString) {\n        super(columnName);\n    }\n}","import {StringUtils} from \"../utils/stringUtils\";\nimport {ComparingOperator, ComparingOperatorType} from \"../vetree/comparingOperator\";\nimport {LogicalOperator} from \"../vetree/logicalOperator\";\nimport {LiteralValue} from \"../vetree/literalValue\";\nimport {ReferenceValue} from \"../vetree/referenceValue\";\nimport {ComputingOperator} from \"../vetree/computingOperator\";\nimport {\n    ClosingParentheses,\n    ComparingToken,\n    ComputingDivisionToken,\n    ComputingMinusToken,\n    ComputingMultiplicationToken,\n    ComputingPlusToken,\n    LiteralToken,\n    LogicalAndToken,\n    LogicalNotToken,\n    LogicalOrToken,\n    OpeningParentheses,\n    OperatorToken,\n    ParenthesisToken,\n    ReferenceToken,\n    ValueToken\n} from \"./valueTokens\"\nimport {VETreeNode} from \"../vetree/veTreeNode\";\nimport {IndexedString} from \"../types/indexedString\";\nimport {IndexedStringUtils} from \"../utils/indexedStringUtils\";\nimport {ErrorWithTextRange, insertRangeIfUndefined} from \"../error/errorWithTextRange\";\nimport {ErrorFactory} from \"../error/errorFactory\";\nimport {RASyntaxError} from \"../error/raSyntaxError\";\nimport {language} from \"../language/language\";\n\n/**\n * Parser of the logic-algebraic subexpressions in relational algebra expressions.\n * @category Expression\n * @public\n */\nexport class ValueParser {\n\n    /**\n     * Parses given string infix boolean and algebraic expression into a value-evaluating tree and returns the tree.\n     * Uses Shunting-yard algorithm (first, it transforms the string into reverse polish notation).\n     * Supported expressions:\n     * - logical: and (&&, &), or (||, |), not (!, ~)\n     * - computing: addition (+), deduction (-), multiplication (*), division (/)\n     * - comparing: equal (==, =), non-equal (!=, <>), less (<), more (>), less-or-equal (<=), more-or-equal (>=)\n     * - literals: numbers (1, 5.02, etc.), strings (\"String\", \"With inner \\\" symbol\", etc.), nulls (null),\n     * booleans (true, false)\n     * - column references (ColumnNameAsStringWithoutQuotes, Id, etc.)\n     *\n     * @param str infix boolean and algebraic expression to be parsed {@type IndexedString}\n     * @param nullValuesSupport whether null values are supported {@type boolean}\n     * @return VETreeNode root of the evaluation tree {@type VETreeNode}\n     * @public\n     */\n    public static parse(str: IndexedString, nullValuesSupport: boolean): VETreeNode {\n        let tokens: ValueToken[] = ValueParser.parseTokens(str, nullValuesSupport, true);\n        this.assertValidInfixTokens(tokens, true);\n        tokens = this.simplify(tokens);\n        try {\n            const rpn: ValueToken[] = ValueParser.toRPN(tokens);\n            return ValueParser.rpnToVETree(rpn);\n        }\n        catch (err) {\n            throw insertRangeIfUndefined(err, str.getRange());\n        }\n    }\n\n    /**\n     * Parses given string infix boolean and algebraic expression and returns errors in it.\n     * For supported operations see {@link parse}.\n     *\n     * @param str infix boolean and algebraic expression to be parsed {@type IndexedString}\n     * @param nullValuesSupport whether null values are supported {@type boolean}\n     * @param columns available source column names {@type string[]}\n     * @return detected errors {@type ErrorWithTextRange[]}\n     * @public\n     */\n    public static fakeParse(str: IndexedString, nullValuesSupport: boolean, columns: string[]): ErrorWithTextRange[] {\n        const errors: ErrorWithTextRange[] = [];\n        let tokens: ValueToken[] = ValueParser.parseTokens(str, nullValuesSupport, false, errors);\n        tokens.forEach(token => {\n            if (token instanceof ReferenceToken && columns.indexOf(token.str.toString()) === -1) {\n                errors.push(ErrorFactory.semanticError(language().semanticErrors.referenceValue_absentColumn,\n                    token.str.getRange(), token.str.toString(), columns.join(', ')));\n            }\n        })\n        this.assertValidInfixTokens(tokens, false, errors);\n        return errors;\n    }\n\n    /**\n     * Parses given string infix boolean and algebraic expression into an array of Tokens.\n     * Tokens are returned infix (in order parsed from string).\n     * If doThrow is true, found errors are thrown. Otherwise, they are added in errors array and ignored.\n     *\n     * @param str infix boolean and algebraic expression to be parsed\n     * @param nullValuesSupport whether null values are supported\n     * @param doThrow true if errors should be thrown\n     * @param errors array for storing not thrown errors\n     * @return infix array of parsed Tokens\n     */\n    public static parseTokens(str: IndexedString, nullValuesSupport: boolean, doThrow: boolean,\n                              errors: ErrorWithTextRange[] = []): ValueToken[] {\n        const handleError = (error: RASyntaxError) => {\n            if (doThrow) {\n                throw error;\n            }\n            else {\n                errors.push(error);\n            }\n        }\n        let rest: IndexedString = str.trim();\n        if (rest.isEmpty()) {\n            handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_emptyInput, undefined));\n        }\n        const tokens: ValueToken[] = [];\n        while (!rest.isEmpty()) {\n            // PARENTHESES\n            if (rest.startsWith('(')) {\n                tokens.push(new OpeningParentheses(rest.slice(0, 1)));\n                rest = rest.slice(1);\n            }\n            else if (rest.startsWith(')')) {\n                tokens.push(new ClosingParentheses(rest.slice(0, 1)));\n                rest = rest.slice(1);\n            }\n            // COMPUTING OPERATORS\n            else if (rest.startsWith('+')) {\n                tokens.push(new ComputingPlusToken(rest.slice(0, 1)));\n                rest = rest.slice(1);\n            }\n            else if (rest.startsWith('-')) {\n                tokens.push(new ComputingMinusToken(rest.slice(0, 1)));\n                rest = rest.slice(1);\n            }\n            else if (rest.startsWith('*')) {\n                tokens.push(new ComputingMultiplicationToken(rest.slice(0, 1)));\n                rest = rest.slice(1);\n            }\n            else if (rest.startsWith('/')) {\n                tokens.push(new ComputingDivisionToken(rest.slice(0, 1)));\n                rest = rest.slice(1);\n            }\n            // COMPARING OPERATORS\n            else if (rest.startsWith('==')) {\n                tokens.push(new ComparingToken(ComparingOperatorType.equal, rest.slice(0, 2)));\n                rest = rest.slice(2);\n            }\n            else if (rest.startsWith('=')) {     // NOTE: needs to be after '==' check\n                tokens.push(new ComparingToken(ComparingOperatorType.equal, rest.slice(0, 1)));\n                rest = rest.slice(1);\n            }\n            else if (rest.startsWith('!=')) {\n                tokens.push(new ComparingToken(ComparingOperatorType.nonEqual, rest.slice(0, 2)));\n                rest = rest.slice(2);\n            }\n            else if (rest.startsWith('<>')) {\n                tokens.push(new ComparingToken(ComparingOperatorType.nonEqual, rest.slice(0, 2)));\n                rest = rest.slice(2);\n            }\n            else if (rest.startsWith('<=')) {\n                tokens.push(new ComparingToken(ComparingOperatorType.lessOrEqual, rest.slice(0, 2)));\n                rest = rest.slice(2);\n            }\n            else if (rest.startsWith('>=')) {\n                tokens.push(new ComparingToken(ComparingOperatorType.moreOrEqual, rest.slice(0, 2)));\n                rest = rest.slice(2);\n            }\n            else if (rest.startsWith('<')) {\n                tokens.push(new ComparingToken(ComparingOperatorType.less, rest.slice(0, 1)));\n                rest = rest.slice(1);\n            }\n            else if (rest.startsWith('>')) {\n                tokens.push(new ComparingToken(ComparingOperatorType.more, rest.slice(0, 1)));\n                rest = rest.slice(1);\n            }\n            // LOGICAL OPERATORS\n            else if (rest.startsWith('!') || rest.startsWith('~')\n                || rest.startsWith('\\u00ac')) { // NOTE: needs to be after '!=' check\n                tokens.push(new LogicalNotToken(rest.slice(0, 1)));\n                rest = rest.slice(1);\n            }\n            else if (rest.startsWith('&&')) {\n                tokens.push(new LogicalAndToken(rest.slice(0, 2)));\n                rest = rest.slice(2);\n            }\n            else if (rest.startsWith('&') || rest.startsWith('\\u2227')) { // NOTE: needs to be after '&&' check\n                tokens.push(new LogicalAndToken(rest.slice(0, 1)));\n                rest = rest.slice(1);\n            }\n            else if (rest.startsWith('||')) {\n                tokens.push(new LogicalOrToken(rest.slice(0, 2)));\n                rest = rest.slice(2);\n            }\n            else if (rest.startsWith('|') || rest.startsWith('\\u2228')) { // NOTE: needs to be after '||' check\n                tokens.push(new LogicalOrToken(rest.slice(0, 1)));\n                rest = rest.slice(1);\n            }\n            // LITERALS\n            else if (rest.startsWith('\"')) {\n                const split = IndexedStringUtils.nextQuotedString(rest);\n                if (split.error !== undefined) {\n                    handleError(split.error);\n                }\n                const end = split.first.length() > 1 ? -1 : undefined;\n                const str = split.first.slice(1, end);\n                tokens.push(new LiteralToken(str, str.toString(), \"string\"));\n                rest = split.second;\n            }\n            else if (StringUtils.isDigit(rest.charAt(0))) {\n                let split = IndexedStringUtils.nextNumber(rest);\n                tokens.push(new LiteralToken(split.first, Number(split.first.toString()), \"number\"));\n                rest = split.second;\n            }\n            else if (rest.startsWith('null')) {\n                if (!nullValuesSupport) {\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_unsupportedNull,\n                        rest.slice(0, 4).getRange()));\n                }\n                tokens.push(new LiteralToken(rest.slice(0, 4), null, \"null\"));\n                rest = rest.slice(4);\n            }\n            else if (rest.startsWith('true') || rest.startsWith('True') || rest.startsWith('TRUE')) {\n                tokens.push(new LiteralToken(rest.slice(0, 4), true, \"boolean\"));\n                rest = rest.slice(4);\n            }\n            else if (rest.startsWith('false') || rest.startsWith('False') || rest.startsWith('FALSE')) {\n                tokens.push(new LiteralToken(rest.slice(0, 5), false, \"boolean\"));\n                rest = rest.slice(5);\n            }\n            // COLUMN REFERENCE\n            else if (StringUtils.isLetter(rest.charAt(0)) || rest.charAt(0) === '_') {\n                let split = IndexedStringUtils.nextName(rest);\n                tokens.push(new ReferenceToken(split.first));\n                rest = split.second;\n            }\n            // UNEXPECTED PART\n            else {\n                const split = IndexedStringUtils.nextNonWhitespacePart(rest);\n                handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_unexpectedPart,\n                    split.first.getRange(), split.first.toString()));\n                rest = rest.slice(split.first.length());\n            }\n            rest = rest.trim();\n        }\n        return tokens;\n    }\n\n    /**\n     * It checks whether all adjacent pairs of tokens are possible and if the array start and end are valid\n     * (e.i., it starts with '(', literal, column reference or '!' and it ends with ')', literal or column reference).\n     * If doThrow is true, found errors are thrown. Otherwise, they are added in errors array and ignored.\n     */\n    public static assertValidInfixTokens(tokens: ValueToken[], doThrow: boolean, errors: ErrorWithTextRange[] = []) {\n        if (tokens.length === 0) {\n            return;\n        }\n        \n        const handleError = (error: RASyntaxError) => {\n            if (doThrow) {\n                throw error;\n            }\n            else {\n                errors.push(error);\n            }\n        }\n        \n        // checks start of an array: it must start with '(', literal, reference or '!'\n        // it cannot start with binary operator or ')'\n        if ((tokens[0] instanceof ClosingParentheses) || ((tokens[0] instanceof OperatorToken) && !(tokens[0] instanceof LogicalNotToken))) {\n            handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_invalidStart,\n                tokens[0].getRange(), tokens[0].str.toString()));\n        }\n        // checks end of an array: it must end with ')', literal or reference\n        // it cannot end with operator or '('\n        if ((tokens[tokens.length - 1] instanceof OpeningParentheses) || (tokens[tokens.length - 1] instanceof OperatorToken)) {\n            handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_invalidEnd,\n                tokens[tokens.length - 1].getRange(), tokens[tokens.length - 1].str.toString()));\n        }\n        // checks adjacent pairs of tokens\n        let i2: number = 1;\n        while (i2 < tokens.length) {\n            const token1: ValueToken = tokens[i2 - 1];\n            const token2: ValueToken = tokens[i2];\n            ++i2;\n\n            // valid predecessors: operator or '('\n            // invalid predecessors: literal, reference or ')'\n            if (token2 instanceof LiteralToken) {\n                if (token1 instanceof LiteralToken) {\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_literalAfterLiteral,\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\n                }\n                if (token1 instanceof ReferenceToken) {\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_literalAfterReference,\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\n                }\n                if (token1 instanceof ClosingParentheses) {\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_literalAfterClosing,\n                        token2.getRange(), token2.str.toString()));\n                }\n            }\n            // valid predecessors: operator or '('\n            // invalid predecessors: literal, reference or ')'\n            else if (token2 instanceof ReferenceToken) {\n                if (token1 instanceof LiteralToken) {\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_referenceAfterLiteral,\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\n                }\n                if (token1 instanceof ReferenceToken) {\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_referenceAfterReference,\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\n                }\n                if (token1 instanceof ClosingParentheses) {\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_referenceAfterClosing,\n                        token2.getRange(), token2.str.toString()));\n                }\n            }\n            // valid predecessors: operator or '('\n            // invalid predecessors: literal, reference or ')'\n            else if (token2 instanceof LogicalNotToken) {\n                if (token1 instanceof LiteralToken) {\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_notAfterLiteral,\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\n                }\n                if (token1 instanceof ReferenceToken) {\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_notAfterReference,\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\n                }\n                if (token1 instanceof ClosingParentheses) {\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_notAfterClosing,\n                        token2.getRange(), token2.str.toString()));\n                }\n            }\n            // valid predecessors: literal, reference or ')'\n            // invalid predecessors: operator or '('\n            else if (token2 instanceof OperatorToken /* only binary (without LogicalNotToken) */ ) {\n                if (token1 instanceof OperatorToken) {\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_binaryAfterOperator,\n                        token2.getRange(), token2.str.toString(), token1.str.toString()));\n                }\n                if (token1 instanceof OpeningParentheses) {\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_binaryAfterOpening,\n                        token2.getRange(), token2.str.toString()));\n                }\n            }\n            // valid predecessors: operator or '('\n            // invalid predecessors: literal, reference or ')'\n            else if (token2 instanceof OpeningParentheses) {\n                if (token1 instanceof LiteralToken) {\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_openingAfterLiteral,\n                        token2.getRange(), token1.str.toString()));\n                }\n                if (token1 instanceof ReferenceToken) {\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_openingAfterReference,\n                        token2.getRange(), token1.str.toString()));\n                }\n                if (token1 instanceof ClosingParentheses) {\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_openingAfterClosing,\n                        token2.getRange()));\n                }\n            }\n            // valid predecessors: literal or reference\n            // invalid predecessors: operator, '(' or ')'\n            else if (token2 instanceof ClosingParentheses) {\n                if (token1 instanceof OperatorToken) {\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_closingAfterOperator,\n                        token2.getRange(), token1.str.toString()));\n                }\n                if (token1 instanceof OpeningParentheses) {\n                    handleError(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_closingAfterOpening,\n                        token2.getRange()));\n                }\n            }\n        }\n    }\n\n    /**\n     * Simplifies given token array in infix form. That means all groups of LogicalNotTokens ('!') are reduced to 1 or 0\n     * tokens (\"!\" => \"!\", \"!!\" => \"\", \"!!!\" => \"!\", \"!!!!\" => \"\", ...).\n     *\n     * @param tokens tokens to simplify\n     */\n    public static simplify(tokens: ValueToken[]): ValueToken[] {\n        const notIndexes: number[] = [];\n        const indexesToRemove: Set<number> = new Set<number>();\n        // finds indexes in tokens where '!'s are\n        tokens.forEach((token, i) => {\n            if (token instanceof LogicalNotToken) {\n                notIndexes.push(i);\n            }\n        });\n        for (let i = 1; i < notIndexes.length; ++i) {\n            // if there is \"x - 1\" and \"x\" next to each other, adds them to remove\n            if (notIndexes[i - 1] + 1 === notIndexes[i]) {\n                indexesToRemove.add(notIndexes[i - 1]);\n                indexesToRemove.add(notIndexes[i]);\n                notIndexes[i] = NaN; // sets to NaN to not remove possible third '!' in a row\n            }\n        }\n        if (indexesToRemove.size === 0) {\n            return tokens;\n        }\n        return tokens.filter((t, i) => !indexesToRemove.has(i));\n    }\n\n    /**\n     * Transforms given infix boolean and algebraic expression into postfix (reverse polish) form.\n     *\n     * @param tokens infix boolean and algebraic expression as Token array\n     * @return postfix (reverse polish) form of given array\n     */\n    public static toRPN(tokens: ValueToken[]): ValueToken[] {\n        const rpnQueue: ValueToken[] = [];\n        const operatorsStack: Array<OperatorToken | ParenthesisToken> = [];\n        tokens.forEach(token => {\n            if (token instanceof LiteralToken || token instanceof ReferenceToken) {\n                rpnQueue.push(token);\n            }\n            else if (token instanceof OperatorToken) {\n                while (operatorsStack.length > 0 && operatorsStack[operatorsStack.length - 1] instanceof OperatorToken) {\n                    // @ts-ignore (token must be of OperatorToken class)\n                    let other: OperatorToken = operatorsStack[operatorsStack.length - 1];\n                    // all used operators have left associativity\n                    if (token.precedence <= other.precedence) {\n                        // @ts-ignore (token must be present)\n                        rpnQueue.push(operatorsStack.pop());\n                    }\n                    else {\n                        break;\n                    }\n                }\n                operatorsStack.push(token);\n            }\n            else if (token instanceof OpeningParentheses) {\n                operatorsStack.push(token);\n            }\n            else if (token instanceof ClosingParentheses) {\n                while (true) {\n                    if (operatorsStack.length === 0) {\n                        throw ErrorFactory.syntaxError(language().syntaxErrors.valueParser_missingOpeningParenthesis,\n                            undefined);\n                    }\n                    if (operatorsStack[operatorsStack.length - 1] instanceof OpeningParentheses) {\n                        operatorsStack.pop();\n                        break;\n                    }\n                    // @ts-ignore (token must be present)\n                    rpnQueue.push(operatorsStack.pop());\n                }\n            }\n        });\n        while (operatorsStack.length > 0) {\n            // @ts-ignore (token must be present)\n            const curToken: ValueToken = operatorsStack.pop();\n            if (curToken instanceof OpeningParentheses) {\n                throw ErrorFactory.syntaxError(language().syntaxErrors.valueParser_missingClosingParenthesis,\n                    undefined);\n            }\n            else {\n                rpnQueue.push(curToken);\n            }\n        }\n        return rpnQueue;\n    }\n\n    /**\n     * Creates a value-evaluating tree from the given array of tokens in reverse polish form.\n     * Wraps recursive function rpnToVETreeRecursive(tokens), when not all tokens are used, throws error.\n     *\n     * @param tokens value-evaluating expression in reverse polish form\n     * @return VETreeNode tree (its root)\n     */\n    public static rpnToVETree(tokens: ValueToken[]): VETreeNode {\n        const ret: VETreeNode = this.rpnToVETreeRecursive(tokens);\n        // not all tokens were used\n        if (tokens.length > 0) {\n            throw ErrorFactory.syntaxError(language().syntaxErrors.valueParser_invalidExpression, undefined);\n        }\n        return ret;\n    }\n\n    /**\n     * Creates a value-evaluating tree from the given array of tokens in reverse polish form.\n     *\n     * @param tokens value-evaluating expression in reverse polish form\n     * @return VETreeNode tree (its root)\n     */\n    public static rpnToVETreeRecursive(tokens: ValueToken[]): VETreeNode {\n        if (tokens.length === 0) {\n            throw ErrorFactory.syntaxError(language().syntaxErrors.valueParser_invalidExpression, undefined);\n        }\n        // @ts-ignore (there must be a token)\n        const token: ValueToken = tokens.pop();\n        if (token instanceof LogicalNotToken) {\n            const subtree: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\n            return LogicalOperator.not(token.str, subtree);\n        }\n        if (token instanceof LogicalAndToken) {\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\n            return LogicalOperator.and(token.str, left, right);\n        }\n        if (token instanceof LogicalOrToken) {\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\n            return LogicalOperator.or(token.str, left, right);\n        }\n        if (token instanceof ComparingToken) {\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\n            return new ComparingOperator(token.type, token.str, left, right);\n        }\n        if (token instanceof LiteralToken) {\n            return new LiteralValue(token.value, token.type);\n        }\n        if (token instanceof ReferenceToken) {\n            return new ReferenceValue(token.str);\n        }\n        if (token instanceof ComputingPlusToken) {\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\n            return ComputingOperator.add(left, right, token.getRange());\n        }\n        if (token instanceof ComputingMinusToken) {\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\n            return ComputingOperator.deduct(left, right, token.getRange());\n        }\n        if (token instanceof ComputingMultiplicationToken) {\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\n            return ComputingOperator.multiply(left, right, token.getRange());\n        }\n        if (token instanceof ComputingDivisionToken) {\n            const right: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\n            const left: VETreeNode = ValueParser.rpnToVETreeRecursive(tokens);\n            return ComputingOperator.divide(left, right, token.getRange());\n        }\n        // should never happen\n        throw ErrorFactory.codeError(language().codeErrors.valueParser_unexpectedToken, JSON.stringify(token));\n    }\n}","import {NodeFakeEvalResult, RATreeNode} from \"./raTreeNode\";\nimport {Relation} from \"../relation/relation\";\n\n/**\n * Classes extending binary node.\n * @category RATree\n * @public\n */\nexport type BinaryNodeClass = \"left antijoin\" | \"right antijoin\" | \"cartesian product\" | \"division\" | \"natural join\"\n    | \"left outer join\" | \"right outer join\" | \"full outer join\" | \"left semijoin\" | \"right semijoin\" | \"union\"\n    | \"intersection\" | \"difference\" | \"theta join\" | \"left theta semijoin\" | \"right theta semijoin\";\n\n/**\n * Abstract node of the relational algebra syntactic tree with two subtrees.\n * @extends RATreeNode\n * @category RATree\n * @public\n */\nexport abstract class BinaryNode extends RATreeNode {\n\n    protected leftSubtree: RATreeNode;\n    protected rightSubtree: RATreeNode;\n\n    /**\n     * Creates a new BinaryNode.\n     *\n     * @param left left subtree {@type RATreeNode}\n     * @param right right subtree {@type RATreeNode}\n     * @public\n     */\n    protected constructor(left: RATreeNode, right: RATreeNode) {\n        super();\n        this.leftSubtree = left;\n        this.rightSubtree = right;\n    }\n\n    /**\n     * Returns left subtree of the binary node.\n     * @return left subtree {@type RATreeNode}\n     * @public\n     */\n    public getLeftSubtree(): RATreeNode {\n        return this.leftSubtree;\n    }\n\n    /**\n     * Returns right subtree of the binary node.\n     * @return right subtree {@type RATreeNode}\n     * @public\n     */\n    public getRightSubtree(): RATreeNode {\n        return this.rightSubtree;\n    }\n\n    /**\n     * Fake evaluates left and right subtrees of the current not-parametrized binary node.\n     * Returns new simple faked schema with empty \"\" name:\n     * - type = union: returns union of source schemas\n     * - type = left: returns left source schema\n     * - type = right: returns right source schema\n     *\n     * @param cursorIndex index of the cursor in original text input {@type number}\n     * @param type type of the returned relational schema {@type (\"union\" | \"left\" | \"right\")}\n     * @return fake evaluation information {@type NodeFakeEvalResult}\n     * @public\n     */\n    protected fakeEvalBinary(cursorIndex: number, type: \"union\" | \"left\" | \"right\"): NodeFakeEvalResult {\n        // evaluates the subtrees\n        const left = this.leftSubtree.fakeEval(cursorIndex);\n        const right = this.rightSubtree.fakeEval(cursorIndex);\n        // creates return relation\n        const result: Relation = new Relation(\"Binary\");\n        if (type === \"left\" || type === \"union\") {\n            left.result.forEachColumn((type, name) => result.addColumn(name, type));\n        }\n        if (type === \"right\" || type === \"union\") {\n            right.result.forEachColumn((type, name) => result.addColumn(name, type));\n        }\n        left.errors.push(...right.errors);\n        return {\n            result,\n            whispers: left.whispers.length !== 0 ? left.whispers : right.whispers,\n            errors: left.errors\n        };\n    }\n}","import {RATreeNode} from \"./raTreeNode\";\nimport {UnaryNode} from \"./unaryNode\";\nimport {BinaryNode} from \"./binaryNode\";\nimport {IndexedString} from \"../types/indexedString\";\nimport {StartEndPair} from \"../types/startEndPair\";\n\n/**\n * Finds the root in the given tree with the given index with respect to depth first search. Root has index 0.\n *\n * @param root root of the searched tree {@type RATreeNode}\n * @param index index to be found {@type number}\n * @return found root with given index or null if not found {@type RATreeNode?}\n * @category RATree\n * @public\n */\nexport function depthSearch(root: RATreeNode, index: number): RATreeNode | null {\n    let i: number = 0;\n    const findIndexInTree = (node: RATreeNode): RATreeNode | null => {\n        // wanted index found\n        if (i === index) {\n            return node;\n        }\n        i++;\n        if (node instanceof UnaryNode) {\n            return findIndexInTree(node.getSubtree());\n        }\n        if (node instanceof BinaryNode) {\n            const leftSearch = findIndexInTree(node.getLeftSubtree());\n            if (leftSearch === null) {\n                return findIndexInTree(node.getRightSubtree());\n            }\n            return leftSearch;\n        }\n        // end of the branch without the result\n        return null;\n    }\n    return findIndexInTree(root);\n}\n\n/**\n * Computes depth of the tree. One node has depth 0.\n *\n * @param root root of the tree to compute the depth for {@type RATreeNode}\n * @return tree depth {@type number}\n * @category RATree\n * @public\n */\nexport function getTreeDepth(root: RATreeNode): number {\n    if (root instanceof BinaryNode) {\n        const left: number = getTreeDepth(root.getLeftSubtree());\n        const right: number = getTreeDepth(root.getRightSubtree());\n        return Math.max(left, right) + 1;\n    }\n    if (root instanceof UnaryNode) {\n        return getTreeDepth(root.getSubtree()) + 1;\n    }\n    return 0;\n}\n\n/**\n * Returns true if the given cursor position is in the given range, it is not inside quotes, and the character at the\n * cursor position is present (i.e., was not removed as comment).\n * Note: given range is expected to be computed from given string.\n *\n * @param cursor index of the cursor {@type number}\n * @param range range of the string {@type StartEndPair?}\n * @param str string to search in {@type IndexedString}\n * @return true if the given cursor position is in the given range, it is not inside quotes, and the character at the\n * cursor position is present {@type boolean}\n * @category RATree\n * @public\n */\nexport function isInRangeAndNotInQuotes(cursor: number, range: StartEndPair | undefined, str: IndexedString): boolean {\n    if (range !== undefined && range.start < cursor && cursor <= range.end) {\n        const len = range.end - range.start;\n        const s = str.toString();\n        const cursorIndexInStr = cursor - range.start;\n        let insideQuotes: boolean = false;\n        let backslashes: number = 0;\n        for (let i = 0; i < len; ++i) {\n            const curChar = s.charAt(i);\n            // quotes found\n            if (curChar === '\"' && (backslashes % 2) === 0) {\n                insideQuotes = !insideQuotes;\n            }\n            if (insideQuotes && curChar === '\\\\') {\n                ++backslashes;\n            }\n            else {\n                backslashes = 0;\n            }\n            if (i === cursorIndexInStr - 1) {\n                // when the cursor was reached, returns true, if it is not in quotes and the position is present (was not removed as comment)\n                return !insideQuotes && str.getChars().some(c => c.index === cursor - 1);\n            }\n        }\n        console.warn(\"isInRangeAndNotInQuotes outside range\");\n    }\n    return false;\n}","import {UnaryNode} from \"./unaryNode\";\nimport {RATreeNode} from \"./raTreeNode\";\nimport {Relation} from \"../relation/relation\";\nimport {VEResult, VETreeNode} from \"../vetree/veTreeNode\";\nimport {IndexedString} from \"../types/indexedString\";\nimport {ValueParser} from \"../expression/valueParser\";\nimport {ErrorFactory} from \"../error/errorFactory\";\nimport {insertRangeIfUndefined} from \"../error/errorWithTextRange\";\nimport {isInRangeAndNotInQuotes} from \"./raTreeTools\";\nimport {language} from \"../language/language\";\nimport {StartEndPair} from \"../types/startEndPair\";\n\n/**\n * Selection node of the relational algebra syntactic tree.\n * @extends UnaryNode\n * @category RATree\n * @public\n */\nexport class SelectionNode extends UnaryNode {\n\n    private readonly selection: IndexedString;\n    private readonly stringRange: StartEndPair | undefined;\n    private readonly nullValuesSupport: boolean;\n\n    /**\n     * Creates a new SelectionNode.\n     * Expects the selection string to start with '(' and end with ')'.\n     *\n     * @param selection logic-algebraic expression {@type IndexedString}\n     * @param subtree source subtree for renaming {@type RATreeNode}\n     * @param nullValuesSupport whether null values are supported {@type boolean}\n     * @public\n     */\n    public constructor(selection: IndexedString, subtree: RATreeNode, nullValuesSupport: boolean) {\n        super(subtree);\n        this.selection = selection;\n        this.stringRange = selection.getRange();\n        this.nullValuesSupport = nullValuesSupport;\n    }\n\n    /**\n     * Evaluates the RA query in this node and its subtree.\n     * After successful call, this.resultRelation must be set to valid Relation.\n     * Expectations: condition is valid expression which evaluates to boolean\n     * @public\n     */\n    public eval(): void {\n        if (this.isEvaluated()) {\n            return;\n        }\n\n        let boolExpr: VETreeNode;\n        try {\n            boolExpr = ValueParser.parse(this.selection.slice(1, -1), this.nullValuesSupport);\n        }\n        catch (e) {\n            throw insertRangeIfUndefined(e, this.stringRange);\n        }\n\n        const source: Relation = this.subtree.getResult();\n        const result: Relation = new Relation(source.name + \"(...)\");\n        source.forEachColumn((type, name) => result.addColumn(name, type));\n\n        source.getRows().forEach(row => {\n            let bool: VEResult = boolExpr.eval(row);\n            if (bool.type !== \"boolean\") {\n                throw ErrorFactory.syntaxError(language().syntaxErrors.selectionNode_resultNotBoolean,\n                    this.stringRange, this.selection.replace(/\\s+/g, \" \"), bool.type);\n            }\n            if (bool.value) {\n                result.addRow(row);\n            }\n        });\n        this.resultRelation = result;\n    }\n\n    /**\n     * Evaluates the RA query in this node and its subtree.\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\n     * Otherwise returns the result relation schema (only column names, no rows).\n     * When an error occurs, it is faked to work, and adds it to the errors array.\n     *\n     * Strict expectations: columns names used in the condition exists in source schema\n     * Returned schema: source schema\n     * Usage of absent column names does not affect returned schema.\n     *\n     * @param cursorIndex index of the cursor in original text input {@type number}\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper {@type NodeFakeEvalResult}\n     * @public\n     */\n    public fakeEval(cursorIndex: number) {\n        let {result, whispers, errors} = this.subtree.fakeEval(cursorIndex);\n        const newResult = new Relation(result.getName() + \"(...)\");\n        result.forEachColumn((type, name) => {\n            newResult.addColumn(name, type);\n        });\n        result = newResult;\n        // checks whether the cursor is in this selection block (and not in the string) - saves current available columns\n        if (isInRangeAndNotInQuotes(cursorIndex, this.stringRange, this.selection)) {\n            whispers = result.getColumnNames();\n        }\n        // checks empty selection input\n        if (this.selection.toString().slice(1, -1).trim().length  === 0) {\n            errors.push(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_emptyInput, this.stringRange));\n        }\n        // adds errors from current expression\n        else {\n            errors.push(...ValueParser.fakeParse(this.selection.slice(1, -1), this.nullValuesSupport, result.getColumnNames()));\n        }\n        // result schema is the same as the source\n        return {result, whispers, errors};\n    }\n\n    /**\n     * Creates a string with a structure of the RA tree in one line.\n     *\n     * @return string with a structure of the RA tree in one line {@type string}\n     * @public\n     */\n    public printInLine(): string {\n        return this.subtree.printInLine() + this.getOperationSymbol();\n    }\n\n    /**\n     * Return the word name of the RA operation of the node.\n     * Example: returns \"Selection\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n    public getOperationName(): string {\n        return language().operations.selection;\n    }\n\n    /**\n     * Return the symbolic representation of the RA operation of the node.\n     * Example: returns \"(some + expr = 15)\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n    public getOperationSymbol(): string {\n        return this.selection.replace(/\\s+/g, ' ');\n    }\n}","import {BinaryNode} from \"./binaryNode\";\nimport {RATreeNode} from \"./raTreeNode\";\nimport {Relation} from \"../relation/relation\";\nimport {Row} from \"../relation/row\";\nimport {language} from \"../language/language\";\n\n/**\n * Enum of types of antijoin node: left, right.\n * @enum {string}\n * @category RATree\n * @public\n */\nexport enum AntijoinType {\n    left = \"\\u22b3\",\n    right = \"\\u22b2\"\n}\n\n/**\n * Antijoin node of the relational algebra syntactic tree.\n * @extends BinaryNode\n * @category RATree\n * @public\n */\nexport class AntijoinNode extends BinaryNode {\n\n    private readonly type: AntijoinType;\n\n    /**\n     * Creates a new AntijoinNode.\n     *\n     * @param operator type of antijoin {@type AntijoinType}\n     * @param leftSubtree left subtree {@type RATreeNode}\n     * @param rightSubtree right subtree {@type RATreeNode}\n     * @public\n     */\n    public constructor(operator: AntijoinType, leftSubtree: RATreeNode, rightSubtree: RATreeNode) {\n        super(leftSubtree, rightSubtree);\n        this.type = operator;\n    }\n\n    /**\n     * Evaluates the RA query in this node and its subtree.\n     * Expectations on source schemas: none\n     * @public\n     */\n    public eval(): void {\n        if (this.isEvaluated()) {\n            return;\n        }\n        const leftSource: Relation = this.leftSubtree.getResult();\n        const rightSource: Relation = this.rightSubtree.getResult();\n        // intersection of columns in left and right subtree\n        const commonColumns: string[] = leftSource.getColumnNames().filter(lc => rightSource.hasColumn(lc));\n        let rowsToKeep: Row[];   // rows from the subtree, which have to be kept in result\n        let rowsToHelp: Row[];\n        // change of relational schema\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + this.type + rightSource.getName() + \")\");\n        if (this.type === AntijoinType.left) {\n            leftSource.forEachColumn((type, name) => result.addColumn(name, type));\n            rowsToKeep = leftSource.getRows();\n            rowsToHelp = rightSource.getRows();\n        }\n        else {\n            rightSource.forEachColumn((type, name) => result.addColumn(name, type));\n            rowsToKeep = rightSource.getRows();\n            rowsToHelp = leftSource.getRows();\n        }\n        // join of relation rows\n        rowsToKeep.forEach(keptRow => {\n            let someMatch: boolean = rowsToHelp.some(helpRow => {\n                // if all common columns match, the row should not be added\n                return commonColumns.every(c => keptRow.getValue(c) === helpRow.getValue(c));\n            });\n            if (!someMatch) {\n                let newRow: Row = new Row(result.getColumns());\n                keptRow.getValues().forEach((value, name) => newRow.addValue(name, value));\n                result.addRow(newRow);\n            }\n        });\n        this.resultRelation = result;\n    }\n\n    /**\n     * Evaluates the RA query in this node and its subtree.\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\n     * Otherwise returns the result relation schema (only column names, no rows).\n     * When an error occurs, it is faked to work, and adds it to the errors array.\n     *\n     * Strict expectations: none\n     * Returned schema: left/right source schema (for left/right antijoin)\n     *\n     * @param cursorIndex index of the cursor in original text input {@type number}\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper {@type NodeFakeEvalResult}\n     * @public\n     */\n    public fakeEval(cursorIndex: number) {\n        const type = this.type === AntijoinType.left ? \"left\" : \"right\";\n        return this.fakeEvalBinary(cursorIndex, type);\n    }\n\n    /**\n     * Creates a string with a structure of the RA tree in one line.\n     *\n     * @return string with a structure of the RA tree in one line {@type string}\n     * @public\n     */\n    public printInLine(): string {\n        return \"(\" + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + \")\";\n    }\n\n    /**\n     * Return the word name of the RA operation of the node.\n     * Example: returns \"Selection\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n    public getOperationName(): string {\n        const lang = language().operations;\n        return this.type === AntijoinType.left ? lang.leftAntijoin : lang.rightAntijoin;\n    }\n\n    /**\n     * Return the symbolic representation of the RA operation of the node.\n     * Example: returns \"(some + expr = 15)\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n    public getOperationSymbol(): string {\n        return this.type;\n    }\n}","import {BinaryNode} from \"./binaryNode\";\nimport {RATreeNode} from \"./raTreeNode\";\nimport {Relation} from \"../relation/relation\";\nimport {Row} from \"../relation/row\";\nimport {language} from \"../language/language\";\n\n/**\n * Enum of types of outer join node: full, left, right.\n * @enum {string}\n * @category RATree\n * @public\n */\nexport enum OuterJoinType {\n    left = \"*L*\",\n    right = \"*R*\",\n    full = \"*F*\"\n}\n\n/**\n * Outer join node of the relational algebra syntactic tree.\n * @extends BinaryNode\n * @category RATree\n * @public\n */\nexport class OuterJoinNode extends BinaryNode {\n\n    private readonly type: OuterJoinType;\n\n    /**\n     * Creates a new OuterJoinNode.\n     *\n     * @param operator type of outer join {@type OuterJoinType}\n     * @param leftSubtree left subtree {@type RATreeNode}\n     * @param rightSubtree right subtree {@type RATreeNode}\n     * @public\n     */\n    public constructor(operator: OuterJoinType, leftSubtree: RATreeNode, rightSubtree: RATreeNode) {\n        super(leftSubtree, rightSubtree);\n        this.type = operator;\n    }\n\n    /**\n     * Evaluates the RA query in this node and its subtree.\n     * Expectations on source schemas: none\n     */\n    public eval(): void {\n        if (this.isEvaluated()) {\n            return;\n        }\n        const leftSource: Relation = this.leftSubtree.getResult();\n        const rightSource: Relation = this.rightSubtree.getResult();\n        // change of relational schema\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + this.type + rightSource.getName() + \")\");\n        leftSource.forEachColumn((type, name) => result.addColumn(name, type));\n        rightSource.forEachColumn((type, name) => result.addColumn(name, type));\n        // join of relation rows\n        const leftRows: Row[] = leftSource.getRows();\n        const rightRows: Row[] = rightSource.getRows();\n        // intersection of columns in left and right subtree\n        const commonColumns: string[] = leftSource.getColumnNames().filter(lc => rightSource.hasColumn(lc));\n        // adds naturally joined rows\n        leftRows.forEach(leftRow => {\n            rightRows.forEach(rightRow => {\n                // if all common columns have the same value\n                if (commonColumns.every(c => leftRow.getValue(c) === rightRow.getValue(c))) {\n                    let newRow: Row = new Row(result.getColumns());\n                    leftRow.getValues().forEach((value, name) => newRow.addValue(name, value));\n                    rightRow.getValues().forEach((value, name) => newRow.addValue(name, value));\n                    result.addRow(newRow);\n                }\n            });\n        });\n        // adds left source rows with right null values\n        if (this.type === OuterJoinType.left || this.type === OuterJoinType.full) {\n            leftRows.forEach(leftRow => {\n                let someMatch: boolean = rightRows.some(rightRow => {\n                    // if all common columns match, the row should not be added\n                    return commonColumns.every(c => leftRow.getValue(c) === rightRow.getValue(c));\n                });\n                if (!someMatch) {\n                    let newRow: Row = new Row(result.getColumns());\n                    leftRow.getValues().forEach((value, name) => newRow.addValue(name, value));\n                    result.addRow(newRow);\n                }\n            });\n        }\n        // adds right source rows with left null values\n        if (this.type === OuterJoinType.right || this.type === OuterJoinType.full) {\n            rightRows.forEach(rightRow => {\n                let someMatch: boolean = leftRows.some(leftRow => {\n                    // if all common columns match, the row should not be added\n                    return commonColumns.every(c => leftRow.getValue(c) === rightRow.getValue(c));\n                });\n                if (!someMatch) {\n                    let newRow: Row = new Row(result.getColumns());\n                    rightRow.getValues().forEach((value, name) => newRow.addValue(name, value));\n                    result.addRow(newRow);\n                }\n            });\n        }\n        this.resultRelation = result;\n    }\n    /**\n     * Evaluates the RA query in this node and its subtree.\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\n     * Otherwise returns the result relation schema (only column names, no rows).\n     * When an error occurs, it is faked to work, and adds it to the errors array.\n     *\n     * Strict expectations: none\n     * Returned schema: union of source schemas (in all cases - full/left/right)\n     *\n     * @param cursorIndex index of the cursor in original text input {@type number}\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper {@type NodeFakeEvalResult}\n     * @public\n     */\n    public fakeEval(cursorIndex: number) {\n        return this.fakeEvalBinary(cursorIndex, \"union\");\n    }\n\n    /**\n     * Creates a string with a structure of the RA tree in one line.\n     *\n     * @return string with a structure of the RA tree in one line {@type string}\n     * @public\n     */\n    public printInLine(): string {\n        return \"(\" + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + \")\";\n    }\n\n    /**\n     * Return the word name of the RA operation of the node.\n     * Example: returns \"Selection\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n    public getOperationName(): string {\n        const lang = language().operations;\n        if (this.type === OuterJoinType.left) {\n            return lang.leftOuterJoin;\n        }\n        else if (this.type === OuterJoinType.right) {\n            return lang.rightOuterJoin;\n        }\n        else {\n            return lang.fullOuterJoin;\n        }\n    }\n\n    /**\n     * Return the symbolic representation of the RA operation of the node.\n     * Example: returns \"(some + expr = 15)\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n    public getOperationSymbol(): string {\n        return this.type;\n    }\n}","import {BinaryNode} from \"./binaryNode\";\nimport {RATreeNode} from \"./raTreeNode\";\nimport {Relation} from \"../relation/relation\";\nimport {Row} from \"../relation/row\";\nimport {ErrorFactory} from \"../error/errorFactory\";\nimport {language} from \"../language/language\";\nimport {StartEndPair} from \"../types/startEndPair\";\n\n/**\n * Cartesian product node of the relational algebra syntactic tree.\n * @extends BinaryNode\n * @category RATree\n * @public\n */\nexport class CartesianProductNode extends BinaryNode {\n\n    /**\n     * Creates a new CartesianProductNode.\n     *\n     * @param leftSubtree left subtree {@type RATreeNode}\n     * @param rightSubtree right subtree {@type RATreeNode}\n     * @param stringRange position of the operator in the original text {@type StartEndPair?}\n     * @public\n     */\n    public constructor(leftSubtree: RATreeNode, rightSubtree: RATreeNode, private stringRange: StartEndPair | undefined) {\n        super(leftSubtree, rightSubtree);\n    }\n\n    /**\n     * Evaluates the RA query in this node and its subtree.\n     * Expectations on source schemas: disjointness\n     * @public\n     */\n    public eval(): void {\n        if (this.isEvaluated()) {\n            return;\n        }\n        const leftSource: Relation = this.leftSubtree.getResult();\n        const rightSource: Relation = this.rightSubtree.getResult();\n        // join of relational schema\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + \"\\u2a2f\" + rightSource.getName() + \")\");\n        leftSource.forEachColumn((type, name) => result.addColumn(name, type));\n        rightSource.forEachColumn((type, name) => {\n            if (!result.addColumn(name, type)) {\n                throw ErrorFactory.semanticError(language().semanticErrors.binaryNode_commonColumns,\n                    this.stringRange, \"cartesian product\", name);\n            }\n        });\n        // join of relation rows\n        leftSource.getRows().forEach(leftRow => {\n            rightSource.getRows().forEach(rightRow => {\n                let newRow: Row = new Row(result.getColumns());\n                leftRow.getValues().forEach((value, name) => newRow.addValue(name, value));\n                rightRow.getValues().forEach((value, name) => newRow.addValue(name, value));\n                result.addRow(newRow);\n            });\n        });\n        this.resultRelation = result;\n    }\n    /**\n     * Evaluates the RA query in this node and its subtree.\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\n     * Otherwise returns the result relation schema (only column names, no rows).\n     * When an error occurs, it is faked to work, and adds it to the errors array.\n     *\n     * Strict expectations: disjointness\n     * Returned schema: union of source schemas\n     * Returned fake schema is not affected when disjointness is not held\n     *\n     * @param cursorIndex index of the cursor in original text input {@type number}\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper {@type NodeFakeEvalResult}\n     * @public\n     */\n    public fakeEval(cursorIndex: number) {\n        // evaluates the subtrees\n        const left = this.leftSubtree.fakeEval(cursorIndex);\n        const right = this.rightSubtree.fakeEval(cursorIndex);\n        // creates return relation\n        const result: Relation = new Relation(\"\");\n        left.result.forEachColumn((type, name) => result.addColumn(name, type));\n        right.result.forEachColumn((type, name) => result.addColumn(name, type));\n        // checks errors\n        left.errors.push(...right.errors);\n        const commonColumns: string[] = [];\n        left.result.getColumnNames().forEach(leftColumn => {\n            if (right.result.hasColumn(leftColumn)) {\n                commonColumns.push(leftColumn);\n            }\n        });\n        if (commonColumns.length > 0) {\n            left.errors.push(ErrorFactory.semanticError(language().semanticErrors.binaryNode_commonColumns,\n                this.stringRange, \"cartesian product\", commonColumns.join('\", \"')));\n        }\n        return {\n            result,\n            whispers: left.whispers.length !== 0 ? left.whispers : right.whispers,\n            errors: left.errors\n        };\n    }\n\n    /**\n     * Creates a string with a structure of the RA tree in one line.\n     *\n     * @return string with a structure of the RA tree in one line {@type string}\n     * @public\n     */\n    public printInLine(): string {\n        return \"(\" + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + \")\";\n    }\n\n    /**\n     * Return the word name of the RA operation of the node.\n     * Example: returns \"Selection\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n    public getOperationName(): string {\n        return language().operations.cartesianProduct;\n    }\n\n    /**\n     * Return the symbolic representation of the RA operation of the node.\n     * Example: returns \"(some + expr = 15)\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n    public getOperationSymbol(): string {\n        return \"⨯\";\n    }\n}","import {BinaryNode} from \"./binaryNode\";\nimport {RATreeNode} from \"./raTreeNode\";\nimport {Relation} from \"../relation/relation\";\nimport {Row} from \"../relation/row\";\nimport {SupportedColumnType} from \"../relation/columnType\";\nimport {ErrorFactory} from \"../error/errorFactory\";\nimport {language} from \"../language/language\";\nimport {StartEndPair} from \"../types/startEndPair\";\n\n/**\n * Division node of the relational algebra syntactic tree.\n * @extends BinaryNode\n * @category RATree\n * @public\n */\nexport class DivisionNode extends BinaryNode {\n\n    /**\n     * Creates a new DivisionNode.\n     *\n     * @param leftSubtree left subtree {@type RATreeNode}\n     * @param rightSubtree right subtree {@type RATreeNode}\n     * @param stringRange position of the operator in the original text {@type StartEndPair?}\n     * @public\n     */\n    public constructor(leftSubtree: RATreeNode, rightSubtree: RATreeNode, private stringRange: StartEndPair | undefined) {\n        super(leftSubtree, rightSubtree);\n    }\n\n    /**\n     * Evaluates the RA query in this node and its subtree.\n     * Expectations on source schemas: right source schema is a proper subset of left source schema\n     */\n    public eval(): void {\n        if (this.isEvaluated()) {\n            return;\n        }\n        const leftSource: Relation = this.leftSubtree.getResult();\n        const rightSource: Relation = this.rightSubtree.getResult();\n        const leftColumns: Map<string, SupportedColumnType> = leftSource.getColumns();\n        const rightColumns: Map<string, SupportedColumnType> = rightSource.getColumns();\n\n        if (![...rightColumns].every(value => leftColumns.has(value[0]) && leftColumns.get(value[0]) === value[1])) {\n            throw ErrorFactory.semanticError(language().semanticErrors.divisionNode_rightColumnsNotSubset,\n                this.stringRange, rightSource.getSchemaString(), leftSource.getSchemaString());\n        }\n\n        // difference of columns in left and right subtree\n        const resultColumns: Map<string, SupportedColumnType> = new Map<string, SupportedColumnType>();\n        leftColumns.forEach((type, name) => {\n           if (!rightColumns.has(name)) {\n               resultColumns.set(name, type);\n           }\n        });\n\n        if (resultColumns.size === 0) {\n            throw ErrorFactory.semanticError(language().semanticErrors.divisionNode_rightColumnsNotProperSubset,\n                this.stringRange, rightSource.getNamesSchemaString(), leftSource.getNamesSchemaString());\n        }\n\n        // join of relational schema\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + \"\\u00f7\" + rightSource.getName() + \")\");\n        resultColumns.forEach((type, name) => result.addColumn(name, type));\n        // filter relation rows\n        const leftRows: Row[] = leftSource.getRows();\n        const rightRows: Row[] = rightSource.getRows();\n        leftRows.forEach(leftRow => {\n           if (rightRows.every(rightRow => {\n               // creates a row with left row's extra columns and right row's common columns\n               let testRow: Row = new Row(leftColumns);\n               // left row's extra columns\n               // @ts-ignore ('name' must be present in left row)\n               resultColumns.forEach((type, name) => testRow.addValue(name, leftRow.getValue(name)));\n               // right row's common columns\n               rightRow.getValues().forEach((type, name) => testRow.addValue(name, type));\n               // tests if the created row exists in left relation\n               return [...leftRows].some(lr => lr.equals(testRow));\n           })) {\n               let newRow: Row = new Row(result.getColumns());\n               // @ts-ignore ('name' must be present in left row)\n               resultColumns.forEach((value, name) => newRow.addValue(name, leftRow.getValue(name)));\n               result.addRow(newRow);\n           }\n        });\n        this.resultRelation = result;\n    }\n\n    /**\n     * Evaluates the RA query in this node and its subtree.\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\n     * Otherwise returns the result relation schema (only column names, no rows).\n     * When an error occurs, it is faked to work, and adds it to the errors array.\n     *\n     * Strict expectations: right source schema is a proper subset of left source schema\n     * Returned schema: left source schema minus right source schema\n     * Returned fake schema may be empty (right source schema may contain all left source columns).\n     *\n     * @param cursorIndex index of the cursor in original text input {@type number}\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper {@type NodeFakeEvalResult}\n     * @public\n     */\n    public fakeEval(cursorIndex: number) {\n        const left = this.leftSubtree.fakeEval(cursorIndex);\n        const right = this.rightSubtree.fakeEval(cursorIndex);\n        const leftColumns = left.result.getColumns();\n        const rightColumns = right.result.getColumns();\n        // creates relation schema - \"left columns minus right columns\"\n        const resultColumns = new Map([...leftColumns.entries()].filter(([key, _]) => !rightColumns.has(key)));\n        const result = new Relation(\"(\" + left.result.getName() + \"\\u00f7\" + right.result.getName() + \")\");\n        resultColumns.forEach((type, name) => result.addColumn(name, type));\n        // checks errors in schema\n        const errors = left.errors;\n        errors.push(...right.errors);\n        if (![...rightColumns].every(value => leftColumns.has(value[0]) && leftColumns.get(value[0]) === value[1])\n            && left.result.getName() !== \"\") {\n            errors.push(ErrorFactory.semanticError(language().semanticErrors.divisionNode_rightColumnsNotSubset,\n                this.stringRange, right.result.getSchemaString(), left.result.getSchemaString()));\n        }\n        else if (resultColumns.size === 0 && left.result.getName() !== \"\") {\n            errors.push(ErrorFactory.semanticError(language().semanticErrors.divisionNode_rightColumnsNotProperSubset,\n                this.stringRange, right.result.getNamesSchemaString(), left.result.getNamesSchemaString()));\n        }\n        return {\n            result,\n            whispers: left.whispers.length !== 0 ? left.whispers : right.whispers,\n            errors: left.errors\n        };\n    }\n\n    /**\n     * Creates a string with a structure of the RA tree in one line.\n     *\n     * @return string with a structure of the RA tree in one line {@type string}\n     * @public\n     */\n    public printInLine(): string {\n        return \"(\" + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + \")\";\n    }\n\n    /**\n     * Return the word name of the RA operation of the node.\n     * Example: returns \"Selection\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n    public getOperationName(): string {\n        return language().operations.division;\n    }\n\n    /**\n     * Return the symbolic representation of the RA operation of the node.\n     * Example: returns \"(some + expr = 15)\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n    public getOperationSymbol(): string {\n        return \"÷\";\n    }\n}","import {BinaryNode} from \"./binaryNode\";\nimport {RATreeNode} from \"./raTreeNode\";\nimport {Relation} from \"../relation/relation\";\nimport {Row} from \"../relation/row\";\nimport {language} from \"../language/language\";\n\n/**\n * Enum of types of natural join node: natural, left semi, right semi.\n * @enum {string}\n * @category RATree\n * @public\n */\nexport enum NaturalJoinType {\n    natural = \"*\",\n    leftSemi = \"<*\",\n    rightSemi = \"*>\"\n}\n\n/**\n * Natural join or semi join node of the relational algebra syntactic tree.\n * @extends BinaryNode\n * @category RATree\n * @public\n */\nexport class NaturalJoinNode extends BinaryNode {\n\n    private readonly type: NaturalJoinType;\n\n    /**\n     * Creates a new NaturalJoinNode.\n     *\n     * @param operator type of natural join {@type NaturalJoinNode}\n     * @param leftSubtree left subtree {@type RATreeNode}\n     * @param rightSubtree right subtree {@type RATreeNode}\n     * @public\n     */\n    public constructor(operator: NaturalJoinType, leftSubtree: RATreeNode, rightSubtree: RATreeNode) {\n        super(leftSubtree, rightSubtree);\n        this.type = operator;\n    }\n\n    /**\n     * Evaluates the RA query in this node and its subtree.\n     * Expectations on source schemas: none\n     * @public\n     */\n    public eval(): void {\n        if (this.isEvaluated()) {\n            return;\n        }\n        const leftSource: Relation = this.leftSubtree.getResult();\n        const rightSource: Relation = this.rightSubtree.getResult();\n        // intersection of columns in left and right subtree\n        const commonColumns: string[] = leftSource.getColumnNames().filter(lc => rightSource.hasColumn(lc));\n        // change of relational schema\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + this.type + rightSource.getName() + \")\");\n        if (this.type === NaturalJoinType.leftSemi || this.type === NaturalJoinType.natural) {\n            leftSource.forEachColumn((type, name) => result.addColumn(name, type));\n        }\n        if (this.type === NaturalJoinType.rightSemi || this.type === NaturalJoinType.natural) {\n            rightSource.forEachColumn((type, name) => result.addColumn(name, type));\n        }\n        // join of relation rows\n        leftSource.getRows().forEach(leftRow => {\n            rightSource.getRows().forEach(rightRow => {\n                // if all common columns have the same value\n                if ([...commonColumns].every(c => leftRow.getValue(c) === rightRow.getValue(c))) {\n                    let newRow: Row = new Row(result.getColumns());\n                    if (this.type === NaturalJoinType.leftSemi || this.type === NaturalJoinType.natural) {\n                        leftRow.getValues().forEach((value, name) => newRow.addValue(name, value));\n                    }\n                    if (this.type === NaturalJoinType.rightSemi || this.type === NaturalJoinType.natural) {\n                        rightRow.getValues().forEach((value, name) => newRow.addValue(name, value));\n                    }\n                    result.addRow(newRow);\n                }\n            });\n        });\n        this.resultRelation = result;\n    }\n    /**\n     * Evaluates the RA query in this node and its subtree.\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\n     * Otherwise returns the result relation schema (only column names, no rows).\n     * When an error occurs, it is faked to work, and adds it to the errors array.\n     *\n     * Strict expectations: none\n     * Returned schema: left/right/both source schema (for left-semijoin/right-semijoin/natural join)\n     *\n     * @param cursorIndex index of the cursor in original text input {@type number}\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper {@type NodeFakeEvalResult}\n     * @public\n     */\n    public fakeEval(cursorIndex: number) {\n        let type: \"union\" | \"left\" | \"right\" = \"union\";\n        if (this.type === NaturalJoinType.leftSemi) {\n            type = \"left\";\n        }\n        else if (this.type === NaturalJoinType.rightSemi) {\n            type = \"right\";\n        }\n        return this.fakeEvalBinary(cursorIndex, type);\n    }\n\n    /**\n     * Creates a string with a structure of the RA tree in one line.\n     *\n     * @return string with a structure of the RA tree in one line {@type string}\n     * @public\n     */\n    public printInLine(): string {\n        return \"(\" + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + \")\";\n    }\n\n    /**\n     * Return the word name of the RA operation of the node.\n     * Example: returns \"Selection\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n    public getOperationName(): string {\n        const lang = language().operations;\n        if (this.type === NaturalJoinType.leftSemi) {\n            return lang.leftSemiJoin;\n        }\n        else if (this.type === NaturalJoinType.rightSemi) {\n            return lang.rightSemiJoin;\n        }\n        else {\n            return lang.naturalJoin;\n        }\n    }\n\n    /**\n     * Return the symbolic representation of the RA operation of the node.\n     * Example: returns \"(some + expr = 15)\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n    public getOperationSymbol(): string {\n        return \"*\";\n    }\n\n    /**\n     * Returns type of the NaturalJoinNode.\n     *\n     * @return type of the node {@type NaturalJoinType}\n     * @public\n     */\n    public getType(): NaturalJoinType {\n        return this.type;\n    }\n}","import {BinaryNode} from \"./binaryNode\";\nimport {RATreeNode} from \"./raTreeNode\";\nimport {Relation} from \"../relation/relation\";\nimport {Row} from \"../relation/row\";\nimport {isEqual} from \"lodash\";\nimport {ErrorFactory} from \"../error/errorFactory\";\nimport {language} from \"../language/language\";\nimport {StartEndPair} from \"../types/startEndPair\";\n\n/**\n * Enum of types of set operation node: union, intersection, difference.\n * @enum {string}\n * @category RATree\n * @public\n */\nexport enum SetOperationType {\n    union = \"\\u222a\",\n    intersection = \"\\u2229\",\n    difference = \"\\\\\"\n}\n\n/**\n * Set operation node of the relational algebra syntactic tree.\n * @extends BinaryNode\n * @category RATree\n * @public\n */\nexport class SetOperationNode extends BinaryNode {\n\n    private readonly type: SetOperationType;\n\n    /**\n     * Creates a new SetOperationNode.\n     *\n     * @param operator type of set operation {@type SetOperationType}\n     * @param leftSubtree left subtree {@type RATreeNode}\n     * @param rightSubtree right subtree {@type RATreeNode}\n     * @param stringRange position of the operator in the original text {@type StartEndPair?}\n     * @public\n     */\n    public constructor(operator: SetOperationType, leftSubtree: RATreeNode, rightSubtree: RATreeNode,\n                       private stringRange: StartEndPair | undefined) {\n        super(leftSubtree, rightSubtree);\n        this.type = operator;\n    }\n\n    /**\n     * Evaluates the RA query in this node and its subtree.\n     * Expectations on source schemas: equality\n     */\n    public eval(): void {\n        if (this.isEvaluated()) {\n            return;\n        }\n        const leftSource: Relation = this.leftSubtree.getResult();\n        const rightSource: Relation = this.rightSubtree.getResult();\n\n        if (!isEqual(leftSource.getColumns(), rightSource.getColumns())) {\n            let typeStr: string = this.getOperationName().toLowerCase();\n            throw ErrorFactory.semanticError(language().semanticErrors.setOperationNode_notEqualColumns,\n                this.stringRange, leftSource.getSchemaString(), rightSource.getSchemaString(), typeStr);\n        }\n        // copy of relational schema\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + this.type + rightSource.getName() + \")\");\n        leftSource.forEachColumn((type, name) => result.addColumn(name, type));\n        // change of relation rows\n        let resultRows: Row[];\n        const leftRows: Row[] = leftSource.getRows();\n        const rightRows: Row[] = rightSource.getRows();\n        if (this.type === SetOperationType.union) {\n            resultRows = [...leftRows, ...rightRows];\n        }\n        else if (this.type === SetOperationType.intersection) {\n            resultRows = [...leftRows].filter(lr => [...rightRows].some(rr => lr.equals(rr)));\n        }\n        else /* this.type === SetOperationType.difference */ {\n            resultRows = [...leftRows].filter(lr => ![...rightRows].some(rr => lr.equals(rr)));\n        }\n        resultRows.forEach(row => result.addRow(row));\n        this.resultRelation = result;\n    }\n    /**\n     * Evaluates the RA query in this node and its subtree.\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\n     * Otherwise returns the result relation schema (only column names, no rows).\n     * When an error occurs, it is faked to work, and adds it to the errors array.\n     *\n     * Strict expectations: equality\n     * Returned schema: intersection of source schemas\n     * Returned schema may be empty (when there is no common column in sources).\n     *\n     * @param cursorIndex index of the cursor in original text input {@type number}\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper {@type NodeFakeEvalResult}\n     * @public\n     */\n    public fakeEval(cursorIndex: number) {\n        const left = this.leftSubtree.fakeEval(cursorIndex);\n        const right = this.rightSubtree.fakeEval(cursorIndex);\n        // join of relational schema - \"left intersection right\"\n        const result: Relation = new Relation(\"(\" + left.result.getName() + this.type + right.result.getName() + \")\");\n        left.result.forEachColumn((type, name) => {\n            if (right.result.hasColumn(name)) {\n                result.addColumn(name, type);\n            }\n        });\n        // checks errors in schema\n        const errors = left.errors;\n        errors.push(...right.errors);\n        if (!isEqual(left.result.getColumns(), right.result.getColumns()) && left.result.getName() !== \"\" && right.result.getName() !== \"\") {\n            let typeStr: string = this.getOperationName().toLowerCase();\n            errors.push(ErrorFactory.semanticError(language().semanticErrors.setOperationNode_notEqualColumns,\n                this.stringRange, left.result.getSchemaString(), right.result.getSchemaString(), typeStr));\n        }\n        return {\n            result,\n            whispers: left.whispers.length !== 0 ? left.whispers : right.whispers,\n            errors: left.errors\n        };\n    }\n\n    /**\n     * Creates a string with a structure of the RA tree in one line.\n     *\n     * @return string with a structure of the RA tree in one line {@type string}\n     * @public\n     */\n    public printInLine(): string {\n        return \"(\" + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + \")\";\n    }\n\n    /**\n     * Return the word name of the RA operation of the node.\n     * Example: returns \"Selection\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n    public getOperationName(): string {\n        const lang = language().operations;\n        if (this.type === SetOperationType.union) {\n            return lang.union;\n        }\n        else if (this.type === SetOperationType.intersection) {\n            return lang.intersection;\n        }\n        else {\n            return lang.difference;\n        }\n    }\n\n    /**\n     * Return the symbolic representation of the RA operation of the node.\n     * Example: returns \"(some + expr = 15)\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n    public getOperationSymbol(): SetOperationType {\n        return this.type;\n    }\n}","import {BinaryNode} from \"./binaryNode\";\nimport {RATreeNode} from \"./raTreeNode\";\nimport {Relation} from \"../relation/relation\";\nimport {Row} from \"../relation/row\";\nimport {SupportedColumnType} from \"../relation/columnType\";\nimport {VEResult, VETreeNode} from \"../vetree/veTreeNode\";\nimport {IndexedString} from \"../types/indexedString\";\nimport {ValueParser} from \"../expression/valueParser\";\nimport {ErrorFactory} from \"../error/errorFactory\";\nimport {insertRangeIfUndefined} from \"../error/errorWithTextRange\";\nimport {isInRangeAndNotInQuotes} from \"./raTreeTools\";\nimport {language} from \"../language/language\";\nimport {StartEndPair} from \"../types/startEndPair\";\n\n/**\n * Enum of types of theta join node: full (theta), left (theta semi), right (theta semi).\n * @enum {string}\n * @category RATree\n * @public\n */\nexport enum ThetaJoinType {\n    full = \"[]\",\n    left = \"\\u27e8]\",\n    right = \"[\\u27e9\"\n}\n\n/**\n * Theta join or theta semijoin node of the relational algebra syntactic tree.\n * @extends BinaryNode\n * @category RATree\n * @public\n */\nexport class ThetaJoinNode extends BinaryNode {\n\n    private readonly type: ThetaJoinType;\n    private readonly condition: IndexedString;\n    private readonly stringRange: StartEndPair | undefined;\n    private readonly nullValuesSupport: boolean;\n\n    /**\n     * Creates a new ThetaJoinNode.\n     * Expects the condition string to start with '[' and end with ']' or start with'⟨' and end with ']' or start\n     * with '[' and end with '⟩'.\n     *\n     * @param type type of natural join {@type ThetaJoinType}\n     * @param condition logic-algebraic condition {@type IndexedString}\n     * @param leftSubtree left subtree {@type RATreeNode}\n     * @param rightSubtree right subtree {@type RATreeNode}\n     * @param nullValuesSupport whether null values are supported\n     * @public\n     */\n    public constructor(type: ThetaJoinType, condition: IndexedString,\n                       leftSubtree: RATreeNode, rightSubtree: RATreeNode, nullValuesSupport: boolean) {\n        super(leftSubtree, rightSubtree);\n        this.condition = condition;\n        this.stringRange = condition.getRange();\n        this.nullValuesSupport = nullValuesSupport;\n        this.type = type;\n    }\n\n    /**\n     * Evaluates the RA query in this node and its subtree.\n     * Expectations on source schemas: disjointness\n     * Other expectations: condition is valid expression which evaluates to boolean\n     * @public\n     */\n    public eval(): void {\n        if (this.isEvaluated()) {\n            return;\n        }\n\n        let boolExpr: VETreeNode;\n        try {\n            boolExpr = ValueParser.parse(this.condition.slice(1, -1), this.nullValuesSupport);   // slices brackets out\n        }\n        catch (e) {\n            throw insertRangeIfUndefined(e, this.stringRange);\n        }\n\n        const leftSource: Relation = this.leftSubtree.getResult();\n        const rightSource: Relation = this.rightSubtree.getResult();\n\n        leftSource.getColumnNames().forEach(leftColumn => {\n            if (rightSource.hasColumn(leftColumn)) {\n                throw ErrorFactory.semanticError(language().semanticErrors.binaryNode_commonColumns, this.stringRange,\n                    this.getOperationName().toLowerCase(), leftColumn);\n            }\n        });\n        // change of relational schema\n        const result: Relation = new Relation(\"(\" + leftSource.getName() + this.type.charAt(0) + \"...\" + this.type.charAt(1) + rightSource.getName() + \")\");\n        if (this.type === ThetaJoinType.left || this.type === ThetaJoinType.full) {\n            leftSource.forEachColumn((type, name) => result.addColumn(name, type));\n        }\n        if (this.type === ThetaJoinType.right || this.type === ThetaJoinType.full) {\n            rightSource.forEachColumn((type, name) => result.addColumn(name, type));\n        }\n        // combine columns of both source relations to use it in testing row\n        const bothSourceColumns: Map<string, SupportedColumnType> = new Map<string, SupportedColumnType>(leftSource.getColumns());\n        rightSource.forEachColumn((type, name) => bothSourceColumns.set(name, type));\n\n        leftSource.getRows().forEach(leftRow => {\n            rightSource.getRows().forEach(rightRow => {\n                const testRow: Row = new Row(bothSourceColumns);\n                leftRow.getValues().forEach((value, name) => testRow.addValue(name, value));\n                rightRow.getValues().forEach((value, name) => testRow.addValue(name, value));\n                // checks whether the combined row from both relation columns satisfies the condition\n                let booleanResult: VEResult = boolExpr.eval(testRow);\n                if (booleanResult.type !== \"boolean\") {\n                    throw ErrorFactory.syntaxError(language().syntaxErrors.thetaJoinNode_resultNotBoolean,\n                        this.stringRange, this.condition.replace(/\\s+/g, \" \"), booleanResult.type);\n                }\n                if (booleanResult.value) {\n                    const newRow: Row = new Row(result.getColumns());\n                    if (this.type === ThetaJoinType.left || this.type === ThetaJoinType.full) {\n                        leftRow.getValues().forEach((value, name) => newRow.addValue(name, value));\n                    }\n                    if (this.type === ThetaJoinType.right || this.type === ThetaJoinType.full) {\n                        rightRow.getValues().forEach((value, name) => newRow.addValue(name, value));\n                    }\n                    result.addRow(newRow);\n                }\n            });\n        });\n        this.resultRelation = result;\n    }\n\n    /**\n     * Evaluates the RA query in this node and its subtree.\n     * It searches for given cursor index in parametrized nodes and if it finds it, returns the available columns.\n     * Otherwise returns the result relation schema (only column names, no rows).\n     * When an error occurs, it is faked to work, and adds it to the errors array.\n     *\n     * Strict expectations: disjointness\n     * Returned schema: left/right/both source schema (for left/right/full semijoin)\n     * Returned fake schema is not affected when disjointness is not held\n     *\n     * @param cursorIndex index of the cursor in original text input {@type number}\n     * @return resulting relation schema gained by evaluating this node and its subtree or found columns to whisper {@type NodeFakeEvalResult}\n     * @public\n     */\n    public fakeEval(cursorIndex: number) {\n        const left = this.leftSubtree.fakeEval(cursorIndex);\n        const right = this.rightSubtree.fakeEval(cursorIndex);\n        const sourceColumns: string[] = [];\n        sourceColumns.push(...left.result.getColumnNames());\n        sourceColumns.push(...right.result.getColumnNames());\n        // creates return relation\n        const result: Relation = new Relation(this.type);\n        if (this.type === ThetaJoinType.left || this.type === ThetaJoinType.full) {\n            left.result.forEachColumn((type, name) => result.addColumn(name, type));\n        }\n        if (this.type === ThetaJoinType.right || this.type === ThetaJoinType.full) {\n            right.result.forEachColumn((type, name) => result.addColumn(name, type));\n        }\n        // checks whether the cursor is in this condition block (and not in the string) - saves current available columns\n        let whispers = left.whispers.length !== 0 ? left.whispers : right.whispers;\n        if (isInRangeAndNotInQuotes(cursorIndex, this.stringRange, this.condition)) {\n            whispers = sourceColumns;\n        }\n        // adds errors from current expression\n        const errors = left.errors;\n        errors.push(...right.errors);\n        const commonColumns: string[] = [];\n        left.result.getColumnNames().forEach(leftColumn => {\n            if (right.result.hasColumn(leftColumn)) {\n                commonColumns.push(leftColumn);\n            }\n        });\n        if (commonColumns.length > 0 && this.stringRange !== undefined) {\n            errors.push(ErrorFactory.semanticError(language().semanticErrors.binaryNode_commonColumns,\n                {start: this.stringRange.start, end: this.stringRange.start},   // highlight only opening bracket\n                this.getOperationName().toLowerCase(), commonColumns.join('\", \"')));\n        }\n        // checks empty condition input\n        if (this.condition.toString().slice(1, -1).trim().length  === 0) {\n            errors.push(ErrorFactory.syntaxError(language().syntaxErrors.valueParser_emptyInput, this.stringRange));\n        }\n        else {\n            errors.push(...ValueParser.fakeParse(this.condition.slice(1, -1), this.nullValuesSupport, sourceColumns));\n        }\n        return {result, whispers, errors};\n    }\n\n    /**\n     * Creates a string with a structure of the RA tree in one line.\n     *\n     * @return string with a structure of the RA tree in one line {@type string}\n     * @public\n     */\n    public printInLine(): string {\n        return \"(\" + this.leftSubtree.printInLine() + this.getOperationSymbol() + this.rightSubtree.printInLine() + \")\";\n    }\n\n    /**\n     * Return the word name of the RA operation of the node.\n     * Example: returns \"Selection\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n    public getOperationName(): string {\n        const lang = language().operations;\n        if (this.type === ThetaJoinType.left) {\n            return lang.leftThetaSemiJoin;\n        }\n        else if (this.type === ThetaJoinType.right) {\n            return lang.rightThetaSemiJoin;\n        }\n        else {\n            return lang.thetaJoin;\n        }\n    }\n\n    /**\n     * Return the symbolic representation of the RA operation of the node.\n     * Example: returns \"(some + expr = 15)\" for SelectionNode.\n     *\n     * @return name of the RA operation of the node {@type string}\n     * @public\n     */\n    public getOperationSymbol(): string {\n        return this.condition.replace(/\\s+/g, ' ');\n    }\n\n    /**\n     * Returns type of ThetaJoinNode.\n     *\n     * @return type of the node {@type ThetaJoinType}\n     * @public\n     */\n    public getType(): ThetaJoinType {\n        return this.type;\n    }\n}","import {RATreeNode} from \"./raTreeNode\";\nimport {ProjectionNode} from \"./projectionNode\";\nimport {RenameNode} from \"./renameNode\";\nimport {SelectionNode} from \"./selectionNode\";\nimport {UnaryNode, UnaryNodeClass} from \"./unaryNode\";\nimport {AntijoinNode, AntijoinType} from \"./antijoinNode\";\nimport {CartesianProductNode} from \"./cartesianProductNode\";\nimport {DivisionNode} from \"./divisionNode\";\nimport {OuterJoinNode, OuterJoinType} from \"./outerJoinNode\";\nimport {NaturalJoinNode, NaturalJoinType} from \"./naturalJoinNode\";\nimport {SetOperationNode, SetOperationType} from \"./setOperationNode\";\nimport {BinaryNode, BinaryNodeClass} from \"./binaryNode\";\nimport {IndexedString} from \"../types/indexedString\";\nimport {ThetaJoinNode, ThetaJoinType} from \"./thetaJoinNode\";\n\n/**\n * Factory for creating unary and binary nodes of given class.\n * @category RATree\n * @public\n */\nexport class RATreeFactory {\n\n    /**\n     * Creates new unary node of given class.\n     *\n     * @param unaryClass wanted class {@type UnaryNodeClass}\n     * @param subtree source subtree for a node {@type RATreeNode}\n     * @param nullValuesSupport whether null values are supported {@type boolean}\n     * @param expr expression used to specify node's behavior {@type IndexedString}\n     * @return created unary node {@type UnaryNode}\n     * @public\n     */\n    public static createUnary(unaryClass: UnaryNodeClass, subtree: RATreeNode,\n                              nullValuesSupport: boolean, expr: IndexedString): UnaryNode {\n        switch (unaryClass) {\n            case \"projection\":\n                return new ProjectionNode(expr, subtree);\n            case \"rename\":\n                return new RenameNode(expr, subtree);\n            case \"selection\":\n                return new SelectionNode(expr, subtree, nullValuesSupport);\n        }\n    }\n\n    /**\n     * Creates new binary node of given class.\n     *\n     * @param binaryClass wanted class {@type BinaryNodeClass}\n     * @param left left source subtree for a node {@type RATreeNode}\n     * @param right right source subtree for a node {@type RATreeNode}\n     * @param nullValuesSupport whether null values are supported {@type boolean}\n     * @param expr expression used to specify node's behavior {@type IndexedString}\n     * @return created binary node {@type BinaryNode}\n     * @public\n     */\n    public static createBinary(binaryClass: BinaryNodeClass, left: RATreeNode, right: RATreeNode,\n                               nullValuesSupport: boolean, expr: IndexedString): BinaryNode {\n        switch (binaryClass) {\n            case \"left antijoin\":\n                return new AntijoinNode(AntijoinType.left, left, right);\n            case \"right antijoin\":\n                return new AntijoinNode(AntijoinType.right, left, right);\n            case \"cartesian product\":\n                return new CartesianProductNode(left, right, expr.getRange());\n            case \"division\":\n                return new DivisionNode(left, right, expr.getRange());\n            case \"natural join\":\n                return new NaturalJoinNode(NaturalJoinType.natural, left, right);\n            case \"left outer join\":\n                return new OuterJoinNode(OuterJoinType.left, left, right);\n            case \"right outer join\":\n                return new OuterJoinNode(OuterJoinType.right, left, right);\n            case \"full outer join\":\n                return new OuterJoinNode(OuterJoinType.full, left, right);\n            case \"left semijoin\":\n                return new NaturalJoinNode(NaturalJoinType.leftSemi, left, right);\n            case \"right semijoin\":\n                return new NaturalJoinNode(NaturalJoinType.rightSemi, left, right);\n            case \"union\":\n                return new SetOperationNode(SetOperationType.union, left, right, expr.getRange());\n            case \"intersection\":\n                return new SetOperationNode(SetOperationType.intersection, left, right, expr.getRange());\n            case \"difference\":\n                return new SetOperationNode(SetOperationType.difference, left, right, expr.getRange());\n            case \"theta join\":\n                return new ThetaJoinNode(ThetaJoinType.full, expr, left, right, nullValuesSupport);\n            case \"left theta semijoin\":\n                return new ThetaJoinNode(ThetaJoinType.left, expr, left, right, nullValuesSupport);\n            case \"right theta semijoin\":\n                return new ThetaJoinNode(ThetaJoinType.right, expr, left, right, nullValuesSupport);\n        }\n    }\n}","import {Relation} from \"../relation/relation\";\nimport {ErrorFactory} from \"../error/errorFactory\";\nimport {\n  BinaryOperatorToken,\n  ClosingParenthesis,\n  ExprToken,\n  OpeningParenthesis,\n  ParenthesisToken,\n  RelationToken,\n  UnaryOperatorToken\n} from \"./exprTokens\";\nimport {StringUtils} from \"../utils/stringUtils\";\nimport {RATreeNode} from \"../ratree/raTreeNode\";\nimport {RelationNode} from \"../ratree/relationNode\";\nimport {IndexedString} from \"../types/indexedString\";\nimport {IndexedStringUtils} from \"../utils/indexedStringUtils\";\nimport {ErrorWithTextRange} from \"../error/errorWithTextRange\";\nimport {RATreeFactory} from \"../ratree/raTreeFactory\";\nimport {language} from \"../language/language\";\nimport {StartEndPair} from \"../types/startEndPair\";\n\n/**\n * Fake parsing result in {@link ExprParser}.\n * @category Expression\n * @public\n */\nexport interface ExprFakeParseResult {\n    /**\n     * found words to whisper (relation or column names)\n     * @type string[]\n     * @public\n     */\n    whispers: string[],\n    /**\n     * detected errors\n     * @type ErrorWithTextRange[]\n     * @public\n     */\n    errors: ErrorWithTextRange[],\n    /**\n     * pairs of indexes with parentheses\n     * @type StartEndPair[]\n     * @public\n     */\n    parentheses: StartEndPair[]\n}\n\n/**\n * Parser of relational algebra expressions from textual inputs.\n * @category Expression\n * @public\n */\nexport class ExprParser {\n\n    /**\n     * Creates a parser with given source relations.\n     *\n     * @param relations map of relations used as source for leave nodes {@type Map<String, Relation>}\n     * @param nullValuesSupport whether to support null values {@type boolean}\n     * @public\n     */\n    public constructor(readonly relations: Map<string, Relation>, readonly nullValuesSupport: boolean) {}\n\n    /**\n     * Parses given relational algebra expression 'expr' and returns tree of RA operations.\n     * Expression is expected to respect following constraints:\n     * - all relation's and column's names contain letters, numbers and underscores only\n     * - all relation's and column's names start with a letter\n     * - used operations must be in a simplified notation and be well-structured\n     * - line comments begin with '//' and ends with newline\n     * - block comments begins with '/*' and ends with '* /'\n     *\n     * Supported operations are:\n     * - projection of columns: Relation[projectedColumn1, ...]\n     * - selection of rows: Relation(condition)\n     * - rename of columns: Relation<oldName -> newName, ...>\n     * - cartesian product: A ⨯ B\n     * - natural join: A * B\n     * - theta join: A [condition] B\n     * - left and right semijoin: A <* B and A *> B\n     * - left and right antijoin: A ⊳ B and A ⊲ B\n     * - left and right theta semijoin: A <condition] B and A [condition> B\n     * - division: A ÷ B\n     * - left, right and full outer join: A *L* B, A *R* B and A *F* B\n     * - union, intersection and difference: A ∪ B, A ∩ B and A \\ B\n     *\n     * See {@link ValueParser} for condition-subexpressions constraints.\n     *\n     * @param expr relational algebra expression in expected format {@type string}\n     * @return tree structure of the given expression {@type RATreeNode}\n     * @public\n     */\n    public parse(expr: string): RATreeNode {\n        const {str, err} = IndexedStringUtils.deleteAllComments(IndexedString.new(expr));\n        if (err !== undefined) {\n            throw err;\n        }\n        const {tokens} = this.parseTokens(str);\n        if (tokens.length === 0) {\n            throw ErrorFactory.syntaxError(language().syntaxErrors.exprParser_emptyStringGiven, undefined);\n        }\n        this.assertValidInfixTokens(tokens);\n        const rpn: ExprToken[] = this.toRPN(tokens);\n        return this.rpnToRATree(rpn);\n    }\n\n    /**\n     * Parses given expression and finds words to whisper for the given cursorIndex.\n     * If the cursor is located next to any RA operator, returns list of all defined relation names.\n     * If the cursor is located inside any RA operator, which uses relation columns, returns list of available column\n     * names at given place.\n     * If a parsing error occurs, it is faked to work or ignored and reported in returning errors array.\n     * For supported operations see {@link parse}.\n     *\n     * @param expr input expression to fake parse {@type string}\n     * @param cursorIndex current index of the cursor {@type number}\n     * @return parsed information {@type ExprFakeParseResult}\n     * @public\n     */\n    public fakeParse(expr: string, cursorIndex: number): ExprFakeParseResult {\n        if (expr.trim() === \"\") {\n            return {whispers: [...this.relations.keys()], errors: [], parentheses: []};\n        }\n        const {str, err} = IndexedStringUtils.deleteAllComments(IndexedString.new(expr));\n        const {whispers, tokens, errors, parentheses} = this.parseTokens(str, false, cursorIndex);\n        if (err !== undefined) {\n            errors.push(err);\n        }\n        // prevent errors in creation of RPN\n        if (tokens.length === 0) {\n            return {whispers: whispers, errors: errors, parentheses: parentheses};\n        }\n        // fakes found errors to valid parse\n        this.assertValidInfixTokens(tokens, false, errors);\n        const rpn: ExprToken[] = this.toRPN(tokens);\n        const raTree: RATreeNode = this.rpnToRATree(rpn, false, errors);\n        // tries to find whispers inside RA operations with parameters\n        const innerResult: {whispers: string[], errors: ErrorWithTextRange[]} = raTree.fakeEval(cursorIndex);\n        errors.push(...innerResult.errors);\n        // if there are whispers from inner operators, returns them\n        if (innerResult.whispers.length > 0) {\n            return {whispers: innerResult.whispers, errors: errors, parentheses: parentheses};\n        }\n        // otherwise returns outer whispers (or empty array if no were found)\n        return {whispers: whispers, errors: errors, parentheses: parentheses};\n    }\n\n    /**\n     * Parses given expression to ExprToken array. While parsing, it tries to find cursor index and returns whispers.\n     * When doThrow is false, parsing errors are not thrown but stored in errors array. Returns found pair characters\n     * (e.g., parentheses).\n     *\n     * @param expr IndexedString to parse the expression from\n     * @param cursorIndex current cursor index\n     * @param doThrow whether to throw encountered errors was a relation or an unary operator (default false)\n     */\n    public parseTokens(expr: IndexedString, doThrow: boolean = true, cursorIndex: number = NaN):\n        { tokens: ExprToken[], whispers: string[], errors: ErrorWithTextRange[], parentheses: StartEndPair[] } {\n        // handles empty string\n        if (expr.isEmpty()) {\n            return {tokens: [], whispers: [...this.relations.keys()], errors: [], parentheses: []};\n        }\n\n        let tokens: ExprToken[] = [];\n        let whispers: string[] = cursorIndex === 0 ? [...this.relations.keys()] : [];\n        let errors: ErrorWithTextRange[] = [];\n        let parentheses: StartEndPair[] = [];\n\n        // throws the error if doThrow is true, otherwise adds it to the errors array\n        const handleError = (err: ErrorWithTextRange) => {\n            if (doThrow) {\n                throw err;\n            }\n            errors.push(err);\n        }\n\n        // adds new pair of parentheses from margins of the given string\n        const pushParentheses = (str: IndexedString) => {\n            parentheses.push({start: str.getFirstIndex(), end: str.getLastIndex()});\n        }\n\n        let selectionExpected: boolean = false;\n        let rest: IndexedString = expr;\n        while (!rest.isEmpty()) {\n            // checks whether the cursor was reached\n            const restStartIndex: number = rest.getFirstIndex();\n            if (restStartIndex === cursorIndex) {\n                whispers = [...this.relations.keys()];\n            }\n\n            // '(' can be a selection or a parentheses\n            if (rest.startsWith(\"(\")) {\n                let split: {first: IndexedString, second: IndexedString};\n                try {\n                    split = IndexedStringUtils.nextBorderedPart(rest, '(', ')');\n                }\n                // catches error from nextBorderedPart\n                catch (err) {\n                    // saves error\n                    if (err instanceof ErrorWithTextRange) {\n                        handleError(err);\n                    }\n\n                    if (selectionExpected) {\n                        // it fakes the unclosed expression part as a selection operator\n                        tokens.push(UnaryOperatorToken.selection(rest.concat(IndexedString.new(')', rest.getLastIndex() + 1))));\n                    }\n                    else {\n                        // it fakes the unclosed expression as nested expression in parentheses\n                        tokens.push(new OpeningParenthesis(rest.slice(0, 1)));\n                        // parses inner part between parentheses\n                        const recursiveReturn = this.parseTokens(rest.slice(1), doThrow, cursorIndex);\n                        errors.push(...recursiveReturn.errors);\n                        if (whispers.length === 0) {\n                            whispers.push(...recursiveReturn.whispers);\n                        }\n                        tokens.push(...recursiveReturn.tokens);\n                        parentheses.push(...recursiveReturn.parentheses);\n                        // gives invalid index (NaN for not reporting errors with this imaginary parentheses\n                        tokens.push(new ClosingParenthesis(IndexedString.new(')', NaN)));\n                    }\n                    // breaks the while cycle because rest was parsed recursively\n                    break;\n                }\n\n                // saves parentheses\n                pushParentheses(split.first);\n\n                // whole \"(...)\" part pushed as selection\n                if (selectionExpected) {\n                    tokens.push(UnaryOperatorToken.selection(split.first));\n                }\n                // inner of \"(...)\" part parsed as parentheses structure\n                else {\n                    tokens.push(new OpeningParenthesis(split.first.slice(0, 1)));\n                    const recursiveReturn = this.parseTokens(split.first.slice(1, -1), doThrow, cursorIndex);\n                    errors.push(...recursiveReturn.errors);\n                    if (whispers.length === 0) {\n                        whispers.push(...recursiveReturn.whispers);\n                    }\n                    tokens.push(...recursiveReturn.tokens);\n                    parentheses.push(...recursiveReturn.parentheses);\n                    tokens.push(new ClosingParenthesis(split.first.slice(-1)));\n                    selectionExpected = true;\n                }\n                rest = split.second;\n            }\n            // '[' can be a projection, theta join, or right theta semi join\n            else if (rest.startsWith(\"[\")) {\n                let split: {first: IndexedString, second: IndexedString};\n                let error: boolean = false;\n                try {\n                    split = IndexedStringUtils.nextBorderedPart(rest, '[', ']\\u27e9');\n                }\n                // catches error from nextBorderedPart\n                catch (err) {\n                    error = true;\n                    // saves error\n                    if (err instanceof ErrorWithTextRange) {\n                        handleError(err);\n                    }\n                    // it fakes the unclosed expression part as a projection operator\n                    split = {first: rest.concat(IndexedString.new(']', rest.getLastIndex() + 1)), second: IndexedString.empty()};\n                }\n\n                // saves parentheses\n                pushParentheses(split.first);\n\n                // checks whether the cursor was reached\n                if (!error && split.first.getLastIndex() === cursorIndex - 1) {\n                    whispers = [...this.relations.keys()];\n                }\n\n                // right theta semijoin found \"[...⟩\"\n                if (split.first.endsWith('\\u27e9')) {\n                    tokens.push(BinaryOperatorToken.rightThetaSemijoin(split.first));\n                    selectionExpected = false;\n                    rest = split.second;\n                }\n                // if the next part contains any character from =<>+/*&|~\"()! it cannot be a valid Projection\n                else if (split.first.containsAny('=<>+/*&|~\"()!')) {\n                    tokens.push(BinaryOperatorToken.thetaJoin(split.first));\n                    selectionExpected = false;\n                    rest = split.second;\n                }\n                // else suppose it is a projection\n                else {\n                    tokens.push(UnaryOperatorToken.projection(split.first));\n                    selectionExpected = true;\n                    rest = split.second;\n                }\n            }\n            // BINARY OPERATORS\n            else if (rest.startsWith(\"*F*\") || rest.startsWith(\"*L*\") || rest.startsWith(\"*R*\")) {\n                const operator: IndexedString = rest.slice(0, 3);\n                // checks whether the cursor was reached\n                if (operator.getLastIndex() === cursorIndex - 1) {\n                    whispers = [...this.relations.keys()];\n                }\n\n                if (rest.startsWith(\"*F\")) {\n                    tokens.push(BinaryOperatorToken.fullOuterJoin(operator));\n                }\n                else if (rest.startsWith(\"*L\")) {\n                    tokens.push(BinaryOperatorToken.leftOuterJoin(operator));\n                }\n                else {\n                    tokens.push(BinaryOperatorToken.rightOuterJoin(operator));\n                }\n                rest = rest.slice(3);\n                selectionExpected = false;\n            }\n            // operators of 2 characters\n            else if (rest.startsWith(\"<*\") || rest.startsWith(\"*>\")) {\n                const operator: IndexedString = rest.slice(0, 2);\n                // checks whether the cursor was reached\n                if (operator.getLastIndex() === cursorIndex - 1) {\n                    whispers = [...this.relations.keys()];\n                }\n\n                if (rest.startsWith(\"<*\")) {\n                    tokens.push(BinaryOperatorToken.leftSemijoin(operator));\n                }\n                else {\n                    tokens.push(BinaryOperatorToken.rightSemijoin(operator));\n                }\n                rest = rest.slice(2);\n                selectionExpected = false;\n            }\n            // operators of 1 character\n            else if (\"*\\u2a2f\\u222a\\u2229\\\\\\u22b3\\u22b2\\u00f7\".indexOf(rest.charAt(0)) > -1) {\n                const operator: IndexedString = rest.slice(0, 1);\n                // checks whether the cursor was reached\n                if (operator.getLastIndex() === cursorIndex - 1) {\n                    whispers = [...this.relations.keys()];\n                }\n\n                if (rest.startsWith(\"*\")) {\n                    tokens.push(BinaryOperatorToken.naturalJoin(operator));\n                }\n                else if (rest.startsWith(\"\\u2a2f\")) {\n                    tokens.push(BinaryOperatorToken.cartesianProduct(operator));\n                }\n                else if (rest.startsWith(\"\\u222a\")) {\n                    tokens.push(BinaryOperatorToken.union(operator));\n                }\n                else if (rest.startsWith(\"\\u2229\")) {\n                    tokens.push(BinaryOperatorToken.intersection(operator));\n                }\n                else if (rest.startsWith(\"\\\\\")) {\n                    tokens.push(BinaryOperatorToken.difference(operator));\n                }\n                else if (rest.startsWith(\"\\u22b3\")) {\n                    tokens.push(BinaryOperatorToken.leftAntijoin(operator));\n                }\n                else if (rest.startsWith(\"\\u22b2\")) {\n                    tokens.push(BinaryOperatorToken.rightAntijoin(operator));\n                }\n                else if (rest.startsWith(\"\\u00f7\")) {\n                    tokens.push(BinaryOperatorToken.division(operator));\n                }\n                rest = rest.slice(1);\n                selectionExpected = false;\n            }\n            // '<' can be a rename or left theta semi join - this \"if\" must be after <*\n            else if (rest.startsWith('<')) {\n                try {\n                    const split = IndexedStringUtils.nextBorderedPart(rest, '<', '>', '-');\n                    // saves parentheses\n                    pushParentheses(split.first);\n                    // checks whether the cursor was reached\n                    if (split.first.getLastIndex() === cursorIndex - 1) {\n                        whispers = [...this.relations.keys()];\n                    }\n                    tokens.push(UnaryOperatorToken.rename(split.first));\n                    selectionExpected = true;\n                    rest = split.second;\n                }\n                // catches error from nextBorderedPart\n                catch (err) {\n                    // saves error\n                    if (err instanceof ErrorWithTextRange) {\n                        handleError(err);\n                    }\n                    // it fakes the unclosed expression part as a rename operator\n                    tokens.push(UnaryOperatorToken.rename(rest.concat(IndexedString.new('>', rest.getLastIndex() + 1))));\n                    // breaks the while cycle as all was used\n                    break;\n                }\n            }\n            // '⟨' can be a rename or left theta semi join - this \"if\" must be after <*\n            else if (rest.startsWith('\\u27e8')) {\n                try {\n                    const split = IndexedStringUtils.nextBorderedPart(rest, '\\u27e8', ']');\n                    // saves parentheses\n                    pushParentheses(split.first);\n                    // checks whether the cursor was reached\n                    if (split.first.getLastIndex() === cursorIndex - 1) {\n                        whispers = [...this.relations.keys()];\n                    }\n                    tokens.push(BinaryOperatorToken.leftThetaSemijoin(split.first));\n                    selectionExpected = false;\n                    rest = split.second;\n                }\n                // catches error from nextBorderedPart\n                catch (err) {\n                    // saves error\n                    if (err instanceof ErrorWithTextRange) {\n                        handleError(err);\n                    }\n                    // it fakes the unclosed expression part as a theta join operator\n                    tokens.push(BinaryOperatorToken.leftThetaSemijoin(rest.concat(IndexedString.new(']', rest.getLastIndex() + 1))));\n                    // breaks the while cycle as all was used\n                    break;\n                }\n            }\n            // RELATION REFERENCE\n            else if (StringUtils.isLetter(rest.charAt(0)) || rest.charAt(0) === '_') {\n                const split = IndexedStringUtils.nextName(rest);\n\n                // checks whether the cursor was reached in the relation reference string\n                if (split.first.getFirstIndex() <= cursorIndex - 1 && cursorIndex - 1 <= split.first.getLastIndex()) {\n                    whispers = [...this.relations.keys()];\n                }\n\n                tokens.push(new RelationToken(split.first));\n                rest = split.second;\n                selectionExpected = true;\n            }\n            // WHITE SPACE\n            else if (rest.charAt(0).match(/\\s/)) {\n                let i = 0;\n                while (i < rest.length() && rest.charAt(i).match(/\\s/)) {\n                    if (rest.indexAt(i) === cursorIndex - 1) {\n                        whispers = [...this.relations.keys()];\n                    }\n                    ++i;\n                }\n                rest = rest.slice(i);\n            }\n            // UNEXPECTED PART\n            else {\n                const split = IndexedStringUtils.nextNonWhitespacePart(rest);\n                handleError(ErrorFactory.syntaxError(language().syntaxErrors.exprParser_unexpectedPart,\n                    split.first.getRange(), split.first.toString()));\n                // tries to skip first unexpected character\n                rest = rest.slice(split.first.length());\n            }\n        }\n        return { tokens, whispers, errors, parentheses };\n    }\n\n    /**\n     * Checks the validity of the given infix token array. If doThrow is false, pushes found errors to the given errors\n     * array. Fake tokens are relations with empty name \"\", or natural joins \"*\", their error ranges are undefined.\n     * All faked errors are pushed in given errors array.\n     * Expects validly nested parentheses: yes \"(()())\", no \")()\", \")(\". Expects not empty array.\n     *\n     * @param tokens token array to check\n     * @param doThrow whether to throw found errors\n     * @param errors array for pushing faked errors for NOT_THROW type\n     */\n    public assertValidInfixTokens(tokens: ExprToken[], doThrow: boolean = true, errors: ErrorWithTextRange[] = []): void {\n        /**\n         * Handles the error described by given error code, params and range. If doThrow is true, throws the described\n         * error. Otherwise, fakes it by inserting a new token at given index. The token is binary (natural join) if\n         * missing is \"binary\", otherwise, it is a relation with empty name.\n         */\n        const handleError = (index: number, missing: \"binary\" | \"relation\",\n                             msg: string[], range: StartEndPair | undefined, ...params: string[]) => {\n            const error = ErrorFactory.syntaxError(msg, range, ...params);\n            if (doThrow) {\n                throw error;\n            }\n            else if (missing === \"binary\") {\n                errors.push(error);\n                tokens.splice(index, 0, BinaryOperatorToken.naturalJoin(IndexedString.new(\"*\")));\n            }\n            else {\n                errors.push(error);\n                tokens.splice(index, 0, new RelationToken(IndexedString.new(\"\")));\n            }\n        }\n\n        // checks start of an array: it must start with '(' or relation\n        if (tokens[0] instanceof UnaryOperatorToken || tokens[0] instanceof BinaryOperatorToken || tokens[0] instanceof ClosingParenthesis) {\n            handleError(0, \"relation\", language().syntaxErrors.exprParser_invalidStart,\n                tokens[0].getRange(), tokens[0].str.toString());\n        }\n\n        // checks end of an array: it must end with ')', relation or an unary operator\n        if (tokens[tokens.length - 1] instanceof OpeningParenthesis || tokens[tokens.length - 1] instanceof BinaryOperatorToken) {\n            handleError(tokens.length, \"relation\", language().syntaxErrors.exprParser_invalidEnd,\n                tokens[tokens.length - 1].getRange(), tokens[tokens.length - 1].str.toString());\n        }\n\n        // checks adjacent pairs of tokens\n        let i2: number = 1;\n        while (i2 < tokens.length) {\n            const token1: ExprToken = tokens[i2 - 1];\n            const token2: ExprToken = tokens[i2];\n\n            // valid predecessors: binary operator or '('\n            if (token2 instanceof RelationToken) {\n                if (token1 instanceof RelationToken) {\n                    handleError(i2, \"binary\", language().syntaxErrors.exprParser_relationAfterRelation,\n                        token2.getRange(), token2.str.toString(), token1.str.toString());\n                }\n                if (token1 instanceof UnaryOperatorToken) {\n                    handleError(i2, \"binary\", language().syntaxErrors.exprParser_relationAfterUnary,\n                        token2.getRange(), token2.str.toString(), token1.str.toString());\n                }\n                if (token1 instanceof ClosingParenthesis) {\n                    handleError(i2, \"binary\", language().syntaxErrors.exprParser_relationAfterClosing,\n                        token2.getRange(), token2.str.toString());\n                }\n            }\n            // valid predecessors: relation, unary operator or ')'\n            else if (token2 instanceof UnaryOperatorToken) {\n                if (token1 instanceof BinaryOperatorToken) {\n                    handleError(i2, \"relation\", language().syntaxErrors.exprParser_unaryAfterBinary,\n                        token2.getRange(), token2.str.toString(), token1.str.toString());\n                }\n                if (token1 instanceof OpeningParenthesis) {\n                    handleError(i2, \"relation\", language().syntaxErrors.exprParser_unaryAfterOpening,\n                        token2.getRange(), token2.str.toString());\n                }\n            }\n            // valid predecessors: relation, unary operator or ')'\n            else if (token2 instanceof BinaryOperatorToken) {\n                if (token1 instanceof BinaryOperatorToken) {\n                    handleError(i2, \"relation\", language().syntaxErrors.exprParser_binaryAfterBinary,\n                        token2.getRange(), token2.str.toString(), token1.str.toString());\n                }\n                if (token1 instanceof OpeningParenthesis) {\n                    handleError(i2, \"relation\", language().syntaxErrors.exprParser_binaryAfterOpening,\n                        token2.getRange(), token2.str.toString());\n                }\n            }\n            // valid predecessors: binary operator or '('\n            else if (token2 instanceof OpeningParenthesis) {\n                if (token1 instanceof RelationToken) {\n                    handleError(i2, \"binary\", language().syntaxErrors.exprParser_openingAfterRelation,\n                        token2.getRange(), token1.str.toString());\n                }\n                if (token1 instanceof UnaryOperatorToken) {\n                    handleError(i2, \"binary\", language().syntaxErrors.exprParser_openingAfterUnary,\n                        token2.getRange(), token1.str.toString());\n                }\n                if (token1 instanceof ClosingParenthesis) {\n                    handleError(i2, \"binary\", language().syntaxErrors.exprParser_openingAfterClosing,\n                        token2.getRange());\n                }\n            }\n            // valid predecessors: relation, unary operator or ')'\n            else if (token2 instanceof ClosingParenthesis) {\n                if (token1 instanceof BinaryOperatorToken) {\n                    handleError(i2, \"relation\", language().syntaxErrors.exprParser_closingAfterBinary,\n                        token2.getRange(), token1.str.toString());\n                }\n                if (token1 instanceof OpeningParenthesis) {\n                    handleError(i2, \"relation\", language().syntaxErrors.exprParser_closingAfterOpening,\n                        token2.getRange());\n                }\n            }\n            else {\n                throw ErrorFactory.codeError(language().codeErrors.exprParser_unexpectedToken, JSON.stringify(token2));\n            }\n            ++i2;\n        }\n    }\n\n    /**\n     * Transforms given infix relation algebra expression into postfix (reverse polish) form.\n     * Throws error when invalid parentheses structure is given.\n     *\n     * @param tokens infix relational algebra expression as Token array\n     * @return postfix (reverse polish) form of given array\n     */\n    public toRPN(tokens: ExprToken[]): ExprToken[] {\n        const rpnQueue: ExprToken[] = [];\n        const operatorsStack: Array<BinaryOperatorToken | ParenthesisToken> = [];\n        tokens.forEach(token => {\n            if (token instanceof RelationToken || token instanceof UnaryOperatorToken) {\n                rpnQueue.push(token);\n            }\n            else if (token instanceof BinaryOperatorToken) {\n                while (operatorsStack.length > 0 && operatorsStack[operatorsStack.length - 1] instanceof BinaryOperatorToken) {\n                    // @ts-ignore (token must be of BinaryOperatorToken class)\n                    let other: BinaryOperatorToken = operatorsStack[operatorsStack.length - 1];\n                    // all used operators have left associativity\n                    if (token.precedence <= other.precedence) {\n                        // @ts-ignore (token must be present)\n                        rpnQueue.push(operatorsStack.pop());\n                    }\n                    else {\n                        break;\n                    }\n                }\n                operatorsStack.push(token);\n            }\n            else if (token instanceof OpeningParenthesis) {\n                operatorsStack.push(token);\n            }\n            else if (token instanceof ClosingParenthesis) {\n                while (true) {\n                    if (operatorsStack.length === 0) {\n                        throw ErrorFactory.syntaxError(language().syntaxErrors.exprParser_invalidParentheses,\n                            undefined);\n                    }\n                    if (operatorsStack[operatorsStack.length - 1] instanceof OpeningParenthesis) {\n                        operatorsStack.pop();\n                        break;\n                    }\n                    // @ts-ignore (token must be present)\n                    rpnQueue.push(operatorsStack.pop());\n                }\n            }\n        });\n        while (operatorsStack.length > 0) {\n            // @ts-ignore (token must be present)\n            const curToken: ExprToken = operatorsStack.pop();\n            if (curToken instanceof OpeningParenthesis) {\n                throw ErrorFactory.syntaxError(language().syntaxErrors.exprParser_invalidParentheses,\n                    undefined);\n            }\n            else {\n                rpnQueue.push(curToken);\n            }\n        }\n        return rpnQueue;\n    }\n\n    /**\n     * Creates a RA expression evaluating tree from the given array of tokens in reverse polish form.\n     * Wraps recursive function rpnToRATreeRecursive(tokens).\n     * Possible errors:\n     * - not all tokens were used (invalid RPN structure was given, should not happen if the previous infix structure\n     * was asserted/faked) - if doThrow = false, returns a RelationNode with an empty relation\n     * - reference to a relation which does not exist found - if doThrow = false, replaces it with an empty relation\n     *\n     * @param tokens value-evaluating expression in reverse polish form\n     * @param doThrow if true and an error occurs, throws an error, if false and an error occurs, fakes it and does\n     * not throw\n     * @param errors array to store found errors when doThrow = false\n     * @return RATreeNode tree (its root)\n     */\n    public rpnToRATree(tokens: ExprToken[], doThrow: boolean = true, errors: ErrorWithTextRange[] = []): RATreeNode {\n        const ret: RATreeNode = this.rpnToRATreeRecursive(tokens, doThrow, errors);\n        // not all tokens were used\n        if (tokens.length > 0) {\n            if (doThrow) {\n                throw ErrorFactory.syntaxError(language().syntaxErrors.exprParser_invalidExpression, undefined);\n            }\n            else {\n                return new RelationNode(new Relation(\"\"));\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Helper function for rpnToRATree.\n     */\n    public rpnToRATreeRecursive(tokens: ExprToken[], doThrow: boolean, errors: ErrorWithTextRange[]): RATreeNode {\n        if (tokens.length === 0) {\n            throw ErrorFactory.syntaxError(language().syntaxErrors.exprParser_invalidExpression, undefined);\n        }\n        // @ts-ignore (there must be a token)\n        const token: ExprToken = tokens.pop();\n        // RELATION REFERENCE\n        if (token instanceof RelationToken) {\n            const relation: Relation | undefined = this.relations.get(token.str.toString());\n            // when the relation does not exist, throws or fakes it with an empty relation\n            if (relation === undefined) {\n                const error = ErrorFactory.semanticError(language().semanticErrors.exprParser_relationNotDefined,\n                    token.getRange(), token.str.toString());\n                if (doThrow) {\n                    throw error;\n                }\n                else {\n                    errors.push(error);\n                    return new RelationNode(new Relation(\"\"));\n                }\n            }\n            return new RelationNode(relation);\n        }\n        // UNARY OPERATORS\n        if (token instanceof UnaryOperatorToken) {\n            const subtree: RATreeNode = this.rpnToRATreeRecursive(tokens, doThrow, errors);\n            // @ts-ignore\n            return RATreeFactory.createUnary(token.type, subtree, this.nullValuesSupport, token.str);\n        }\n        // BINARY OPERATORS\n        if (token instanceof BinaryOperatorToken) {\n            const right: RATreeNode = this.rpnToRATreeRecursive(tokens, doThrow, errors);\n            const left: RATreeNode = this.rpnToRATreeRecursive(tokens, doThrow, errors);\n            // @ts-ignore\n            return RATreeFactory.createBinary(token.type, left, right, this.nullValuesSupport, token.str);\n        }\n        // should never happen\n        throw ErrorFactory.codeError(language().codeErrors.exprParser_unexpectedToken, JSON.stringify(token));\n    }\n}\n","import React from \"react\";\n\n/**\n * Props of TextInput component.\n * @category Components\n * @public\n */\ninterface TextInputProps {\n    /**\n     * initial value for the input\n     * @type string\n     * @public\n     */\n    value: string,\n    /**\n     * text on the submit button\n     * @type string\n     * @public\n     */\n    buttonText: string,\n    /**\n     * handler of input submit\n     * @type function\n     * @public\n     */\n    onSubmit: (text: string) => void,\n    /**\n     * function which returns true for forbidden inputs which cannot be submitted\n     * @type function\n     * @public\n     */\n    forbidden: (text: string) => boolean,\n    /**\n     * id of the input\n     * @type string\n     * @public\n     */\n    id: string\n}\n\ninterface TextInputState {\n    value: string,\n    buttonDisable: boolean\n}\n\n/**\n * Basic text input with submit button (without label). The input cannot be submit if the current value is forbidden.\n * All inserted tabulators are replaced by 4 spaces.\n * Accepts {@link TextInputProps} props.\n * @category Components\n * @public\n */\nexport class TextInput extends React.Component<TextInputProps, TextInputState> {\n\n    private readonly inputRef: React.RefObject<HTMLInputElement>;\n\n    constructor(props: TextInputProps) {\n        super(props);\n        this.state = {\n            value: this.props.value,\n            buttonDisable: this.props.forbidden(this.props.value)\n        }\n        this.inputRef = React.createRef();\n    }\n\n    componentDidUpdate(prevProps: Readonly<TextInputProps>) {\n        if (prevProps.value !== this.props.value) {\n            this.setState({value: this.props.value});\n        }\n    }\n\n    private handleChange = (value: string): void => {\n        value = value.replace(/\\t/g, \"    \");\n        const disable: boolean = this.props.forbidden(value);\n        this.setState({\n            value: value,\n            buttonDisable: disable\n        });\n    }\n\n    private handleKeyDown = (event: React.KeyboardEvent<HTMLInputElement>): void => {\n        if (event.key === \"Enter\") {\n            if (!this.state.buttonDisable) {\n                this.handleSubmit();\n            }\n        }\n        else if (event.key === \"Escape\" || event.key === \"Esc\") {\n            if (this.inputRef.current !== null) {\n                this.inputRef.current.blur();\n            }\n        }\n    }\n\n    private handleSubmit = (): void => {\n        this.props.onSubmit(this.state.value);\n    }\n\n    public render() {\n        return (\n            <>\n                <input\n                    ref={this.inputRef}\n                    type='text'\n                    id={this.props.id}\n                    spellCheck={false}\n                    autoComplete={\"off\"}\n                    value={this.state.value}\n                    onChange={event => this.handleChange(event.target.value)}\n                    onKeyDown={this.handleKeyDown}\n                    className={'text-input'}\n                />\n                <button\n                    onClick={this.handleSubmit}\n                    disabled={this.state.buttonDisable}\n                >{this.props.buttonText}</button>\n            </>\n        );\n    }\n}","import \"./css/messageBox.css\"\n\n// @ts-ignore\nconst cssConstants: CSSStyleDeclaration = getComputedStyle(document.querySelector(':root'));\nconst boxMargin: number = Number(cssConstants.getPropertyValue('--message-box-margin-num'));\n\n/**\n * Class for displaying messages and errors to the user in a pop-up box.\n * @category Components\n * @public\n */\nexport class MessageBox {\n\n    private static readonly hideTimeout: number = 5000;\n\n    private static box: HTMLDivElement = MessageBox.init();\n    private static hideIntervalId: NodeJS.Timeout;\n\n    private static init(): HTMLDivElement {\n        const box = document.createElement(\"div\");\n        box.classList.add(\"message-box\");\n        box.style.visibility = \"hidden\";\n        box.onmouseenter = () => {\n            MessageBox.clearHideTimeout();\n        }\n        box.onmouseleave = () => {\n            MessageBox.setHideTimeout();\n        }\n\n        const paragraph = document.createElement(\"p\");\n        box.appendChild(paragraph);\n\n        const button = document.createElement(\"button\");\n        button.innerText = \"\\u2716\";\n        button.onclick = () => {\n            MessageBox.hideBox();\n        }\n        box.appendChild(button);\n\n        window.addEventListener('resize', () => {\n            MessageBox.moveBox();\n        });\n\n        document.body.appendChild(box);\n        return box;\n    }\n\n    private static setHideTimeout = () => {\n        // clears previous hide interval\n        MessageBox.clearHideTimeout();\n        MessageBox.hideIntervalId = setTimeout(MessageBox.hideBox, MessageBox.hideTimeout);\n    }\n\n    private static clearHideTimeout = () => {\n        clearTimeout(MessageBox.hideIntervalId);\n    }\n\n    private static hideBox = () => {\n        MessageBox.box.style.visibility = \"hidden\";\n    }\n\n    private static moveBox = () => {\n        if (MessageBox.box.style.visibility === \"visible\") {\n            MessageBox.box.style.width = (document.body.clientWidth - 2 * boxMargin) + \"px\";\n        }\n    }\n\n    private static display(msg: string, error: boolean): void {\n        const box = MessageBox.box;\n        // @ts-ignore - first element is paragraph\n        box.firstElementChild.innerText = msg;\n        box.style.visibility = \"visible\";\n        box.classList.toggle(\"message-box-message\", !error);\n        box.classList.toggle(\"message-box-error\", error);\n        MessageBox.moveBox();\n        MessageBox.setHideTimeout();\n    }\n\n    /**\n     * Displays given message in a message box fixed on the page bottom.\n     * @param msg message to display {@type string}\n     * @public\n     */\n    public static message(msg: string): void {\n        MessageBox.display(msg, false);\n    }\n\n    /**\n     * Displays given error in a message box fixed on the page bottom.\n     * @param msg error to display {@type string}\n     * @public\n     */\n    public static error(msg: string): void {\n        MessageBox.display(msg, true);\n    }\n}","import React from \"react\";\nimport \"./css/expressionSection.css\"\nimport {Relation} from \"../relation/relation\";\nimport {TooltipButton} from \"./tooltipButton\";\nimport {RASyntaxError} from \"../error/raSyntaxError\";\nimport {RASemanticError} from \"../error/raSemanticError\";\nimport {LocatedError, XTextArea} from \"./xTextArea\";\nimport {ExprParser} from \"../expression/exprParser\";\nimport {getStartOfWordBeforeIndex, sortWhispers} from \"../utils/whisperUtils\";\nimport {Expression} from \"../expression/expression\";\nimport {TextInput} from \"./textInput\";\nimport {ErrorWithTextRange} from \"../error/errorWithTextRange\";\nimport {RATreeNode} from \"../ratree/raTreeNode\";\nimport {MessageBox} from \"./messageBox\";\nimport {LanguageDef} from \"../language/language\";\nimport {StartEndPair} from \"../types/startEndPair\";\n\n/**\n * Props of ExpressionSection component.\n * @category Components\n * @public\n */\ninterface ExpressionSectionProps {\n    /**\n     * available expressions\n     * @type Expression[]\n     * @public\n     */\n    expressions: Expression[],\n    /**\n     * index of the current selected expression in the expression list\n     * @type number\n     * @public\n     */\n    currentExpressionIndex: number,\n    /**\n     * loaded relations user as sources for expression evaluation\n     * @type Map<String, Relation>\n     * @public\n     */\n    relations: Map<string, Relation>,\n    /**\n     * handler of selecting different expression as current\n     * @type function\n     * @public\n     */\n    onSelectDifferentExpression: (newIndex: number) => void,\n    /**\n     * handler of moving an expression on a new position using drag and drop\n     * @type function\n     * @public\n     */\n    onDragExpression: (from: number, to: number) => void,\n    /**\n     * handler of creating the new expression\n     * @type function\n     * @public\n     */\n    onNewExpression: () => void,\n    /**\n     * handler of deleting the current expression\n     * @type function\n     * @public\n     */\n    onDeleteExpression: (onDone: () => void) => void,\n    /**\n     * handler of saving the expressions\n     * @type function\n     * @public\n     */\n    onExportExpressions: (onDone: (msg: string) => void) => void,\n    /**\n     * handler of loading the expressions\n     * @type function\n     * @public\n     */\n    onImportExpressions: (onDone: (msg: string) => void) => void,\n    /**\n     * handler of change in the current selected expression\n     * @type function\n     * @public\n     */\n    onChange: (name: string, text: string) => void,\n    /**\n     * handler of evaluation, it accepts the parsed tree from the expression text\n     * @type function\n     * @public\n     */\n    onEval: (tree: RATreeNode) => void,\n    /**\n     * handler of unexpected errors\n     * @type function\n     * @public\n     */\n    onUnexpectedError: (e: Error) => void,\n    /**\n     * whether to support null values\n     * @type boolean\n     * @public\n     */\n    nullValuesSupport: boolean,\n    /**\n     * true if dark theme should be applied\n     * @type boolean\n     * @public\n     */\n    darkTheme: boolean,\n    /**\n     * current application language\n     * @type LanguageDef\n     * @public\n     */\n    language: LanguageDef\n}\n\ninterface ExpressionSectionState {\n    sectionClicked: boolean,\n    whispers: string[],\n    errors: LocatedError[],\n    parentheses: StartEndPair[],\n    cursorIndex: number\n}\n\n/**\n * Identifier of elements drag-and-dropped from the ExpressionSection.\n */\nconst dndId: string = \"E\";\n\n/**\n * Section to edit, manage, and eval relational algebra expressions.\n * Accepts {@link ExpressionSectionProps} props.\n * @category Components\n * @public\n */\nexport class ExpressionSection extends React.Component<ExpressionSectionProps, ExpressionSectionState> {\n\n    // reference to child textarea element\n    private readonly textAreaRef: React.RefObject<XTextArea>;\n    // timestamp of last expression text change\n    private lastChange: number = 0;\n    // timestamp of last display of whispers and errors\n    private lastWhisperAndErrorsUpdate: number = 0;\n    // update rate of whispers and errors (in ms)\n    private readonly whispersAndErrorsUpdateRate: number = 400;\n\n    constructor(props: ExpressionSectionProps) {\n        super(props);\n        this.state = {\n            sectionClicked: false,\n            whispers: [],\n            errors: [],\n            parentheses: [],\n            cursorIndex: 0\n        }\n        this.textAreaRef = React.createRef<XTextArea>();\n        setInterval(() => this.updateWhispersAndErrors(), this.whispersAndErrorsUpdateRate);\n    }\n\n    componentDidUpdate(prevProps: Readonly<ExpressionSectionProps>) {\n        if (this.props.language !== prevProps.language) {\n            const textarea = this.textAreaRef.current;\n            if (textarea !== null) {\n                textarea.setPlaceholder(this.props.language.expressionSection.expressionTextareaPlaceholder);\n            }\n        }\n    }\n\n    /**\n     * Updates displayed errors and parentheses pairs in the text area input.\n     * @public\n     */\n    public updateErrorsAndParentheses = () => {\n        const text = this.getCurExpr().text;\n        const exprParser: ExprParser = new ExprParser(this.props.relations, this.props.nullValuesSupport);\n        const { errors, parentheses } = exprParser.fakeParse(text, this.state.cursorIndex);\n        this.setState({\n            errors: errors.filter(err => err.range !== undefined && !isNaN(err.range.start) && !isNaN(err.range.end))\n                // @ts-ignore\n                .map(err => {return {start: err.range.start, end: err.range.end + 1, msg: err.message}}),\n            parentheses: parentheses.filter(p => !isNaN(p.start) && !isNaN(p.end))\n        });\n    }\n\n    private getCurExpr(): Expression {\n        return this.props.expressions[this.props.currentExpressionIndex];\n    }\n\n    private handleSelectDifferentExpression(index: number): void {\n        this.props.onSelectDifferentExpression(index);\n    }\n\n    private evalExpr = (): void => {\n        try {\n            const exprParser: ExprParser = new ExprParser(this.props.relations, this.props.nullValuesSupport);\n            const tree = exprParser.parse(this.props.expressions[this.props.currentExpressionIndex].text);\n            tree.eval();\n            this.setState({errors: []});\n            this.props.onEval(tree);\n        }\n        catch (err) {\n            if (err instanceof ErrorWithTextRange) {\n                if (err.range !== undefined) {\n                    // change end to also highlight the last char\n                    err.range.end += 1;\n                    this.setState(state => {\n                        const errorRanges = state.errors;\n                        // does not push duplicate error range\n                        if (errorRanges.every(er => er.start !== err.range.start || er.end !== err.range.end)) {\n                            errorRanges.push({...err.range, msg: err.message});\n                        }\n                        return {errors: errorRanges}\n                    });\n                }\n            }\n            this.showError(err);\n        }\n    }\n\n    private newExpression = (): void => {\n        this.props.onNewExpression();\n    }\n\n    private deleteExpression = (): void => {\n        this.props.onDeleteExpression(this.updateErrorsAndParentheses);\n    }\n\n    private exportExpressions = (): void => {\n        this.props.onExportExpressions(MessageBox.message);\n    }\n\n    private importExpressions = (): void => {\n        this.props.onImportExpressions((msg) => {\n            MessageBox.message(msg);\n            this.updateErrorsAndParentheses();\n        });\n    }\n\n    /**\n     * Adds given special string into RA expression at the current cursor position.\n     *\n     * @param str string to be added\n     * @param shift move of the cursor from added string end position (to the beginning)\n     */\n    private addSpecialString = (str: string, shift: number): void => {\n        // @ts-ignore\n        const {start, end} = this.textAreaRef.current.getSelection();\n        const firstPart: string = this.getCurExpr().text.substring(0, start);\n        const secondPart: string = this.getCurExpr().text.substring(end);\n        const newPosition: number = firstPart.length + str.length - shift;\n        const newStr: string = firstPart + str + secondPart;\n        // updates text in textarea\n        this.handleExprChange(newStr, newPosition, () => {\n            // @ts-ignore - moves cursor to expected position\n            this.textAreaRef.current.setSelection(newPosition);\n            // @ts-ignore\n            this.textAreaRef.current.focus();\n        });\n    }\n\n    /**\n     * Handles change of expression text. Updates text and notifies the parent.\n     *\n     * @param text\n     * @param cursorIndex\n     * @param onDone callback after updating the state\n     */\n    private handleExprChange = (text: string, cursorIndex: number, onDone: () => void = () => {}): void => {\n        this.props.onChange(this.getCurExpr().name, text);  // must be called before setState for proper functionality of XTextArea\n        this.setState({cursorIndex: cursorIndex}, onDone);\n        this.lastChange = Date.now();\n    }\n\n    /**\n     * Handles input with Ctrl key pressed from textarea.\n     */\n    private handleCtrlInput = (ev: KeyboardEvent): void => {\n        if (ev.key === \"Enter\") {\n            this.evalExpr();\n        }\n    }\n\n    /**\n     * Shows current whispers and errors, if the text area is focused and there was a text change after last update.\n     */\n    private updateWhispersAndErrors = () => {\n        const textArea = this.textAreaRef.current;\n        if (textArea !== null && textArea.isFocused() && this.lastChange > this.lastWhisperAndErrorsUpdate) {\n            const text = this.getCurExpr().text;\n            const exprParser: ExprParser = new ExprParser(this.props.relations, this.props.nullValuesSupport);\n            const fakeParseResult = exprParser.fakeParse(text, this.state.cursorIndex);\n            const wordBeforeCursor: string = text.slice(getStartOfWordBeforeIndex(text, this.state.cursorIndex), this.state.cursorIndex);\n            const whispers = sortWhispers(fakeParseResult.whispers, wordBeforeCursor);\n            this.setState({\n                whispers: whispers,\n                errors: fakeParseResult.errors.filter(err => err.range !== undefined && !isNaN(err.range.start) && !isNaN(err.range.end))\n                    // @ts-ignore\n                    .map(err => {return {start: err.range.start, end: err.range.end + 1, msg: err.message}}),\n                parentheses: fakeParseResult.parentheses.filter(p => !isNaN(p.start) && !isNaN(p.end))\n            });\n            this.lastWhisperAndErrorsUpdate = Date.now();\n        }\n    }\n\n    private handleExprNameChange = (name: string) => {\n        this.props.onChange(name, this.getCurExpr().text);\n    }\n\n    /**\n     * Handles and shows the given error. If the error is not of RASyntaxError or RASemanticError class, it is passed\n     * to the parent as unexpected error.\n     *\n     * @param err the error to handle\n     */\n    private showError = (err: Error) => {\n        // common user's errors\n        if (err instanceof RASyntaxError || err instanceof RASemanticError) {\n            MessageBox.error(err.message);\n        }\n        else {\n            this.props.onUnexpectedError(err);\n            MessageBox.error(\"UNEXPECTED ERROR: \" + err.message + \"\\n\" +\n                \"Please, help us and report your last actions, thank you!\");\n        }\n    }\n\n    /**\n     * Requests expressions move when the drag ends.\n     */\n    // @ts-ignore\n    private handleDragDrop = (e: DragEvent<HTMLDivElement>, i: number) => {\n        e.preventDefault();\n        const data = e.dataTransfer.getData(\"text/plain\");\n        const fromIndex = Number(data.slice(1));\n        if (data.charAt(0) === dndId && !isNaN(fromIndex)) {\n            this.props.onDragExpression(fromIndex, i);\n        }\n    }\n\n    render() {\n        const lang = this.props.language.expressionSection;\n        const ops = this.props.language.operations;\n\n        const createExprMenuButtons = () => {\n            return this.props.expressions.map((expr, i) => {\n                const className: string = (this.props.currentExpressionIndex === i ? \"button-clicked\" : \"\");\n                return (<button\n                    key={i}\n                    onClick={() => this.handleSelectDifferentExpression(i)}\n                    className={className}\n                    draggable={true}\n                    onDragStart={e => e.dataTransfer.setData(\"text/plain\", dndId + String(i))}\n                    onDragOver={e => e.preventDefault()}\n                    onDrop={e => this.handleDragDrop(e, i)}\n                >{expr.name}</button>);\n            });\n        }\n\n        const createButton = (text: string, onClick: () => void, tooltip: string, style?: React.CSSProperties) => {\n            return (<TooltipButton\n                key={text}\n                text={text}\n                onClick={onClick}\n                style={style}\n                tooltip={tooltip}\n            />);\n        }\n\n        const createOpButton = (key: string, char: string, text: string, tooltip: string, shift: number, style: React.CSSProperties = {}) => {\n            return (<TooltipButton\n                key={key}\n                text={text}\n                onClick={() => this.addSpecialString(char, shift)}\n                tooltip={tooltip}\n                style={style}\n            />);\n        }\n        const buttonGroupMargin = {marginRight: \"10px\"};\n\n        return (\n            <section className=\"page-section\">\n                <header>\n                    <h2>{lang.expressionSectionHeader}</h2>\n                    {createButton(lang.importButton, this.importExpressions, lang.importButtonTooltip)}\n                    {createButton(lang.exportButton, this.exportExpressions, lang.exportButtonTooltip)}\n                </header>\n\n                <menu className=\"page-section-tab-menu\">\n                    {createExprMenuButtons()}\n                    <button onClick={this.newExpression}\n                        style={{minWidth: \"0\", marginLeft: \"10px\", padding: \"2px 6px 1px 6px\"}}>\n                        <strong>+</strong>\n                    </button>\n                </menu>\n\n                <XTextArea\n                    ref={this.textAreaRef}\n                    id=\"expression-section-textarea\"\n                    text={this.getCurExpr().text}\n                    placeholder={lang.expressionTextareaPlaceholder}\n                    errors={this.state.errors}\n                    whispers={this.state.whispers}\n                    parentheses={this.state.parentheses}\n\n                    onChange={this.handleExprChange}\n                    onCtrlInput={this.handleCtrlInput}\n\n                    darkTheme={this.props.darkTheme}\n                />\n\n                <menu className=\"expressions-operators-menu\">\n                    {createOpButton(\"unary_a\", \"()\", \"()\", ops.selection, 1)}\n                    {createOpButton(\"unary_b\", \"[]\", \"[]\", ops.projection, 1)}\n                    {createOpButton(\"unary_c\", \"< -> >\", \"<>\", ops.rename, 5, buttonGroupMargin)}\n\n                    {createOpButton(\"set_a\", \"\\u222a\", \"\\u222a\", ops.union, 0)}\n                    {createOpButton(\"set_b\", \"\\u2229\", \"\\u2229\", ops.intersection, 0)}\n                    {createOpButton(\"set_c\", \"\\\\\", \"\\\\\", ops.difference, 0, buttonGroupMargin)}\n\n                    {createOpButton(\"inner_a\", \"*\", \"*\", ops.naturalJoin, 0)}\n                    {createOpButton(\"inner_b\", \"\\u2a2f\", \"\\u2a2f\", ops.cartesianProduct, 0)}\n                    {createOpButton(\"inner_c\", \"<*\", \"<*\", ops.leftSemiJoin, 0)}\n                    {createOpButton(\"inner_d\", \"*>\", \"*>\", ops.rightSemiJoin, 0)}\n                    {createOpButton(\"inner_e\", \"\\u22b3\", \"\\u22b3\", ops.leftAntijoin, 0)}\n                    {createOpButton(\"inner_f\", \"\\u22b2\", \"\\u22b2\", ops.rightAntijoin, 0)}\n                    {createOpButton(\"inner_g\", \"[]\", \"[]\", ops.thetaJoin, 1)}\n                    {createOpButton(\"inner_h\", \"\\u27e8]\", \"\\u27e8]\", ops.leftThetaSemiJoin, 1)}\n                    {createOpButton(\"inner_i\", \"[\\u27e9\", \"[\\u27e9\", ops.rightThetaSemiJoin, 1, buttonGroupMargin)}\n\n                    {this.props.nullValuesSupport && createOpButton(\"outer_a\", \"*F*\", \"*F*\", ops.fullOuterJoin, 0)}\n                    {this.props.nullValuesSupport && createOpButton(\"outer_b\", \"*L*\", \"*L*\", ops.leftOuterJoin, 0)}\n                    {this.props.nullValuesSupport && createOpButton(\"outer_c\", \"*R*\", \"*R*\", ops.rightOuterJoin, 0, buttonGroupMargin)}\n\n                    {createOpButton(\"division\", \"\\u00f7\", \"\\u00f7\", ops.division, 0, buttonGroupMargin)}\n\n                    {createOpButton(\"line_comment\", \"//\", \"//\", lang.lineComment, 0)}\n                    {createOpButton(\"block_comment\", \"/**/\", \"/*\", lang.blockComment, 2)}\n                </menu>\n\n                <menu className=\"page-section-management-menu\">\n                    <TooltipButton\n                        text={lang.evaluateButton}\n                        onClick={this.evalExpr}\n                        className={\"action-button\"}\n                        style={{marginRight: \"40px\"}}\n                        tooltip={lang.evaluateButtonTooltip}\n                    />\n                    <TextInput\n                        value={this.getCurExpr().name}\n                        buttonText={lang.renameButton}\n                        onSubmit={this.handleExprNameChange}\n                        forbidden={() => false}\n                        id=\"expression-name-input\"\n                    />\n                    {createButton(lang.deleteButton, this.deleteExpression, lang.deleteButtonTooltip)}\n                </menu>\n            </section>\n        );\n    }\n}","import React from \"react\";\nimport {Relation} from \"../relation/relation\";\nimport './css/resultRelationTable.css'\nimport {Row} from \"../relation/row\";\n\n/**\n * Props of RelationTable component.\n * @category Components\n * @public\n */\ninterface RelationTableProps {\n    /**\n     * relation to be shown\n     * @type Relation\n     * @public\n     */\n    relation: Relation\n}\n\ninterface RelationTableState {\n    // index of the column which is used to order the table (or -1 if none is used)\n    orderBy: number,\n    // 1 = ascending, -1 = descending\n    orderDir: number\n}\n\n/**\n * Table which shows given relation. The relation cannot be edited\n * Rows can be ordered by column values when the column header is clicked.\n * When the same column header is clicked for the second time, the order direction is changed (asc, des, asc, des, ...).\n * Accepts {@link RelationTableProps} props.\n * @category Components\n * @public\n */\nexport class ResultRelationTable extends React.Component<RelationTableProps, RelationTableState> {\n\n    constructor(props: RelationTableProps) {\n        super(props);\n        this.state = {\n            orderBy: -1,\n            orderDir: 1\n        }\n    }\n\n    componentDidUpdate(prevProps: Readonly<RelationTableProps>, prevState: Readonly<RelationTableState>, snapshot?: any) {\n        if (prevProps.relation !== this.props.relation) {\n            this.setState({\n                orderDir: 1,\n                orderBy: -1\n            });\n        }\n    }\n\n    /**\n     * Updates ordering column or direction. If the given orderBy index is already selected, switches ASC/DESC order.\n     * Otherwise, sets ASC ordering by new orderBy column index.\n     */\n    private updateOrderBy(orderBy: number): void {\n        this.setState(state => {\n            if (state.orderBy === orderBy) {\n                return {\n                    orderDir: -state.orderDir,\n                    orderBy: orderBy\n                };\n            }\n            else {\n                return {\n                    orderDir: 1,\n                    orderBy: orderBy\n                };\n            }\n        });\n    }\n\n    private getOrderByText = (): string => {\n        return this.state.orderDir === 1 ? \" ▼\" : \" ▲\";\n    }\n\n    /**\n     * Creates a header row for a table (with given column names).\n     *\n     * @param columns\n     */\n    private createHeaderRow(columns: string[]) {\n        return (\n            <tr>\n                <td className=\"row-number-td\"/>\n                {columns.map((columnName, index) => {\n                    const text: string = this.state.orderBy === index ?\n                        (columnName + this.getOrderByText()) : columnName;\n                    return <th key={index} onClick={() => this.updateOrderBy(index)}>{text}</th>\n                })}\n            </tr>\n        );\n    }\n\n    /**\n     * Creates rows for a table. If there is no row in a resultRelation, returns one cell \"<<NO ROWS>>\".\n     *\n     * @param columns\n     */\n    private createRows(columns: string[]) {\n        // creates default row if no exists\n        if (this.props.relation.getRowsCount() === 0) {\n            return (\n                <tr key='1'>\n                    <td className=\"row-number-td\"/>\n                    <td key='1' colSpan={columns.length}>{'<<NO ROWS>>'}</td>\n                </tr>\n            );\n        }\n        const rows: Row[] = this.props.relation.getRows();\n        // sorts rows if orderBy is given (null values are after other values)\n        if (this.state.orderBy > -1 && this.state.orderBy < columns.length) {\n            const sortCol: string = columns[this.state.orderBy];\n            // @ts-ignore cannot be undefined\n            const type: \"string\" | \"number\" | \"boolean\" = rows[0].getType(sortCol);\n            if (type === \"number\") {\n                rows.sort((a, b) => {\n                    // @ts-ignore\n                    let aValue: number | null = a.getValue(sortCol);\n                    // @ts-ignore\n                    let bValue: number | null = b.getValue(sortCol);\n                    // a is null\n                    if (aValue === null && bValue !== null) {\n                        return this.state.orderDir * Number.MAX_SAFE_INTEGER;\n                    }\n                    // b is null\n                    if (aValue !== null && bValue === null) {\n                        return this.state.orderDir * Number.MIN_SAFE_INTEGER;\n                    }\n                    // no is null - compares as numbers\n                    if (aValue !== null && bValue !== null) {\n                        // @ts-ignore\n                        return this.state.orderDir * (a.getValue(sortCol) - b.getValue(sortCol));\n                    }\n                    // both are null\n                    return 0;\n                });\n            }\n            else {\n                rows.sort((a, b) => {\n                    // @ts-ignore\n                    let aValue: string | boolean | null = a.getValue(sortCol);\n                    // @ts-ignore\n                    let bValue: string | boolean | null = b.getValue(sortCol);\n                    // a is null\n                    if (aValue === null && bValue !== null) {\n                        return this.state.orderDir * Number.MAX_SAFE_INTEGER;\n                    }\n                    // b is null\n                    if (aValue !== null && bValue === null) {\n                        return this.state.orderDir * Number.MIN_SAFE_INTEGER;\n                    }\n                    // no is null - compares as strings\n                    if (aValue !== null && bValue !== null) {\n                        return this.state.orderDir * String(a.getValue(sortCol)).localeCompare(String(b.getValue(sortCol)));\n                    }\n                    // both are null\n                    return 0;\n                });\n            }\n        }\n        // creates all rows if any\n        return rows.map((row, index) => (\n            <tr key={index}>\n                <td className=\"row-number-td\">{index + 1}</td>\n                {row.getOrderedPrintValues(columns).map((value, index) => (\n                    <td key={index}>{value}</td>\n                ))}\n            </tr>\n        ));\n    }\n\n    render(){\n        // creates header row\n        const columns: string[] = this.props.relation.getColumnNames();\n        const headerRow = this.createHeaderRow(columns);\n        const rows = this.createRows(columns);\n\n        return (\n            <div className=\"result-table-container scrollbar-container\">\n                <table className=\"result-table\">\n                    <thead>\n                    {headerRow}\n                    </thead>\n                    <tbody>\n                    {rows}\n                    </tbody>\n                </table>\n            </div>\n        );\n    }\n}","import React from \"react\";\nimport {Group} from '@visx/group';\nimport {hierarchy, Tree} from '@visx/hierarchy';\nimport {HierarchyPointLink, HierarchyPointNode} from '@visx/hierarchy/lib/types';\nimport {LinkVertical} from '@visx/shape';\nimport ParentSize from \"@visx/responsive/lib/components/ParentSize\";\nimport {useTooltip} from '@visx/tooltip';\nimport './css/evaluationTree.css';\nimport {RATreeNode} from \"../ratree/raTreeNode\";\nimport {UnaryNode} from \"../ratree/unaryNode\";\nimport {BinaryNode} from \"../ratree/binaryNode\";\nimport {getTreeDepth} from \"../ratree/raTreeTools\";\nimport {computeFontSizeInPx} from \"../utils/fontUtils\";\n\n/**\n * Id of the SVG element for evaluation tree rendering.\n * @type string\n * @category Components\n * @public\n */\nexport const evalTreeSVGId: string = \"eval-tree-svg\";\n\n/**\n * Props of EvaluationTree component.\n * @category Components\n * @public\n */\ninterface EvaluationTreeProps {\n    /**\n     * root of the evaluation tree to be displayed\n     * @type RATreeNode\n     * @public\n     */\n    tree: RATreeNode,\n    /**\n     * index of the current selected node (with respect to depth first search)\n     * @type number\n     * @public\n     */\n    selected: number,\n    /**\n     * handler of click on nodes, it receives the index of the clicked node (with respect to depth first search)\n     * @type function\n     * @public\n     */\n    onClick: (index: number) => void,\n    /**\n     * true if dark theme should be applied\n     * @type boolean\n     * @public\n     */\n    darkTheme: boolean\n}\n\n/**\n * Component displaying an evaluation tree. The tree is interactive and handles clicking on the nodes.\n * Accepts {@link EvaluationTreeProps} props.\n * @category Components\n * @public\n */\nexport class EvaluationTree extends React.Component<EvaluationTreeProps, {}> {\n    render() {\n        return (\n            <ParentSize>{({ width }) =>\n                <TreeComponent\n                    raTree={this.props.tree}\n                    selected={this.props.selected}\n                    width={width}\n                    onClick={this.props.onClick}\n                    darkTheme={this.props.darkTheme}\n                />}\n            </ParentSize>\n        );\n    }\n}\n\n// @ts-ignore\nconst cssConstants: CSSStyleDeclaration = getComputedStyle(document.querySelector(':root'));\n\nconst fontSize: string = cssConstants.getPropertyValue('--eval-tree-font-size');\nconst fontFamily: string = cssConstants.getPropertyValue('--eval-tree-font-family');\nconst {fontWidth, fontHeight} = computeFontSizeInPx(fontFamily, fontSize);\nconst nodePaddingX2: number = 24;\nconst nodeHeight = 2 * fontHeight + nodePaddingX2;\nconst maxNodeTextLength = 30;\n\nconst backgroundColorLight = cssConstants.getPropertyValue('--light-color-a');\nconst backgroundColorDark = cssConstants.getPropertyValue('--dark-color-a');\nconst textColorLight = cssConstants.getPropertyValue('--text-color-light');\nconst textColorDark = cssConstants.getPropertyValue('--text-color-dark');\nconst selectedNodeColorLight = cssConstants.getPropertyValue('--light-color-c');\nconst unselectedNodeColorLight = cssConstants.getPropertyValue('--light-color-b');\nconst selectedNodeColorDark = cssConstants.getPropertyValue('--dark-color-d');\nconst unselectedNodeColorDark = cssConstants.getPropertyValue('--dark-color-c');\n\n/**\n * Data for evaluation tree nodes.\n */\ninterface DisplayTreeNode {\n    title: string;\n    symbol: string,\n    index: number;\n    children?: this[];\n}\n\n/**\n * Creates a DisplayTreeNode tree from the given RATreeNode tree.\n *\n * @param tree RATreeNode tree to parse to DisplayTreeNode tree\n * @return parsed DisplayTreeNode tree\n */\nfunction parseTreeForDisplay(tree: RATreeNode): DisplayTreeNode {\n    let indexes = 0;\n    function parseTreeForDisplayHelper(node: RATreeNode): DisplayTreeNode {\n        let symbol: string = node.getOperationSymbol();\n        if (symbol.length > maxNodeTextLength) {\n            symbol = symbol.slice(0, maxNodeTextLength - 4) + \"...\" + symbol.charAt(symbol.length - 1);\n        }\n\n        if (node instanceof UnaryNode) {\n            return {\n                title: node.getOperationName(),\n                symbol: symbol,\n                index: indexes++,\n                children: [\n                    parseTreeForDisplayHelper(node.getSubtree())\n                ]\n            }\n        }\n        else if (node instanceof BinaryNode) {\n            return {\n                title: node.getOperationName(),\n                symbol: symbol,\n                index: indexes++,\n                children: [\n                    parseTreeForDisplayHelper(node.getLeftSubtree()),\n                    parseTreeForDisplayHelper(node.getRightSubtree())\n                ]\n            }\n        }\n        else /* (tree instanceof RelationNode) */ {\n            return {\n                title: node.getOperationName(),\n                symbol: symbol,\n                index: indexes++\n            };\n        }\n    }\n    return parseTreeForDisplayHelper(tree);\n}\n\n/**\n * Component representing individual nodes of the displayed tree.\n *\n * Props:\n * - node: HierarchyPointNode<DisplayTreeNode>: node to be displayed wrapped as visx HierarchyPointNode.\n * - selected: boolean: boolean whether the given node is currently selected by the user\n * - onClick: (index: number) => void: handler of click on the node, it receives the index of the node (with\n * respect to depth first search)\n */\nfunction TreeNodeComponent({ node, selected, onClick, darkTheme }:\n            { node: HierarchyPointNode<DisplayTreeNode>, selected: boolean, onClick: (index: number) => void, darkTheme: boolean }): JSX.Element {\n    const {\n        tooltipOpen, // true when mouse is over\n        showTooltip,\n        hideTooltip\n    } = useTooltip();\n\n    const handleMouseOver = () => {\n        showTooltip({ tooltipLeft: 0, tooltipTop: 0 });\n    };\n\n    // computes node width with respect to the text length and asserts it wider than taller\n    let nodeWidth = Math.max(node.data.title.length, node.data.symbol.length) * fontWidth + nodePaddingX2;\n    if (nodeWidth < nodeHeight) {\n        nodeWidth = nodeHeight;\n    }\n\n    return (\n        // top=y, left=x for vertical layout; top=x, left=y for horizontal layout\n        <Group top={node.y} left={node.x}>\n            <rect\n                height={nodeHeight} width={nodeWidth}\n                y={-nodeHeight / 2} x={-nodeWidth / 2} rx={5}\n                fill={darkTheme ?\n                    (selected ? selectedNodeColorDark : (tooltipOpen ? selectedNodeColorDark : unselectedNodeColorDark)) :\n                    (selected ? selectedNodeColorLight : (tooltipOpen ? selectedNodeColorLight : unselectedNodeColorLight))}\n                onClick={() => {\n                    onClick(node.data.index);\n                }}\n                cursor=\"pointer\"\n                onMouseOver={handleMouseOver}\n                onMouseOut={hideTooltip}\n            />\n            <text\n                y=\"-4px\"\n                dy=\".2em\"\n                fontSize={fontSize}\n                fontFamily={fontFamily}\n                textAnchor=\"middle\"\n                style={{ pointerEvents: \"none\"}}\n                fill={darkTheme ? textColorDark : textColorLight}\n            >\n                {node.data.symbol === \"\" ?\n                    <tspan x=\"0\" dy=\".5em\">{node.data.title}</tspan> :\n                    (<>\n                        <tspan x=\"0\" dy=\"0\">{node.data.title}</tspan>\n                        <tspan x=\"0\" dy=\"1.2em\">{node.data.symbol}</tspan>\n                    </>)}\n            </text>\n        </Group>\n    );\n}\n\n/**\n * Internal component for displaying the evaluation tree. It uses visx Tree component.\n *\n * Props:\n * - tree: RATreeNode: root of the evaluation tree to be displayed\n * - selected: number: index of the current selected node (with respect to depth first search)\n * - width: number: width of the parent container\n * - onClick: (index: number) => void: handler of click on nodes, it receives the index of the clicked node (with\n * respect to depth first search)\n */\nfunction TreeComponent({raTree, selected, width, onClick, darkTheme}:\n            {raTree: RATreeNode, selected: number, width: number, onClick: (index: number) => void, darkTheme: boolean}): JSX.Element | null {\n    const treeDepth: number = getTreeDepth(raTree);\n    // height = \"nodes height\" + \"gaps between nodes\" + \"margin up and under\"\n    const height = (treeDepth + 1) * nodeHeight + treeDepth * nodeHeight / 2 + nodeHeight;\n    const margin = { top: nodeHeight, left: 0 / 2, right: 0 / 2, bottom: nodeHeight };\n    const yMax = height - margin.top - margin.bottom;\n    const xMax = width - margin.left - margin.right;\n\n    const tree: DisplayTreeNode = parseTreeForDisplay(raTree);\n    const data = hierarchy<DisplayTreeNode>(tree);\n\n    return width < 10 ? null : (\n        <svg id=\"eval-tree-svg\" width={width} height={height}>\n            <rect width={width} height={height} rx={14} fill={darkTheme ? backgroundColorDark : backgroundColorLight} />\n            <Tree<DisplayTreeNode> root={data} size={[xMax, yMax]}>\n                {tree => (\n                    <Group top={margin.top} left={margin.left}>\n                        {tree.links().map((link, i) => (\n                            <LinkVertical<HierarchyPointLink<DisplayTreeNode>, HierarchyPointNode<DisplayTreeNode>>\n                                key={`cluster-link-${i}`}\n                                data={link}\n                                stroke={darkTheme ? textColorDark : textColorLight}\n                                strokeWidth=\"1\"\n                                strokeOpacity={1}\n                                fill=\"none\"\n                            />\n                        ))}\n                        {tree.descendants().map((node) => (\n                            <TreeNodeComponent\n                                key={`node-${node.data.index}`}\n                                node={node}\n                                selected={node.data.index === selected}\n                                onClick={onClick}\n                                darkTheme={darkTheme}\n                            />\n                        ))}\n                    </Group>\n                )}\n            </Tree>\n        </svg>\n    );\n}","/**\n * Textual file information.\n * @category Utils\n * @public\n */\nexport interface File {\n    /**\n     * name of the file\n     * @type string\n     * @public\n     */\n    name: string,\n    /**\n     * textual content of the file\n     * @type string?\n     * @public\n     */\n    text: string | null\n}\n\n/**\n * FileDialog for loading files to the application.\n * @category Utils\n * @public\n */\nexport class FileDialog {\n\n    /**\n     * Loads asynchronously a Blob content of one ZIP file selected by the user in the file browser.\n     *\n     * @return a Zip file as a Blob in a promise {@type Promise<Blob>}\n     * @public\n     */\n    public static openZip(): Promise<Blob> {\n        return new Promise<Blob>(resolve => {\n            let element = document.createElement('div');\n            element.innerHTML = `<input type=\"file\" accept=\".zip\">`;\n            let fileInput = element.firstChild;\n            // @ts-ignore\n            fileInput.addEventListener('change', function() {\n                // @ts-ignore\n                resolve(fileInput.files[0]);\n            });\n            // @ts-ignore\n            fileInput.click();\n        });\n    }\n\n    /**\n     * Loads asynchronously a textual content from one file selected by the user in the file browser.\n     *\n     * @param accept comma-separated list of extensions for filter (default are all extensions) {@type string}\n     * @return a file in a promise {@type Promise<File>}\n     * @public\n     */\n    public static openFile(accept: string = \"*\"): Promise<File> {\n        return new Promise<File>(resolve => {\n            let element = document.createElement('div');\n            element.innerHTML = `<input type=\"file\" accept=${accept}>`;\n            let fileInput = element.firstChild;\n            // @ts-ignore\n            fileInput.addEventListener('change', function() {\n                // @ts-ignore\n                let file = fileInput.files[0];\n                let reader = new FileReader();\n                reader.onload = function() {\n                    // @ts-ignore\n                    resolve({name: file.name, text: reader.result});\n                };\n                reader.readAsText(file);\n            });\n            // @ts-ignore\n            fileInput.click();\n        });\n    }\n\n    /**\n     * Asynchronously loads textual content from multiple files selected by the user in the file browser.\n     *\n     * @param accept comma-separated list of extensions for filter (default are all extensions) {@type string}\n     * @return array of files in a promise {@type Promise<File[]>}\n     * @public\n     */\n    public static openFiles(accept: string = \"*\"): Promise<File[]> {\n        return new Promise<File[]>(resolve => {\n            FileDialog.openFilesHelper(resolve, accept);\n        });\n    }\n\n    /**\n     * Loads textual content from multiple files selected by the user in the file browser.\n     * Multiple file input handling inspired by xaedes on https://stackoverflow.com/a/13975217.\n     *\n     * @param resolve - resolving function accepting an array of file information\n     * @param accept comma-separated list of extensions for filter\n     */\n    private static openFilesHelper(resolve: (files: File[]) => void, accept: string): void {\n        let element = document.createElement('div');\n        element.innerHTML = `<input type=\"file\" accept=${accept} multiple>`;\n        // @ts-ignore\n        let fileInput: HTMLInputElement = element.firstChild;\n        const fileInfo: {name: string, text: string | null}[] = [];\n        fileInput.addEventListener('change', function() {\n            // @ts-ignore\n            const files: FileList = fileInput.files;\n            function readFile(index: number) {\n                if (index === files.length) {\n                    return resolve(fileInfo);\n                }\n                const file = files[index];\n                const reader = new FileReader();\n                reader.onload = function(e) {\n                    // @ts-ignore\n                    fileInfo.push({name: file.name, text: e.target.result});\n                    readFile(index+1);\n                    console.log('File ' + (index+1) + '/' + files.length + ' loaded');\n                }\n                reader.readAsText(file);\n            }\n            readFile(0);\n        });\n        fileInput.click();\n    }\n}\n","/**\n * Two possible CSV value separators: comma (,) and semicolon (;).\n * @typedef {(\",\" | \";\")} CsvValueSeparator\n */\nexport type CsvValueSeparator = \",\" | \";\";\n\n/**\n * Returns the first found value separator character: (,) or (;). If no separator is found, returns undefined.\n *\n * @param str string to search in {@type string}\n * @return found separator or undefined {@type CsvValueSeparator?}\n * @category Types\n * @public\n */\nexport function findValueSeparator(str: string): CsvValueSeparator | undefined {\n    let inQuotes: boolean = false;\n    for (let i = 0; i < str.length; ++i) {\n        const char: string = str.charAt(i);\n        // quotes found\n        if (char === '\"') {\n            if (!inQuotes) {\n                inQuotes = true;\n            }\n            else {\n                const c2 = str.charAt(i + 1);\n                if (c2 === \",\" || c2 === \";\") {\n                    return c2;\n                }\n                // double-quotes mean one quote in cell\n                else if (c2 === '\"') {\n                    // skips second quote\n                    ++i;\n                }\n                // error\n                else {\n                    return undefined;\n                }\n            }\n        }\n        if (!inQuotes && (char === \",\" || char === \";\")) {\n            return char;\n        }\n    }\n    return undefined;\n}\n\n/**\n * Splits the given line using the given CSV separator. It follows CSV rules:\n * - a cell with a separator (as value) needs to be enclosed in quotes.\n * - a cell with a quote (as value) needs to be enclosed in additional quotes. The value quote needs to be typed twice.\n *\n * @param line line of CSV file to be split {@type string}\n * @param separator CSV separator to use {@type CsvValueSeparator}\n * @return split line to individual cells {@type string[]}\n * @category Types\n * @public\n */\nexport function splitCSVLine(line: string, separator: CsvValueSeparator): string[] {\n    // adds separator to simply handle the last cell\n    line += separator;\n    const ret: string[] = [];\n    let inQuotes: boolean = false;\n    let partStart: number = 0;\n    let i: number = 0;\n    while (i < line.length) {\n        const c = line.charAt(i);\n        // quotes found\n        if (c === '\"') {\n            // first quotes (after separator)\n            if (!inQuotes) {\n                inQuotes = true;\n                partStart = i;\n            }\n            else {\n                const c2 = line.charAt(i + 1);\n                if (c2 === separator) {\n                    ret.push(line.slice(partStart + 1, i).replace(/\"\"/g, '\"'));\n                    inQuotes = false;\n                    partStart = i + 2;\n                }\n                // double-quotes mean one quote in cell, else error\n                else if (c2 !== '\"') {\n                    throw new Error();\n                }\n                i += 2;\n                continue;\n            }\n        }\n        else if (c === separator && !inQuotes) {\n            ret.push(line.slice(partStart, i).replace(/\"\"/g, '\"'));\n            partStart = i + 1;\n        }\n        ++i;\n    }\n    return ret;\n}","/**\n * Wrapper of JavaScript Map object to provide usage of object (row: number | \"name\", column: number) as a key for\n * string values.\n * @category Types\n * @public\n */\nexport class NNToSMap {\n    private map: Map<string, string> = new Map<string, string>();\n\n    /**\n     * Gets the value for the given key (row, column).\n     *\n     * @param row row part of the key {@type (number | \"name\")}\n     * @param column row column of the key {@type number}\n     * @return value of the given key or undefined {@type string?}\n     * @public\n     */\n    public get(row: number | \"name\", column: number): string | undefined {\n        return this.map.get(row + \":\" + column);\n    }\n\n    /**\n     * Sets the value of the given key (row, column).\n     *\n     * @param row row part of the key {@type (number | \"name\")}\n     * @param column row column of the key {@type number}\n     * @param value value to set {@type string}\n     * @public\n     */\n    public set(row: number | \"name\", column: number, value: string): void {\n        this.map.set(row + \":\" + column, value);\n    }\n\n    /**\n     * Deletes the value for the given key (row, column).\n     *\n     * @param row row part of the key {@type (number | \"name\")}\n     * @param column row column of the key {@type number}\n     * @return true if an element in the Map object existed and has been removed, or false if the element does not exist {@type boolean}\n     * @public\n     */\n    public delete(row: number | \"name\", column: number): boolean {\n        return this.map.delete(row + \":\" + column);\n    }\n\n    /**\n     * Removes all values from the map.\n     * @public\n     */\n    public clear(): void {\n        this.map.clear();\n    }\n\n    /**\n     * Returns the size og the map.\n     *\n     * @return size of the map {@type number}\n     * @public\n     */\n    public size(): number {\n        return this.map.size;\n    }\n\n    /**\n     * Performs the given function for each (value, row, column, index) in the map.\n     *\n     * @param f function to perform {@type function}\n     * @public\n     */\n    public forEach(f: (value: string, row: number | \"name\", column: number, index?: number) => void): void {\n        [...this.map.entries()]\n            .map((entry) => {return {value: entry[1], key: NNToSMap.parseKey(entry[0])}})\n            .forEach((entry, index) => f(entry.value, entry.key.row, entry.key.column, index));\n    }\n\n    private static parseKey(key: string): {row: number | \"name\", column: number} {\n        const split = key.split(':');\n        return {row: Number(split[0]), column: Number(split[1])};\n    }\n}","import {isSupportedColumnType, SupportedColumnType} from \"./columnType\";\nimport {StringUtils} from \"../utils/stringUtils\";\nimport {NNToSMap} from \"../types/nnToSMap\";\nimport {Relation} from \"./relation\";\nimport {Row} from \"./row\";\nimport {isForbiddenColumnName} from \"../utils/keywords\";\nimport {language} from \"../language/language\";\n\n/**\n * Plain object representation of the stored relation.\n *\n * @category Relation\n * @public\n */\nexport interface StoredRelationData {\n    name: string;\n    columnNames: string[];\n    columnTypes: SupportedColumnType[];\n    rows: string[][];\n    columnCount: number;\n    rowCount: number;\n}\n\n/**\n * Creates a copy of the given stored relation data.\n *\n * @param data stored relation data to copy {@type StoredRelationData}\n * @return deep copied stored relation data {@type StoredRelationData}\n * @category Relation\n * @public\n */\nexport function copyStoredRelationData(data: StoredRelationData): StoredRelationData {\n    return {\n        name: data.name,\n        columnNames: [...data.columnNames],\n        columnTypes: [...data.columnTypes],\n        rows: data.rows.map(row => [...row]),\n        columnCount: data.columnCount,\n        rowCount: data.rowCount\n    }\n}\n\n/**\n * String-arrays representation of the relation for its storing. The relation may happen to be in inconsistent state.\n * For formal representation (sets of concrete types) use {@link Relation}.\n * @category Relation\n * @public\n */\nexport class StoredRelation {\n\n    /**\n     * Creates a new stored relation with given name, one column and no rows.\n     *\n     * @param name name of the relation {@type string}\n     * @param nullValuesSupport whether null values are supported {@type boolean}\n     * @return stored relation {@type StoredRelation}\n     * @public\n     */\n    public static new(name: string, nullValuesSupport: boolean): StoredRelation {\n        return new StoredRelation(name, [\"Column1\"], [\"number\"], [], nullValuesSupport);\n    }\n\n    /**\n     * Creates a new stored relation from given plain relation object. If the object is not a valid StoredRelationData,\n     * throws error.\n     *\n     * @param data input object {@type any}\n     * @param nullValuesSupport whether null values are supported {@type boolean}\n     * @return stored relation {@type StoredRelation}\n     * @public\n     */\n    public static fromData(data: any, nullValuesSupport: boolean): StoredRelation {\n        if (isStoredRelationData(data)) {\n            const d: StoredRelationData = data as StoredRelationData;\n            return new StoredRelation(d.name, d.columnNames, d.columnTypes, d.rows, nullValuesSupport);\n        }\n        throw new Error(\"Given object is not a valid relation.\");\n    }\n\n    /**\n     * Creates a new stored relation from given full relation representation.\n     *\n     * @param name name to overwrite original relation name {@type string}\n     * @param relation formal relation representation {@type Relation}\n     * @param nullValuesSupport whether null values are supported {@type boolean}\n     * @return stored relation {@type StoredRelation}\n     * @public\n     */\n    public static fromRelation(name: string, relation: Relation, nullValuesSupport: boolean): StoredRelation {\n        const columnNames: string[] = [];\n        const columnTypes: SupportedColumnType[] = [];\n        relation.getColumns().forEach((type, name) => {\n            columnNames.push(name);\n            columnTypes.push(type);\n        });\n        const rows: string[][] = relation.getRows().map(row => {\n            return row.getOrderedPrintValues(columnNames);\n        });\n        return new StoredRelation(name, columnNames, columnTypes, rows, nullValuesSupport);\n    }\n\n    /**\n     * Creates a new relation with the same name, columns, rows a null values support.\n     *\n     * @param relation relation to copy {@type StoredRelation}\n     * @return deep copied relation {@type StoredRelation}\n     * @public\n     */\n    public static copy(relation: StoredRelation): StoredRelation {\n        const name = relation.name;\n        const columnNames = [...relation.columnNames];\n        const columnTypes = [...relation.columnTypes];\n        const rows = relation.rows.map(row => [...row]);\n        const nullValuesSupport = relation.nullValuesSupport;\n        return new StoredRelation(name, columnNames, columnTypes, rows, nullValuesSupport);\n    }\n\n    /**\n     * Returns formatted string representation of StoredRelation or StoredRelationData.\n     *\n     * @param rel relation to stringify {@type StoredRelation}\n     * @return formatted string representation {@type string}\n     * @public\n     */\n    public static format(rel: StoredRelation | StoredRelationData): string {\n        // finds longest inputs in each column\n        const longest = rel.columnNames.map(n => n.length);\n        rel.columnTypes.forEach((t, i) => {\n            if (longest[i] < t.length) {\n                longest[i] = t.length;\n            }\n        });\n        rel.rows.forEach(r => {\n            r.forEach((d, i) => {\n                if (longest[i] < d.length) {\n                    longest[i] = d.length;\n                }\n            });\n        });\n        // function for end-padding strings with spaces\n        const pad = (ss: string[]) => ss.map((s, i) => s.padEnd(longest[i], \" \")).join(' | ');\n        return pad(rel.columnNames) + '\\n' +\n            pad(rel.columnTypes) + '\\n' +\n            longest.map(n => \"-\".repeat(n)).join(\"-+-\") + '\\n' +\n            rel.rows.map(r => pad(r)).join('\\n') + '\\n\\n';\n    }\n\n    private name: string;\n    columnNames: string[];\n    columnTypes: SupportedColumnType[];\n    rows: string[][];\n    private columnCount: number;\n    private rowCount: number;\n    private readonly errors: NNToSMap;\n    private nullValuesSupport: boolean;\n    private actual: boolean;\n    private revertState: StoredRelationData;\n\n    /**\n     * Creates new relation with given name, one default column and no rows.\n     *\n     * @param name relation name {@type string}\n     * @param columnNames column names {@type string[]}\n     * @param columnTypes column types {@type SupportedColumnType[]}\n     * @param rows data tuples as 2D string array [row, column] {@type string[][]}\n     * @param nullValuesSupport whether null values are supported {@type boolean}\n     * @public\n     */\n    constructor(name: string, columnNames: string[], columnTypes: SupportedColumnType[],\n                        rows: string[][], nullValuesSupport: boolean) {\n        this.name = name;\n        this.columnNames = columnNames;\n        this.columnTypes = columnTypes;\n        this.rows = rows;\n        this.columnCount = columnNames.length;\n        this.rowCount = rows.length;\n        this.errors = new NNToSMap();\n        this.nullValuesSupport = nullValuesSupport;\n        this.actual = false;\n        this.revertState = this.toDataObject();\n        this.recomputeErrors();\n    }\n\n    /**\n     * Checks all possible errors in the relation.\n     * @public\n     */\n    public recomputeErrors(): void {\n        this.errors.clear();\n        this.checkColumnNames();\n        for (let c = 0; c < this.columnCount; ++c) {\n            [...new Array(this.rowCount).keys()].forEach(r => this.checkRowInput(c, r));\n        }\n    }\n\n    /**\n     * Checks whether the column name on given index is valid and not duplicit and updates error map.\n     */\n    private checkColumnNames(): void {\n        const lang = language().relationErrors;\n        for (let columnIndex = 0; columnIndex < this.columnCount; ++columnIndex) {\n            const columnName: string = this.columnNames[columnIndex].trim();\n            if (columnName === \"\") {\n                this.errors.set(\"name\", columnIndex, lang.emptyColumn);\n                continue;\n            }\n            const nameCount: number = this.columnNames.reduce((agg, name) => {\n                return (name === columnName) ? (agg + 1) : agg;\n            }, 0);\n            if (nameCount > 1) {\n                this.errors.set(\"name\", columnIndex, lang.duplicitColumn);\n                continue;\n            }\n            if (isForbiddenColumnName(columnName)) {\n                this.errors.set(\"name\", columnIndex, lang.keywordColumn);\n                continue;\n            }\n            if (!StringUtils.isName(columnName)) {\n                this.errors.set(\"name\", columnIndex, lang.invalidColumn);\n                continue;\n            }\n            this.errors.delete(\"name\", columnIndex);\n        }\n    }\n\n    /**\n     * Checks whether the row input on given index is valid and updates error map.\n     */\n    private checkRowInput(columnIndex: number, rowIndex: number): void {\n        const lang = language().relationErrors;\n        this.errors.delete(rowIndex, columnIndex);\n        const input: string = this.rows[rowIndex][columnIndex].trim();\n        // empty input = null in non-string columns\n        if (input === \"null\" || (input === \"\" && this.columnTypes[columnIndex] !== \"string\")) {\n            if (!this.nullValuesSupport) {\n                this.errors.set(rowIndex, columnIndex, lang.unsupportedNull);\n            }\n        }\n        else if (this.columnTypes[columnIndex] === \"number\") {\n            if (!StringUtils.isNumber(input.replace(/\\s/g, \"\"))) {\n                this.errors.set(rowIndex, columnIndex, lang.invalidNumber);\n            }\n        }\n        else if (this.columnTypes[columnIndex] === \"boolean\") {\n            const lower = input.toLowerCase();\n            if (lower !== \"true\" && lower !== \"t\" && lower !== \"false\" && lower !== \"f\") {\n                this.errors.set(rowIndex, columnIndex, lang.invalidBoolean);\n            }\n        }\n        /* STRING COLUMNS CANNOT BE INVALID */\n    }\n\n    /**\n     * Checks whether all row inputs on given column index are valid and updates error map.\n     */\n    private checkColumnTypes(columnIndex: number): void {\n        this.rows.forEach((_, i) => this.checkRowInput(columnIndex, i));\n    }\n\n    /**\n     * Creates a relation with full schema.\n     * WARNING: It expects that there are no errors in the stored relation before call.\n     *\n     * @return formal relation representation {@type Relation}\n     * @public\n     */\n    public createRelation(): Relation {\n        const relation: Relation = new Relation(this.name);\n        for (let c = 0; c < this.columnCount; ++c) {\n            relation.addColumn(this.columnNames[c], this.columnTypes[c]);\n        }\n        this.rows.forEach(rowInput => {\n            const row: Row = new Row(relation.getColumns());\n            rowInput.forEach((input, c) => {\n                input = input.trim();\n                if (input === \"null\") {\n                    row.addValue(this.columnNames[c], null);\n                }\n                else if (this.columnTypes[c] === \"string\") {\n                    // changes input representation to expected in inner relations\n                    // replaces all used '\\' by two '\\\\' and all used '\"' by '\\\"'\n                    input = input.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"');\n                    row.addValue(this.columnNames[c], input);\n                }\n                else if (input === \"\") {\n                    row.addValue(this.columnNames[c], null);\n                }\n                else if (this.columnTypes[c] === \"number\") {\n                    row.addValue(this.columnNames[c], Number(input.replace(/\\s/g, \"\")));\n                }\n                else /* this.columnTypes[c] === \"boolean\" */ {\n                    const lower = input.toLowerCase();\n                    row.addValue(this.columnNames[c], lower === \"t\" || lower === \"true\");\n                }\n            });\n            relation.addRow(row);\n        });\n        relation.finishSchema();\n        return relation;\n    }\n\n    /**\n     * Creates plain object representation of the stored relation.\n     *\n     * @return compressed representation {@type StoredRelationData}\n     * @public\n     */\n    public toDataObject(): StoredRelationData {\n        return {\n            name: this.name,\n            columnNames: [...this.columnNames],\n            columnTypes: [...this.columnTypes],\n            rows: this.rows.map(row => [...row]),\n            columnCount: this.columnCount,\n            rowCount: this.rowCount\n        }\n    }\n\n    /**\n     * Returns map \"row/column => error\". Numeric row keys are for relation rows, row key \"name\" is for column name row.\n     *\n     * @return map of errors in the relation {@type NNToSMap}\n     * @public\n     */\n    public getErrors(): NNToSMap {\n        return this.errors;\n    }\n\n    /**\n     * Returns true if there are no errors in the relation.\n     *\n     * @return true if there are no errors in the relation {@type boolean}\n     * @public\n     */\n    public isValid(): boolean {\n        return this.errors.size() === 0;\n    }\n\n    /**\n     * Sets null values support to check null errors in the relation.\n     *\n     * @param nullValuesSupport whether null values are supported {@type boolean}\n     * @public\n     */\n    public setNullValuesSupport(nullValuesSupport: boolean): void {\n        if (nullValuesSupport !== this.nullValuesSupport) {\n            this.nullValuesSupport = nullValuesSupport;\n            this.recomputeErrors();\n        }\n    }\n\n    /**\n     * Adds a new column with default name \"Column n\", default type \"number\", and empty inputs \"\" in all rows.\n     * @public\n     */\n    public addNewColumn(): void {\n        let i = (this.columnNames.length + 1);\n        let name = \"Column\" + i;\n        while (this.columnNames.indexOf(name) > -1) {\n            name = \"Column\" + ++i;\n        }\n        this.columnNames.push(name);\n        this.columnTypes.push(\"number\");\n        if (this.nullValuesSupport) {\n            this.rows.forEach(r => r.push(\"\"));\n        }\n        else {\n            this.rows.forEach(r => r.push(\"0\"));\n        }\n        ++this.columnCount;\n        this.checkColumnNames();\n        this.actual = false;\n    }\n\n    /**\n     * Adds a new row with empty inputs \"\" in all columns.\n     * @public\n     */\n    public addNewRow(): void {\n        if (this.nullValuesSupport) {\n            this.rows.push([...new Array(this.columnCount).keys()].map(_ => \"\"));\n        }\n        else {\n            this.rows.push([...new Array(this.columnCount).keys()].map(i => {\n                if (this.columnTypes[i] === \"number\") {\n                    return \"0\";\n                }\n                else if (this.columnTypes[i] === \"boolean\") {\n                    return \"false\";\n                }\n                return \"\";\n            }));\n        }\n        ++this.rowCount;\n        this.actual = false;\n    }\n\n    /**\n     * Deletes a column with the given index. If the last column was deleted, removes all rows and creates\n     * new default column.\n     *\n     * @param columnIndex column to delete {@type number}\n     * @public\n     */\n    public deleteColumn(columnIndex: number): void {\n        this.columnNames.splice(columnIndex, 1);\n        this.columnTypes.splice(columnIndex, 1);\n        this.rows.forEach(row => row.splice(columnIndex, 1));\n        --this.columnCount;\n        // if last column was deleted, removes all rows and creates new default column\n        if (this.columnCount === 0) {\n            this.rows = [];\n            this.addNewColumn();\n        }\n        this.errors.forEach((value, row, column) => {\n            // removes errors for given row\n            if (column === columnIndex) {\n                this.errors.delete(row, column);\n            }\n            // updates row index for errors in rows under deleted one\n            else if (column > columnIndex) {\n                this.errors.delete(row, column);\n                this.errors.set(row, column, value);\n            }\n        });\n        this.actual = false;\n    }\n\n    /**\n     * Deletes a row with given index.\n     *\n     * @param rowIndex row to delete {@type number}\n     * @public\n     */\n    public deleteRow(rowIndex: number): void {\n        this.rows.splice(rowIndex, 1);\n        --this.rowCount;\n        this.errors.forEach((value, row, column) => {\n            // removes errors for given row\n            if (row === rowIndex) {\n                this.errors.delete(row, column);\n            }\n            // updates row index for errors in rows under deleted one\n            else if (typeof row === \"number\" && row > rowIndex) {\n                this.errors.delete(row, column);\n                this.errors.set(row - 1, column, value);\n            }\n        });\n        this.actual = false;\n    }\n\n    /**\n     * Returns row count.\n     *\n     * @return row count {@type number}\n     * @public\n     */\n    public getRowCount(): number {\n        return this.rowCount;\n    }\n\n    /**\n     * Returns column count.\n     *\n     * @return column count {@type number}\n     * @public\n     */\n    public getColumnCount(): number {\n        return this.columnCount;\n    }\n\n    /**\n     * Sets relation name.\n     *\n     * @param name new relation name {@type string}\n     * @public\n     */\n    public setName(name: string): void {\n        this.name = name;\n        this.actual = false;\n    }\n\n    /**\n     * Gets relation name.\n     *\n     * @return relation name {@type string}\n     * @public\n     */\n    public getName(): string {\n        return this.name;\n    }\n\n    /**\n     * Gets column names.\n     *\n     * @return column names {@type string[]}\n     * @public\n     */\n    public getColumnNames(): string[] {\n        return this.columnNames;\n    }\n\n    /**\n     * Sets column name on the given index.\n     *\n     * @param columnName name to set {@type string}\n     * @param columnIndex column to update {@type number}\n     * @public\n     */\n    public setColumnName(columnName: string, columnIndex: number): void {\n        this.columnNames[columnIndex] = columnName;\n        this.checkColumnNames();\n        this.actual = false;\n    }\n\n    /**\n     * Gets column types.\n     *\n     * @return column types {@type SupportedColumnType[]}\n     * @public\n     */\n    public getColumnTypes(): SupportedColumnType[] {\n        return this.columnTypes;\n    }\n\n    /**\n     * Sets column type on the given index.\n     *\n     * @param columnType type to set {@type SupportedColumnType}\n     * @param columnIndex column to update {@type number}\n     * @public\n     */\n    public setColumnType(columnType: SupportedColumnType, columnIndex: number): void {\n        this.columnTypes[columnIndex] = columnType;\n        this.checkColumnTypes(columnIndex);\n        this.actual = false;\n    }\n\n    /**\n     * Gets all rows.\n     *\n     * @return data tuples as 2D string array [row, column] {@type string[][]}\n     * @public\n     */\n    public getRows(): string[][] {\n        return this.rows;\n    }\n\n    /**\n     * Sets value in the row in the given row and column.\n     *\n     * @param input value to set {@type string}\n     * @param rowIndex row to insert {@type number}\n     * @param columnIndex column to insert {@type number}\n     * @public\n     */\n    public setRowInput(input: string, rowIndex: number, columnIndex: number): void {\n        this.rows[rowIndex][columnIndex] = input;\n        this.checkRowInput(columnIndex, rowIndex);\n        this.actual = false;\n    }\n\n    /**\n     * Returns true if no changes were made after last setActual(true) call.\n     * The StoredRelation is created with isActual() = false.\n     *\n     * @return actual value {@type boolean}\n     * @public\n     */\n    public isActual(): boolean {\n        return this.actual;\n    }\n\n    /**\n     * Sets current StoredRelation state as actual. Any change sets the state as not actual automatically.\n     * If it is set to actual, the current state is saved as the revert state.\n     *\n     * @param actual set relation actual value to the given value {@type boolean}\n     * @public\n     */\n    public setActual(actual: boolean): void {\n        this.actual = actual;\n        if (actual) {\n            this.revertState = this.toDataObject();\n        }\n    }\n\n    /**\n     * Returns name of the saved relation state to revert or empty string.\n     *\n     * @return name of the saver relation state to revert or empty string {@type string}\n     * @public\n     */\n    public getRevertName(): string {\n        if (this.revertState !== undefined) {\n            return this.revertState.name;\n        }\n        else {\n            return \"\";\n        }\n    }\n\n    /**\n     * Reverts the current relation to its last loaded state (if any exists, call canRevert() to check).\n     * The relation is set as not actual, null values support and saved revert state is not reverted.\n     * @public\n     */\n    public revert(): void {\n        if (this.revertState !== undefined) {\n            this.name = this.revertState.name;\n            this.columnNames = [...this.revertState.columnNames];\n            this.columnTypes = [...this.revertState.columnTypes];\n            this.rows = this.revertState.rows.map(row => [...row]);\n            this.columnCount = this.revertState.columnCount;\n            this.rowCount = this.revertState.rowCount;\n            this.actual = false;\n            this.recomputeErrors();\n        }\n    }\n}\n\n/**\n * Returns true if the given object is a {@link StoredRelationData}, has at least one column, and all rows has the same length.\n * @param obj checked object {@type any}\n * @return whether the given object is a valid StoredRelationData {@type boolean}\n * @category Relation\n * @public\n */\nexport function isStoredRelationData(obj: any): boolean {\n    if (typeof obj !== \"object\") {\n        return false;\n    }\n    if (!(\"name\" in obj) || typeof obj.name !== \"string\") {\n        return false;\n    }\n    if (!(\"columnCount\" in obj) || typeof obj.columnCount !== \"number\" || obj.columnCount < 1) {\n        return false;\n    }\n    if (!(\"rowCount\" in obj) || typeof obj.rowCount !== \"number\") {\n        return false;\n    }\n    if (!(\"columnNames\" in obj) || !Array.isArray(obj.columnNames) || obj.columnNames.length !== obj.columnCount ||\n        obj.columnNames.some((o: any) => typeof o !== \"string\")) {\n        return false;\n    }\n    if (!(\"columnTypes\" in obj) || !Array.isArray(obj.columnTypes) || obj.columnTypes.length !== obj.columnCount ||\n        obj.columnTypes.some((o: any) => !isSupportedColumnType(o))) {\n        return false;\n    }\n    return (\"rows\" in obj && Array.isArray(obj.rows) && obj.rows.every((o: any) => {\n        return Array.isArray(o) && o.length === obj.columnCount && o.every((d: any) => typeof d === \"string\");\n    }));\n}","/**\n * Specifies supported column types in the application. When changed, update the keywords.ts file.\n */\n\n/**\n * Supported string names of types of columns for a relational schema.\n * @typedef SupportedColumnType\n * @category Relation\n * @public\n */\nexport type SupportedColumnType = \"string\" | \"number\" | \"boolean\";\n\n/**\n * Possible types of the content of columns (null values included).\n * @typedef ColumnContent\n * @category Relation\n * @public\n */\nexport type ColumnContent = string | number | boolean | null;\n\n/**\n * Returns true if the given obj is string with value SupportedColumnType value.\n * @param obj checked object {@type any}\n * @return whether the given obj is string with value SupportedColumnType value {@type boolean}\n * @category Relation\n * @public\n */\nexport function isSupportedColumnType(obj: any): boolean {\n    if (typeof obj !== \"string\") {\n        return false;\n    }\n    return obj === \"string\" || obj === \"number\" || obj === \"boolean\";\n}","import {FileDialog} from \"../utils/fileDialog\";\nimport {CsvValueSeparator, findValueSeparator, splitCSVLine} from \"../types/csvSupport\";\nimport {StoredRelation} from \"./storedRelation\";\nimport {SupportedColumnType} from \"./columnType\";\nimport {saveAs} from \"file-saver\";\nimport JSZip from \"jszip\";\nimport {StringUtils} from \"../utils/stringUtils\";\n\n/**\n * Class for loading and saving relation definitions as {@link StoredRelation}.\n * @category Relation\n * @public\n */\nexport class RelationStoreManager {\n\n    /**\n     * Loads textual relation representations from multiple CSV files selected by the user. If the csv does not have\n     * valid stricture, it is skipped. Loaded CSVs are parsed to StoredRelations and returned in a promise.\n     *\n     * @param nullValuesSupport null values support to set in created StoredRelations {@type boolean}\n     * @return parsed StoredRelations and number of skipped files in a promise {@type Promise}\n     * @public\n     */\n    public static load(nullValuesSupport: boolean): Promise<{relations: StoredRelation[], skipped: number}> {\n        return new Promise<{relations: StoredRelation[], skipped: number}>(resolve => {\n            FileDialog.openFiles(\".csv\").then(files => {\n                let relations: StoredRelation[] = [];\n                let skipped: number = 0;\n                files.forEach(file => {\n                    if (file.name.match(/\\.csv$/)) {\n                        try {\n                            relations.push(this.csvToRelation(RelationStoreManager.createValidName(file.name.slice(0, -4)),\n                                file.text, nullValuesSupport));\n                        }\n                        catch (err) {\n                            console.log('File ' + file.name + ' skipped for bad format of csv');\n                            skipped += 1;\n                        }\n                    }\n                    else {\n                        console.log('Unsupported filetype: ' + file.name);\n                        skipped += 1;\n                    }\n                });\n                resolve({relations: relations, skipped: skipped});\n            });\n        });\n    }\n\n    /**\n     * Saves given relations into csv files (in one csv file each relation). Uses given value separator.\n     *\n     * @param relations map of the relations to be  {@type StoredRelation[]}\n     * @param filename name of the downloaded file (without .zip/.csv extension) {@type string}\n     * @param valueSeparator the separator of values {@type CsvValueSeparator}\n     * @public\n     */\n    public static save(relations: StoredRelation[], filename: string, valueSeparator: CsvValueSeparator): void {\n        if (relations.length === 0) {\n            return;\n        }\n        if (relations.length === 1) {\n            const blob = new Blob([this.relationToCsv(relations[0], valueSeparator)], {type: \"text/plain;charset=utf-8\"});\n            saveAs(blob, relations[0].getName() + '.csv');\n            return;\n        }\n        const zip: JSZip = JSZip();\n        relations.forEach(relation => {\n            zip.file(relation.getName() + '.csv', this.relationToCsv(relation, valueSeparator));\n        });\n        zip.generateAsync({type: \"blob\"}).then(content => {\n            saveAs(content, filename + \".zip\");\n        }).catch(err => {\n            throw err;\n        });\n    }\n\n    /**\n     * Parses a StoredRelation from given csv text. If the text is invalid, throws error.\n     *\n     * @param name name of the relation\n     * @param text csv content to parse a relation from\n     * @param nullValuesSupport null values support to set in created StoredRelation\n     */\n    private static csvToRelation(name: string, text: string | null, nullValuesSupport: boolean): StoredRelation {\n        if (text === null || text === \"\") {\n            console.log(\"null or empty string read from file \" + name);\n            throw Error();\n        }\n\n        text = text.trim().replace(/\\r\\n/g, '\\n')\n            .replace(/\\r/g, '\\n').replace(/\\t/g, \"    \");\n\n        const lines: string[] = text.split('\\n');\n\n        if (lines.length < 2) {\n            console.log(\"file \" + name + \" has only one line\");\n            throw new Error();  // at least two lines are expected (names and types)\n        }\n\n        lines[0] = lines[0].replace(/\\s/g, '');\n        lines[1] = lines[1].replace(/\\s/g, '');\n\n        let separator = findValueSeparator(lines[1]);\n        // if no separator is found, only one column is expected - sets separator to not defined value to unify the\n        // following process\n        if (separator === undefined) {\n            separator = ';';\n        }\n\n        const columnNames: string[] = splitCSVLine(lines[0], separator);\n        const columnTypes: SupportedColumnType[] = splitCSVLine(lines[1], separator).map(str => {\n            const lower = str.toLowerCase();\n            if (lower === \"string\" || lower === \"str\" || lower === \"s\") {\n                return \"string\";\n            }\n            else if (lower === \"number\" || lower === \"num\" || lower === \"n\") {\n                return \"number\";\n            }\n            return \"boolean\";\n        });\n        // @ts-ignore - separator cannot be undefined\n        const rows: string[][] = lines.slice(2).map(line => splitCSVLine(line, separator));\n\n        // all rows must have equal column count\n        const columnCount = columnNames.length;\n        if (columnTypes.length !== columnCount || rows.some(row => row.length !== columnCount)) {\n            console.log(\"rows in file \" + name + \" do not have the same number of columns\");\n            throw new Error();\n        }\n\n        return new StoredRelation(name, columnNames, columnTypes, rows, nullValuesSupport);\n    }\n\n    /**\n     * Removes invalid characters for name. If the filtered name is empty, returns string \"relation\".\n     */\n    private static createValidName(name: string): string {\n        name = name.split('').filter(char => StringUtils.isNameChar(char)).join('');\n        if (name === \"\") {\n            return \"relation\";\n        }\n        return name;\n    }\n\n    /**\n     * Creates a csv representation for the given relation.\n     */\n    private static relationToCsv(relation: StoredRelation, valueSeparator: CsvValueSeparator): string {\n        const names: string = relation.getColumnNames().map(\n            n => '\"' + n.replace(/\"/g, '\"\"') + '\"'\n        ).join(valueSeparator);\n        const types: string = relation.getColumnTypes().join(valueSeparator);\n        const rows: string[] = relation.getRows().map(row => row.map(\n            data => '\"' + data.replace(/\"/g, '\"\"') + '\"'\n        ).join(valueSeparator));\n        return [names, types, ...rows].join('\\n');\n    }\n}","import React from \"react\";\n// @ts-ignore - type declaration is not needed for its short usage\nimport downloadSVG from \"export-svg-with-styles\";\nimport {Relation} from \"../relation/relation\";\nimport {ResultRelationTable} from \"./resultRelationTable\";\nimport {TooltipButton} from \"./tooltipButton\";\nimport {RATreeNode} from \"../ratree/raTreeNode\";\nimport {CsvValueSeparator} from \"../types/csvSupport\";\nimport {evalTreeSVGId, EvaluationTree} from \"./evaluationTree\";\nimport {depthSearch} from \"../ratree/raTreeTools\";\nimport {ErrorFactory} from \"../error/errorFactory\";\nimport {RelationStoreManager} from \"../relation/relationStoreManager\";\nimport {StoredRelation} from \"../relation/storedRelation\";\nimport \"./css/resultSection.css\"\nimport {language, LanguageDef} from \"../language/language\";\n\n/**\n * Props of ResultSection component.\n * @category Components\n * @public\n */\ninterface ResultSectionProps {\n    /**\n     * the root of the current evaluation tree to display\n     * @type RATreeNode\n     * @public\n     */\n    evaluationTreeRoot: RATreeNode,\n    /**\n     * name of the evaluated expression\n     * @type string\n     * @public\n     */\n    expressionName: string,\n    /**\n     * handler of adding the given relation to defined relations\n     * @type function\n     * @public\n     */\n    onAddResult: (relation: Relation) => void,\n    /**\n     * handler of unexpected errors\n     * @type function\n     * @public\n     */\n    onUnexpectedError: (e: Error) => void,\n    /**\n     * current selected value separator in csv files\n     * @type CsvValueSeparator\n     * @public\n     */\n    csvValueSeparator: CsvValueSeparator,\n    /**\n     * true if dark theme should be applied\n     * @type boolean\n     * @public\n     */\n    darkTheme: boolean,\n    /**\n     * current application language\n     * @type LanguageDef\n     * @public\n     */\n    language: LanguageDef\n}\n\ninterface ResultSectionState {\n    selectedIndex: number\n}\n\n/**\n * Section to show the evaluation result. It contains a table with a result and text input and buttons to save it.\n * The component is hidden if given resultRelation is null.\n * Accepts {@link ResultSectionProps} props.\n * @category Components\n * @public\n */\nexport class ResultSection extends React.Component<ResultSectionProps, ResultSectionState> {\n\n    // reference to this section element\n    private readonly sectionRef: React.RefObject<HTMLDivElement>;\n\n    constructor(props: ResultSectionProps) {\n        super(props);\n        this.state = {\n            selectedIndex: 0\n        }\n        this.sectionRef = React.createRef<HTMLDivElement>();\n    }\n\n    componentDidUpdate(prevProps: Readonly<ResultSectionProps>) {\n        if (prevProps.evaluationTreeRoot !== this.props.evaluationTreeRoot) {\n            this.setState({selectedIndex: 0});\n        }\n    }\n\n    /**\n     * Gets the result relation for the current selected node.\n     */\n    private getCurrentRelation = (): Relation | null => {\n        let currentNode: RATreeNode | null = depthSearch(this.props.evaluationTreeRoot, this.state.selectedIndex);\n        if (currentNode === null) {\n            currentNode = depthSearch(this.props.evaluationTreeRoot, 0);\n            if (currentNode === null) {\n                this.props.onUnexpectedError(ErrorFactory.codeError(language().codeErrors.resultSection_nodeIndexNotFound));\n                return null;\n            }\n        }\n        try {\n            return currentNode.getResult();\n        }\n        catch (err) {\n            // errors should be handled in expression section\n            this.props.onUnexpectedError(ErrorFactory.codeError(language().codeErrors.resultSection_evalError, err.message));\n            return null;\n        }\n    }\n\n    private handleSelectedNodeChange = (index: number): void => {\n        this.setState({selectedIndex: index});\n    }\n\n    /**\n     * Saves the displayed evaluation tree as png picture.\n     */\n    private exportEvalTreeAsPng = (): void => {\n        const svg = document.getElementById(evalTreeSVGId);\n        if (svg !== null) {\n            const rect = svg.getBoundingClientRect();\n            const options = {\n                width: rect.width * 3,\n                height: rect.height * 3,\n                svg: svg,\n                filename: this.props.expressionName + \" - evaluation tree.png\"\n            }\n            downloadSVG(options);\n        }\n    }\n\n    /**\n     * Saves the current selected relation to a file.\n     */\n    private exportRelation = (): void => {\n        if (this.getCurrentRelation() === null) {\n            this.props.onUnexpectedError(ErrorFactory.codeError(language().codeErrors.resultSection_nullRelationToSave));\n            return;\n        }\n        try {\n            RelationStoreManager.save(\n                [StoredRelation.fromRelation(\"rachel_result\", this.getCurrentRelation() as Relation, true)],\n                \"rachel_result\", this.props.csvValueSeparator);\n        }\n        catch (err) {\n            console.warn(\"Saving error: \" + err, true);\n        }\n    }\n\n    /**\n     * Passes the current selected relation with the given name to the parent.\n     */\n    private addRelation = (): void => {\n        if (this.getCurrentRelation() === null) {\n            this.props.onUnexpectedError(\n                ErrorFactory.codeError(language().codeErrors.resultSection_nullRelationToAdd)\n            );\n            return;\n        }\n        // @ts-ignore\n        this.props.onAddResult(this.getCurrentRelation());\n    }\n\n    render() {\n        const relation = this.getCurrentRelation();\n        // does not show null result\n        if (relation === null) {\n            return null;\n        }\n        const lang = this.props.language.resultSection;\n\n        const relationType: string = this.state.selectedIndex === 0 ? lang.resultRelationTitle : lang.intermediateRelationTitle;\n        const selectedNode: RATreeNode | null = depthSearch(this.props.evaluationTreeRoot, this.state.selectedIndex);\n        const tableTitle: string | null = selectedNode === null ? null : selectedNode.printInLine();\n\n        return (\n            <section\n                ref={this.sectionRef}\n                className=\"page-section result-section\">\n                <header>\n                    <h2>{lang.resultSectionHeader}</h2>\n                    <TooltipButton\n                        text={lang.exportEvalTreeButton}\n                        onClick={this.exportEvalTreeAsPng}\n                        tooltip={lang.exportEvalTreeButtonTooltip}\n                    />\n                </header>\n\n                <p className=\"upper-p\">\n                    <strong>{lang.evalTreeTitle + ' ' + this.props.evaluationTreeRoot.printInLine() + ':'}</strong>\n                </p>\n\n                <EvaluationTree\n                    tree={this.props.evaluationTreeRoot}\n                    selected={this.state.selectedIndex}\n                    onClick={this.handleSelectedNodeChange}\n                    darkTheme={this.props.darkTheme}\n                />\n\n                <p className=\"lower-p\"><strong>{relationType} {tableTitle}:</strong></p>\n\n                <menu className=\"page-section-tab-menu\">\n                    <TooltipButton\n                        text={lang.addButton}\n                        onClick={this.addRelation}\n                        tooltip={lang.addButtonTooltip}\n                    />\n                    <TooltipButton\n                        text={lang.exportRelationButton}\n                        onClick={this.exportRelation}\n                        tooltip={lang.exportRelationButtonTooltip}\n                    />\n                </menu>\n\n                <ResultRelationTable relation={relation} />\n            </section>\n        );\n    }\n}","import {FileDialog} from \"../utils/fileDialog\";\nimport {saveAs} from \"file-saver\";\nimport {Expression} from \"./expression\";\n\n/**\n * Promised expression information in {@link ExpressionStoreManager}.load() function.\n * @category Expression\n * @public\n */\nexport interface ExpressionLoadData {\n    /**\n     * successfully parsed expressions\n     * @type Expression[]\n     * @public\n     */\n    expressions: Expression[],\n    /**\n     * number of skipped expressions (from successfully loaded files)\n     * @type number\n     * @public\n     */\n    skippedExpressions: number,\n    /**\n     * number of successfully loaded files\n     * @type number\n     * @public\n     */\n    loadedFiles: number,\n    /**\n     * number of skipped files (not .txt, null loaded...)\n     * @type number\n     * @public\n     */\n    skippedFiles: number\n}\n\n/**\n * Class for loading and saving expressions.\n * @category Expression\n * @public\n */\nexport class ExpressionStoreManager {\n\n    /**\n     * Loads expressions from multiple textual files selected by the user. Each file can contain multiple expressions,\n     * split by '\\n###\\n'. When different line separator is used (\\r, \\r\\n), it is replaced by \\n before return.\n     * All tabulators are replaces by 4 spaces.\n     *\n     * @return information about loaded expressions in a promise {@type Promise<ExpressionLoadData>}\n     * @public\n     */\n    public static load(): Promise<ExpressionLoadData> {\n        return new Promise<ExpressionLoadData>(resolve => {\n            FileDialog.openFiles(\".txt\").then(files =>{\n                let expressions: Expression[] = [];\n                let skippedExpressions: number = 0;\n                let loadedFiles: number = 0;\n                let skippedFiles: number = 0;\n                files.forEach(file => {\n                    if (file.text === null) {\n                        console.log('Null read from file ' + file.name);\n                        skippedFiles += 1;\n                    }\n                    else if (file.name.match(/\\.txt$/)) {\n                        // replaces line separators to expected '\\n' and tabulators to four spaces\n                        file.text = file.text.replace(/\\r\\n/g, '\\n')\n                            .replace(/\\r/g, '\\n').replace(/\\t/g, \"    \");\n                        // prepends newline for first expected splitting of the first expression\n                        ('\\n'.concat(file.text)).split('\\n### ').forEach(part => {\n                            try {\n                                if (part.trim().length !== 0) {\n                                    expressions.push(this.splitExpressionNameAndText(part));\n                                }\n                            }\n                            catch (err) {\n                                skippedExpressions += 1;\n                            }\n                        });\n                        loadedFiles += 1;\n                    }\n                    else {\n                        console.log('Unsupported filetype: ' + file.name);\n                        skippedFiles += 1;\n                    }\n                });\n                resolve({expressions, skippedExpressions, loadedFiles, skippedFiles});\n            });\n        });\n    }\n\n    private static splitExpressionNameAndText(expr: string): Expression {\n        const firstNewLineIndex: number = expr.indexOf('\\n');\n        if (firstNewLineIndex === -1) {\n            console.log(\"Expression does not contain first name line.\");\n            throw Error();\n        }\n        const firstRow: string = expr.slice(0, firstNewLineIndex).trim();\n        if (!firstRow.endsWith(' ###')) {\n            console.log(\"Expression does not contain name between hashes.\");\n            throw Error();\n        }\n        const name: string = firstRow.slice(0, -4);\n        const text: string = expr.slice(firstNewLineIndex).trim();\n        return {name: name, text: text};\n    }\n\n    /**\n     * Saves given expressions to a textual file. Each expression starts with \"### Expression name ###\\n\" line.\n     *\n     * @param expressions array of expressions to be saved {@type Expression[]}\n     * @param filename name of the downloaded file (without extension) {@type string}\n     * @public\n     */\n    public static save(expressions: Expression[], filename: string): void {\n        const textContent: string = expressions.map(e => {\n            return \"### \" + e.name + \" ###\\n\\n\" + e.text;\n        }).join('\\n\\n');\n        const blob = new Blob([textContent], {type: \"text/plain;charset=utf-8\"});\n        saveAs(blob, filename + '.txt');\n    }\n}","import {Project} from \"./project\";\n\n/**\n * Sample of the application {@link Project} with a name.\n * @category Project\n * @public\n */\nexport interface ProjectSample {\n    /**\n     * name of the sample\n     * @type string\n     * @public\n     */\n    name: string,\n    /**\n     * sample project\n     * @type Project\n     * @public\n     */\n    project: Project\n}\n\nconst samples: ProjectSample[] = [\n    // english sample\n    {\n        name: \"Cars and Owners (EN)\",\n        project: {\n            relations: [\n                {\n                    name: \"Car\",\n                    columnNames: [\"Id\", \"Owner\", \"Color\", \"Electric\", \"Weight\"],\n                    columnTypes: [\"number\", \"number\", \"string\", \"boolean\", \"number\"],\n                    rows: [\n                        ['1', '1', 'Blue', 'True', '1000'],\n                        ['2', '1', 'Green', 'false', '1 200'],\n                        ['3', '2', 'Blue', 'F', '850.42'],\n                        ['4', '3', 'Black', 't', '1 111.111 111']\n                    ],\n                    columnCount: 5,\n                    rowCount: 4\n                },\n                {\n                    name: \"Owner\",\n                    columnNames: [\"Id\", \"Name\"],\n                    columnTypes: [\"number\", \"string\"],\n                    rows: [\n                        ['1', 'George Smith'],\n                        ['2', 'Adam \"Driver /\\\\\" Jackson'],\n                        ['3', 'Michael Trueman'],\n                        ['Fix errors', 'before loading'],\n                        ['Or delete', 'invalid rows']\n                    ],\n                    columnCount: 2,\n                    rowCount: 3\n                }\n            ],\n            expressions: [\n                {\n                    name: \"Relation only\",\n                    text:\n                        \"// You can use comments until the line end after '//'\\n\" +\n                        \"// You must load relations before using them in expressions\\n\" +\n                        \"\\n\" +\n                        \"Car\\n\" +\n                        \"\\n\" +\n                        \"// After evaluation, you will see the evaluation tree\\n\" +\n                        \"// and the result relation at the bottom of the page\\n\" +\n                        \"\"\n                },\n                {\n                    name: \"Unary operator\",\n                    text:\n                        \"// Unary operator comes after the source relation\\n\" +\n                        \"// If the relation is still not defined, go check its definition\\n\" +\n                        \"// This expression returns all owners with id 1\\n\" +\n                        \"\\n\" +\n                        \"Owner(Id = 1)\\n\" +\n                        \"\"\n                },\n                {\n                    name: \"Binary operator\",\n                    text:\n                        \"// Binary operator comes between source relations\\n\" +\n                        \"// This expression returns natural join of cars and owners\\n\" +\n                        \"\\n\" +\n                        \"Car*Owner\\n\" +\n                        \"\"\n                },\n                {\n                    name: \"Escapes\",\n                    text:\n                        \"// Strings in expressions are enclosed in quotes\\n\" +\n                        \"// To use quotes inside a string, you must escape them by a backslash '\\\\\\\"'\\n\" +\n                        \"// To use backslash inside a string, you must escape it with second one '\\\\\\\\'\\n\" +\n                        \"\\n\" +\n                        'Owner(Name == \"Adam \\\\\"Driver /\\\\\\\\\\\\\" Jackson\")\\n' +\n                        '\\n' +\n                        '// This does not work: Owner(Name == \"Adam \"Driver /\\\\\" Jackson\")\\n' +\n                        \"\"\n                },\n                {\n                    name: \"Example\",\n                    text:\n                        \"// Errors are highlighted by red underline - hover mouse over it to see details\\n\" +\n                        \"// While typing, Rachel shows you available relations or columns\\n\" +\n                        \"// (if relations are loaded in the application)\\n\" +\n                        \"// Try to write a query for: all cars' ids and their owners' names\\n\" +\n                        \"\\n\" +\n                        \"TODO...\\n\" +\n                        \"\"\n                },\n                {\n                    name: \"Example result\",\n                    text:\n                        \"// One possible expression is like this...\\n\" +\n                        \"\\n\" +\n                        \"(\\n\" +\n                        \"  Car\\n\" +\n                        \"  *\\n\" +\n                        \"  Owner< Id -> Owner >\\n\" +\n                        \")[Id, Name]\\n\" +\n                        \"\\n\" +\n                        \"// For more detailed manual click 'About' button in the page header\\n\" +\n                        \"\"\n                }\n            ],\n            nullValuesSupport: true\n        }\n    },\n    // czech sample\n    {\n        name: \"Auta a Majitelé (CS)\",\n        project: {\n            relations: [\n                {\n                    name: \"Auto\",\n                    columnNames: [\"Id\", \"Majitel\", \"Barva\", \"Elektro\", \"Váha\"],\n                    columnTypes: [\"number\", \"number\", \"string\", \"boolean\", \"number\"],\n                    rows: [\n                        ['1', '1', 'Modrá', 'True', '1000'],\n                        ['2', '1', 'Zelená', 'false', '1 200'],\n                        ['3', '2', 'Modrá', 'F', '850.42'],\n                        ['4', '3', 'Černá', 't', '1 111.111 111']\n                    ],\n                    columnCount: 5,\n                    rowCount: 4\n                },\n                {\n                    name: \"Majitel\",\n                    columnNames: [\"Id\", \"Jméno\"],\n                    columnTypes: [\"number\", \"string\"],\n                    rows: [\n                        ['1', 'Pepa Mrázek'],\n                        ['2', 'Adam \"Závodník /\\\\\" Horváth'],\n                        ['3', 'Michael Dvořák'],\n                        ['Před nahráním', 'oprav chyby'],\n                        ['Nebo odstraň', 'chybné řádky']\n                    ],\n                    columnCount: 2,\n                    rowCount: 3\n                }\n            ],\n            expressions: [\n                {\n                    name: \"Pouze relace\",\n                    text:\n                        \"// Můžeš používat komentáře po '//'\\n\" +\n                        \"// Před použitím relací ve výrazech je musíš nahrát\\n\" +\n                        \"\\n\" +\n                        \"Auto\\n\" +\n                        \"\\n\" +\n                        \"// Po vyhodnocení uvidíš evaluační strom\\n\" +\n                        \"// a výslednou relaci dole na stránce\\n\" +\n                        \"\"\n                },\n                {\n                    name: \"Unární operátor\",\n                    text:\n                        \"// Unární operátory se píší za vstupní relaci\\n\" +\n                        \"// Pokud je tato relace stále nedefinovaná, zkontroluj její definici\\n\" +\n                        \"// Tento dotaz vrátí všechny majitele s id = 1\\n\" +\n                        \"\\n\" +\n                        \"Majitel(Id = 1)\\n\" +\n                        \"\"\n                },\n                {\n                    name: \"Binární operátor\",\n                    text:\n                        \"// Binární operátory se píší mezi vstupní relace\\n\" +\n                        \"// Tento výraz vrátí přirozené spojení aut a majitelů\\n\" +\n                        \"\\n\" +\n                        \"Auto*Majitel\\n\" +\n                        \"\"\n                },\n                {\n                    name: \"Escapes\",\n                    text:\n                        \"// Textové řetězce ve výrazech musí být mezi uvozovkami\\n\" +\n                        \"// Pro použití uvozovek v řetězci před ně musíš napsat zpětné lomítko '\\\\\\\"'\\n\" +\n                        \"// Pro použití zpětného lomítka před něj musíš napsat druhé '\\\\\\\\'\\n\" +\n                        \"\\n\" +\n                        'Majitel(Jméno == \"Adam \\\\\"Závodník /\\\\\\\\\\\\\" Horváth\")\\n' +\n                        '\\n' +\n                        '// Toto by nefungovalo: Majitel(Jméno == \"Adam \"Závodník /\\\\\" Horváth\")\\n' +\n                        \"\"\n                },\n                {\n                    name: \"Příklad\",\n                    text:\n                        \"// Chyby jsou zvýrazněni červeným podtržením - přejeď na ně myší pro detaily\\n\" +\n                        \"// Při psaní ti Rachel nabízí dostupné relace nebo sloupce\\n\" +\n                        \"// (pokud jsou relace nahrané v aplikace)\\n\" +\n                        \"// Zkus napsat dotaz pro: id všech aut a jména jejich majitelů\\n\" +\n                        \"\\n\" +\n                        \"TODO...\\n\" +\n                        \"\"\n                },\n                {\n                    name: \"Výsledek příkladu\",\n                    text:\n                        \"// Jedno možné řešení je toto...\\n\" +\n                        \"\\n\" +\n                        \"(\\n\" +\n                        \"  Auto\\n\" +\n                        \"  *\\n\" +\n                        \"  Majitel< Id -> Majitel >\\n\" +\n                        \")[Id, Jméno]\\n\" +\n                        \"\\n\" +\n                        \"// Pro více informací navštiv manuál přes odkaz 'O aplikaci' v horním menu\\n\" +\n                        \"\"\n                }\n            ],\n            nullValuesSupport: true\n        }\n    }\n];\n\n/**\n * Returns prepared project samples.\n *\n * @return {@type ProjectSample[]}\n * @category Project\n * @public\n */\nexport function getSamples(): ProjectSample[] {\n    return samples;\n}","import React from \"react\";\nimport {CsvValueSeparator} from \"../types/csvSupport\";\nimport {allSupportedLanguages, LanguageDef, SupportedLanguage} from \"../language/language\";\nimport \"./css/managementSection.css\"\nimport {getSamples} from \"../project/samples\";\nimport {Project} from \"../project/project\";\nimport {TooltipButton} from \"./tooltipButton\";\n\n/**\n * Props of ManagementSection component.\n * @category Components\n * @public\n */\ninterface ManagementSectionProps {\n    /**\n     * handler of loading a config file for batch processing\n     * @type function\n     * @public\n     */\n    onBatchConfig: () => void,\n    /**\n     * handler of loading project files for batch processing\n     * @type function\n     * @public\n     */\n    onBatchLoad: () => void,\n    /**\n     * information about current batch configuration\n     * @type string\n     * @public\n     */\n    batchConfigurationInfo: string,\n    /**\n     * handler of project loading\n     * @type function\n     * @public\n     */\n    onLoadProject: () => void,\n    /**\n     * handler of project saving\n     * @type function\n     * @public\n     */\n    onSaveProject: () => void,\n    /**\n     * handler of loading the selected sample project\n     * @type function\n     * @public\n     */\n    onLoadSample: (sample: Project) => void,\n    /**\n     * current selected value separator in csv files\n     * @type CsvValueSeparator\n     * @public\n     */\n    csvValueSeparator: CsvValueSeparator,\n    /**\n     * current selected language of the application\n     * @type LanguageDef\n     * @public\n     */\n    language: LanguageDef,\n    /**\n     * current selected null values support\n     * @type boolean\n     * @public\n     */\n    nullValuesSupport: boolean,\n    /**\n     * true if dark theme should be applied\n     * @type boolean\n     * @public\n     */\n    darkTheme: boolean,\n    /**\n     * handler of change of the current selected value separator in csv files\n     * @type function\n     * @public\n     */\n    onCsvValueSeparatorChange: (csvValueSeparator: CsvValueSeparator) => void,\n    /**\n     * handler of change of the current selected language of the application\n     * @type function\n     * @public\n     */\n    onLanguageChange: (language: SupportedLanguage) => void,\n    /**\n     * handler of change of the current selected null values support\n     * @type function\n     * @public\n     */\n    onNullValuesSupportChange: (nullValuesSupport: boolean) => void,\n    /**\n     * handler of change of the current selected theme\n     * @type function\n     * @public\n     */\n    onDarkThemeChange: (darkTheme: boolean) => void\n}\n\ninterface ManagementSectionState {\n    sectionClicked: boolean\n}\n\n/**\n * Section to manage batch processing, importing/exporting the project, and settings.\n * Accepts {@link ManagementSectionProps} props.\n * @category Components\n * @public\n */\nexport class ManagementSection extends React.Component<ManagementSectionProps, ManagementSectionState> {\n\n    constructor(props: ManagementSectionProps) {\n        super(props);\n        this.state = {\n            sectionClicked: false\n        }\n    }\n\n    render() {\n        const lang = this.props.language.managementSection;\n\n        const createBatchButton = () => {\n            const batchMenu = (\n              <ul className=\"list-menu\">\n                  <TooltipButton text={lang.batchConfig} onClick={this.props.onBatchConfig}\n                                 tooltip={this.props.batchConfigurationInfo}/>\n                  <button onClick={this.props.onBatchLoad}>{lang.batchLoad}</button>\n              </ul>\n            )\n            return (<div className={\"button-like\"}>{lang.batchTitle}{batchMenu}</div>);\n        }\n        const createLoadProjectButton = () => {\n            return (<button onClick={this.props.onLoadProject} >{lang.loadButton}</button>);\n        }\n        const createSaveProjectButton = () => {\n            return (<button onClick={this.props.onSaveProject} >{lang.saveButton}</button>);\n        }\n        const createSettingsButton = () => {\n            const settingsMenu = (\n                <ul className=\"list-menu\">\n                    <li>\n                        <span>{lang.settingsNullValues}:</span>\n                        <input\n                            type=\"radio\"\n                            name=\"null_values_support\"\n                            value=\"allowed\"\n                            id=\"null_values_support_allowed\"\n                            checked={this.props.nullValuesSupport}\n                            onChange={() => this.props.onNullValuesSupportChange(true)} />\n                        <label htmlFor=\"null_values_support_allowed\">{lang.settingsNullValuesAllowed}</label>\n                        <input\n                            type=\"radio\"\n                            name=\"null_values_support\"\n                            value=\"forbidden\"\n                            id=\"null_values_support_forbid\"\n                            checked={!this.props.nullValuesSupport}\n                            onChange={() => this.props.onNullValuesSupportChange(false)} />\n                        <label htmlFor=\"null_values_support_forbid\">{lang.settingsNullValuesForbidden}</label>\n                    </li>\n                    <li>\n                        <span>{lang.settingsCSVSeparator}:</span>\n                        <input\n                            type=\"radio\"\n                            name=\"value_separator\"\n                            value=\"semicolon\"\n                            id=\"value_separator_semi\"\n                            checked={this.props.csvValueSeparator === \";\"}\n                            onChange={() => this.props.onCsvValueSeparatorChange(\";\")}/>\n                        <label htmlFor=\"value_separator_semi\">{lang.settingsCSVSeparatorSemicolon}</label>\n                        <input\n                            type=\"radio\"\n                            name=\"value_separator\"\n                            value=\"comma\"\n                            id=\"value_separator_comma\"\n                            checked={this.props.csvValueSeparator === \",\"}\n                            onChange={() => this.props.onCsvValueSeparatorChange(\",\")}/>\n                        <label htmlFor=\"value_separator_comma\">{lang.settingsCSVSeparatorComma}</label>\n                    </li>\n                    <li>\n                        <span>{lang.settingsTheme}:</span>\n                        <input\n                            type=\"radio\"\n                            name=\"dark_mode\"\n                            value=\"on\"\n                            id=\"dark_mode_on\"\n                            checked={!this.props.darkTheme}\n                            onChange={() => this.props.onDarkThemeChange(false)} />\n                        <label htmlFor=\"dark_mode_on\">{lang.settingsThemeLight}</label>\n                        <input\n                            type=\"radio\"\n                            name=\"dark_mode\"\n                            value=\"off\"\n                            id=\"dark_mode_off\"\n                            checked={this.props.darkTheme}\n                            onChange={() => this.props.onDarkThemeChange(true)} />\n                        <label htmlFor=\"dark_mode_off\">{lang.settingsThemeDark}</label>\n                    </li>\n                    <li>\n                        <span>{lang.settingsLanguage}:</span>\n                        {allSupportedLanguages.map(lang => {\n                            return (<div key={lang} style={{display: \"inline\"}}>\n                                <input\n                                    type=\"radio\"\n                                    name=\"language\"\n                                    value={lang}\n                                    id={\"language_\" + lang}\n                                    checked={this.props.language.abbr === lang}\n                                    onChange={() => this.props.onLanguageChange(lang)} />\n                                <label htmlFor={\"language_\" + lang}>{lang}</label>\n                            </div>)\n                        })}\n                    </li>\n                </ul>\n            );\n            return (<div className={\"button-like\"}>{lang.settingsButton}{settingsMenu}</div>);\n        }\n        const createSamplesButton = () => {\n            const samplesMenu = (\n            <ul className=\"list-menu\">\n                {lang.samplesMenuTitle}\n                {getSamples().map((sample, i) => {\n                    return (\n                        <li key={i}>\n                            <button onClick={() => this.props.onLoadSample(sample.project)}>{sample.name}</button>\n                        </li>\n                    );\n                })}\n            </ul>\n            );\n            return (<div className={\"button-like\"} >{lang.samplesButton}{samplesMenu}</div>);\n        }\n        const createAboutButton = () => {\n            return (\n                <a  href=\"https://github.com/kotliluk/rachel\"\n                    target=\"_blank\"\n                    rel=\"noreferrer\"\n                    className={\"button-like\"}\n                >{lang.aboutButton}</a>\n            );\n        }\n\n        return (\n            <header className=\"management-section\">\n                <h1>RACHEL</h1>\n                {createLoadProjectButton()}\n                {createSaveProjectButton()}\n                {createSamplesButton()}\n                {createSettingsButton()}\n                {createBatchButton()}\n                {createAboutButton()}\n            </header>\n        );\n    }\n}","import {copyExpression, Expression, isExpression} from \"../expression/expression\";\nimport {copyStoredRelationData, isStoredRelationData, StoredRelationData} from \"../relation/storedRelation\";\n\n/**\n * Project interface to store information about project relations, expressions, and null values support.\n * Does not store custom settings about saving file types etc.\n *\n * @category Project\n * @public\n */\nexport interface Project {\n    /**\n     * stored relation data in compressed representation\n     * @type StoredRelationData[]\n     * @public\n     */\n    relations: StoredRelationData[],\n    /**\n     * expressions\n     * @type Expression[]\n     * @public\n     */\n    expressions: Expression[],\n    /**\n     * whether the project supports null values\n     * @type boolean\n     * @public\n     */\n    nullValuesSupport: boolean\n}\n\n/**\n * Checks whether the given object is {@link Project} (i.e., has all required fields of required types).\n *\n * @param obj value to be checked {@type any}\n * @return \"OK\" string if the given obj is Project or string description of found error in the structure {@type string}\n *\n * @category Project\n * @public\n */\nexport function isProjectObject(obj: any): string {\n    if (typeof obj !== \"object\") {\n        return 'The file cannot be parsed to an object.';\n    }\n    if (!(\"relations\" in obj) || !Array.isArray(obj.relations) || obj.relations.length === 0 ||\n        obj.relations.some((o: any) => !isStoredRelationData(o))) {\n        return 'The file must contain the field \"relations: StoredRelationData[]\" of length at least one';\n    }\n    if (!(\"expressions\" in obj) || !Array.isArray(obj.expressions) || obj.expressions.length === 0 ||\n        obj.expressions.some((o: any) => !isExpression(o))) {\n        return 'The file must contain the field \"expressions: Expression[]\" of length at least one';\n    }\n    if (!(\"nullValuesSupport\" in obj) || typeof obj.nullValuesSupport !== \"boolean\") {\n        return 'The file must contain the field \"nullValuesSupport: boolean\"';\n    }\n    return 'OK';\n}\n\n/**\n * Creates a copy of the given project.\n *\n * @param proj project to copy {@type Project}\n * @return deep copied project {@type Project}\n * @category Project\n * @public\n */\nexport function copyProject(proj: Project): Project {\n    return {\n        relations: proj.relations.map(rel => copyStoredRelationData(rel)),\n        expressions: proj.expressions.map(expr => copyExpression(expr)),\n        nullValuesSupport: proj.nullValuesSupport\n    }\n}","/**\n * Representation of named relational algebra expression.\n * @category Expression\n * @public\n */\nexport interface Expression {\n    /**\n     * name of the expression\n     * @type string\n     * @public\n     */\n    name: string,\n    /**\n     * text of the expression\n     * @type string\n     * @public\n     */\n    text: string\n}\n\n/**\n * Checks whether the given obj is an {@link Expression}.\n *\n * @param obj object to check {@type any}\n * @return whether the given obj is an Expression {@type boolean}\n * @category Expression\n * @public\n */\nexport function isExpression(obj: any): boolean {\n    if (typeof obj !== \"object\") {\n        return false;\n    }\n    return (\"name\" in obj) && (typeof obj.name === \"string\") && (\"text\" in obj) && (typeof obj.text === \"string\");\n}\n\n/**\n * Creates a copy of the given expression.\n *\n * @param exp Expression to copy {@type Expression}\n * @return deep copied expression {@type Expression}\n * @category Expression\n * @public\n */\nexport function copyExpression(exp: Expression): Expression {\n    return {name: exp.name, text: exp.text};\n}","import {isProjectObject, Project} from \"./project\";\nimport {FileDialog} from \"../utils/fileDialog\";\nimport {saveAs} from \"file-saver\";\n\n/**\n * Class for loading and saving all project data as {@link Project} objects.\n * @category Project\n * @public\n */\nexport class ProjectStoreManager {\n\n    /**\n     * Loads asynchronously the project from a .rachel (JSON) file selected by the user.\n     * The file must contain the representation of the project object.\n     * Returned string values always use '\\n' as line separator.\n     *\n     * @return loaded project as a Promise {@type Promise<Project>}\n     * @public\n     */\n    public static load(): Promise<Project> {\n        return new Promise<Project>((resolve, reject) => {\n            FileDialog.openFile(\".rachel\").then(file => {\n                if (file.text === null) {\n                    reject(\"Reading of the content of the file \" + file.name + \" failed.\");\n                }\n                else if (file.name.match(/\\.rachel$/)) {\n                    // replaces line separators to expected '\\n'\n                    file.text = file.text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n')\n                        .replace(/\\t/g, \"    \");\n                    let obj = JSON.parse(file.text);\n                    const result: string = isProjectObject(obj);\n                    if (result === \"OK\") {\n                        const project: Project = obj;\n                        resolve(project);\n                    }\n                    else {\n                        reject(\"Invalid structure of the JSON file. \" + result)\n                    }\n                }\n                else {\n                    reject(\"Please select a JSON file to load a project relation from.\");\n                }\n            });\n        });\n    }\n\n    /**\n     * Saves the given Project into the .rachel (JSON) file.\n     *\n     * @param project the Project object with all project data {@type Project}\n     * @param filename name of the downloaded file (without extension, .rachel is added) {@type string}\n     * @public\n     */\n    public static save(project: Project, filename: string): void {\n        const blob = new Blob([JSON.stringify(project)], {type: \"text/plain;charset=utf-8\"});\n        saveAs(blob, filename + '.rachel');\n    }\n}","import {RATreeNode} from \"../ratree/raTreeNode\";\nimport {UnaryNode} from \"../ratree/unaryNode\";\nimport {BinaryNode} from \"../ratree/binaryNode\";\nimport {ProjectionNode} from \"../ratree/projectionNode\";\nimport {RenameNode} from \"../ratree/renameNode\";\nimport {SelectionNode} from \"../ratree/selectionNode\";\nimport {AntijoinNode} from \"../ratree/antijoinNode\";\nimport {CartesianProductNode} from \"../ratree/cartesianProductNode\";\nimport {DivisionNode} from \"../ratree/divisionNode\";\nimport {OuterJoinNode} from \"../ratree/outerJoinNode\";\nimport {NaturalJoinNode, NaturalJoinType} from \"../ratree/naturalJoinNode\";\nimport {SetOperationNode, SetOperationType} from \"../ratree/setOperationNode\";\nimport {ThetaJoinNode, ThetaJoinType} from \"../ratree/thetaJoinNode\";\n\nexport const OperationsTypes: string[] = [\"antijoin\", \"cartesian\", \"division\", \"natural\", \"outerJoin\", \"projection\",\n  \"rename\", \"selection\", \"semijoin\", \"setOperation\", \"thetaJoin\", \"thetaSemijoin\"];\n\n/**\n * Counts of all supported relational algebra operations.\n */\nexport interface OperationsCount {\n  antijoin: number,\n  cartesian: number,\n  division: number,\n  natural: number,\n  outerJoin: number,\n  projection: number,\n  rename: number,\n  selection: number,\n  semijoin: number,\n  union: number,\n  intersection: number,\n  difference: number,\n  thetaJoin: number,\n  thetaSemijoin: number,\n}\n\n/**\n * Creates zero counts for all operations.\n */\nexport function zeroOperations(): OperationsCount {\n  return addOperations();\n}\n\n/**\n * Adds given OperationsCounts together.\n */\nexport function addOperations(...counts: OperationsCount[]): OperationsCount {\n  return {\n    antijoin: counts.reduce((agg, count) => agg + count.antijoin, 0),\n    cartesian: counts.reduce((agg, count) => agg + count.cartesian, 0),\n    division: counts.reduce((agg, count) => agg + count.division, 0),\n    natural: counts.reduce((agg, count) => agg + count.natural, 0),\n    outerJoin: counts.reduce((agg, count) => agg + count.outerJoin, 0),\n    projection: counts.reduce((agg, count) => agg + count.projection, 0),\n    rename: counts.reduce((agg, count) => agg + count.rename, 0),\n    selection: counts.reduce((agg, count) => agg + count.selection, 0),\n    semijoin: counts.reduce((agg, count) => agg + count.semijoin, 0),\n    union: counts.reduce((agg, count) => agg + count.union, 0),\n    intersection: counts.reduce((agg, count) => agg + count.intersection, 0),\n    difference: counts.reduce((agg, count) => agg + count.difference, 0),\n    thetaJoin: counts.reduce((agg, count) => agg + count.thetaJoin, 0),\n    thetaSemijoin: counts.reduce((agg, count) => agg + count.thetaSemijoin, 0),\n  }\n}\n\n/**\n * Sums all operation counts.\n */\nexport function totalOperations(o: OperationsCount): number {\n  return binaryOperations(o) + unaryOperations(o);\n}\n\n/**\n * Sums all binary operation counts.\n */\nexport function binaryOperations(o: OperationsCount): number {\n  return o.antijoin + o.cartesian + o.division + o.natural + o.outerJoin + o.semijoin + o.union + o.intersection +\n    o.difference + o.thetaJoin + o.thetaSemijoin;\n}\n\n/**\n * Sums all unary operation counts.\n */\nexport function unaryOperations(o: OperationsCount): number {\n  return o.projection + o.rename + o.selection;\n}\n\n/**\n * Counts all operations used in the given tree.\n */\nexport function operationsOfTree(tree: RATreeNode): OperationsCount {\n  if (tree instanceof UnaryNode) {\n    return addOperations(operationOfUnaryNode(tree), operationsOfTree(tree.getSubtree()));\n  }\n  if (tree instanceof BinaryNode) {\n    return addOperations(operationOfBinaryNode(tree), operationsOfTree(tree.getLeftSubtree()), operationsOfTree(tree.getRightSubtree()));\n  }\n  // no subtree - relation node\n  return zeroOperations();\n}\n\n/**\n * Returns OperationsCount with one given unary operation count set to 1, other operators to 0.\n */\nexport function operationOfUnaryNode(node: UnaryNode): OperationsCount {\n  let ret: OperationsCount = zeroOperations();\n  if (node instanceof ProjectionNode) {\n    ret.projection = 1;\n    return ret;\n  }\n  if (node instanceof RenameNode) {\n    ret.rename = 1;\n    return ret;\n  }\n  if (node instanceof SelectionNode) {\n    ret.selection = 1;\n    return ret;\n  }\n  return ret;\n}\n\n/**\n * Returns OperationsCount with one given binary operation count set to 1, other operators to 0.\n */\nexport function operationOfBinaryNode(node: BinaryNode): OperationsCount {\n  let ret: OperationsCount = zeroOperations();\n  if (node instanceof AntijoinNode) {\n    ret.antijoin = 1;\n    return ret;\n  }\n  if (node instanceof CartesianProductNode) {\n    ret.cartesian = 1;\n    return ret;\n  }\n  if (node instanceof DivisionNode) {\n    ret.division = 1;\n    return ret;\n  }\n  if (node instanceof OuterJoinNode) {\n    ret.outerJoin = 1;\n    return ret;\n  }\n  if (node instanceof NaturalJoinNode) {\n    if (node.getType() === NaturalJoinType.natural) {\n      ret.natural = 1;\n    }\n    else {\n      ret.semijoin = 1;\n    }\n    return ret;\n  }\n  if (node instanceof SetOperationNode) {\n    const type = node.getOperationSymbol();\n    if (type === SetOperationType.union) {\n      ret.union = 1;\n    }\n    else if (type === SetOperationType.intersection) {\n      ret.intersection = 1;\n    }\n    else {\n      ret.difference = 1;\n    }\n    return ret;\n  }\n  if (node instanceof ThetaJoinNode) {\n    if (node.getType() === ThetaJoinType.full) {\n      ret.thetaJoin = 1;\n    }\n    else {\n      ret.thetaSemijoin = 1;\n    }\n    return ret;\n  }\n  return ret;\n}","import {OperationsCount, OperationsTypes} from \"./operationsCount\";\n\n/**\n * Rule for operations count. Should return \"OK\" when it is held, \"ERROR ruleName: ruleDescription\" if not.\n */\nexport type OperationRule = (ops: OperationsCount) => string;\n\n/**\n * Rule for tables count. Should return \"OK\" when it is held, \"ERROR ruleName: ruleDescription\" if not.\n */\nexport type TableRule = (tables: number) => string;\n\n/**\n * Rule for queries count. Should return \"OK\" when it is held, \"ERROR ruleName: ruleDescription\" if not.\n */\nexport type QueryRule = (tables: number) => string;\n\n/**\n * Compares the given number to the predefined value.\n */\nexport type CountComparator = (x: number) => string;\n\n/**\n * Creates a CountComparator function with the given count.\n *\n * @param count values to be compared to, expected to be a number or an object with any of the following fields:\n * \"$eq\", \"$gte\", \"$gt\", \"$lte\", \"$lt\".\n * @return created comparator or undefined if count is invalid\n */\nexport const createCountComparator = (count: any): CountComparator | undefined => {\n  // case of \"count\": 5, etc.\n  if (typeof count === \"number\") {\n    return (x: number) => {\n      if (x === count) {\n        return \"\";\n      }\n      return `Expected ${count}, found ${x}`;\n    };\n  }\n  // case of \"count\": { \"$eq\": 5 }, etc.\n  if (typeof count === \"object\") {\n    const comparators: CountComparator[] = [];\n    for (const field in count) {\n      const countValue = count[field];\n      if (typeof countValue !== \"number\") {\n        console.warn(field + \" parameter of count field is not a number\");\n        return undefined;\n      }\n      if (field === \"$eq\") {\n        comparators.push((x: number) => {\n          if (x === countValue) {\n            return \"\";\n          }\n          return `Expected ${countValue}, found ${x}`;\n        });\n      }\n      else if (field === \"$gte\") {\n        comparators.push((x: number) => {\n          if (x >= countValue) {\n            return \"\";\n          }\n          return `Expected greater or equal to ${countValue}, found ${x}`;\n        });\n      }\n      else if (field === \"$gt\") {\n        comparators.push((x: number) => {\n          if (x > countValue) {\n            return \"\";\n          }\n          return `Expected greater than ${countValue}, found ${x}`;\n        });\n      }\n      else if (field === \"$lte\") {\n        comparators.push((x: number) => {\n          if (x <= countValue) {\n            return \"\";\n          }\n          return `Expected less or equal to ${countValue}, found ${x}`;\n        });\n      }\n      else if (field === \"$lt\") {\n        comparators.push((x: number) => {\n          if (x < countValue) {\n            return \"\";\n          }\n          return `Expected less than ${countValue}, found ${x}`;\n        });\n      }\n    }\n    if (comparators.length === 0) {\n      console.warn(\"Count objects has no valid parameters\")\n      return undefined;\n    }\n    return (x: number) => comparators.map(comparator => comparator(x)).filter(msg => msg !== \"\").join(' + ');\n  }\n  console.warn(\"Count field is not a number nor object\");\n  return undefined;\n}\n\n/**\n * Sums predefined subset of operations.\n */\nexport type OperationsCounter = (x: OperationsCount) => number;\n\n/**\n * Creates a OperationsCounter function with the given operations to count.\n *\n * @param ops operations to be counted, expected to be a string or an array of string, each string must be supported\n * operation type\n * @return created counter or undefined if ops is invalid\n */\nexport const createOperationsCounter = (ops: any): OperationsCounter | undefined => {\n  if (typeof ops === \"string\") {\n    if (OperationsTypes.indexOf(ops) === -1) {\n      console.warn(\"Invalid value of operations field: \" + ops);\n      return undefined;\n    }\n    // @ts-ignore\n    return (x: OperationsCount) => x[ops];\n  }\n  else if (Array.isArray(ops)) {\n    if (ops.some(op => OperationsTypes.indexOf(op) === -1)) {\n      console.warn(\"Invalid value of operation in operations field: \" + ops);\n      return undefined;\n    }\n    const _ops = [...ops];\n    // @ts-ignore\n    return (x: OperationsCount) => _ops.reduce<number>((prev, cur) => prev + x[cur], 0);\n  }\n  console.warn(\"Invalid operations field\");\n  return undefined;\n}\n\n/**\n * Creates a OperationsCounter function with the given operations to indicate (returns +1 for present operations, 0 for\n * absent ones).\n *\n * @param ops operations to be searched for, expected to be a string or an array of string, each string must be supported\n * operation type\n * @return created indicator or undefined if ops is invalid\n */\nexport const createOperationsIndicator = (ops: any): OperationsCounter | undefined => {\n  if (typeof ops === \"string\") {\n    if (OperationsTypes.indexOf(ops) === -1) {\n      console.warn(\"Invalid value of operations field: \" + ops);\n      return undefined;\n    }\n    // @ts-ignore\n    return (x: OperationsCount) => Math.sign(x[ops]);\n  }\n  else if (Array.isArray(ops)) {\n    if (ops.some(op => OperationsTypes.indexOf(op) === -1)) {\n      console.warn(\"Invalid value of operation in operations field: \" + ops);\n      return undefined;\n    }\n    const _ops = [...ops];\n    // @ts-ignore\n    return (x: OperationsCount) => _ops.reduce<number>((prev, cur) => prev + Math.sign(x[cur]), 0);\n  }\n  console.warn(\"Invalid operations field\");\n  return undefined;\n}\n\nexport const getDescription = (ruleDef: any): string => {\n  return ruleDef.description ? ` (${ruleDef.description})` : \"\";\n}\n\n/**\n * Creates an OperationRule for total count of given operations.\n *\n * @param ruleDef definition of the rule. Expected to contain \"count\" (number/count object) field. If the optional \"unique\" (boolean)\n * field is true, the created rule counts occurrences of operations as 0/1. If the \"description\" (string) is set, it is\n * appended to the returning error description.\n * @param ops operations to count\n */\nexport const createCountOperationRule = (ruleDef: any, ops: string[]): OperationRule | undefined => {\n  const unique = ruleDef.unique === true;\n  const comparator = createCountComparator(ruleDef.count);\n  const counter = unique ? createOperationsIndicator(ops) : createOperationsCounter(ops);\n  if (comparator !== undefined && counter !== undefined) {\n    return (x: OperationsCount) => {\n      const result = comparator(counter(x));\n      if (result === \"\") {\n        return \"OK\";\n      }\n      return `${unique ? 'Unique count' : 'Count'} of operations \"${ops.join(', ')}\": ${result}${getDescription(ruleDef)}`;\n    };\n  }\n}\n\n/**\n * Creates an OperationRule for counts of each from given operations.\n *\n * @param ruleDef definition of the rule. Expected to contain \"each\" (number/count object) field. If the \"description\" (string) is set, it is\n * appended to the returning error description.\n * @param ops operations to count\n */\nexport const createEachOperationRule = (ruleDef: any, ops: string[]): OperationRule | undefined => {\n  const subRules: OperationRule[] = [];\n  // @ts-ignore\n  ops.forEach((op: string) => {\n    const comparator = createCountComparator(ruleDef.each);\n    const counter = createOperationsCounter(op);\n    if (comparator !== undefined && counter !== undefined) {\n      const subRule = (x: OperationsCount) => {\n        const result = comparator(counter(x));\n        if (result === \"\") {\n          return \"OK\";\n        }\n        return `${op}: ${result}`;\n      };\n      subRules.push(subRule);\n    }\n  });\n  if (subRules.length > 0) {\n    return (x: OperationsCount) => {\n      const errors = subRules.map(sr => sr(x)).filter(msg => msg !== \"OK\").join(',\\n - ');\n      if (errors === \"\") {\n        return \"OK\";\n      }\n      return `Count of each operation \"${ops.join(', ')}\"${getDescription(ruleDef)}:\\n - ${errors}`;\n    };\n  }\n}\n\n/**\n * Creates a TableRule.\n *\n * @param ruleDef definition of the rule. Expected to contain \"tables\" (number/count object) field. If the \"description\" (string) is set, it is\n * appended to the returning error description.\n */\nexport const createTableRule = (ruleDef: any): TableRule | undefined => {\n  const comparator = createCountComparator(ruleDef.tables);\n  if (comparator !== undefined) {\n    return (x: number) => {\n      const result = comparator(x);\n      if (result === \"\") {\n        return \"OK\";\n      }\n      return `Count of tables: ${result}${getDescription(ruleDef)}`;\n    };\n  }\n}\n\n/**\n * Creates a QueryRule.\n *\n * @param ruleDef definition of the rule. Expected to contain \"queries\" (number/count object) field. If the \"description\" (string) is set, it is\n * appended to the returning error description.\n */\nexport const createQueryRule = (ruleDef: any): QueryRule | undefined => {\n  const comparator = createCountComparator(ruleDef.queries);\n  if (comparator !== undefined) {\n    return (x: number) => {\n      const result = comparator(x);\n      if (result === \"\") {\n        return \"OK\";\n      }\n      return `Count of queries: ${result}${getDescription(ruleDef)}`;\n    };\n  }\n}\n\n/**\n * Modifies given name of source project to report name.\n */\nexport type ReportNameModifier = (name: string) => string;\n\nconst removeExtension = (name: string) => {\n  const lastDotIndex = name.lastIndexOf('.');\n  return (lastDotIndex > -1 ? name.slice(0, lastDotIndex) : name);\n};\n\nexport const identityReportNameModifier = (name: string) => {\n  return removeExtension(name) + '.txt';\n};\n\n/**\n * Creates ReportNameModifier which given path parts joined with given joiner.\n * The config can specified the following fields:\n * * usePathParts if the array is empty, all path parts are used\n * * joinPathParts if the string is undefined, original path joiners are kept\n * * prefix string to prepend to the name\n * * suffix string to append to the name\n */\nexport const createReportNameModifier = (config: any): ReportNameModifier => {\n  let modifier = removeExtension;\n\n  let usePathParts: number[] = [];\n  let joinPathParts: string | undefined = undefined;\n  let prefix: string = \"\";\n  let suffix: string = \"\";\n\n  for (const fieldName in config) {\n    const field = config[fieldName];\n    if (fieldName === \"usePathParts\" && Array.isArray(field) && field.every(n => typeof n === \"number\")) {\n      usePathParts = field;\n      continue;\n    }\n    if (fieldName === \"joinPathParts\" && typeof field === \"string\") {\n      joinPathParts = field;\n      continue;\n    }\n    if (fieldName === \"prefix\" && typeof field === \"string\") {\n      prefix = field;\n      continue;\n    }\n    if (fieldName === \"suffix\" && typeof field === \"string\") {\n      suffix = field;\n    }\n  }\n\n  if (usePathParts.length > 0) {\n    const previousModifier = modifier;\n    modifier = (name) => {\n      const parts = previousModifier(name).split(/[/\\\\]/g);\n      const count = parts.length;\n      return parts.filter((part, i) => usePathParts.includes(count - i)).join('/');\n    }\n  }\n\n  if (joinPathParts !== undefined) {\n    const previousModifier = modifier;\n    // @ts-ignore\n    modifier = (name) => previousModifier(name).replace(/[/\\\\]/g, joinPathParts);\n  }\n\n  return (name) => prefix + modifier(name) + suffix + '.txt';\n}\n","import {FileDialog} from \"../utils/fileDialog\";\nimport JSZip from \"jszip\";\nimport {saveAs} from \"file-saver\";\nimport {Relation} from \"../relation/relation\";\nimport {isProjectObject, Project} from \"../project/project\";\nimport {ExprParser} from \"../expression/exprParser\";\nimport {StoredRelation, StoredRelationData} from \"../relation/storedRelation\";\nimport {Expression} from \"../expression/expression\";\nimport {MessageBox} from \"../components/messageBox\";\nimport {\n  addOperations,\n  binaryOperations,\n  OperationsCount,\n  operationsOfTree,\n  totalOperations,\n  unaryOperations,\n  zeroOperations\n} from \"./operationsCount\";\nimport {\n  createCountOperationRule,\n  createEachOperationRule,\n  createQueryRule,\n  createReportNameModifier,\n  createTableRule,\n  identityReportNameModifier,\n  OperationRule,\n  QueryRule,\n  ReportNameModifier,\n  TableRule\n} from \"./configUtils\";\nimport {language} from \"../language/language\";\n\n/**\n * Class for processing multiple input .rachel project files and generating their reports.\n * @category Batch\n * @public\n */\nexport class BatchProcessor {\n\n  private static loadType: \"files\" | \"zip\" = \"zip\";\n  private static resultFilename: string = \"rachel-eval-results\";\n  private static configurationFileName: string | null = null;\n  private static reportNameModifier: ReportNameModifier = identityReportNameModifier;\n  private static operationRules: OperationRule[] = [];\n  private static tableRules: TableRule[] = [];\n  private static queryRules: QueryRule[] = [];\n\n  /**\n   * Opens file dialog and loads configuration from a JSON file.\n   *\n   * @return promise with string description of the loaded configuration\n   * @public\n   */\n  public static config(): Promise<string> {\n    return new Promise<string>((resolve, reject) => {\n      FileDialog.openFile(\".json\").then(file => {\n        if (file.text === null) {\n          return reject('No content read from the configuration file ' + file.name);\n        } else if (file.name.match(/\\.json$/)) {\n          BatchProcessor.loadType = \"zip\";\n          BatchProcessor.configurationFileName = file.name;\n          BatchProcessor.reportNameModifier = identityReportNameModifier;\n          BatchProcessor.operationRules = [];\n          BatchProcessor.tableRules = [];\n          BatchProcessor.queryRules = [];\n          try {\n            const config = JSON.parse(file.text);\n            let loaded = 0;\n            let skipped = 0;\n            for (const ruleName in config) {\n              const rule = config[ruleName];\n              // sets loading type\n              if (ruleName === \"loadType\" && typeof rule === \"string\" && (rule === \"zip\" || rule === \"files\")) {\n                BatchProcessor.loadType = rule;\n                continue;\n              }\n              // sets result zip file name\n              if (ruleName === \"resultFilename\" && typeof rule === \"string\") {\n                BatchProcessor.resultFilename = rule;\n                continue;\n              }\n              // sets result zip file name\n              if (ruleName === \"reportName\") {\n                BatchProcessor.reportNameModifier = createReportNameModifier(rule);\n                continue;\n              }\n              if (BatchProcessor.createRule(ruleName, rule)) {\n                ++loaded;\n              } else {\n                ++skipped;\n              }\n            }\n            return resolve(loaded + ' rules loaded from the configuration file, ' + skipped + ' skipped');\n          } catch (e) {\n            return reject('Invalid configuration file ' + file.name + ': ' + e);\n          }\n        } else {\n          return reject('Unsupported type of the configuration file ' + file.name);\n        }\n      });\n    });\n  }\n\n  /**\n   * Returns formatted information about current loaded config file and its rules.\n   *\n   * @return string information\n   */\n  public static getConfigInfo(): string {\n    if (BatchProcessor.configurationFileName !== null) {\n      const msg = language().managementSection.batchConfigInfo;\n      return msg[0] + BatchProcessor.configurationFileName + msg[1] +\n        (BatchProcessor.operationRules.length + BatchProcessor.tableRules.length + BatchProcessor.queryRules.length) + msg[2];\n    }\n    return language().managementSection.batchNoConfig;\n  }\n\n  /**\n   * Creates individual rule object and adds it in BatchProcessor rules array.\n   *\n   * @param ruleName name of the rule\n   * @param ruleDef rule definition from the configuration JSON file\n   * @return true if the rule was created successfully\n   */\n  private static createRule(ruleName: string, ruleDef: any): boolean {\n    const fields: string[] = [];\n    for (const field in ruleDef) {\n      fields.push(field);\n    }\n    if (fields.length === 0) {\n      console.log(\"Rule \" + ruleName + \" has no fields specified.\");\n      return false;\n    }\n    // case of an operation rule\n    if (fields.indexOf(\"operations\") > -1) {\n      const ops: string[] = Array.isArray(ruleDef.operations) ? ruleDef.operations : [ruleDef.operations];\n      // creates a rule for a total count of all listed operations together\n      if (fields.indexOf(\"count\") > -1) {\n        const rule = createCountOperationRule(ruleDef, ops);\n        if (rule !== undefined) {\n          BatchProcessor.operationRules.push(rule);\n          return true;\n        }\n      }\n      // creates a rule for a count of each listed operation\n      else if (fields.indexOf(\"each\") > -1) {\n        const rule = createEachOperationRule(ruleDef, ops);\n        if (rule !== undefined) {\n          BatchProcessor.operationRules.push(rule);\n          return true;\n        }\n      }\n      return false;\n    }\n    // case of a table rule\n    else if (fields.indexOf(\"tables\") > -1) {\n      const rule = createTableRule(ruleDef);\n      if (rule !== undefined) {\n        BatchProcessor.tableRules.push(rule);\n        return true;\n      }\n    }\n    // case of a query rule\n    else if (fields.indexOf(\"queries\") > -1) {\n      const rule = createQueryRule(ruleDef);\n      if (rule !== undefined) {\n        BatchProcessor.queryRules.push(rule);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Opens file dialog and processes project files selected by the user.\n   * If the configuration is set to use multiple files, lets the user select multiple .rachel files.\n   * If the configuration is set to use a zip file, lets the user select one zip file with .rachel files.\n   * For each .rachel file creates a textual evaluation report.\n   *\n   * @public\n   */\n  public static process(): void {\n    if (BatchProcessor.loadType === \"files\") {\n      FileDialog.openFiles(\".rachel\").then(files => BatchProcessor.processFiles(files));\n    } else {\n      FileDialog.openZip()\n        .then(result => JSZip.loadAsync(result, {createFolders: true}))\n        .then(zip => {\n          // final array of unzipped files\n          const files: { name: string, text: string }[] = [];\n          // uses only .rachel files in a ZIP\n          const zippedFiles = Object.values(zip.files).filter(file => !file.dir);\n          const count = zippedFiles.length;\n          zippedFiles.forEach(zippedFile => {\n            zippedFile.async(\"string\").then(text => {\n              files.push({name: zippedFile.name, text});\n              // if all files are unzipped, processes them\n              if (files.length === count) {\n                BatchProcessor.processFiles(files);\n              }\n            });\n          });\n        })\n        .catch(_ => {\n          console.warn(\"Error in loading a zip file.\");\n          MessageBox.error(\"Error in loading a zip file.\");\n        });\n    }\n  }\n\n  /**\n   * For each given file creates a report.\n   *\n   * @param files loaded textual files expected to be .rachel project files\n   */\n  private static processFiles = (files: { name: string, text: string | null }[]) => {\n    console.log(files.length + ' files loaded to BatchProcessor');\n    console.time(\"Batch duration\");\n\n    let reports: { name: string, text: string }[] = [];\n    let processed: number = 0;\n    let skipped: number = 0;\n\n    /**\n     * Processes a file on the given index and calls the processing of the next file.\n     * If all files were processed, calls downloadReports().\n     */\n    const processNext = (i: number) => {\n      if (i >= files.length) {\n        return downloadReports();\n      }\n      const file = files[i];\n      const name = BatchProcessor.reportNameModifier(file.name);\n      if (file.text === null) {\n        skipped += 1;\n        console.warn('Null read from ' + file.name);\n      } else if (file.name.match(/\\.rachel$/)) {\n        // @ts-ignore - file.text cannot be null now\n        const report = BatchProcessor.processFile(file, name);\n        reports.push(report);\n        processed += 1;\n      } else {\n        skipped += 1;\n        console.warn('Unsupported filetype: ' + file.name);\n      }\n      MessageBox.message(\"Batch in progress... \" + (processed + skipped) + \"/\" + files.length);\n      setTimeout(() => processNext(i + 1), 0);\n    }\n\n    /**\n     * Downloads created reports.\n     */\n    const downloadReports = () => {\n      const zip: JSZip = JSZip();\n      reports.forEach(report => {\n        zip.file(report.name, report.text);\n      })\n      zip.generateAsync({type: \"blob\"}).then(content => {\n        saveAs(content, BatchProcessor.resultFilename + \".zip\");\n        console.log(\"Batch finished: \" + processed + \" files processed, \" + skipped + \" skipped.\");\n        MessageBox.message(\"Batch finished: \" + processed + \" files processed, \" + skipped + \" skipped.\");\n      }).catch(err => {\n        MessageBox.error(\"Batch results saving error: \" + err.message);\n      });\n      console.timeEnd(\"Batch duration\");\n    }\n\n    processNext(0);\n  }\n\n  /**\n   * Tries to parse Project object from given file.text. If successful, parses relations in the project, evaluates\n   * expressions in the project and generates textual report: header (see reportHeader()),\n   * formatted relations (see formatRelations()) and formatted expressions (see processExpression()).\n   *\n   * @param file JSON file to process (its name and text)\n   * @param name name of the generated report\n   * @throws SyntaxError when the given file content is not a valid JSON\n   */\n  private static processFile = (file: { name: string, text: string }, name: string): { name: string, text: string } => {\n    let project: Project;\n    try {\n      project = JSON.parse(file.text);\n      const status = isProjectObject(project);\n      if (status !== \"OK\") {\n        return {name, text: \"Invalid JSON file: \" + status};\n      }\n    }\n    catch (e) {\n      console.warn('Batch processing error in file ' + file.name + ': ' + e);\n      return {name, text: \"Invalid JSON file: \" + e};\n    }\n\n    const relations: Map<string, Relation> = BatchProcessor.parseRelations(project.relations, project.nullValuesSupport);\n    const exprParser: ExprParser = new ExprParser(relations, project.nullValuesSupport);\n\n    const exprCount: number = project.expressions.length;\n    const reports = project.expressions.map(e => BatchProcessor.processExpression(e, exprParser));\n    const ops: OperationsCount = addOperations(...reports.map(r => r.counts));\n    const errors: number = reports.reduce((agg, report) => agg + report.error, 0);\n\n    return {\n      name,\n      text: BatchProcessor.reportHeader(file.name, project.relations.length, exprCount, errors, ops, project.nullValuesSupport) +\n        BatchProcessor.formatRelations(project.relations) +\n        sectionLine + \"\\n\\nQUERIES (\" + exprCount + \")\\n\\n\" +\n        reports.map(r => r.text).join('') + sectionLine + '\\n\\n'\n    };\n  }\n\n  /**\n   * Creates Relation representation for given StoredRelationData array.\n   */\n  private static parseRelations(storedData: StoredRelationData[], nullValuesSupport: boolean): Map<string, Relation> {\n    const map: Map<string, Relation> = new Map();\n    storedData.forEach(data => {\n      try {\n        const storedRelation: StoredRelation = StoredRelation.fromData(data, nullValuesSupport);\n        if (storedRelation.isValid()) {\n          map.set(storedRelation.getName(), storedRelation.createRelation());\n        }\n      } catch (ignored) {\n      }\n    });\n    return map;\n  }\n\n  /**\n   * Processes the given expression in the context of the given parser. Returns a formatted expression and its result\n   * (or error), a count of used RA operations and 0/1 error indicator.\n   */\n  private static processExpression = (expr: Expression, parser: ExprParser): { text: string, counts: OperationsCount, error: number } => {\n    try {\n      const evaluationTree = parser.parse(expr.text);\n      const counts: OperationsCount = operationsOfTree(evaluationTree);\n      const relation: Relation = evaluationTree.getResult();\n      return {\n        text: contentLine + '\\n' + expr.name + '\\n\\n' + expr.text + '\\n\\n' + relation.contentString() + '\\n\\n\\n',\n        counts: counts,\n        error: 0\n      };\n    } catch (err) {\n      return {\n        text: contentLine + '\\n' + expr.name + '\\n\\n' + expr.text + '\\n\\nERROR: ' + err.message + '\\n\\n\\n',\n        counts: zeroOperations(),\n        error: 1\n      };\n    }\n  }\n\n  /**\n   * Creates the header of the report. The header contains the time of the report, count of expressions and errors,\n   * count of used operations and null values support info.\n   *\n   * @param name name of the processed file\n   * @param rels count of relations\n   * @param exprs count of expressions\n   * @param errs count of errors\n   * @param ops count of operations\n   * @param nvs whether null values are supported\n   */\n  private static reportHeader = (name: string, rels: number, exprs: number, errs: number, ops: OperationsCount, nvs: boolean): string => {\n    const total: number = totalOperations(ops);\n    const binary: number = binaryOperations(ops);\n    const unary: number = unaryOperations(ops);\n    let ruleErrors: string[] = BatchProcessor.operationRules.map(rule => rule(ops));\n    ruleErrors.push(...BatchProcessor.tableRules.map(rule => rule(rels)));\n    ruleErrors.push(...BatchProcessor.queryRules.map(rule => rule(exprs)));\n    const rulesCount = ruleErrors.length;\n    ruleErrors = ruleErrors.filter(msg => msg !== \"OK\");\n    const errorsCount = ruleErrors.length;\n    return sectionLine + '\\n\\nRachel project report from ' + new Date().toLocaleString('cs-CZ') + '\\nSource: ' +\n      name + '\\n\\n' + sectionLine + '\\n\\nQueries: ' + exprs + '    Invalid queries: ' + errs + '\\n\\n' +\n      (errorsCount === 0 ? 'No errors' : 'Errors (' + errorsCount + ' errors/' + rulesCount + ' rules):\\n' +\n        ruleErrors.map((err, i) => `${i + 1}) ${err}`).join('\\n')) + '\\n\\n' +\n      'Used operations (' + total + ' in total: ' + binary + ' binary, ' + unary + ' unary):\\n' +\n      '    Selection: ' + ops.selection + '\\n' +\n      '    Projection: ' + ops.projection + '\\n' +\n      '    Rename: ' + ops.rename + '\\n\\n' +\n      '    Union: ' + ops.union + '\\n' +\n      '    Intersection: ' + ops.intersection + '\\n' +\n      '    Difference: ' + ops.difference + '\\n\\n' +\n      '    Natural join: ' + ops.natural + '\\n' +\n      '    Cartesian product: ' + ops.cartesian + '\\n' +\n      '    Semijoin: ' + ops.semijoin + '\\n' +\n      '    Antijoin: ' + ops.antijoin + '\\n' +\n      '    Theta Join: ' + ops.thetaJoin + '\\n' +\n      '    Theta Semijoin: ' + ops.thetaSemijoin + '\\n\\n' +\n      '    Outer Join: ' + ops.outerJoin + '\\n\\n' +\n      '    Division: ' + ops.division + '\\n\\n' +\n      'Null values ' + (nvs ? 'ALLOWED.\\n\\n' : 'FORBIDDEN.\\n\\n');\n  }\n\n  /**\n   * Returns formatted string for the given StoredRelationsData array.\n   */\n  private static formatRelations = (storedData: StoredRelationData[]): string => {\n    const inlines = storedData.map(data => {\n      return data.name + \"(\" + data.columnNames.join(\", \") + \")\\n\"\n    }).join('');\n    return sectionLine + \"\\n\\nTABLES (\" + storedData.length + \")\\n\\n\" + inlines + \"\\n\" +\n      storedData.map(data => contentLine + \"\\n\" + data.name + '\\n\\n' + StoredRelation.format(data)).join('');\n  }\n}\n\nconst sectionLine: string = \"################################################################################\";\nconst contentLine: string = \"--------------------------------------------------------------------------------\";\n","import React from \"react\";\nimport './css/editRelationTable.css';\nimport {StoredRelation} from \"../relation/storedRelation\";\nimport {SupportedColumnType} from \"../relation/columnType\";\nimport {NNToSMap} from \"../types/nnToSMap\";\n\n/**\n * Props of EditRelationTable component.\n * @category Components\n * @public\n */\ninterface EditRelationTableProps {\n    /**\n     * stored representation of the relation to be edited\n     * @type StoredRelation\n     * @public\n     */\n    relation: StoredRelation,\n    /**\n     * handler of column name change\n     * @type function\n     * @public\n     */\n    onColumnNameChange: (columnName: string, columnIndex: number) => void,\n    /**\n     * handler of column type change\n     * @type function\n     * @public\n     */\n    onColumnTypeChange: (columnType: SupportedColumnType, columnIndex: number) => void,\n    /**\n     * handler of row input change\n     * @type function\n     * @public\n     */\n    onRowInputChange: (input: string, columnIndex: number, rowIndex: number) => void,\n    /**\n     * handler of adding new row\n     * @type function\n     * @public\n     */\n    onNewRow: (onDone: () => void) => void,\n    /**\n     * handler of adding new column\n     * @type function\n     * @public\n     */\n    onNewColumn: (onDone: () => void) => void,\n    /**\n     * handler of deleting the row of given index\n     * @type function\n     * @public \n     */\n    onDeleteRow: (rowIndex: number) => void,\n    /**\n     * handler of deleting the column of given index\n     * @type function\n     * @public\n     */\n    onDeleteColumn: (columnIndex: number) => void,\n    /**\n     * handler of input with Ctrl key\n     * @type function\n     * @public \n     */\n    onCtrlInput: (ev: React.KeyboardEvent) => void\n}\n\ninterface EditRelationTableState {\n    selectedColumn: number | undefined,\n    selectedRow: \"names\" | \"types\" | number | undefined\n}\n\n// @ts-ignore\nconst cssConstants: CSSStyleDeclaration = getComputedStyle(document.querySelector(':root'));\nconst cellPaddingSides: number = Number(cssConstants.getPropertyValue('--cell-padding-sides-num'));\nconst inputMarginSides: number = Number(cssConstants.getPropertyValue('--input-margin-sides-num'));\n\n/**\n * Table for editing a relation relation. It supports adding new columns and rows and editing all relation (column names,\n * column types and row inputs).\n * Accepts {@link EditRelationTableProps} props.\n * @category Components\n * @public\n */\nexport class EditRelationTable extends React.Component<EditRelationTableProps, EditRelationTableState> {\n    // reference to the table container div\n    private readonly containerRef: React.RefObject<HTMLDivElement>;\n    // reference to the head row with columns names\n    private readonly tableHeadRowRef: React.RefObject<HTMLTableRowElement>;\n    // width of cells in head (with deducted padding) to set proper inputs width to not resize the table\n    private columnWidths: number[] = [];\n\n    constructor(props: EditRelationTableProps) {\n        super(props);\n        this.state = {\n            selectedColumn: undefined,\n            selectedRow: undefined\n        }\n        this.containerRef = React.createRef<HTMLDivElement>();\n        this.tableHeadRowRef = React.createRef<HTMLTableRowElement>();\n    }\n\n    componentDidMount() {\n        // clicking in the window blurs the selected input (if clicked into a cell, event propagation is stopped to not blur\n        window.addEventListener('click', () => {\n            this.setSelectedInput(undefined, undefined);\n        });\n        this.componentDidUpdate();\n    }\n\n    componentDidUpdate() {\n        const headRow = this.tableHeadRowRef.current;\n        if (headRow !== null) {\n            // cells without the first (line number) and last (add column button)\n            const cells = [...headRow.cells].slice(1, -1);\n            this.columnWidths = cells.map(cell => cell.clientWidth - 2 * (cellPaddingSides + inputMarginSides));\n        }\n    }\n\n    /**\n     * Changes column width if the resized input element does not fit in it anymore.\n     */\n    private handleInputResize = (inputElement: EventTarget & HTMLInputElement, column: number) => {\n        // handles larger width\n        if (inputElement.scrollWidth > this.columnWidths[column]) {\n            this.columnWidths[column] = inputElement.scrollWidth;\n        }\n    }\n\n    /**\n     * Returns error of the relation to edit.\n     */\n    private getErrors = (): NNToSMap => {\n        return this.props.relation.getErrors();\n    }\n\n    /**\n     * Sets selected input column and row to given values.\n     */\n    private setSelectedInput = (column: number | undefined, row: \"names\" | \"types\" | number | undefined): void => {\n        this.setState({\n            selectedColumn: column,\n            selectedRow: row\n        });\n    }\n\n    /**\n     * Moves selected input to right if it is defined and not in the last column.\n     */\n    private moveSelectedInputRight = (): void => {\n        const selectedColumn = this.state.selectedColumn;\n        const selectedRow = this.state.selectedRow;\n        if (selectedColumn !== undefined && selectedRow !== undefined) {\n            // if not last column was selected\n            if (selectedColumn < this.props.relation.getColumnCount() - 1) {\n                this.setState({selectedColumn: selectedColumn + 1});\n            }\n        }\n    }\n\n    /**\n     * Moves selected input to left if it is defined and not in the first column.\n     */\n    private moveSelectedInputLeft = (): void => {\n        const selectedColumn = this.state.selectedColumn;\n        const selectedRow = this.state.selectedRow;\n        if (selectedColumn !== undefined && selectedRow !== undefined) {\n            // if not first column was selected\n            if (selectedColumn > 0) {\n                this.setState({selectedColumn: selectedColumn - 1});\n            }\n        }\n    }\n\n    /**\n     * Moves selected input up if it is defined and not in the first row.\n     */\n    private moveSelectedInputUp = (): void => {\n        const selectedColumn = this.state.selectedColumn;\n        const selectedRow = this.state.selectedRow;\n        if (selectedColumn !== undefined && selectedRow !== undefined) {\n            // if not first row was selected\n            if (typeof selectedRow === \"number\") {\n                if (selectedRow === 0) {\n                    this.setState({selectedRow: \"names\"});\n                }\n                else {\n                    this.setState({selectedRow: selectedRow - 1});\n                }\n            }\n        }\n    }\n\n    /**\n     * Moves selected input down if it is defined and not in the last row.\n     */\n    private moveSelectedInputDown = (): void => {\n        const selectedColumn = this.state.selectedColumn;\n        const selectedRow = this.state.selectedRow;\n        if (selectedColumn !== undefined && selectedRow !== undefined) {\n            if (selectedRow === \"names\" && this.props.relation.getRowCount() > 0) {\n                this.setState({selectedRow: 0});\n            }\n            // if not last row was selected\n            if (typeof selectedRow === \"number\" && selectedRow < this.props.relation.getRowCount() - 1) {\n                this.setState({selectedRow: selectedRow + 1});\n            }\n        }\n    }\n\n    /**\n     * Catches key inputs with special effects in tht table.\n     */\n    private handleKeyDown = (event: React.KeyboardEvent): void => {\n        if (event.key === \"Enter\" || event.key === \"Esc\" || event.key === \"Escape\") {\n            this.setSelectedInput(undefined, undefined);\n        }\n        else if (event.key === \"Tab\" || (event.ctrlKey && event.key === \"ArrowRight\")) {\n            this.moveSelectedInputRight();\n            event.preventDefault();\n        }\n        else if (event.ctrlKey && event.key === \"ArrowLeft\") {\n            this.moveSelectedInputLeft();\n            event.preventDefault();\n        }\n        else if (event.ctrlKey && event.key === \"ArrowUp\") {\n            this.moveSelectedInputUp();\n            event.preventDefault();\n        }\n        else if (event.ctrlKey && event.key === \"ArrowDown\") {\n            this.moveSelectedInputDown();\n            event.preventDefault();\n        }\n        if (event.ctrlKey) {\n            this.props.onCtrlInput(event);\n        }\n    }\n\n    /**\n     * Passes the change of the column name, column type or row input to the parent element.\n     * When row = \"types\", it is expected that value is of SupportedColumnType type.\n     * Tabulators are replaced by 4 spaces.\n     */\n    private handleChange = (value: string, column: number, row: \"names\" | \"types\" | number): void => {\n        value = value.replace(/\\t/g, \"    \");\n        if (row === \"names\") {\n            this.props.onColumnNameChange(value, column);\n        }\n        else if (row === \"types\") {\n            // @ts-ignore - should be ensured before method call\n            this.props.onColumnTypeChange(value, column);\n        }\n        else {\n            this.props.onRowInputChange(value, column, row);\n        }\n    }\n\n    /**\n     * Adds a new column to the relation and scrolls to it.\n     */\n    private handleNewColumn = (): void => {\n        this.props.onNewColumn(() => {\n            // @ts-ignore\n            this.containerRef.current.scrollTo(this.containerRef.current.clientWidth, this.containerRef.current.scrollTop)\n        });\n    }\n\n    /**\n     * Adds a new row to the relation and scrolls to it.\n     */\n    private handleNewRow = (): void => {\n        this.props.onNewRow(() => {\n            // @ts-ignore\n            this.containerRef.current.scrollTo(this.containerRef.current.scrollLeft, this.containerRef.current.clientHeight)\n        });\n    }\n\n    /**\n     * Deletes the column at given index.\n     */\n    private handleDeleteColumn = (column: number): void => {\n        this.props.onDeleteColumn(column);\n    }\n\n    /**\n     * Deletes the row at given index.\n     */\n    private handleDeleteRow = (row: number): void => {\n        this.props.onDeleteRow(row);\n    }\n\n    /**\n     * Creates a text input bind to handling change of given column and row.\n     */\n    private createInput = (value: string, column: number, row: \"names\" | \"types\" | number) => {\n        return (\n            <input\n                type='text'\n                className={'text-input'}\n                spellCheck={false}\n                value={value}\n                onChange={(e) => {\n                    this.handleChange(e.target.value, column, row);\n                    this.handleInputResize(e.target, column);\n                }}\n                autoFocus={true}\n                style={{width: this.columnWidths[column] + \"px\"}}\n            />\n        )\n    }\n\n    /**\n     * Creates a tooltip with given text.\n     */\n    private createTooltip(text: string, style?: React.CSSProperties) {\n        return (<span className={\"tooltip\"} style={style}>{text}</span>)\n    }\n\n    /**\n     * Creates a button for deleting rows or columns.\n     */\n    private createDeleteButton = (callback: () => void) => {\n        return (<button className=\"delete-row-or-column-button\" onClick={callback}>&#10006;</button>);\n    }\n\n    /**\n     * Creates content of the first row of the table with column names.\n     * If the table is editable, additional blank column is added for \"add column\" button in next rows.\n     */\n    private createNamesRow() {\n        const rowData = this.props.relation.getColumnNames().map((columnName, columnIndex) => {\n            let content: string | JSX.Element = columnName;\n            if (this.state.selectedColumn === columnIndex && this.state.selectedRow === \"names\") {\n                content = this.createInput(columnName, columnIndex, \"names\");\n            }\n            let span: null | JSX.Element = null;\n            let className: string = \"name-th\";\n            const error = this.getErrors().get(\"name\", columnIndex);\n            if (error !== undefined) {\n                span = this.createTooltip(error, {top: \"90%\", bottom: \"auto\"});\n                className += \" error-input\";\n            }\n            return (\n                <th key={columnIndex}\n                    className={className}\n                    onClick={ev => {\n                        this.setSelectedInput(columnIndex, \"names\");\n                        ev.stopPropagation();\n                    }}\n                >{content}{span}</th>\n            )});\n        // pushes \"add column\" button in last column\n        rowData.push(\n            <td key='add-column'\n                rowSpan={2}\n                style={{width: \"24px\", border: \"none\", padding: \"1px\"}}>\n                <button onClick={this.handleNewColumn}\n                    style={{width: \"100%\", height: \"100%\"}}><strong>+</strong></button>\n            </td>);\n        return (\n            <><td className=\"row-number-td\"/>{rowData}</>\n        );\n    }\n\n    /**\n     * Creates content of the second row of the table with column types.\n     * If the table is editable, \"add column\" button is added in the last column with row span to the end of the table.\n     */\n    private createTypesRow() {\n        const rowData = this.props.relation.getColumnTypes().map((columnType, columnIndex) => {\n            const content = (\n                <select value={columnType}\n                    onChange={(e) => this.handleChange(e.target.value, columnIndex, \"types\")}>\n                    <option>number</option>\n                    <option>string</option>\n                    <option>boolean</option>\n                </select>\n            );\n            return (\n                <th key={columnIndex}\n                    className=\"type-th\"\n                >{content}{this.createDeleteButton(() => this.handleDeleteColumn(columnIndex))}</th>\n            )});\n        return (\n            <><td className=\"row-number-td\"/>{rowData}</>\n        );\n    }\n\n    /**\n     * Creates a data rows of the table.\n     */\n    private createRows() {\n        // creates default row if no exists\n        if (this.props.relation.getRows().length === 0) {\n            return null;\n        }\n        const rows: string[][] = this.props.relation.getRows();\n        // creates all rows if any\n        return rows.map((row, rowIndex) => (\n            <tr key={rowIndex}>\n                <td className=\"row-number-td\">\n                    {rowIndex + 1}\n                    {this.createDeleteButton(() => this.handleDeleteRow(rowIndex))}\n                </td>\n                {row.map((value, columnIndex) => {\n                    let content: string | JSX.Element = value;\n                    if (this.state.selectedColumn === columnIndex && this.state.selectedRow === rowIndex) {\n                        content = this.createInput(value, columnIndex, rowIndex);\n                    }\n                    let span: null | JSX.Element = null;\n                    let className: string = \"\";\n                    const error = this.getErrors().get(rowIndex, columnIndex);\n                    if (error !== undefined) {\n                        span = this.createTooltip(error);\n                        className = \"error-input\";\n                    }\n                    return (\n                        <td key={columnIndex}\n                            className={className}\n                            onClick={ev => {\n                                this.setSelectedInput(columnIndex, rowIndex);\n                                ev.stopPropagation();\n                            }}\n                        >{content}{span}</td>\n                    )})}\n            </tr>\n        ));\n    }\n\n    /**\n     * Creates the last row of the table with button for adding rows.\n     */\n    private createAddRow() {\n        return (\n            <tr key='add-row'>\n                <td key='add-row-column'\n                    className=\"add-row-td\">\n                    <button onClick={this.handleNewRow}><strong>+</strong></button>\n                </td>\n            </tr>\n        );\n    }\n\n    render() {\n        let divClassName: string = \"edit-table-container scrollbar-container\";\n        let tableClassName: string = \"edit-table\";\n\n        return (\n            <div\n                className={divClassName}\n                ref={this.containerRef}\n                onKeyDown={this.handleKeyDown}>\n                <table className={tableClassName}>\n                    <thead>\n                        <tr ref={this.tableHeadRowRef}>{this.createNamesRow()}</tr>\n                        <tr>{this.createTypesRow()}</tr>\n                    </thead>\n                    <tbody>\n                        {this.createRows()}\n                        {this.createAddRow()}\n                    </tbody>\n                </table>\n            </div>\n        );\n    }\n}","import React from \"react\";\nimport {Relation} from \"../relation/relation\";\nimport {TooltipButton} from \"./tooltipButton\";\nimport {SupportedColumnType} from \"../relation/columnType\";\nimport {EditRelationTable} from \"./editRelationTable\";\nimport {StoredRelation} from \"../relation/storedRelation\";\nimport {TextInput} from \"./textInput\";\nimport {isForbiddenRelationName} from \"../utils/keywords\";\nimport {StringUtils} from \"../utils/stringUtils\";\nimport {MessageBox} from \"./messageBox\";\nimport {LanguageDef} from \"../language/language\";\n\n/**\n * Props of RelationsSection component.\n * @category Components\n * @public\n */\ninterface RelationsSectionProps {\n    /**\n     * all stored relations\n     * @type StoredRelation[]\n     * @public\n     */\n    storedRelations: StoredRelation[],\n    /**\n     * index of the current selected relation\n     * @type number\n     * @public\n     */\n    storedRelationIndex: number,\n    /**\n     * all currently loaded relations in the application\n     * @type Relation[]\n     * @public\n     */\n    loadedRelations: Relation[],\n    /**\n     * handler of change of the name of the current selected relation\n     * @type function\n     * @public\n     */\n    onRelationNameChange: (newName: string) => void,\n    /**\n     * handler of change of the name of the column at given index in the current selected relation\n     * @type function\n     * @public\n     */\n    onColumnNameChange: (columnName: string, columnIndex: number) => void,\n    /**\n     * handler of change of the type of the column at given index in the current selected relation\n     * @type function\n     * @public\n     */\n    onColumnTypeChange: (columnType: SupportedColumnType, columnIndex: number) => void,\n    /**\n     * handler of change of the row input at given column/row index in the current selected relation\n     * @type function\n     * @public\n     */\n    onRowInputChange: (input: string, columnIndex: number, rowIndex: number) => void,\n    /**\n     * handler of adding a new row in the current selected relation\n     * @type function\n     * @public\n     */\n    onNewRow: (onDone: () => void) => void,\n    /**\n     * handler of adding a new column in the current selected relation\n     * @type function\n     * @public\n     */\n    onNewColumn: (onDone: () => void) => void,\n    /**\n     * handler of deleting the row on given index\n     * @type function\n     * @public\n     */\n    onDeleteRow: (rowIndex: number) => void,\n    /**\n     * handler of deleting the column on given index\n     * @type function\n     * @public\n     */\n    onDeleteColumn: (columnIndex: number) => void,\n    /**\n     * handler of selecting a different relation as current\n     * @type function\n     * @public\n     */\n    onSelectDifferentRelation: (newIndex: number) => void,\n    /**\n     * handler of moving a relation on a new position using drag and drop\n     * @type function\n     * @public\n     */\n    onDragRelation: (from: number, to: number) => void,\n    /**\n     * handler of creating a new relation\n     * @type function\n     * @public\n     */\n    onNewRelation: () => void,\n    /**\n     * handler of loading the current selected relation into the application\n     * @type function\n     * @public\n     */\n    onLoadRelation: (onDone: (msg: string) => void) => void,\n    /**\n     * handler of deleting the current stored relation\n     * @type function\n     * @public\n     */\n    onDeleteStoredRelation: () => void,\n    /**\n     * handler of reverting the current relation to its last saved (valid) state\n     * @type function\n     * @public\n     */\n    onRevertRelation: () => void,\n    /**\n     * handler of loading all valid relations into the application\n     * @type function\n     * @public\n     */\n    onLoadAllRelations: (onDone: (msg: string) => void) => void,\n    /**\n     * handler of deleting the loaded relations\n     * @type function\n     * @public\n     */\n    onRemoveLoadedRelations: (onDone: (msg: string) => void) => void,\n    /**\n     * handler of saving the stored relations into the files\n     * @type function\n     * @public\n     */\n    onExportRelations: (onDone: (msg: string) => void) => void,\n    /**\n     * handler of loading new relations from files\n     * @type function\n     * @public\n     */\n    onImportRelations: (onDone: (msg: string) => void) => void,\n    /**\n     * whether to support null values\n     * @type boolean\n     * @public\n     */\n    nullValuesSupport: boolean,\n    /**\n     * current application language\n     * @type LanguageDef\n     * @public\n     */\n    language: LanguageDef\n}\n\ninterface RelationsSectionState {\n    sectionClicked: boolean\n}\n\n/**\n * Identifier of elements drag-and-dropped from the RelationSection.\n */\nconst dndId: string = \"R\";\n\n/**\n * Section to type the RA expression. It contains textarea for relations definition and control buttons.\n * Accepts {@link RelationsSectionProps} props.\n * @category Components\n * @public\n */\nexport class RelationsSection extends React.Component<RelationsSectionProps, RelationsSectionState> {\n\n    constructor(props: RelationsSectionProps) {\n        super(props);\n        this.state = {\n            sectionClicked: false\n        }\n    }\n\n    /**\n     * Returns selected stored relation.\n     */\n    private getCurRel = (): StoredRelation => {\n        return this.props.storedRelations[this.props.storedRelationIndex];\n    }\n\n    /**\n     * Passes change to the parent element if isShowingStored = true. Otherwise, changes the state.loadedRelationIndex.\n     */\n    private handleSelectDifferentRelation(index: number): void {\n        this.props.onSelectDifferentRelation(index);\n    }\n\n    /**\n     * Passes change of the relation name to the parent element.\n     */\n    private handleRelationNameChange = (name: string) => {\n        this.props.onRelationNameChange(name);\n    }\n\n    /**\n     * Loads the selected relation to the application if there are no errors in it. Otherwise, displays a message to user.\n     */\n    private loadRelation = () => {\n        if (this.getCurRel().isValid()) {\n            this.props.onLoadRelation(MessageBox.message);\n        }\n        else {\n            MessageBox.error(\"Cannot use the invalid relation. Check errors and try again.\");\n        }\n    }\n\n    /**\n     * Passes the load all relations call to the parent.\n     */\n    private loadAllRelations = () => {\n        this.props.onLoadAllRelations(MessageBox.message);\n    }\n\n    /**\n     * Passes the export stored relations call to the parent.\n     */\n    private exportRelations = () => {\n        this.props.onExportRelations(MessageBox.message);\n    }\n\n    /**\n     * Passes the import stored relations call to the parent.\n     */\n    private importRelations = () => {\n        this.props.onImportRelations(MessageBox.message);\n    }\n\n    /**\n     * Passes the call to delete current selected stored relation.\n     */\n    private deleteRelation = () => {\n        this.props.onDeleteStoredRelation();\n    }\n\n    private revertRelation = () => {\n        this.props.onRevertRelation();\n    }\n\n    /**\n     * Passes the create new stored relation call to the parent.\n     */\n    private newRelation = () => {\n        this.props.onNewRelation();\n    }\n\n    /**\n     * Passes the remove loaded relations call to the parent.\n     */\n    private removeLoadedRelations = () => {\n        this.props.onRemoveLoadedRelations(MessageBox.message);\n    }\n\n    /**\n     * Handles input with Ctrl key pressed from relation table.\n     */\n    private handleCtrlInput = (event: React.KeyboardEvent) => {\n        if (event.key === \"Enter\") {\n            this.loadRelation();\n        }\n    }\n\n    /**\n     * Creates menu buttons. Buttons for relations with errors are highlighted.\n     */\n    private createRelationMenuButtons = () => {\n        return this.props.storedRelations.map((rel, i) => {\n            const className: string = (this.props.storedRelationIndex === i ? \"button-clicked\" : \"\");\n            const actuality: string = rel.isActual() ? \"\" : \"*\";\n            const style = rel.isValid() ? {} : {border: \"2px solid #fd3030\"};\n            return (\n                <button\n                    key={i}\n                    onClick={() => this.handleSelectDifferentRelation(i)}\n                    className={className}\n                    style={style}\n                    draggable={true}\n                    onDragStart={e => e.dataTransfer.setData(\"text/plain\", dndId + String(i))}\n                    onDragOver={e => e.preventDefault()}\n                    onDrop={e => this.handleDragDrop(e, i)}\n                >{actuality + rel.getName()}</button>\n            );\n        });\n    }\n\n    /**\n     * Requests relation move when the drag ends.\n     */\n    // @ts-ignore\n    private handleDragDrop = (e: DragEvent<HTMLDivElement>, i: number) => {\n        e.preventDefault();\n        const data = e.dataTransfer.getData(\"text/plain\");\n        const fromIndex = Number(data.slice(1));\n        if (data.charAt(0) === dndId && !isNaN(fromIndex)) {\n            this.props.onDragRelation(fromIndex, i);\n        }\n    }\n\n    public render() {\n        const lang = this.props.language.relationSection;\n\n        const createButton = (text: string, onClick: () => void, tooltip: string, style?: React.CSSProperties) => {\n            return (<TooltipButton\n                key={text}\n                text={text}\n                onClick={onClick}\n                style={style}\n                tooltip={tooltip}\n            />);\n        }\n\n        // the relation cannot be renamed to forbidden relation names and other currently used relation names\n        const forbiddenRelationNames: string[] = this.props.storedRelations\n            .filter((sr, i) => i !== this.props.storedRelationIndex)\n            .map(sr => sr.getName());\n        const forbiddenNamesFunction = (text: string): boolean => {\n            if (forbiddenRelationNames.indexOf(text) > -1) {\n                return true;\n            }\n            return !StringUtils.isName(text) || isForbiddenRelationName(text);\n        }\n\n        return (\n            <section className=\"page-section\">\n                <header>\n                    <h2>{lang.relationSectionHeader}</h2>\n                    {createButton(lang.loadAllButton, this.loadAllRelations, lang.loadAllButtonTooltip)}\n                    {createButton(lang.removeLoadedButton, this.removeLoadedRelations, lang.removeLoadedButtonTooltip)}\n                    {createButton(lang.importButton, this.importRelations, lang.importButtonTooltip)}\n                    {createButton(lang.exportButton, this.exportRelations, lang.exportButtonTooltip)}\n                </header>\n\n                <menu className=\"page-section-tab-menu\">\n                    {this.createRelationMenuButtons()}\n                    <button onClick={this.newRelation}\n                        style={{minWidth: \"0\", marginLeft: \"10px\", padding: \"2px 6px 1px 6px\"}}>\n                        <strong>+</strong>\n                    </button>\n                </menu>\n\n                <EditRelationTable\n                    relation={this.getCurRel()}\n\n                    onColumnNameChange={this.props.onColumnNameChange}\n                    onColumnTypeChange={this.props.onColumnTypeChange}\n                    onRowInputChange={this.props.onRowInputChange}\n                    onNewRow={this.props.onNewRow}\n                    onNewColumn={this.props.onNewColumn}\n                    onDeleteRow={this.props.onDeleteRow}\n                    onDeleteColumn={this.props.onDeleteColumn}\n\n                    onCtrlInput={this.handleCtrlInput}\n                />\n\n                <menu className=\"page-section-management-menu\">\n                    <TooltipButton\n                        text={lang.loadButton}\n                        onClick={this.loadRelation}\n                        className={\"action-button\"}\n                        style={{marginRight: \"40px\"}}\n                        tooltip={lang.loadButtonTooltip}\n                    />\n                    <TextInput\n                        value={this.getCurRel().getName()}\n                        buttonText={lang.renameButton}\n                        onSubmit={this.handleRelationNameChange}\n                        forbidden={forbiddenNamesFunction}\n                        id=\"relation-name-input\"\n                    />\n                    {createButton(lang.deleteButton, this.deleteRelation, lang.deleteButtonTooltip)}\n                    {createButton(lang.revertButton, this.revertRelation,\n                        lang.revertButtonTooltip + \" (\" + this.getCurRel().getRevertName() + \")\")}\n                </menu>\n            </section>\n        );\n    }\n}","interface SendData {\n    access_token: string,\n    subject: string,\n    text: string\n}\n\n/**\n * Class for sending emails. Powered by https://postmail.invotes.com/.\n * TypeScript version of JavaScript Copy & Paste Example from PostMail webpage.\n */\nexport class Mail {\n\n    /**\n     * Creates a mailer with given Mail access token.\n     *\n     * @param accessToken token which specifies Mail receiver of mails\n     */\n    constructor(readonly accessToken: string) {}\n\n    /**\n     * Sends given subject and body of the email to the Mail receiver.\n     *\n     * @param subject subject of the mail\n     * @param body body of the mail\n     */\n    public send(subject: string, body: string): void {\n        const data_js: SendData = {\n            access_token: this.accessToken,\n            subject: subject,\n            text: body\n        };\n\n        const request = new XMLHttpRequest();\n        request.onreadystatechange = function() {\n            if (request.readyState === 4 && request.status === 200) {\n            } else if(request.readyState === 4) {\n                console.log(\"failed creating XMLHttpRequest in Mail.send: \" + request.response);\n            }\n        };\n\n        let params = Mail.toParams(data_js);\n        request.open(\"POST\", \"https://postmail.invotes.com/send\", true);\n        request.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\n        request.send(params);\n    }\n\n    private static toParams(data: SendData): string {\n        return encodeURIComponent(\"access_token\") + \"=\" + encodeURIComponent(data.access_token) + \"&\" +\n            encodeURIComponent(\"subject\") + \"=\" + encodeURIComponent(data.subject) + \"&\" +\n                encodeURIComponent(\"text\") + \"=\" + encodeURIComponent(data.text);\n    }\n}","import React, {Component} from 'react';\nimport {Relation} from '../relation/relation';\nimport {RATreeNode} from \"../ratree/raTreeNode\";\nimport {ExpressionSection} from \"./expressionSection\";\nimport {ResultSection} from \"./resultSection\";\nimport {ExpressionStoreManager} from \"../expression/expressionStoreManager\";\nimport {ManagementSection} from \"./managementSection\";\nimport {CsvValueSeparator} from \"../types/csvSupport\";\nimport {ProjectStoreManager} from \"../project/projectStoreManager\";\nimport {language, LanguageDef, SupportedLanguage} from \"../language/language\";\nimport {LocalStorage} from \"../utils/localStorage\";\nimport {BatchProcessor} from \"../batch/batchProcessor\";\nimport {Expression} from \"../expression/expression\";\nimport {RelationsSection} from \"./relationsSection\";\nimport {StoredRelation} from \"../relation/storedRelation\";\nimport {SupportedColumnType} from \"../relation/columnType\";\nimport {RelationStoreManager} from \"../relation/relationStoreManager\";\nimport {Mail} from \"../utils/mail\";\nimport {POSTMAIL_ACCESS_TOKEN} from \"../postMailAccessToken\";\nimport {copyProject, Project} from \"../project/project\";\nimport {getSamples} from \"../project/samples\";\nimport {MessageBox} from \"./messageBox\";\n\n/**\n * Props of MainScreen component.\n * @category Components\n * @public\n */\ninterface MainScreenProps {}\n\ninterface MainScreenState {\n    samples: { name: string, project: Project }[],\n\n    loadedRelations: Map<string, Relation>,\n    storedRelations: StoredRelation[],\n    selectedRelation: number,\n\n    expressions: Expression[],\n    selectedExpression: number,\n\n    evaluationTreeRoot: RATreeNode | null,\n    evaluatedExpressionName: string,\n\n    batchConfigurationInfo: string,\n    nullValuesSupport: boolean,\n    csvValueSeparator: CsvValueSeparator,\n    language: LanguageDef,\n    darkTheme: boolean\n}\n\n/**\n * Main component of Rachel web page. It wraps all page sections and passes messages between them.\n * Accepts {@link MainScreenProps} props.\n * @category Components\n * @public\n */\nexport class MainScreen extends Component<MainScreenProps, MainScreenState> {\n\n    private readonly expressionSectionRef: React.RefObject<ExpressionSection>;\n\n    constructor(props: MainScreenProps) {\n        super(props);\n\n        // sets body template by settings from local storage\n        document.body.classList.toggle('body-dark', LocalStorage.getDarkTheme());\n        document.body.classList.toggle('body-light', !LocalStorage.getDarkTheme());\n\n        const initRelationData = {\n            name: \"Relation\",\n            columnNames: [\"Column1\", \"Column2\", \"Column3\"],\n            columnTypes: [\"number\", \"string\", \"boolean\"],\n            rows: [\n                ['', '', '']\n            ],\n            columnCount: 3,\n            rowCount: 1\n        };\n\n        this.state = {\n            samples: getSamples(),\n\n            loadedRelations: new Map<string, Relation>(),\n            storedRelations: [ StoredRelation.fromData(initRelationData, true) ],\n            selectedRelation: 0,\n\n            expressions: [ {name: \"Expression 1\", text: \"\"} ],\n            selectedExpression: 0,\n\n            evaluationTreeRoot: null,\n            evaluatedExpressionName: \"\",\n\n            batchConfigurationInfo: BatchProcessor.getConfigInfo(),\n            nullValuesSupport: true,\n            csvValueSeparator: LocalStorage.getCsvValueSeparator(),\n            language: language(),\n            darkTheme: LocalStorage.getDarkTheme()\n        }\n        this.expressionSectionRef = React.createRef();\n    }\n\n    /**\n     * Reports an error to the author of the application via email.\n     *\n     * @param err unexpected error\n     */\n    private reportUnexpectedError = (err: Error): void => {\n        const postMail: Mail = new Mail(POSTMAIL_ACCESS_TOKEN);\n        let body: string = \"Unexpected error \" + err.name + \" in Rachel application.\" +\n            \"\\n\\nMessage:\\n\" + err.message +\n            \"\\n\\nDate:\\n\" + new Date().toString() +\n            \"\\n\\nStack trace:\\n\" + err.stack +\n\n            \"\\n\\nLoaded relations: ----------------------------\\n\" +\n            [...this.state.loadedRelations.values()].map(relation => {\n                return relation.getName() + \"\\n\" + relation.contentString();\n            }).join(\"\\n\\n\") +\n\n            \"\\n\\nStored relations: ----------------------------\" +\n            \"\\nSelected relation (1-index): \" + (this.state.selectedRelation + 1) + \"\\n\\n\" +\n            this.state.storedRelations.map(rel => StoredRelation.format(rel)).join(\"\\n\\n\") +\n\n            \"\\n\\nExpressions: ----------------------------\" +\n            \"\\nSelected expression (1-index): \" + (this.state.selectedExpression + 1) + \"\\n\\n\" +\n            this.state.expressions.map(expr => expr.text).join(\"\\n\\n###\\n\\n\") +\n\n            \"\\n\\nEvaluation tree:\\n\" + this.state.evaluationTreeRoot?.printInLine() +\n\n            \"\\n\\nOther state: ----------------------------\" +\n            \"\\ncsvValueSeparator: \" + this.state.csvValueSeparator +\n            \"\\nlanguage:          \" + this.state.language +\n            \"\\nnullValuesSupport: \" + this.state.nullValuesSupport +\n            \"\\ndarkTheme:         \" + this.state.darkTheme;\n\n        postMail.send(\"Rachel application unexpected error\", body);\n        console.error('Unexpected error: ' + err.stack);\n    }\n\n    /**\n     * Overwrites the current project data with the given one.\n     *\n     * @param project\n     */\n    private loadProject = (project: Project): void => {\n        this.setState({\n            loadedRelations: new Map<string, Relation>(),\n            storedRelations: project.relations.map(r => StoredRelation.fromData(r, project.nullValuesSupport)),\n            selectedRelation: 0,\n            expressions: project.expressions,\n            nullValuesSupport: project.nullValuesSupport,\n            selectedExpression: 0,\n            evaluationTreeRoot: null,\n            evaluatedExpressionName: \"\"\n        }, () => {\n            console.log(\"Project loaded.\");\n            this.updateExpressionsErrors();\n        });\n    }\n\n    /**\n     * Adds number after the given name if it already exists in stored relation.\n     */\n    private ensureUniqueRelationName = (name: string): string => {\n        if (this.state.storedRelations.map(sr => sr.getName()).indexOf(name) > -1) {\n            for (let i = 2; true; ++i) {\n                if (this.state.storedRelations.map(sr => sr.getName()).indexOf(name + i) === -1) {\n                    name += i;\n                    break;\n                }\n            }\n        }\n        return name;\n    }\n\n    /****************************************** MANAGEMENT SECTION HANDLERS ******************************************/\n\n    /**\n     * Loads a JSON file with batch processing configuration.\n     */\n    private handleBatchConfig = () => {\n        BatchProcessor.config().then(msg => {\n            console.log(msg);\n            MessageBox.message(msg);\n            const configInfo = BatchProcessor.getConfigInfo();\n            this.setState({ batchConfigurationInfo: configInfo });\n        }).catch(err => {\n            console.warn(err);\n            MessageBox.error(err);\n        });\n    }\n\n    /**\n     * Processes multiple selected files with expressions by the user and saves the reports of the evaluation in textual\n     * files.\n     */\n    private handleBatchLoad = () => {\n        BatchProcessor.process();\n    }\n\n    /**\n     * Opens a file dialog and lets the user choose a .rachel (JSON) file with project to load.\n     */\n    private handleLoadProject = (): void => {\n        ProjectStoreManager.load().then(this.loadProject).catch(console.warn);\n    }\n\n    /**\n     * Saves the project relation to the .rachel (JSON) file.\n     */\n    private handleSaveProject = (): void => {\n        try {\n            ProjectStoreManager.save({\n                relations: this.state.storedRelations.map(sr => sr.toDataObject()),\n                expressions: this.state.expressions,\n                nullValuesSupport: this.state.nullValuesSupport\n                }, \"project\");\n            console.log(\"Project saved.\");\n        }\n        catch (err) {\n            console.warn(\"Project saving failed: \" + err.message);\n        }\n    }\n\n    /**\n     * Handles loading a sample project.\n     */\n    private handleLoadSampleProject = (sample: Project): void => {\n        this.loadProject(copyProject(sample));\n    }\n\n    /**\n     * Changes the support of the null values in relations.\n     *\n     * @param nullValuesSupport new support of the null values in relations\n     */\n    private handleNullValuesSupportChange = (nullValuesSupport: boolean): void => {\n        this.state.storedRelations.forEach(sr => sr.setNullValuesSupport(nullValuesSupport));\n        // null values change can change validity of the relations, therefore set as not actual\n        this.setState({nullValuesSupport: nullValuesSupport}, this.updateExpressionsErrors);\n    }\n\n    /**\n     * Changes the value separator used in generated CSV files.\n     *\n     * @param csvValueSeparator new value separator used in generated CSV files\n     */\n    private handleCsvValueSeparatorChange = (csvValueSeparator: CsvValueSeparator): void => {\n        LocalStorage.setCsvValueSeparator(csvValueSeparator);\n        this.setState({csvValueSeparator: csvValueSeparator});\n    }\n\n    /**\n     * Changes the language of the application.\n     *\n     * @param lang new language of the application\n     */\n    private handleLanguageChange = (lang: SupportedLanguage): void => {\n        LocalStorage.setLanguage(lang);\n        // updates language of errors in stored relations\n        this.state.storedRelations.forEach(r => r.recomputeErrors());\n        this.setState({language: language()});\n    }\n\n    /**\n     * Changes the dark/light mode of the application.\n     *\n     * @param darkTheme true if dark theme is on\n     */\n    private handleDarkThemeChange = (darkTheme: boolean) => {\n        LocalStorage.setDarkTheme(darkTheme);\n        this.setState({darkTheme: darkTheme});\n        document.body.classList.toggle( 'body-dark', darkTheme);\n        document.body.classList.toggle( 'body-light', !darkTheme);\n    }\n\n    /******************************************* RELATION SECTION HANDLERS *******************************************/\n\n    private handleRelationNameChange = (name: string): void => {\n        this.setState(state => {\n            const storedRelations = state.storedRelations;\n            storedRelations[this.state.selectedRelation].setName(name);\n            return {storedRelations: storedRelations};\n        });\n    }\n\n    private handleRelationColumnNameChange = (columnName: string, columnIndex: number): void => {\n        this.setState(state => {\n            const storedRelations = state.storedRelations;\n            storedRelations[this.state.selectedRelation].setColumnName(columnName, columnIndex);\n            return {storedRelations: storedRelations};\n        });\n    }\n\n    private handleRelationColumnTypeChange = (columnType: SupportedColumnType, columnIndex: number): void => {\n        this.setState(state => {\n            const storedRelations = state.storedRelations;\n            storedRelations[this.state.selectedRelation].setColumnType(columnType, columnIndex);\n            return {storedRelations: storedRelations};\n        });\n    }\n\n    private handleRelationRowInputChange = (input: string, columnIndex: number, rowIndex: number): void => {\n        this.setState(state => {\n            const storedRelations = state.storedRelations;\n            storedRelations[this.state.selectedRelation].setRowInput(input, rowIndex, columnIndex);\n            return {storedRelations: storedRelations};\n        });\n    }\n\n    private handleRelationNewRow = (onDone: () => void): void => {\n        this.state.storedRelations[this.state.selectedRelation].addNewRow();\n        // forces update\n        this.setState({}, onDone);\n    }\n\n    private handleRelationNewColumn = (onDone: () => void): void => {\n        this.state.storedRelations[this.state.selectedRelation].addNewColumn();\n        // forces update\n        this.setState({}, onDone);\n    }\n\n    private handleRelationDeleteRow = (rowIndex: number): void => {\n        this.state.storedRelations[this.state.selectedRelation].deleteRow(rowIndex);\n        // forces update\n        this.setState({});\n    }\n\n    private handleRelationDeleteColumn = (columnIndex: number): void => {\n        this.state.storedRelations[this.state.selectedRelation].deleteColumn(columnIndex);\n        // forces update\n        this.setState({});\n    }\n\n    /**\n     * Selects a new relation from the relations list as the current one.\n     */\n    private handleSelectDifferentRelation = (newIndex: number): void => {\n        this.setState({selectedRelation: newIndex});\n    }\n\n    /**\n     * Moves a relation from the given \"from\" index to the given \"to\" index.\n     */\n    private handleDragRelation = (from: number, to: number): void => {\n        // dragging left\n        if (from > to) {\n            const before = this.state.storedRelations.slice(0, to);\n            const moved = this.state.storedRelations.slice(to, from);\n            const fromValue = this.state.storedRelations[from];\n            const after = this.state.storedRelations.slice(from + 1);\n            const newArray = [...before, fromValue, ...moved, ...after];\n            this.setState({storedRelations: newArray, selectedRelation: to});\n        }\n        // dragging right\n        else if (from < to) {\n            const before = this.state.storedRelations.slice(0, from);\n            const fromValue = this.state.storedRelations[from];\n            const moved = this.state.storedRelations.slice(from + 1, to + 1);\n            const after = this.state.storedRelations.slice(to + 1);\n            const newArray = [...before, ...moved, fromValue, ...after];\n            this.setState({storedRelations: newArray, selectedRelation: to});\n        }\n    }\n\n    /**\n     * Creates a new empty relation and adds it in the relation list.\n     */\n    private handleCreateNewRelation = (): void => {\n        // inserts a new empty relation in the array\n        const newIndex: number = this.state.selectedRelation + 1;\n        let name: string = this.ensureUniqueRelationName(\"NewRelation\");\n        this.state.storedRelations.splice(newIndex, 0, StoredRelation.new(name, this.state.nullValuesSupport));\n        this.setState({selectedRelation: newIndex});\n    }\n\n    /**\n     * Deletes the current relation from the relations list (or clears it if it is the last relation in the list).\n     */\n    private handleDeleteRelation = (): void => {\n        // if there is the last relation, only clears it\n        if (this.state.storedRelations.length === 1) {\n            this.setState({storedRelations: [StoredRelation.new(\"Relation\", this.state.nullValuesSupport)]});\n            return;\n        }\n        const selected: number = this.state.selectedRelation;\n        this.state.storedRelations.splice(selected, 1);\n        if (selected === this.state.storedRelations.length) {\n            this.setState({selectedRelation: selected - 1}, this.updateExpressionsErrors);\n        }\n        else {\n            // forces update\n            this.setState({}, this.updateExpressionsErrors);\n        }\n    }\n\n    /**\n     * Reverts the current selected stored relation to its last loaded state.\n     */\n    private handleRevertRelation = (): void => {\n        this.setState(state => {\n            const storedRelations = state.storedRelations;\n            storedRelations[this.state.selectedRelation].revert();\n            return {storedRelations};\n        });\n    }\n\n    /**\n     * Removes all relations loaded in the application.\n     */\n    private handleRemoveLoadedRelations = (onDone: (msg: string) => void): void => {\n        const lang = this.state.language.userMessages;\n        const previous = this.state.loadedRelations.size;\n        this.state.loadedRelations.clear();\n        this.state.storedRelations.forEach(sr => sr.setActual(false));\n        onDone(previous + lang.deleteLoadedRelations);\n        // forces update\n        this.setState({}, this.updateExpressionsErrors);\n    }\n\n    /**\n     * Saves the relations list in a textual file.\n     *\n     * @param onDone\n     */\n    private handleExportRelations = (onDone: (msg: string) => void): void => {\n        const lang = this.state.language.userMessages;\n        try {\n            RelationStoreManager.save(this.state.storedRelations, \"relations\", this.state.csvValueSeparator);\n            onDone(this.state.storedRelations.length + lang.relationsExportOK);\n        }\n        catch (err) {\n            onDone(lang.relationsExportErr + err);\n        }\n    }\n\n    /**\n     * Loads the relations list from the textual file selected by the user.\n     *\n     * @param onDone\n     */\n    private handleImportRelations = (onDone: (msg: string) => void): void => {\n        const lang = this.state.language.userMessages;\n        RelationStoreManager.load(this.state.nullValuesSupport).then(info => {\n            const countBefore: number = this.state.storedRelations.length;\n            // loads relations to application\n            info.relations.forEach(relation => {\n                const name = this.ensureUniqueRelationName(relation.getName());\n                relation.setName(name);\n                this.state.storedRelations.push(relation);\n            });\n            if (info.relations.length > 0) {\n                // shows first loaded relation\n                this.setState({selectedRelation: countBefore});\n            }\n            onDone(info.relations.length + lang.relationsImport[0] + info.skipped + lang.relationsImport[1])\n        });\n    }\n\n    private handleLoadRelation = (onDone: (msg: string) => void): void => {\n        const lang = this.state.language.userMessages;\n        const currRelation: StoredRelation = this.state.storedRelations[this.state.selectedRelation];\n        currRelation.setActual(true);\n        this.state.loadedRelations.set(currRelation.getName(), currRelation.createRelation());\n        const msgPart2: string = this.state.loadedRelations.size === 0 ? lang.loadedRelationsTotalNo :\n            this.state.loadedRelations.size + lang.loadedRelationsTotalSome + [...this.state.loadedRelations.keys()].join(', ') + \".\";\n        onDone(lang.loadRelationNew + \"\\n\" + msgPart2);\n        // forces update\n        this.setState({}, this.updateExpressionsErrors);\n    }\n\n    private handleLoadAllRelations = (onDone: (msg: string) => void): void => {\n        const lang = this.state.language.userMessages;\n        let loaded: number = 0;\n        let skipped: number = 0;\n        this.state.storedRelations.forEach(sr => {\n            if (sr.isValid()) {\n                sr.setActual(true);\n                this.state.loadedRelations.set(sr.getName(), sr.createRelation());\n                ++loaded;\n            }\n            else {\n                ++skipped;\n            }\n        });\n        const msgPart2: string = this.state.loadedRelations.size === 0 ? lang.loadedRelationsTotalNo :\n            this.state.loadedRelations.size + lang.loadedRelationsTotalSome + [...this.state.loadedRelations.keys()].join(', ') + \".\";\n        onDone(loaded + lang.loadAllRelationsNew[0] + skipped + lang.loadAllRelationsNew[1] + \"\\n\" + msgPart2);\n        // forces update\n        this.setState({}, this.updateExpressionsErrors);\n    }\n\n    /****************************************** EXPRESSION SECTION HANDLERS ******************************************/\n\n    private updateExpressionsErrors = (): void => {\n        const expressionSection = this.expressionSectionRef.current;\n        if (expressionSection !== null) {\n            expressionSection.updateErrorsAndParentheses();\n        }\n    }\n\n    /**\n     * Saves evaluation tree for the evaluated RA expression.\n     */\n    private handleExprEval = (tree: RATreeNode): void => {\n        this.setState({\n            evaluationTreeRoot: tree,\n            evaluatedExpressionName: this.state.expressions[this.state.selectedExpression].name\n        });\n    }\n\n    /**\n     * Updates the text of the current expression and sets it as not actual.\n     */\n    private handleExprTextChange = (name: string, text: string): void => {\n        this.setState(state => {\n            let expressions: Expression[] = state.expressions;\n            expressions[state.selectedExpression] = {name: name, text: text};\n            return { expressions: expressions }\n        });\n    }\n\n    /**\n     * Selects a new expression from the expression list as the current one.\n     */\n    private handleSelectDifferentExpression = (newIndex: number): void => {\n        this.setState({ selectedExpression: newIndex }, this.updateExpressionsErrors);\n    }\n\n    /**\n     * Moves a expression from the given \"from\" index to the given \"to\" index.\n     */\n    private handleDragExpression = (from: number, to: number): void => {\n        // dragging left\n        if (from > to) {\n            const before = this.state.expressions.slice(0, to);\n            const moved = this.state.expressions.slice(to, from);\n            const fromValue = this.state.expressions[from];\n            const after = this.state.expressions.slice(from + 1);\n            const newArray = [...before, fromValue, ...moved, ...after];\n            this.setState({expressions: newArray, selectedExpression: to});\n        }\n        // dragging right\n        else if (from < to) {\n            const before = this.state.expressions.slice(0, from);\n            const fromValue = this.state.expressions[from];\n            const moved = this.state.expressions.slice(from + 1, to + 1);\n            const after = this.state.expressions.slice(to + 1);\n            const newArray = [...before, ...moved, fromValue, ...after];\n            this.setState({expressions: newArray, selectedExpression: to});\n        }\n    }\n\n    /**\n     * Creates a new empty expression and adds it in the expression list.\n     */\n    private handleCreateNewExpression = (): void => {\n        // inserts a new empty expression in the array\n        const newIndex: number = this.state.selectedExpression + 1;\n        this.state.expressions.splice(newIndex, 0, {name: \"New expression\", text: \"\"});\n        this.setState({selectedExpression: newIndex});\n    }\n\n    /**\n     * Deletes the current expression from the expression list (or clears it if it is the last expression in the list).\n     */\n    private handleDeleteExpression = (onDone: () => void): void => {\n        // if there is the last expression, only clears it\n        if (this.state.expressions.length === 1) {\n            return this.handleExprTextChange(\"Expression 1\", \"\");\n        }\n        const selected: number = this.state.selectedExpression;\n        this.state.expressions.splice(selected, 1);\n        if (selected === this.state.expressions.length) {\n            this.setState({selectedExpression: selected - 1}, onDone);\n        }\n        else {\n            // forces update\n            this.setState({}, onDone);\n        }\n    }\n\n    /**\n     * Saves the expression list in a textual file.\n     *\n     * @param onDone\n     */\n    private handleExportExpressions = (onDone: (msg: string) => void): void => {\n        const lang = this.state.language.userMessages;\n        try {\n            ExpressionStoreManager.save(this.state.expressions, 'expressions');\n            onDone(lang.expressionsExportOK);\n        }\n        catch (err) {\n            onDone(lang.expressionsExportErr + err.message);\n        }\n    }\n\n    /**\n     * Loads the expression list from the textual file selected by the user.\n     *\n     * @param onDone\n     */\n    private handleImportExpressions = (onDone: (msg: string) => void): void => {\n        const lang = this.state.language.userMessages;\n        ExpressionStoreManager.load().then(info => {\n            this.state.expressions.push(...info.expressions);\n            this.setState({});\n            onDone(info.expressions.length + lang.expressionsImport[0] + info.loadedFiles + lang.expressionsImport[1] +\n                + info.skippedExpressions + lang.expressionsImport[2] + info.skippedFiles + lang.expressionsImport[3]);\n        });\n    }\n\n    /******************************************** RESULT SECTION HANDLERS ********************************************/\n\n    /**\n     * Adds the given relation to defined relations.\n     *\n     * @return message and its color (red for errors, black for information)\n     */\n    private addResultRelation = (relation: Relation): void => {\n        const name = this.ensureUniqueRelationName(\"Evaluated\");\n        const storedRelation = StoredRelation.fromRelation(name, relation, this.state.nullValuesSupport);\n        this.state.storedRelations.push(storedRelation);\n        this.setState({selectedRelation: this.state.storedRelations.length - 1});\n    }\n\n    /***************************************************** RENDER *****************************************************/\n\n    public render() {\n        let resultSection = null;\n        if (this.state.evaluationTreeRoot !== null) {\n            resultSection = (\n                <ResultSection\n                    evaluationTreeRoot={this.state.evaluationTreeRoot}\n                    expressionName={this.state.evaluatedExpressionName}\n\n                    onAddResult={this.addResultRelation}\n                    onUnexpectedError={this.reportUnexpectedError}\n\n                    csvValueSeparator={this.state.csvValueSeparator}\n                    darkTheme={this.state.darkTheme}\n                    language={this.state.language}\n                />\n            );\n        }\n\n        return (\n            <main>\n                <ManagementSection\n                    onBatchConfig={this.handleBatchConfig}\n                    onBatchLoad={this.handleBatchLoad}\n                    batchConfigurationInfo={this.state.batchConfigurationInfo}\n                    onLoadProject={this.handleLoadProject}\n                    onSaveProject={this.handleSaveProject}\n                    onLoadSample={this.handleLoadSampleProject}\n\n                    csvValueSeparator={this.state.csvValueSeparator}\n                    language={this.state.language}\n                    nullValuesSupport={this.state.nullValuesSupport}\n                    darkTheme={this.state.darkTheme}\n\n                    onCsvValueSeparatorChange={this.handleCsvValueSeparatorChange}\n                    onLanguageChange={this.handleLanguageChange}\n                    onNullValuesSupportChange={this.handleNullValuesSupportChange}\n                    onDarkThemeChange={this.handleDarkThemeChange}\n                />\n\n                <RelationsSection\n                    storedRelations={this.state.storedRelations}\n                    storedRelationIndex={this.state.selectedRelation}\n\n                    loadedRelations={[...this.state.loadedRelations.values()]}\n\n                    onRelationNameChange={this.handleRelationNameChange}\n                    onColumnNameChange={this.handleRelationColumnNameChange}\n                    onColumnTypeChange={this.handleRelationColumnTypeChange}\n                    onRowInputChange={this.handleRelationRowInputChange}\n                    onNewRow={this.handleRelationNewRow}\n                    onNewColumn={this.handleRelationNewColumn}\n                    onDeleteRow={this.handleRelationDeleteRow}\n                    onDeleteColumn={this.handleRelationDeleteColumn}\n\n                    onSelectDifferentRelation={this.handleSelectDifferentRelation}\n                    onDragRelation={this.handleDragRelation}\n                    onNewRelation={this.handleCreateNewRelation}\n                    onLoadRelation={this.handleLoadRelation}\n                    onDeleteStoredRelation={this.handleDeleteRelation}\n                    onRevertRelation={this.handleRevertRelation}\n\n                    onLoadAllRelations={this.handleLoadAllRelations}\n                    onRemoveLoadedRelations={this.handleRemoveLoadedRelations}\n                    onExportRelations={this.handleExportRelations}\n                    onImportRelations={this.handleImportRelations}\n\n                    nullValuesSupport={this.state.nullValuesSupport}\n                    language={this.state.language}\n                />\n\n                <ExpressionSection\n                    ref={this.expressionSectionRef}\n\n                    expressions={this.state.expressions}\n                    currentExpressionIndex={this.state.selectedExpression}\n                    relations={this.state.loadedRelations}\n\n                    onChange={this.handleExprTextChange}\n                    onEval={this.handleExprEval}\n\n                    onSelectDifferentExpression={this.handleSelectDifferentExpression}\n                    onDragExpression={this.handleDragExpression}\n                    onNewExpression={this.handleCreateNewExpression}\n                    onDeleteExpression={this.handleDeleteExpression}\n                    onExportExpressions={this.handleExportExpressions}\n                    onImportExpressions={this.handleImportExpressions}\n\n                    onUnexpectedError={this.reportUnexpectedError}\n                    nullValuesSupport={this.state.nullValuesSupport}\n                    darkTheme={this.state.darkTheme}\n                    language={this.state.language}\n                />\n\n                {resultSection}\n            </main>\n        );\n    }\n}","/**\n * Access token for PostMail service.\n * Replace it with your own token after registration on https://postmail.invotes.com/ to receive email error logs.\n */\nexport const POSTMAIL_ACCESS_TOKEN: string = \"5uog26ex8q9qu7sqib8ea0qd\";","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport * as serviceWorker from './serviceWorker';\nimport {MainScreen} from \"./components/mainScreen\";\n\n/**\n * @license The software is Licensed under the MIT License\n *\n * Copyright (c) Lukáš Kotlík\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n * documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\n * to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions\n * of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO\n * THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n * ********* Used, Licensed third party code: *********\n *\n * JSZIP - Create, read and edit .zip files with Javascript\n * Version: 3.5.0\n * https://github.com/Stuk/jszip\n * MIT License - Copyright (c) 2009-2016 Stuart Knightley, David Duponchel, Franz Buchinger, António Afonso\n *\n * visx - visualization components\n * visx/group - version: 1.0.0\n * visx/hierarchy - version: 1.0.0\n * visx/shape - version: 1.4.0\n * visx/responsive - version: 1.3.0\n * visx/tooltip - version: 1.3.0\n * https://github.com/airbnb/visx\n * MIT License - Copyright (c) 2017-2018 Harrison Shoff\n *\n * export-svg-with-styles - Turn your SVGs to PNGs\n * Version: 0.0.4\n * https://www.npmjs.com/package/export-svg-with-styles\n * MIT License - Copyright (c) 2019 Mathew Leland\n *\n * FileSaver.js - An HTML5 saveAs() FileSaver implementation\n * Version: 2.0.5\n * https://github.com/eligrey/FileSaver.js\n * MIT License - Copyright (c) 2016 Eli Grey\n *\n * Lodash - A modern JavaScript utility library delivering modularity, performance, & extras.\n * Version: 4.17.20\n * https://github.com/lodash/lodash\n * MIT License - Copyright JS Foundation and other contributors <https://js.foundation/>\n * Based on Underscore.js, copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors <http://underscorejs.org/>\n * This software consists of voluntary contributions made by many individuals. For exact contribution history, see the revision history available at https://github.com/lodash/lodash\n *\n * React - A declarative, efficient, and flexible JavaScript library for building user interfaces.\n * Version: 16.13.1\n * https://github.com/facebook/react\n * MIT License - Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Jest - Delightful JavaScript Testing.\n * Version: 26.6.0\n * https://github.com/facebook/jest\n * MIT License - Copyright (c) Facebook, Inc. and its affiliates.\n *\n * create-react-app - Set up a modern web app by running one command.\n * Version: 3.4.1\n * https://github.com/facebook/create-react-app\n * MIT License - Copyright (c) 2013-present, Facebook, Inc.\n *\n * TypeScript - TypeScript is a superset of JavaScript that compiles to clean JavaScript output.\n * Version: 3.7.5\n * https://github.com/microsoft/TypeScript\n * Apache License 2.0\n *\n * JSDoc - An API documentation generator for JavaScript.\n * Version: 3.6.6\n * https://github.com/jsdoc/jsdoc\n * Apache License 2.0\n *\n * better-docs - Beautiful toolbox for jsdoc generated documentation - with 'typescript', `category` and `component` plugins\n * Version: 2.3.2\n * https://github.com/SoftwareBrothers/better-docs\n * MIT License - Copyright 2019 SoftwareBrothers.co\n *\n * ********* Used, not Licensed, free to use code and services: *********\n *\n * PostMail - Send email from JavaScript or static HTML without backend code\n * https://postmail.invotes.com/\n */\nReactDOM.render(\n    <React.StrictMode>\n        <MainScreen/>\n    </React.StrictMode>,\n    document.getElementById('root')\n);\n\nserviceWorker.unregister();","export function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}"],"sourceRoot":""}